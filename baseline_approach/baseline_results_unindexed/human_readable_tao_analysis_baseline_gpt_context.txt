Section_2_2: Example 1

namespace Chapter2

/--
  A minimal version of the natural numbers for Section 2, with successor notation.
-/
inductive Nat where
| zero : Nat
| succ : Nat → Nat

/-- Zero instance for Chapter2.Nat -/
instance Nat.instZero : Zero Nat := ⟨ Nat.zero ⟩

/-- Successor notation `n++` -/
postfix:100 "++" => Nat.succ

/--
  A minimal recursion operator on Chapter2.Nat.
-/
abbrev Nat.recurse (f : Nat → Nat → Nat) (c : Nat) : Nat → Nat
  | 0 => c
  | Nat.succ n => f n (Nat.recurse f c n)

/-- Define addition via recursion. -/
abbrev Nat.add (n m : Nat) : Nat := Nat.recurse (fun _ sum => sum++) m n

/-- Additive structure to enable `+` notation. -/
instance Nat.instAdd : Add Nat where
  add := Nat.add

/-- Define `≤` on Chapter2.Nat via existence of an addend. -/
instance Nat.instLE : LE Nat where
  le n m := ∃ a : Nat, m = n + a

/-- Exercise 2.2.6 (backwards induction). -/
theorem Nat.backwards_induction {n : Nat} {P : Nat → Prop}
  (hind : ∀ m, P (m++) → P m) (hn : P n) :
    ∀ m, m ≤ n → P m := by
  sorry

end Chapter2

-----------------------------------

Section_3_1: Example 2

import Mathlib.Tactic

namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set → Object
  emptyset : Set
  singleton : Object → Set

export SetTheory (Set Object)

variable [SetTheory]

instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

abbrev SetTheory.Set.empty : Set := ∅
abbrev SetTheory.Set.singleton_empty : Set := {(empty : Object)}

/-- Exercise 3.1.2 -/
theorem SetTheory.Set.emptyset_neq_singleton : empty ≠ singleton_empty := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 3

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal structure to support the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set

export SetTheory (Set Object)

variable [SetTheory]

/-- Membership of objects in sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Union notation for sets. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Subset relation on sets. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- The requested theorem (left as sorry). -/
theorem SetTheory.Set.subset_union_subset
    {A B A' B' : Set} (hA'A : A' ⊆ A) (hB'B : B' ⊆ B) :
    A' ∪ B' ⊆ A ∪ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 4

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for the stated theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set

-- Use `Set` and `Object` directly as names.
export SetTheory (Set Object)

-- Assume a fixed instance of our set theory.
variable [SetTheory]

/-- Membership of objects in sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Provide `∪` notation for sets. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Provide `⊆` notation for sets. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Exercise 3.1.7 -/
theorem SetTheory.Set.subset_union_left (A B : Set) : A ⊆ A ∪ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 5

import Mathlib.Tactic

namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set
  union_pair_axiom (X Y : Set) (x : Object) :
    mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y)

export SetTheory (Set Object)

variable [SetTheory]

instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

theorem SetTheory.Set.subset_union_right (A B : Set) : B ⊆ A ∪ B := by
  sorry

end Chapter3

-----------------------------------

Section_2_3: Example 6

import Mathlib.Data.Nat.Basic

namespace Chapter2

-- For this isolated theorem, we identify the chapter's Nat with Lean's ℕ.
abbrev Nat := _root_.Nat

/-- Exercise 2.3.4 -/
theorem Nat.sq_add_eq (a b: Nat) :
    (a + b) ^ (2 : Nat) = a ^ (2 : Nat) + 2 * a * b + b ^ (2 : Nat) := by
  sorry

end Chapter2

-----------------------------------

Section_3_1: Example 7

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  singleton : Object → Set
  singleton_axiom : ∀ x y, mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom : ∀ X Y x, mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y)

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow writing `x ∈ X` for `Object` and `Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Singleton notation `{x}` for sets. -/
instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

@[simp]
theorem SetTheory.Set.mem_singleton (x a : Object) : x ∈ ({a} : Set) ↔ x = a :=
  SetTheory.singleton_axiom x a

/-- Binary union notation `X ∪ Y` for sets. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

@[simp]
theorem SetTheory.Set.mem_union (x : Object) (X Y : Set) :
    x ∈ (X ∪ Y) ↔ (x ∈ X ∨ x ∈ Y) :=
  SetTheory.union_pair_axiom X Y x

/-- Insert notation `insert a X`, enabling `{a, b}` syntax via `insert b {a}`. -/
instance SetTheory.Set.instInsert : Insert Object Set where
  insert x X := {x} ∪ X

/-- Exercise 3.1.1 (statement only; proof omitted). -/
theorem SetTheory.Set.pair_eq_pair {a b c d : Object} (h : ({a, b} : Set) = {c, d}) :
    a = c ∧ b = d ∨ a = d ∧ b = c := by
  sorry

-----------------------------------

Section_3_1: Example 8

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for this theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow `x ∈ X` for `x : Object`, `X : Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem := fun x X => SetTheory.mem x X

/-- Define `⊆` on our abstract `Set`. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Define `∩` on our abstract `Set`. We do not need any properties for this theorem to typecheck. -/
instance SetTheory.Set.instIntersection : Inter Set where
  inter X Y := X

/-- Exercise 3.1.7 -/
theorem SetTheory.Set.inter_subset_left (A B : Set) : A ∩ B ⊆ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 9

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for this theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

-- Expose the names `Set` and `Object` in this namespace
export SetTheory (Set Object)

-- Work under an arbitrary model of the axioms
variable [SetTheory]

/-- Membership of objects in sets, to enable `x ∈ X` notation. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Subset relation on sets, to enable `⊆` notation. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Binary intersection on sets, to enable `∩` notation. -/
instance SetTheory.Set.instIntersection : Inter Set where
  inter X Y := X  -- placeholder definition sufficient for type-checking

/-- Exercise 3.1.12.-/
theorem SetTheory.Set.subset_inter_subset {A B A' B' : Set} (hA'A : A' ⊆ A) (hB'B : B' ⊆ B) :
    A' ∩ B' ⊆ A ∩ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 10

import Mathlib/Data/List/TFAE

namespace Chapter3

universe u

/-- A minimal stub of the ZF-style set theory environment sufficient to state the target theorem. -/
class SetTheory where
  Set : Type u

export SetTheory (Set)

variable [SetTheory]

/-- Provide a trivial union operation to enable the `∪` notation. -/
instance : Union Set where
  union := fun X Y => X

/-- Provide a trivial intersection operation to enable the `∩` notation. -/
instance : Inter Set where
  inter := fun X Y => X

/-- Provide a placeholder subset relation to enable the `⊆` notation. -/
scoped infix:50 " ⊆ " => fun (A B : Set) => False

/-- The requested theorem, stated with `sorry` as instructed. -/
theorem SetTheory.Set.subset_tfae (A B : Set) :
    [A ⊆ B, A ∪ B = B, A ∩ B = A].TFAE := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 11

import Mathlib.Tactic

namespace Chapter3

-- Minimal axiomatization needed for the statement
class SetTheory where
  Set : Type
  Object : Type
  mem : Object → Set → Prop
  union_pair : Set → Set → Set

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow `x ∈ X` where `x : Object`, `X : Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Define subset for our abstract sets. -/
def Subset (X Y : Set) : Prop := ∀ x : Object, x ∈ X → x ∈ Y

/-- Define union notation for our abstract sets. -/
infixl:65 " ∪ " => SetTheory.union_pair

/-- Define subset notation for our abstract sets. -/
infix:50 " ⊆ " => Subset

namespace SetTheory
namespace Set

@[simp]
theorem union_subset_iff (A B C : Set) : A ∪ B ⊆ C ↔ A ⊆ C ∧ B ⊆ C := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_2: Example 12

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Exercise 3.2.2 -/
theorem SetTheory.Set.not_mem_mem (A B:Set) : (A:Object) ∉ B ∨ (B:Object) ∉ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 13

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axiomatization needed for the theorem statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

-- Make `Set` and `Object` available as `Chapter3.Set` and `Chapter3.Object`.
export SetTheory (Set Object)

-- Assume a fixed ambient set theory for the remainder.
variable [SetTheory]

/-- Allow using `x ∈ A` for `x : Object` and `A : Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Interpret a set `A` as a subtype of `Object` consisting of its elements. -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x : Object => x ∈ A)

/-- Coerce a set to the type of its elements (as a subtype of `Object`). -/
instance : CoeSort (Set) (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Subset relation between two sets. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : SetTheory.Object, x ∈ X → x ∈ Y

/--
  Exercise 3.1.11 (statement only, unsolved).
  This formulation only requires the basic primitives introduced above.
-/
theorem SetTheory.Set.specification_from_replacement {A : Set} {P : A → Prop} :
    ∃ B, B ⊆ A ∧ ∀ x, x.val ∈ B ↔ P x := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 14

import Mathlib.Tactic

namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  inter : Set → Set → Set
  subsetRel : Set → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

instance SetTheory.Set.instIntersection : Inter SetTheory.Set where
  inter X Y := SetTheory.inter X Y

instance SetTheory.Set.instSubset : HasSubset SetTheory.Set where
  Subset := SetTheory.subsetRel

@[simp]
theorem SetTheory.Set.subset_inter_iff (A B C:Set) :
    C ⊆ A ∩ B ↔ C ⊆ A ∧ C ⊆ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 15

import Mathlib.Tactic

universe u

/-- Minimal skeleton of the set theory structure needed to state the theorem. -/
class SetTheory where
  Set : Type u
  union_pair : Set → Set → Set
  inter : Set → Set → Set
  sdiff : Set → Set → Set

export SetTheory (Set)

variable [SetTheory]

/-- Provide the notations ∪, ∩, and \ for our abstract `Set`. -/
instance instUnionSet : Union Set where
  union := SetTheory.union_pair

instance instIntersectionSet : Inter Set where
  inter := SetTheory.inter

instance instSDiffSet : SDiff Set where
  sdiff := SetTheory.sdiff

/-- The requested theorem statement, left as `sorry` as instructed. -/
theorem SetTheory.Set.union_eq_partition (A B : Set) :
  A ∪ B = (A \ B) ∪ (A ∩ B) ∪ (B \ A) := by
  sorry

-----------------------------------

Section_3_2: Example 16

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1. The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the replace operation.
-/
theorem SetTheory.Set.replace_exists (h: axiom_of_universal_specification) (A:Set)
  (P: A → Object → Prop) (hP: ∀ x y y', P x y ∧ P x y' → y = y') :
    ∃ (Z:Set), ∀ y, y ∈ Z ↔ ∃ a : A, P a y := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 17

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1. The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the singleton set.
-/
theorem SetTheory.Set.singleton_exists (h: axiom_of_universal_specification) (x:Object):
    ∃ (X:Set), ∀ y, y ∈ X ↔ y = x := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 18

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms and data needed for the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  emptyset : Set
  singleton : Object → Set

export SetTheory (Set Object)

variable [SetTheory]

/-- Membership between `Object` and `Set`. -/
instance : Membership SetTheory.Object SetTheory.Set where
  mem X x := SetTheory.mem x X

/-- Empty set notation `∅`. -/
instance : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Singleton notation `{x}`. -/
instance : Singleton Object Set where
  singleton := SetTheory.singleton

/-- Subset notation `⊆`. -/
instance : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Strict subset notation `⊂`. -/
instance : HasSSubset Set where
  SSubset X Y := X ⊆ Y ∧ X ≠ Y

/-- Exercise 3.1.13 (statement only). -/
theorem SetTheory.Set.singleton_iff (A : Set) (hA : A ≠ ∅) :
    (¬ ∃ B ⊂ A, B ≠ ∅) ↔ ∃ x, A = {x} := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 19

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal scaffolding of the set theory context needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Enable the notation `x ∈ X` for `Object` and `Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1.  The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the pair set.
-/
theorem SetTheory.Set.pair_exists (h: axiom_of_universal_specification) (x₁ x₂:Object):
    ∃ (X:Set), ∀ y, y ∈ X ↔ y = x₁ ∨ y = x₂ := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 20

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow use of `x ∈ X` where `x : Object`, `X : Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1.  The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the empty set.
-/
theorem SetTheory.Set.emptyset_exists (h: axiom_of_universal_specification):
    ∃ (X:Set), ∀ x, x ∉ X := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 21

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- A very small fragment of the axioms of Zermelo-Frankel theory with atoms,
    just enough to state the requested theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  emptyset : Set
  singleton : Object → Set
  union_pair : Set → Set → Set

export SetTheory (Set Object)

variable [SetTheory]

/-- Objects can be coerced to membership with sets (not used below, but standard). -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Sets are objects. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Provide the empty set notation `∅` for our sets. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Provide the singleton notation `{x}` for our sets. -/
instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

/-- Provide the union notation `X ∪ Y` for our sets. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Provide the insert notation `insert x X` and hence `{x,y}` for our sets. -/
instance SetTheory.Set.instInsert : Insert Object Set where
  insert x X := ({x} : Set) ∪ X

/-- Abbreviations used in the statement to be compiled. -/
abbrev SetTheory.Set.empty : Set := ∅
abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}
abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}

/-- The requested theorem (left as `sorry` as instructed). -/
theorem SetTheory.Set.emptyset_neq_pair : empty ≠ pair_empty := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 22

import Mathlib.Tactic

namespace Chapter3

universe u

/-- For this minimal setup, we model `Set` simply as a universe of types. -/
abbrev Set := Type u

/-- Minimal definition of a Chapter 3 style function between sets. -/
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y

/-- The requested theorem, left as a sorry as instructed. -/
theorem Function.refl {X Y : Set} (f : Function X Y) : f = f := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 23

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/-- Exercise 3.2.3 -/
theorem SetTheory.Set.univ_iff :
    axiom_of_universal_specification ↔ ∃ (U : Set), ∀ x, x ∈ U := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 24

namespace Chapter3

universe u

/-- A minimal notion of a "set" that can be used as a type. -/
structure Set where
  carrier : Type u

instance : CoeSort Set (Type u) where
  coe X := X.carrier

/-- A minimal notion of a function between sets. -/
structure Function (X Y : Set) where
  to_fn : X → Y

instance (X Y : Set) : CoeFun (Function X Y) (fun _ => X → Y) where
  coe f := f.to_fn

/-- Composition of Chapter 3 functions. -/
abbrev Function.comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) : Function X Z :=
  ⟨fun x => g (f x)⟩

-- `∘` is already used in Mathlib; we use `○` as in the textbook.
infix:90 "○" => Function.comp

/-- One-to-one (injective) Chapter 3 function. -/
abbrev Function.one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'

/-- Exercise 3.3.2: injectivity is preserved under composition (statement only). -/
theorem Function.comp_of_inj {X Y Z:Set} {f: Function X Y} {g : Function Y Z} (hf: f.one_to_one)
  (hg: g.one_to_one) : (g ○ f).one_to_one := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 25

import Mathlib.Tactic

namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Exercise 3.2.2 -/
theorem SetTheory.Set.not_mem_self (A:Set) : (A:Object) ∉ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 26

import Std.Logic

namespace Chapter3

universe u

-- Minimal stand-in for the "Set" of the textbook: just a type.
abbrev Set := Type u

-- Minimal function structure between sets, with coercion to an actual function.
structure Function (X Y : Set) where
  toFun : X → Y

instance instCoeFun (X Y : Set) : CoeFun (Function X Y) (fun _ => X → Y) where
  coe f := f.toFun

-- Composition of Chapter 3 functions, with the ○ notation.
def Function.comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) : Function X Z :=
  ⟨fun x => g (f x)⟩

infix:90 "○" => Function.comp

-- One-to-one (injective) functions.
def Function.one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'

/--
  Exercise 3.3.4 (statement only).
  Left cancellation of composition by an injective function.
-/
theorem Function.comp_cancel_left {X Y Z:Set} {f f': Function X Y} {g : Function Y Z}
  (heq : g ○ f = g ○ f') (hg: g.one_to_one) : f = f' := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 27

import Mathlib.Tactic

namespace Chapter3

universe u

-- In this minimal setup for Section 3.3, we model a "set" simply as a type.
abbrev Set := Type u

-- A minimal notion of function between sets, as an actual function between the underlying types.
structure Function (X Y : Set) where
  toFn : X → Y

instance {X Y : Set} : CoeFun (Function X Y) (fun _ => X → Y) where
  coe f := f.toFn

-- Composition of Chapter 3 functions
noncomputable def Function.comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) :
    Function X Z :=
  { toFn := fun x => g (f x) }

-- We use a different composition symbol than Mathlib's ∘ to match the textbook.
infix:90 "○" => Function.comp

-- One-to-one (injective) functions
def Function.one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'

/--
  Exercise 3.3.5 (injectivity under composition), minimally formulated.
  We do not solve the theorem here, as requested.
-/
theorem Function.comp_injective {X Y Z:Set} {f: Function X Y} {g : Function Y Z} (hinj :
    (g ○ f).one_to_one) : f.one_to_one := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 28

import Mathlib.Tactic
import Mathlib/Data/Matrix/Notation

namespace Chapter3

universe u

/-- Minimal class to introduce a `Set` type. -/
class SetTheory where
  Set : Type u

export SetTheory (Set)

variable [SetTheory]

/-- Minimal instances to support the notations `∩` and `\` in the statement. -/
instance : Inter Set where
  inter X Y := X

instance : SDiff Set where
  sdiff X Y := X

/-- A placeholder relation `Disjoint` on sets (only for typing the statement). -/
def Disjoint (A B : Set) : Prop := False

/-- A minimal version of `Function.onFun` sufficient to type the statement. -/
namespace Function
def onFun {α β : Sort _} (r : β → β → Prop) (f : α → β) : α → α → Prop :=
  fun a a' => r (f a) (f a')
end Function

/-- A minimal `Pairwise` predicate (only for typing the statement). -/
def Pairwise {α : Sort _} (r : α → α → Prop) : Prop := True

namespace SetTheory
namespace Set

/--
  Exercise 3.1.10.
  You may find `Function.onFun_apply` and the `fin_cases` tactic useful.
-/
theorem pairwise_disjoint (A B : Set) :
    Pairwise (Function.onFun Disjoint ![A \ B, A ∩ B, B \ A]) := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_4: Example 29

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  emptyset : Set
  union_pair : Set → Set → Set

-- Use `Set` and `Object` directly (with typeclass inference).
export SetTheory (Set Object)

-- Assume a model of the axioms is available.
variable [SetTheory]

/-- Provide notation `∅` for the empty set. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Provide notation `∪` for union of two sets. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Exercise 3.4.10: union of two nonempty sets is nonempty. -/
theorem SetTheory.Set.union_of_nonempty {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) : I ∪ J ≠ ∅ := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 30

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : SetTheory.Object → Prop, ∃ A : SetTheory.Set, ∀ x : SetTheory.Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1. The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the union operation.
-/
theorem SetTheory.Set.union_exists
    (h: axiom_of_universal_specification) (A B : SetTheory.Set) :
    ∃ (Z : SetTheory.Set), ∀ z, z ∈ Z ↔ z ∈ A ∨ z ∈ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 31

import Mathlib.Tactic

namespace Chapter3

universe u v

-- A very small skeleton of the structures and notations needed to state the theorem.
class SetTheory where
  Set : Type u
  Object : Type v
  emptyset : Set
  union : Set → Set → Set
  inter : Set → Set → Set
  sdiff : Set → Set → Set

export SetTheory (Set Object)

variable [SetTheory]

instance : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

instance : Union Set where
  union := SetTheory.union

instance : Inter Set where
  inter := SetTheory.inter

instance : SDiff Set where
  sdiff := SetTheory.sdiff

-- The requested theorem (left as sorry).
theorem SetTheory.Set.partition_right {A B X : Set}
    (h_union : A ∪ B = X) (h_inter : A ∩ B = ∅) :
    B = X \ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 32

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal structure for the set theory needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

-- Expose `Set` and `Object` as short names within the `Chapter3` namespace
export SetTheory (Set Object)

variable [SetTheory]

/-- Allow the notation `x ∈ X` for `Object` x and `Set` X. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/--
  Exercise 3.4.8. The point of this exercise is to prove it without using the
  pairwise union operation `∪`. (We only state it here, leaving the proof as `sorry`.)
-/
theorem SetTheory.Set.union_pair_exists (X Y : Set) :
    ∃ Z : Set, ∀ x, x ∈ Z ↔ (x ∈ X ∨ x ∈ Y) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 33

import Mathlib.Tactic

-- Provide a convenient alias so the theorem can use `nat` as in the statement.
abbrev nat := ℕ

namespace SetTheory
namespace Set

/-- Exercise 3.5.12 (compilable stub, not solved). -/
theorem recursion (X: Type) (f: nat → X → X) (c : X) :
    ∃! a : nat → X, a 0 = c ∧ ∀ n, a (n + 1 : ℕ) = f n (a n) := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_3: Example 34

import Mathlib.Tactic

namespace Chapter3

universe u

/-- In this simplified setup for Section 3.3, we model `Set` as a universe of types. -/
abbrev Set := Type u

/-- Chapter 3 notion of a function between sets `X` and `Y`. -/
structure Function (X Y : Set) where
  toFun : X → Y

/-- Allow using a Chapter 3 function as a regular function. -/
instance {X Y : Set} : CoeFun (Function X Y) (fun _ => X → Y) where
  coe f := f.toFun

/-- Build a Chapter 3 function from a regular function. -/
abbrev Function.mk_fn {X Y : Set} (f : X → Y) : Function X Y :=
  ⟨f⟩

/-- One-to-one (injective) Chapter 3 function. -/
abbrev Function.one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  _root_.Function.Injective f.toFun

/-- Onto (surjective) Chapter 3 function. -/
abbrev Function.onto {X Y : Set} (f : Function X Y) : Prop :=
  _root_.Function.Surjective f.toFun

/-- Bijective Chapter 3 function. -/
abbrev Function.bijective {X Y : Set} (f : Function X Y) : Prop :=
  _root_.Function.Bijective f.toFun

/-- Inverse of a bijective Chapter 3 function, via choice (`invFun`). -/
noncomputable def Function.inverse {X Y : Set} (f : Function X Y) (h : f.bijective) :
    Function Y X :=
  Function.mk_fn (_root_.Function.invFun f.toFun)

/-- Exercise 3.3.6 (unsolved): `f⁻¹ ∘ f = id` on the left. -/
theorem Function.inverse_comp_self {X Y: Set} {f: Function X Y} (h: f.bijective) (x: X) :
    (f.inverse h) (f x) = x := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 35

import Mathlib.Tactic

universe u

namespace SetTheory

/-- Minimal placeholder for the "Set" universe used in the theorem statement. -/
abbrev Set := Type u

/-- Minimal subset relation placeholder so that `S ⊆ X` parses as a proposition. -/
instance : HasSubset Set where
  Subset _ _ := Prop

namespace Set

/-- Minimal placeholder for image (no semantics, just to compile statements). -/
def image {X Y : Set} (f : X → Y) (S : Set) : Set := S

/-- Minimal placeholder for preimage (no semantics, just to compile statements). -/
def preimage {X Y : Set} (f : X → Y) (U : Set) : Set := U

/-- The requested theorem stub (left as `sorry` as instructed). -/
theorem preimage_image_of_inj {X Y : Set} (f : X → Y) :
    (∀ S, S ⊆ X → preimage f (image f S) = S) ↔ Function.Injective f := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_4: Example 36

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Definition 3.4.4 (inverse images).
    Again, it is not required that U be a subset of Y. -/
abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set :=
  X.specify (P := fun x ↦ (f x).val ∈ U)

@[simp]
theorem SetTheory.Set.mem_preimage {X Y:Set} (f:X → Y) (U: Set) (x:X) :
    x.val ∈ preimage f U ↔ (f x).val ∈ U := by
  simpa [preimage] using
    (SetTheory.Set.specification_axiom' (A := X) (P := fun x ↦ (f x).val ∈ U) x)

/-- Exercise 3.4.4 -/
theorem SetTheory.Set.preimage_of_inter {X Y:Set} (f:X → Y) (A B: Set) :
    preimage f (A ∩ B) = (preimage f A) ∩ (preimage f B) := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 37

import Mathlib.Tactic

namespace Chapter3

universe u

/-- Minimal skeleton of the Section 3.1 set theory needed just to state the theorem. -/
class SetTheory where
  Set : Type u
  emptyset : Set

export SetTheory (Set)

variable [SetTheory]

/-- Allow the notation `∅ : Set`. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Allow sets to be used as (dummy) index types, so expressions like `A : I → Set` typecheck. -/
instance : CoeSort Set (Type u) where
  coe _ := PUnit

/-- Provide a (dummy) set difference so the notation `X \ Y` is available. -/
instance SetTheory.Set.instSDiff : SDiff Set where
  sdiff X _ := X

/-- Minimal (dummy) indexed union. -/
def SetTheory.Set.iUnion (I : Set) (A : I → Set) : Set :=
  SetTheory.emptyset

/-- Minimal (dummy) indexed intersection (with a nonempty index set hypothesis). -/
def SetTheory.Set.iInter (I : Set) (_hI : I ≠ (∅ : Set)) (A : I → Set) : Set :=
  SetTheory.emptyset

/-- The requested theorem statement (left as `sorry`). -/
theorem SetTheory.Set.compl_iInter {X I : Set} (hI : I ≠ ∅) (A : I → Set) :
    X \ iInter I hI A = iUnion I (fun α ↦ X \ A α) := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 38

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed to state the target theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow writing `x ∈ X` for `Object`/`Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Allow writing `X ⊆ Y` for `Set`. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Provide a (dummy) set difference operation so `\` parses for `Set`. -/
instance SetTheory.Set.instSDiff : SDiff Set where
  sdiff X Y := X

/-- The requested theorem (left as sorry as instructed). -/
theorem SetTheory.Set.subset_diff_subset_counter :
    ∃ (A B A' B':Set), (A' ⊆ A) ∧ (B' ⊆ B) ∧ ¬ (A' \ B') ⊆ (A \ B) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 39

import Mathlib.Tactic

namespace Chapter3

/-- In this minimal stub, `Set` is just an alias for a type.
    This suffices for type-checking the requested theorem. -/
abbrev Set := Type

/-- In this minimal stub, `nat` is the usual natural numbers `ℕ`. -/
abbrev nat := ℕ

namespace SetTheory
namespace Set

/-- Do not change this theorem name or statement; leave it as `sorry` as requested. -/
theorem nat_unique (nat' : Set) (zero : nat') (succ : nat' → nat')
  (succ_ne : ∀ n : nat', succ n ≠ zero)
  (succ_of_ne : ∀ n m : nat', n ≠ m → succ n ≠ succ m)
  (ind : ∀ P : nat' → Prop, P zero → (∀ n, P n → P (succ n)) → ∀ n, P n) :
    ∃! f : nat → nat',
      Function.Bijective f ∧ f 0 = zero
      ∧ ∀ (n : nat) (n' : nat'),
        f n = n' ↔ f (n + 1 : ℕ) = succ n' := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_4: Example 40

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal fragment of the Section 3.1 setup sufficient for iInter'. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  specify :
    (A : Set) →
    (Subtype (fun x : Object => mem x A) → Prop) →
    Set

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow writing `x ∈ X` for `Object` x and `Set` X. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- The subtype of elements of a set `A`. -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x : Object => x ∈ A)

/-- Coerce a `Set` to the type of its elements (as a subtype). -/
instance : CoeSort (Set) (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Convenience wrapper for the specification axiom's constructor. -/
abbrev SetTheory.Set.specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P

/-- Indexed intersection with an arbitrary chosen index `β : I`.
It is independent of the specific choice of `β`, as shown below. -/
abbrev SetTheory.Set.iInter' (I : Set) (β : I) (A : I → Set) : Set :=
  (A β).specify (fun x => ∀ α : I, x.val ∈ A α)

/-- Exercise 3.4.9: the definition of `iInter'` does not depend on `β`. -/
theorem SetTheory.Set.iInter'_insensitive {I : Set} (β β' : I) (A : I → Set) :
    iInter' I β A = iInter' I β' A := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 41

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed from the custom Set theory to state image/preimage. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  extensionality (X Y : Set) : (∀ x, mem x X ↔ mem x Y) → X = Y
  specify (A : Set) (P : Subtype (mem . A) → Prop) : Set
  specification_axiom (A : Set) (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace (A : Set) (P : Subtype (mem . A) → Object → Prop)
    (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom (A : Set) (P : Subtype (mem . A) → Object → Prop)
    (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y

export SetTheory (Set Object)

variable [SetTheory]

/-- Membership of an object in a set. -/
instance : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Coercion of a set to an object. -/
instance : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Treat a set as a type, namely the subtype of objects belonging to it. -/
instance : CoeSort Set (Type v) where
  coe A := Subtype (fun x : Object => x ∈ A)

/-- Subset relation between sets. -/
instance : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Abbreviation for specification at the namespace path `SetTheory.Set`. -/
abbrev SetTheory.Set.specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P

/-- Abbreviation for replacement at the namespace path `SetTheory.Set`. -/
abbrev SetTheory.Set.replace (A : Set) (P : A → Object → Prop)
    (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP

/-- Image of a set under a function between Chapter3 sets. -/
abbrev SetTheory.Set.image {X Y : Set} (f : X → Y) (S : Set) : Set :=
  X.replace
    (P := fun x y => f x = y ∧ x.val ∈ S)
    (by
      intro x y y' h
      have h1 : f x = y := h.1.1
      have h2 : f x = y' := h.2.1
      simpa [h1] using h2)

/-- Preimage of a set under a function between Chapter3 sets. -/
abbrev SetTheory.Set.preimage {X Y : Set} (f : X → Y) (U : Set) : Set :=
  X.specify (P := fun x => (f x).val ∈ U)

/-- Exercise 3.4.5 (statement only, unsolved). -/
theorem SetTheory.Set.image_preimage_of_surj {X Y:Set} (f:X → Y) :
    (∀ S, S ⊆ Y → image f (preimage f S) = S) ↔ Function.Surjective f := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 42

-- Minimal scaffolding to compile the requested theorem name and signature only.

namespace SetTheory

-- A dummy "Set" type sufficient for the statement to typecheck.
def Set : Type := Unit

-- Minimal operations to support the notations used in the theorem.
def prod (A B : Set) : Set := ()
def diff (A B : Set) : Set := ()

-- Notations used in the theorem statement.
notation:75 A:75 " ×ˢ " B:76 => SetTheory.prod A B
notation:70 A:70 " \ " B:71 => SetTheory.diff A B

end SetTheory

-- The requested theorem, left as `sorry` per instructions.
theorem SetTheory.Set.diff_prod (A B C : SetTheory.Set) :
    (A \ B) ×ˢ C = (A ×ˢ C) \ (B ×ˢ C) := by
  sorry

-----------------------------------

Section_3_5: Example 43

import Mathlib.Tactic

namespace Chapter3

namespace SetTheory

-- Minimal placeholder types
def Set : Type := Unit
def Object : Type := Unit

end SetTheory

-- Bring aliases into the Chapter3 namespace
abbrev Set := SetTheory.Set
abbrev Object := SetTheory.Object

-- Define a general binary operation notation ×ˢ via a typeclass
class SProd (α : Type _) (β : Type _) (γ : Type _) where
  sprod : α → β → γ

infixl:70 " ×ˢ " => SProd.sprod

-- Provide union operation notation for our Set type
instance : Union Set where
  union _ _ := ()

-- Provide ×ˢ operation for our Set type
instance : SProd Set Set Set where
  sprod _ _ := ()

namespace SetTheory
namespace Set

-- The requested theorem (left as sorry)
theorem union_prod (A B C : Set) : (A ∪ B) ×ˢ C = (A ×ˢ C) ∪ (B ×ˢ C) := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_4: Example 44

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- A minimal axiomatization to support images and preimages in Section 3.4. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  extensionality (X Y : Set) : (∀ x, mem x X ↔ mem x Y) → X = Y
  specify
    (A : Set)
    (P : Subtype (fun x : Object => mem x A) → Prop) : Set
  specification_axiom
    (A : Set)
    (P : Subtype (fun x : Object => mem x A) → Prop) :
      (∀ x, mem x (specify A P) → mem x A)
      ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace
    (A : Set)
    (P : Subtype (fun x : Object => mem x A) → Object → Prop)
    (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom
    (A : Set)
    (P : Subtype (fun x : Object => mem x A) → Object → Prop)
    (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
      ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y

export SetTheory (Set Object)

variable [SetTheory]

/-- Membership of objects in sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Coercion from sets to objects. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- View a set as a subtype of objects. -/
abbrev SetTheory.Set.toSubtype (A : Set) :=
  Subtype (fun x : Object => SetTheory.mem x A)

/-- Treat a set as a type (its subtype of elements). -/
instance : CoeSort Set (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Subset relation on sets (as in Section 3.1). -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Abbreviation for the axiom of specification on sets. -/
abbrev SetTheory.Set.specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P

/-- Abbreviation for the axiom of replacement on sets. -/
abbrev SetTheory.Set.replace
    (A : Set) (P : A → Object → Prop)
    (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP

/-- Definition 3.4.1: image of a set under a function between sets. -/
abbrev SetTheory.Set.image {X Y : Set} (f : X → Y) (S : Set) : Set :=
  SetTheory.Set.replace X
    (P := fun x y => (f x : Object) = y ∧ x.val ∈ S)
    (by
      intro x y y' h
      rcases h with ⟨⟨h1, _⟩, ⟨h2, _⟩⟩
      exact h1.symm.trans h2)

/-- Definition 3.4.4: preimage (inverse image) of a set under a function between sets. -/
abbrev SetTheory.Set.preimage {X Y : Set} (f : X → Y) (U : Set) : Set :=
  SetTheory.Set.specify X (P := fun x : X => (f x).val ∈ U)

/-- Exercise 3.4.1 (statement only; proof omitted). -/
theorem SetTheory.Set.preimage_eq_image_of_inv
  {X Y V : Set}
  (f : X → Y) (f_inv : Y → X)
  (hf : Function.LeftInverse f_inv f ∧ Function.RightInverse f_inv f)
  (hV : V ⊆ Y) :
  image f_inv V = preimage f V := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 45

import Mathlib.Tactic

/-!
A minimal collection of definitions and instances from Chapter 3 needed to state
the theorem `SetTheory.Set.inter_iInter` from Section 3.4.
-/

namespace Chapter3

universe u v

/-- A minimal version of the SetTheory class containing just the fields needed
to state the target theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  extensionality : ∀ {X Y : Set}, (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem : ∀ x, ¬ mem x emptyset
  union_pair : Set → Set → Set
  union_pair_axiom : ∀ X Y x, mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y)
  specify : ∀ A, (Subtype (mem . A) → Prop) → Set
  specification_axiom :
    ∀ A (P : Subtype (mem . A) → Prop),
      ((∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x)

-- Expose the names `Set` and `Object` from the class.
export SetTheory (Set Object)

variable [SetTheory]

/-- Membership notation `x ∈ X` for `Object` in `Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Coercion of a `Set` to an `Object`. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Extensionality for sets. -/
@[ext]
theorem SetTheory.Set.ext {X Y : Set} (h : ∀ x, x ∈ X ↔ x ∈ Y) : X = Y :=
  SetTheory.extensionality h

/-- Empty set instance to use `∅ : Set`. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- The empty set has no elements. -/
@[simp]
theorem SetTheory.Set.not_mem_empty : ∀ x, x ∉ (∅ : Set) := SetTheory.emptyset_mem

/-- Binary union `X ∪ Y` for sets. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Characterization of membership in a binary union. -/
@[simp]
theorem SetTheory.Set.mem_union (x : Object) (X Y : Set) :
    x ∈ (X ∪ Y) ↔ (x ∈ X ∨ x ∈ Y) :=
  SetTheory.union_pair_axiom X Y x

/-- Interpret a set `A : Set` as a type of its elements with proofs of membership. -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x => x ∈ A)

/-- Coerce `A : Set` to the type of its elements. -/
instance : CoeSort Set (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Elements of a set (as a subtype) are indeed members of the set. -/
lemma SetTheory.Set.subtype_property (A : Set) (x : A) : x.val ∈ A := x.property

/-- Abbreviation for the axiom of specification. -/
abbrev SetTheory.Set.specify (A : Set) (P : A → Prop) : Set := SetTheory.specify A P

/-- Axiom of specification: the specified set is a subset of the original set. -/
theorem SetTheory.Set.specification_axiom {A : Set} {P : A → Prop} {x : Object}
    (h : x ∈ A.specify P) : x ∈ A :=
  (SetTheory.specification_axiom A P).1 x h

/-- Axiom of specification: membership in the specified set corresponds to the predicate. -/
theorem SetTheory.Set.specification_axiom' {A : Set} (P : A → Prop) (x : A) :
    x.val ∈ A.specify P ↔ P x :=
  (SetTheory.specification_axiom A P).2 x

/-- Intersection of sets defined via specification. -/
instance SetTheory.Set.instIntersection : Inter Set where
  inter X Y := X.specify (fun x => x.val ∈ Y)

/-- If a set is not empty, it has an element. -/
lemma SetTheory.Set.nonempty_def {X : Set} (h : X ≠ ∅) : ∃ x, x ∈ X := by
  by_contra! h'
  have claim : ∀ x, x ∈ X ↔ x ∈ (∅ : Set) := by
    intro x; simp [h', SetTheory.Set.not_mem_empty]
  have hx : X = (∅ : Set) := SetTheory.Set.ext claim
  exact h hx

open Classical

/-- Choose a witness from a nonempty set (noncomputably). -/
noncomputable abbrev SetTheory.Set.nonempty_choose {I : Set} (hI : I ≠ ∅) : I :=
  ⟨ (SetTheory.Set.nonempty_def hI).choose, (SetTheory.Set.nonempty_def hI).choose_spec ⟩

/-- Indexed intersection, using a base index `β : I`. -/
abbrev SetTheory.Set.iInter' (I : Set) (β : I) (A : I → Set) : Set :=
  (A β).specify (fun x => ∀ α : I, x.val ∈ A α)

/-- Indexed intersection over a nonempty index set. -/
noncomputable abbrev SetTheory.Set.iInter (I : Set) (hI : I ≠ ∅) (A : I → Set) : Set :=
  SetTheory.Set.iInter' I (SetTheory.Set.nonempty_choose hI) A

/-- A helper lemma from Section 3.4: the union of two nonempty sets is nonempty.
We do not prove it here. -/
theorem SetTheory.Set.union_of_nonempty {I J : Set} (hI : I ≠ ∅) (hJ : J ≠ ∅) : I ∪ J ≠ ∅ := by
  sorry

/-- The target theorem from Section 3.4. We only provide a stub (sorry). -/
theorem SetTheory.Set.inter_iInter {I J : Set} (hI : I ≠ ∅) (hJ : J ≠ ∅)
    (A : (I ∪ J : Set) → Set) :
    iInter I hI (fun α => A ⟨ α.val, by simp [α.property] ⟩)
    ∩ iInter J hJ (fun α => A ⟨ α.val, by simp [α.property] ⟩)
    = iInter (I ∪ J) (union_of_nonempty hI hJ) A := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 46

import Mathlib.Tactic

namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

def Subset (X Y : Set) : Prop := ∀ x : Object, x ∈ X → x ∈ Y
notation:50 X " ⊆ " Y:50 => Subset X Y

def SetTheory.Set.powerset (X : Set) : Set := X

open SetTheory.Set

@[simp]
theorem SetTheory.Set.mem_powerset {X:Set} (x:Object) :
    x ∈ powerset X ↔ ∃ Y:Set, x = Y ∧ Y ⊆ X := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 47

import Mathlib.Tactic

/-!
Minimal scaffolding to state the theorem

theorem SetTheory.Set.partial_functions {X Y:Set} :
    ∃ Z:Set, ∀ F:Object, F ∈ Z ↔ ∃ X' Y':Set, X' ⊆ X ∧ Y' ⊆ Y ∧ ∃ f: X' → Y', F = f

without proving it.
-/

namespace Chapter3

universe u v

/-- Minimal axioms needed for the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  -- We include this so that functions `X → Y` can coerce to `Object`,
  -- making the expression `F = f` well-typed in the statement.
  function_to_object :
    (X Y : Set) →
    (Subtype (fun x : Object => mem x X) → Subtype (fun y : Object => mem y Y)) →
    Object

export SetTheory (Set Object)

variable [SetTheory]

/-- Membership notation `x ∈ X` for `Object` in `Set`. -/
instance : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- View a `Set` as a type (its elements are those `Object`s that belong to it). -/
instance : CoeSort Set (Type v) where
  coe A := { x : Object // SetTheory.mem x A }

/-- Allow functions between sets to coerce to `Object`. -/
instance inst_coe_of_fun (X Y : Set) : CoeOut (X → Y) Object where
  coe f := SetTheory.function_to_object X Y f

/-- Subset notation `X ⊆ Y` for our `Set` type. -/
scoped infix:50 " ⊆ " => fun (X Y : Set) => ∀ x : Object, x ∈ X → x ∈ Y

/-
  Target theorem (left as `sorry` as requested).
-/
theorem SetTheory.Set.partial_functions {X Y:Set} :
    ∃ Z:Set, ∀ F:Object, F ∈ Z ↔
      ∃ X' Y':Set, X' ⊆ X ∧ Y' ⊆ Y ∧ ∃ f: X' → Y', F = f := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 48

import Mathlib.Tactic

/-!
Minimal scaffolding to state the requested theorem without proving it.
We provide a barebones version of the Chapter 3 set-theory framework,
just enough to compile the theorem statement.
-/

namespace Chapter3

universe u v

/-- Minimal class carrying the abstract types `Set` and `Object`. -/
class SetTheory where
  Set : Type u
  Object : Type v

export SetTheory (Set Object)

variable [SetTheory]

/-- Provide an intersection operation `∩` on `Set` (dummy implementation). -/
instance : Inter Set where
  inter X _ := X

/-- Provide the notation `×ˢ` for a Cartesian-like product on `Set` (dummy implementation). -/
infixl:70 " ×ˢ " => fun (X : Set) (_Y : Set) => X

/-- The requested theorem, left as `sorry` (unsolved). -/
theorem SetTheory.Set.inter_prod (A B C : Set) :
    (A ∩ B) ×ˢ C = (A ×ˢ C) ∩ (B ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 49

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal skeleton of the set-theory framework needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop

-- Allow using `Set` and `Object` directly (as in the provided statement).
export SetTheory (Set Object)

variable [SetTheory]

/-- Objects can be elements of sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Sets are objects. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Coerce a `Set` to a type (as a subtype of `Object`). -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x : Object => SetTheory.mem x A)

instance : CoeSort (SetTheory.Set) (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- An alternate definition of a tuple, used in Section 3.5. -/
structure SetTheory.Set.Tuple (n : ℕ) where
  X    : Set
  x    : Fin n → X
  surj : Function.Surjective x

/-- The requested theorem (left as `sorry`). -/
theorem SetTheory.Set.Tuple.eq {n:ℕ} (t t' : SetTheory.Set.Tuple n) :
    t = t' ↔ ∀ n : Fin n, ((t.x n):Object) = ((t'.x n):Object) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 50

import Mathlib.Tactic

namespace Chapter3

universe u

/-- Minimal stub of the set theory environment needed to state the theorem. -/
class SetTheory where
  Set : Type u

export SetTheory (Set)

variable [SetTheory]

/-- Provide union notation `∪` for `Set`. -/
instance : Union Set where
  union A B := A

/-- Provide Cartesian product notation `×ˢ` for `Set`. -/
def cartesian (A B : Set) : Set := A
infixr:82 " ×ˢ " => cartesian

/-- The requested theorem (left as `sorry`). -/
theorem SetTheory.Set.prod_union (A B C : Set) :
    A ×ˢ (B ∪ C) = (A ×ˢ B) ∪ (A ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 51

import Mathlib.Tactic

namespace Chapter3

universe u

/-- Minimal skeleton of the set theory class sufficient to state the theorem. -/
class SetTheory where
  Set : Type u

export SetTheory (Set)

variable [SetTheory]

/-- Provide the `∩` notation via a minimal `Inter` instance. -/
instance SetTheory.Set.instInter : Inter Set where
  inter X Y := X

namespace SetTheory.Set

/-- A placeholder definition for Cartesian product, only to make the statement typecheck. -/
def cartesian (A B : Set) : Set := A

/-- Enable the `×ˢ` notation for our placeholder Cartesian product. -/
notation:70 A " ×ˢ " B => SetTheory.Set.cartesian A B

/-- The requested theorem, left as sorry. -/
theorem prod_inter (A B C : Set) :
    A ×ˢ (B ∩ C) = (A ×ˢ B) ∩ (A ×ˢ C) := by
  sorry

end SetTheory.Set

end Chapter3

-----------------------------------

Section_3_5: Example 52

namespace Chapter3

universe u

namespace SetTheory

/-- A minimal notion of a "set" as a carrier type. -/
structure Set where
  carrier : Type u

/-- Coerce a `Set` to its carrier type so we can write `x : X` for `X : Set`. -/
instance : CoeSort Set (Type u) where
  coe X := X.carrier

/-- A minimal typeclass to support the ×ˢ notation. -/
class SProd (α β γ : Sort _) where
  sprod : α → β → γ

infix:70 " ×ˢ " => SProd.sprod

/-- Cartesian product of two sets, interpreted as product of the carrier types. -/
instance : SProd Set Set Set where
  sprod X Y := ⟨X.carrier × Y.carrier⟩

namespace Set

/-- First projection from a Cartesian product. -/
def fst {X Y : Set} (p : X ×ˢ Y) : X := p.1

/-- Second projection from a Cartesian product. -/
def snd {X Y : Set} (p : X ×ˢ Y) : Y := p.2

/-- Function composition notation (local). -/
notation f:80 " ∘ " g:80 => fun x => f (g x)

/-- Exercise 3.5.7 (statement only). -/
theorem direct_sum {X Y Z : Set} (f : Z → X) (g : Z → Y) :
    ∃! h : Z → X ×ˢ Y, fst ∘ h = f ∧ snd ∘ h = g := by
  sorry

end Set
end SetTheory
end Chapter3

-----------------------------------

Section_3_6: Example 53

import Mathlib.Tactic

/-!
Minimal scaffolding to compile the requested theorem.
We only introduce the bare necessities: a SetTheory class with a Set type,
a dummy element of Set to build placeholders, a placeholder for Permutations,
and a placeholder cardinality function `card`.
-/

namespace Chapter3

/-- Minimal SetTheory scaffold with a Set type and a distinguished element. -/
class SetTheory where
  Set : Type
  arbitrarySet : Set

namespace SetTheory

export SetTheory (Set)

variable [SetTheory]

/-- Namespacing for set-level constructions. -/
namespace Set

/-- Placeholder definition for the set of permutations on `Fin n`. -/
def Permutations (n : ℕ) : Set := SetTheory.arbitrarySet

/-- Placeholder cardinality function on sets. -/
def card (_ : Set) : ℕ := 0

/--
Exercise 3.6.12 (i), second part.
We only provide a stub with `sorry`, as requested.
-/
theorem Permutations_ih (n: ℕ) :
    (Permutations (n + 1)).card = (n + 1) * (Permutations n).card := by
  sorry

end Set
end SetTheory
end Chapter3

-----------------------------------

Section_3_6: Example 54

import Mathlib.Data.Fin.Basic

namespace SetTheory
namespace Set

-- Provide a local alias so the statement matches the requested name and type.
abbrev nat := Nat

theorem bounded_on_finite {n:ℕ} (f: Fin n → nat) :
  ∃ M, ∀ i, (f i:ℕ) ≤ M := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_6: Example 55

import Mathlib.Tactic
import Analysis.Section_3_6

-----------------------------------

Section_3_5: Example 56

import Mathlib.Tactic

/-!
A minimal stub to allow the statement of the requested theorem to compile.
We do not prove anything; we only provide enough structure and notation
so that the theorem statement typechecks.
-/

namespace Chapter3

universe u v

/-- A minimal version of the SetTheory class, exposing just the types we need. -/
class SetTheory where
  Set : Type u
  Object : Type v

-- Make the Set and Object type names available as `Set` and `Object` in this namespace.
export SetTheory (Set Object)

-- We work relative to an (unspecified) instance of SetTheory.
variable [SetTheory]

/-!
Provide a dummy set-difference operation `\` on Chapter 3 sets,
so that expressions like `A \ B` typecheck.
-/
instance : SDiff Set where
  sdiff := fun X _Y => X

/-!
Provide a dummy Cartesian product operation, and bind it to the `×ˢ` notation.
-/
def cartesian (A B : Set) : Set := A

infix:75 " ×ˢ " => cartesian

/-- The requested theorem from Section 3.5, left as `sorry` as instructed. -/
theorem SetTheory.Set.prod_diff (A B C : Set) :
    A ×ˢ (B \ C) = (A ×ˢ B) \ (A ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 57

namespace SetTheory

/-- A minimal stub type of sets, sufficient to state the theorem. -/
structure Set where

/-- A dummy union operation on sets (no semantics needed for compilation). -/
def union (A B : Set) : Set := A

/-- A dummy intersection operation on sets (no semantics needed for compilation). -/
def inter (A B : Set) : Set := A

/-- Union notation for our dummy sets. -/
infixl:65 " ∪ " => SetTheory.union

/-- Intersection notation for our dummy sets. -/
infixl:70 " ∩ " => SetTheory.inter

namespace Set

/-- A dummy predicate asserting finiteness of a set (always true here, for compilation). -/
def finite (X : SetTheory.Set) : Prop := True

/-- A dummy cardinality function (always zero here, for compilation). -/
def card (X : SetTheory.Set) : Nat := 0

/-- The requested theorem, left as `sorry` as instructed. -/
theorem card_union_add_card_inter {A B:Set} (hA: A.finite) (hB: B.finite) :
    A.card + B.card = (A ∪ B).card + (A ∩ B).card := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_5: Example 58

import Mathlib.Tactic

/-!
Minimal scaffolding to compile the theorem

We only introduce enough to define a dummy `graph` and state the theorem
`SetTheory.Set.graph_inj` with the required name and types. We do not provide
any of the actual set-theoretic development, nor do we solve the theorem.
-/

universe u

namespace Chapter3

/-- Minimal placeholder for the "Set" type used in the theorem statement. -/
abbrev Set : Type (u+1) := Type u

namespace SetTheory
namespace Set

/-- Minimal placeholder for the graph of a function `f : X → Y`, returning a "set".
This is just a stub to allow the theorem to compile. -/
abbrev graph {X Y : Chapter3.Set} (f : X → Y) : Chapter3.Set := PUnit.{u}

/-- The requested theorem, left as `sorry`. -/
theorem graph_inj {X Y : Chapter3.Set} (f f' : X → Y) :
    graph f = graph f' ↔ f = f' := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_6: Example 59

import Mathlib.Tactic

namespace Chapter3

universe u

/-- Minimal stub of the set theory framework sufficient to state the theorem. -/
class SetTheory where
  Set : Type u
  emptyset : Set

/-- Expose `Set` so we can write `Set` instead of `SetTheory.Set`. -/
export SetTheory (Set)

variable [SetTheory]

/-- Provide `∅` notation for our sets. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- A placeholder notion of equal cardinality (only for compiling the statement). -/
def SetTheory.Set.EqualCard (X Y : Set) : Prop := True

/-- Make `≈` available for our sets via a trivial setoid (only for compiling the statement). -/
instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set where
  r := SetTheory.Set.EqualCard
  iseqv := by
    refine ⟨?refl, ?symm, ?trans⟩
    · intro X; trivial
    · intro X Y _; trivial
    · intro X Y Z _ _; trivial

/-- A minimal stub for the `Fin n` set used in cardinality statements. -/
abbrev SetTheory.Set.Fin (n : ℕ) : Set := (∅ : Set)

/-- Has-cardinality: `X` has cardinal `n` iff `X ≈ Fin n` (stubbed). -/
abbrev SetTheory.Set.has_card (X : Set) (n : ℕ) : Prop := X ≈ SetTheory.Set.Fin n

/-- The requested theorem (left as `sorry` as instructed). -/
theorem SetTheory.Set.has_card_zero {X : Set} : X.has_card 0 ↔ X = ∅ := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 60

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

-- Provide a minimal stub for cardinality to make the theorem statement compilable.
namespace SetTheory.Set
  abbrev has_card (X : Set) (n : ℕ) : Prop := True
end SetTheory.Set

theorem SetTheory.Set.Example_3_6_7a (a : Object) : ({a} : Set).has_card 1 := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 61

import Mathlib.Tactic

/-
We set up a minimal environment to state the requested theorem without proving it.
This is a lightweight skeleton that provides just enough structure (types and notations)
for the theorem to compile.
-/

namespace Chapter3

universe u

/-- Minimal version of the SetTheory class, only providing a type of sets and an empty set. -/
class SetTheory where
  Set : Type u
  emptyset : Set

-- Expose `Set` at the namespace level as in the textbook files.
export SetTheory (Set)

variable [SetTheory]

/-- Provide `∅` notation for the empty set. -/
instance : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Provide `⊆` notation for a subset relation on our sets (as a trivial Prop to typecheck). -/
instance : HasSubset Set where
  Subset _ _ := True

/-- A minimal "product" operation on sets, just to support the notation `×ˢ`. -/
def SetTheory.Set.sprod (A B : Set) : Set := A

/-- Notation for the cartesian product, as used in the theorem statement. -/
infixl:82 " ×ˢ " => SetTheory.Set.sprod

/-- The requested theorem, left as `sorry` per the instructions. -/
theorem SetTheory.Set.prod_subset_prod {A B C D : Set}
  (hA : A ≠ ∅) (hB : B ≠ ∅) (hC : C ≠ ∅) (hD : D ≠ ∅) :
    A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D := by
  sorry

end Chapter3

-----------------------------------

Section_4_4: Example 62

import Mathlib.Tactic

/-!
# Analysis I, Section 4.4: gaps in the rational numbers

Exercise 4.4.2: No infinite descent in ℕ
-/

namespace Nat

/-- Exercise 4.4.2 -/
theorem no_infinite_descent : ¬ ∃ a : ℕ → ℕ, ∀ n : ℕ, a (n + 1) < a n := by
  sorry

end Nat

-----------------------------------

Section_3_6: Example 63

import Mathlib.Tactic

namespace Chapter3

-- Minimal skeleton to make the requested theorem compile

class SetTheory where
  Set : Type

export SetTheory (Set)

variable [SetTheory]

-- A minimal binary operation and notation for cartesian product
def sprod (A B : Set) : Set := A
infix:70 " ×ˢ " => sprod

-- A minimal placeholder for EqualCard
def SetTheory.Set.EqualCard (X Y : Set) : Prop := True

-- Local alias so the unqualified name `EqualCard` resolves in the theorem statement
abbrev EqualCard := SetTheory.Set.EqualCard

-- The requested (unsolved) theorem
theorem SetTheory.Set.prod_EqualCard_prod (A B:Set) :
    EqualCard (A ×ˢ B) (B ×ˢ A) := by
  sorry

end Chapter3

-----------------------------------

Section_4_3: Example 64

import Mathlib.Tactic

namespace Section_4_3

/-- Exercise 4.3.5 -/
theorem two_pow_geq (N:ℕ) : 2^N ≥ N := by
  sorry

end Section_4_3

-----------------------------------

Section_3_6: Example 65

import Mathlib.Tactic
import Mathlib.Data/Nat/Parity
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

open SetTheory.Set

/-- Definition 3.6.1 (Equal cardinality) -/
abbrev SetTheory.Set.EqualCard (X Y : Set) : Prop := ∃ f : X → Y, Function.Bijective f

/-- Example 3.6.3 -/
theorem SetTheory.Set.Example_3_6_3 :
    EqualCard nat (nat.specify (fun x ↦ Even (x : ℕ))) := by
  sorry

end Chapter3

-----------------------------------

Section_4_1: Example 66

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms
import Mathlib.Data.Int.Basic

namespace Section_4_1

abbrev Int := _root_.Int

theorem Int.sq_nonneg (n:Int) : 0 ≤ n*n := by
  sorry

end Section_4_1

-----------------------------------

Section_3_6: Example 67

import Mathlib.Data.Fin.Basic

/-!
A minimal stub to make the target theorem compile.
We only declare the names and shapes used in the statement.
-/

namespace Chapter3

universe u

/-- Minimal SetTheory class carrying just a type of sets. -/
class SetTheory where
  Set : Type u

variable [SetTheory]

/-!
We now create a namespace `SetTheory.Set` (re-using the name `Set` both as the type
and as the namespace, as in the provided files) and declare the minimal API
needed for the theorem statement to typecheck.
-/
namespace SetTheory.Set

/-- Cardinality of a set (stub). -/
constant card : Set → Nat

/-- Finiteness of a set (stub). -/
constant finite : Set → Prop

/-- Indexed union of a family of sets (stub). The first argument is unused but included
to match the arity used in the provided files (`iUnion _ A`). -/
constant iUnion {ι : Sort _} (I : ι) (A : ι → Set) : Set

/-- The requested theorem, left as `sorry` as instructed. -/
theorem pigeonhole_principle {n : ℕ} {A : Fin n → Set}
  (hA : ∀ i, (A i).finite) (hAcard : (iUnion _ A).card > n) : ∃ i, (A i).card ≥ 2 := by
  sorry

end SetTheory.Set
end Chapter3

-----------------------------------

Section_4_1: Example 68

import Mathlib.Data.Int.Basic

/-!
We set up a minimal environment so that the requested theorem
`Section_4_1.Int.no_induction` compiles. We identify the section's `Int`
with Mathlib's `ℤ`, which already has the needed algebraic structure.
-/

namespace Section_4_1

abbrev Int := ℤ

/-- Exercise 4.1.8 -/
theorem Int.no_induction :
    ∃ P : Int → Prop, P 0 ∧ ∀ n, P n → P (n + 1) ∧ ¬ ∀ n, P n := by
  sorry

end Section_4_1

-----------------------------------

Section_5_3: Example 69

import Analysis.Section_5_2

namespace Chapter5
namespace Real

/-- Exercise 5.3.4 -/
theorem IsBounded.equiv {a b:ℕ → ℚ}
  (ha: (a:Sequence).IsBounded) (hab: Sequence.Equiv a b) :
    (b:Sequence).IsBounded := by
  sorry

end Real
end Chapter5

-----------------------------------

Section_3_6: Example 70

import Mathlib.Tactic

/-
  Minimal scaffolding to make the requested theorem compile without
  importing the full textbook development.
-/

-- A very lightweight class, just to provide a type of "sets".
class SetTheory where
  Set : Type

namespace SetTheory

-- Work under an arbitrary instance of the set theory axioms.
variable [SetTheory]

-- For convenience, use the type of sets with the short name `Set`.
export SetTheory (Set)

namespace Set

-- A dummy notion of "equal cardinality" (we do not prove anything here).
abbrev EqualCard (X Y : Set) : Prop := True

-- A placeholder "power" operation on sets, just to support the notation `^`.
def pow (A B : Set) : Set := A
instance : Pow Set Set where
  pow := pow

-- A placeholder "Cartesian product" operation, with the requested notation `×ˢ`.
def sprod (A B : Set) : Set := A
infixl:70 " ×ˢ " => sprod

/-- The requested theorem (left as `sorry` as instructed). -/
theorem pow_pow_EqualCard_pow_prod (A B C : Set) :
    EqualCard ((A ^ B) ^ C) (A ^ (B ×ˢ C)) := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_6: Example 71

import Mathlib.Tactic

/-
Minimal stubs to make the requested theorem compile, without importing the
full Section 3.x development. We only introduce the names and basic
declarations needed for the statement.
-/

namespace SetTheory

/-- A minimal placeholder for the Chapter 3 notion of a `Set`. -/
constant Set : Type

namespace Set

/-- A minimal placeholder predicate for "finiteness" of a set. -/
constant finite : SetTheory.Set → Prop

/-- A minimal placeholder "cardinality" function on sets. -/
constant card : SetTheory.Set → Nat

end Set

/-- A minimal empty set to support the `∅` notation. -/
constant emptyset : Set

/-- Provide the `∅ : SetTheory.Set` notation. -/
instance : EmptyCollection Set where
  emptyCollection := emptyset

end SetTheory

-- Make `Set` available at the top level so the binder `{X : Set}` parses as requested.
export SetTheory (Set)

/-- The requested theorem statement, left as `sorry` by design. -/
theorem SetTheory.Set.card_eq_zero_of_empty {X : Set} (hX : X.finite) :
    X.card = 0 ↔ X = ∅ := by
  sorry

-----------------------------------

Section_5_4: Example 72

import Mathlib.Data.Real.Basic

namespace Real

theorem dist_le_iff (ε x y : Real) : |x - y| ≤ ε ↔ y - ε ≤ x ∧ x ≤ y + ε := by
  sorry

end Real

-----------------------------------

Section_4_2: Example 73

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Section_4_2

-- Minimal scaffold to compile the requested theorem

abbrev Rat := Int

namespace Rat
def isNeg (q : Rat) : Prop := True
end Rat

theorem Rat.mul_lt_mul_right_of_neg (x y z : Rat) (hxy : x < y) (hz : z.isNeg) :
    x * z > y * z := by
  sorry

end Section_4_2

-----------------------------------

Section_5_3: Example 74

import Mathlib.Data.Real.Basic

namespace Chapter5

@[simp]
theorem Real.ratCast_inj (q r : ℚ) : (q : Real) = (r : Real) ↔ q = r := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 75

import Mathlib.Data.Real.Basic

theorem Real.neg_max (x y : Real) : max x y = - min (-x) (-y) := by
  sorry

-----------------------------------

Section_5_4: Example 76

import Mathlib.Data.Real.Basic

theorem Real.min_add (x y z : Real) : min (x + z) (y + z) = min x y + z := by
  sorry

-----------------------------------

Section_5_4: Example 77

import Mathlib.Data.Real.Basic

namespace Real

theorem le_add_eps_iff (x y : Real) : ∀ ε > 0, x ≤ y + ε ↔ x ≤ y := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 78

import Mathlib.Data.Real.Basic

namespace Real

abbrev IsPos (x : Real) : Prop := 0 < x

theorem min_mul (x y : Real) {z : Real} (hz : z.IsPos) :
    min (x * z) (y * z) = min x y * z := by
  sorry

end Real

-----------------------------------

Section_4_1: Example 79

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Section_4_1

abbrev Int := _root_.Int

theorem Int.sq_nonneg' (n : Int) : ∃ (m : Nat), n * n = m := by
  sorry

end Section_4_1

-----------------------------------

Section_5_2: Example 80

import Mathlib.Tactic
import Analysis.Section_5_1

/-!
Minimal prerequisites from Section 5.2 needed to state the theorem.
-/

abbrev Rat.CloseSeq (ε : ℚ) (a b : Chapter5.Sequence) : Prop :=
  ∀ n, n ≥ a.n₀ → n ≥ b.n₀ → ε.Close (a n) (b n)

abbrev Rat.EventuallyClose (ε : ℚ) (a b : Chapter5.Sequence) : Prop :=
  ∃ N, ε.CloseSeq (a.from N) (b.from N)

namespace Chapter5

/-- Exercise 5.2.2 (statement only) -/
theorem Sequence.isBounded_of_eventuallyClose
    {ε : ℚ} {a b : ℕ → ℚ} (hab : ε.EventuallyClose a b) :
    (a : Sequence).IsBounded ↔ (b : Sequence).IsBounded := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 81

import Mathlib.Data.Real.Basic

namespace Real

theorem min_self (x : Real) : min x x = x := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 82

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

namespace Real

theorem min_comm (x y : Real) : min x y = min y x := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 83

import Mathlib.Data.Real.Basic
import Mathlib.Tactic

namespace Real

theorem dist_le_eps_iff (x y : Real) :
    ∀ ε > 0, |x - y| ≤ ε ↔ x = y := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 84

import Mathlib.Data.Real.Basic

namespace Chapter5

abbrev Real := ℝ

theorem Real.max_comm (x y : Real) : max x y = max y x := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 85

import Mathlib.Data.Real.Basic

theorem Real.floor_exist (x : Real) :
    ∃ n : ℤ, (n : Real) ≤ x ∧ x < (n : Real) + 1 := by
  sorry

-----------------------------------

Section_5_4: Example 86

import Mathlib.Data.Real.Basic

namespace Chapter5

abbrev Real := ℝ

theorem Real.max_add (x y z:Real) : max (x + z) (y + z) = max x y + z := by
  sorry

end Chapter5

-----------------------------------

Section_5_5: Example 87

import Mathlib/Tactic
import Mathlib/Data/Real/Basic
import Mathlib/Order/Bounds

namespace Chapter5

/-- Exercise 5.5.2 -/
theorem Real.upperBound_between
  {E: Set Real} {n:ℕ} {L K:ℤ} (hLK: L < K)
  (hK: K*((1/(n+1):ℚ):Real) ∈ upperBounds E)
  (hL: L*((1/(n+1):ℚ):Real) ∉ upperBounds E) :
    ∃ m, L < m
    ∧ m ≤ K
    ∧ m*((1/(n+1):ℚ):Real) ∈ upperBounds E
    ∧ (m-1)*((1/(n+1):ℚ):Real) ∉ upperBounds E := by
  sorry

end Chapter5

-----------------------------------

Section_6_1: Example 88

import Mathlib.Data.Real.Basic

namespace Chapter6

/--
A minimal real-valued sequence type, indexed by integers.
Only the evaluation function is provided, sufficient for the theorem statement.
-/
structure Sequence where
  seq : ℤ → ℝ

/-- Allow using a sequence as a function ℤ → ℝ. -/
instance : CoeFun Sequence (fun _ => ℤ → ℝ) where
  coe a := a.seq

/-- A minimal placeholder definition of convergence (tends to), sufficient for typechecking. -/
abbrev Sequence.TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), True

/--
Theorem from Section 6.1. Stated as in the textbook. The proof is omitted (`sorry`).
-/
theorem Sequence.tendsTo_iff (a : Sequence) (L : ℝ) :
  a.TendsTo L ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - L| ≤ ε := by
  sorry

end Chapter6

-----------------------------------

Section_5_5: Example 89

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

namespace Chapter5

-- Use Mathlib's real numbers within the Chapter5 namespace
abbrev Real := _root_.Real

/-- Exercise 5.5.5 -/
theorem Real.irrat_between {x y : Real} (hxy : x < y) :
    ∃ z, x < z ∧ z < y ∧ ¬ ∃ q : ℚ, z = (q : Real) := by
  sorry

end Chapter5

-----------------------------------

Section_5_5: Example 90

import Mathlib.Tactic
import Analysis.Section_5_2
import Mathlib.Algebra.Group.MinimalAxioms

namespace Chapter5

abbrev Real := ℚ

noncomputable abbrev LIM (a : ℕ → ℚ) : Real := 0

/-- Exercise 5.5.4 -/
theorem Real.LIM_of_Cauchy {q:ℕ → ℚ}
  (hq: ∀ M, ∀ n ≥ M, ∀ n' ≥ M, |q n - q n'| ≤ 1 / (M+1)) :
    (q:Sequence).IsCauchy ∧ ∀ M, |q M - LIM q| ≤ 1 / (M+1) := by
  sorry

end Chapter5

-----------------------------------

Section_5_5: Example 91

import Mathlib.Data.Real.Basic
import Mathlib.Algebra.Pointwise
import Mathlib.Order.CompleteLattice

namespace Real

-- Exercise 5.5.1 (stub): infimum under negation
theorem inf_neg {E : Set Real} {M : Real} (h : IsLUB E M) : IsGLB (-E) (-M) := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 92

import Mathlib.Data.Real.Basic

namespace Chapter5

/-- We model the textbook's `Chapter5.Real` using the standard real numbers `ℝ`. -/
abbrev Real := ℝ

/-- The textbook's positivity predicate. -/
abbrev Real.IsPos (x : Real) : Prop := 0 < x

/-- Exercise 5.4.9 (from Section 5.4): stated but not proved. -/
theorem Real.inv_max {x y : Real} (hx : x.IsPos) (hy : y.IsPos) :
    (max x y)⁻¹ = min x⁻¹ y⁻¹ := by
  sorry

end Chapter5

-----------------------------------

Section_5_6: Example 93

import Mathlib.Data.Real.Basic
import Mathlib.Data.Nat.Parity

namespace Chapter5

theorem Real.pow_even (x : Real) {n : ℕ} (hn : Even n) : x ^ n ≥ 0 := by
  sorry

end Chapter5

-----------------------------------

Section_6_1: Example 94

import Mathlib.Data.Real.Basic

namespace Chapter6

theorem Sequence.mono_if {a: ℕ → ℝ} (ha: ∀ n, a (n+1) > a n) {n m:ℕ} (hnm: m > n) : a m > a n := by
  sorry

end Chapter6

-----------------------------------

Section_5_4: Example 95

import Mathlib.Tactic

namespace Real

theorem dist_lt_iff (ε x y : ℝ) : |x - y| < ε ↔ y - ε < x ∧ x < y + ε := by
  sorry

end Real

-----------------------------------

Section_6_4: Example 96

import Mathlib.Tactic
import Analysis.Section_6_3

namespace Chapter6

/-- Exercise 6.4.6 -/
theorem Sequence.sup_not_strict_mono :
    ∃ (a b : ℕ → ℝ), (∀ n, a n < b n) ∧ (a : Sequence).sup ≠ (b : Sequence).sup := by
  sorry

end Chapter6

-----------------------------------

Section_6_1: Example 97

import Mathlib.Data.Real.Basic

namespace Chapter6

/--
A minimal real-valued sequence structure (only the components needed for the theorem statement).
-/
structure Sequence where
  m : ℤ := 0
  seq : ℤ → ℝ := fun _ => 0

/-- A dummy division on sequences (its behavior is irrelevant for the unsolved theorem). -/
instance : Div Sequence where
  div a _ := a

/-- A minimal notion of convergence (placeholder, sufficient for type-checking). -/
abbrev Sequence.Convergent (a : Sequence) : Prop := True

/-- A dummy limit function on sequences (placeholder, sufficient for type-checking). -/
noncomputable abbrev lim (a : Sequence) : ℝ := 0

/-- Exercise 6.1.9 (skeleton, not solved). -/
theorem Sequence.lim_div_fail :
    ∃ a b, a.Convergent
    ∧ b.Convergent
    ∧ lim b = 0
    ∧ ¬ ((a / b).Convergent ∧ lim (a / b) = lim a / lim b) := by
  sorry

end Chapter6

-----------------------------------

Section_5_4: Example 98

import Mathlib.Tactic

namespace Chapter5

/-- A minimal stub for the notion of a sequence, sufficient for type-checking. -/
structure Sequence where
  dummy : Unit := ()

/-- Coerce a function `ℕ → ℚ` to a dummy `Sequence`. -/
instance : Coe (ℕ → ℚ) Sequence where
  coe _ := Sequence.mk ()

/-- A minimal stub for the Cauchy property, sufficient for type-checking. -/
abbrev Sequence.IsCauchy (a : Sequence) : Prop := True

/-- A minimal stub for the real numbers used in this section. -/
structure Real where
  dummy : Unit := ()

/-- A minimal stub for casting rationals to these reals. -/
instance : RatCast Real where
  ratCast _ := Real.mk ()

/-- A minimal stub for the formal limit `LIM` of a sequence of rationals. -/
def LIM (a : ℕ → ℚ) : Real := Real.mk ()

/-- A minimal stub for `≤` on these reals (always true), sufficient for type-checking. -/
instance : LE Real where
  le _ _ := True

/-- Exercise 5.4.8 (stubbed): If `a n ≤ x` for all `n`, then `LIM a ≤ x`. -/
theorem Real.LIM_of_le {x : Real} {a : ℕ → ℚ}
    (hcauchy : (a : Sequence).IsCauchy) (h : ∀ n, a n ≤ x) :
    LIM a ≤ x := by
  -- With the stubbed `≤` instance as `True`, this is trivially satisfied.
  trivial

end Chapter5

-----------------------------------

Section_5_4: Example 99

import Mathlib.Tactic

namespace Chapter5

-- Minimal stubs to make the theorem statement typecheck and compile

-- Treat sequences as functions from ℕ to ℚ
abbrev Sequence := ℕ → ℚ

-- A placeholder notion of Cauchy sequence (not used in the proof here)
abbrev Sequence.IsCauchy (a : Sequence) : Prop := True

-- For this minimal setup, take our "Real" numbers to be ℚ
abbrev Real := ℚ

-- A placeholder definition of LIM
abbrev LIM (a : ℕ → ℚ) : Real := 0

namespace Real

-- The requested theorem, left intentionally unsolved
theorem LIM_of_ge {x : Real} {a : ℕ → ℚ}
    (hcauchy : (a : Sequence).IsCauchy) (h : ∀ n, a n ≥ x) :
    LIM a ≥ x := by
  sorry

end Real

end Chapter5

-----------------------------------

Section_5_6: Example 100

import Mathlib.Tactic
import Analysis.Section_5_6

-----------------------------------

Section_5_1: Example 101

import Mathlib.Tactic
import Mathlib.Data.Rat.Basic
import Mathlib.Data.Real.Basic

/-!
Minimal scaffolding to compile the requested theorem from Section 5.1.
We do not solve the theorem; it remains with `by sorry`.
-/

namespace Chapter5

/-- Sequences indexed by ℤ with a left-vanishing condition before the starting index n₀. -/
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n, n < n₀ → seq n = 0

/-- View a `Sequence` as its underlying function `ℤ → ℚ`. -/
instance : CoeFun Sequence (fun _ => ℤ → ℚ) where
  coe := fun a => a.seq

/--
Functions from ℕ to ℚ can be viewed as sequences starting at 0.
To avoid dependent types here, we define negative indices to be 0.
-/
def Sequence.ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if 0 ≤ n then a n.toNat else 0
  vanish := by
    intro n hn
    have h' : ¬ 0 ≤ n := by exact not_le.mpr hn
    simp [h']

/-- Coerce a function `ℕ → ℚ` to a `Sequence` starting from 0. -/
instance : Coe (ℕ → ℚ) Sequence where
  coe := Sequence.ofNatFun

end Chapter5

namespace Rat

/-- ε-closeness on ℚ. -/
def Close (ε : ℚ) (x y : ℚ) : Prop := |x - y| ≤ ε

/-- ε-steadiness of a sequence: after the starting index, all terms are ε-close. -/
abbrev Steady (ε : ℚ) (a : Chapter5.Sequence) : Prop :=
  ∀ n ≥ a.n₀, ∀ m ≥ a.n₀, Close ε (a n) (a m)

end Rat

namespace Chapter5

/-- A specific sequence used in Example 5.1.10 (content not important here). -/
noncomputable def Sequence.sqrt_two : Sequence :=
  ((fun _n : ℕ => (0 : ℚ)) : Sequence)

/--
  Example 5.1.10. We only provide the statement and keep the proof as `sorry`,
  as requested.
-/
theorem Sequence.ex_5_1_10_a : (1 : ℚ).Steady sqrt_two := by
  sorry

end Chapter5

-----------------------------------

Section_6_4: Example 102

import Mathlib.Tactic
import Analysis.Section_6_3

/-!
We introduce minimal placeholder notions of adherent/continually adherent points and limit points
needed only to state the requested theorem. We do not prove any properties about them here.
-/

/-- Placeholder: real ε-adherent point for a real sequence. -/
abbrev Real.Adherent (ε : ℝ) (a : Chapter6.Sequence) (x : ℝ) : Prop := True

/-- Placeholder: real ε-continually-adherent point for a real sequence. -/
abbrev Real.ContinuallyAdherent (ε : ℝ) (a : Chapter6.Sequence) (x : ℝ) : Prop := True

namespace Chapter6

/-- Placeholder: limit point of a real sequence. -/
abbrev Sequence.LimitPoint (a : Sequence) (x : ℝ) : Prop := True

/-- Exercise 6.4.10 -/
theorem Sequence.limit_points_of_limit_points
  {a b : Sequence} {c : ℝ}
  (hab : ∀ n ≥ b.m, a.LimitPoint (b n))
  (hbc : b.LimitPoint c) :
  a.LimitPoint c := by
  sorry

end Chapter6

-----------------------------------

Section_6_1: Example 103

import Mathlib.Data.Real.Basic

namespace Chapter5

@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0

instance : CoeFun Sequence (fun _ => ℤ → ℚ) where
  coe a := a.seq

namespace Sequence

/-- A placeholder notion of Cauchy sequence for Chapter 5 sequences (rationals indexed by integers).
This is only to make the theorem below typecheck; its actual definition is given elsewhere
in the textbook. -/
abbrev IsCauchy (a : Sequence) : Prop := True

/-- The requested theorem statement, left as `sorry` per instructions. -/
theorem IsCauchy_iff (a : Chapter5.Sequence) :
    a.IsCauchy ↔ ∀ ε > (0:ℝ), ∃ N ≥ a.n₀, ∀ n ≥ N, ∀ m ≥ N, |a n - a m| ≤ ε := by
  sorry

end Sequence
end Chapter5

-----------------------------------

Section_7_4: Example 104

import Mathlib.Tactic
import Analysis.Section_7_2

namespace Chapter7

theorem Series.zeta_2_converges :
    (fun n : ℕ ↦ 1 / (n + 1 : ℝ) ^ 2 : Series).converges := by
  sorry

end Chapter7

-----------------------------------

Section_6_5: Example 105

import Mathlib.Tactic
import Analysis.Section_6_1

namespace Chapter6

theorem Sequence.lim_of_rat_power_growth {q:ℚ} (hq: q > 0) :
    (fun (n:ℕ) ↦ ((n+1:ℝ)^(q:ℝ)):Sequence).Divergent := by
  sorry

end Chapter6

-----------------------------------

Section_6_1: Example 106

import Mathlib.Data.Real.Basic
import Mathlib.Tactic

/-!
Minimal setup to state the requested theorem from Section 6.1.

We define the real-valued Sequence structure used in Chapter 6,
a constructor `Sequence.mk'`, and the notion of `TendsTo` we need
for the statement. We then state the theorem with `sorry`.
-/

namespace Chapter6

/-- Real-valued sequences indexed by integers, starting at some `m : ℤ`. -/
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- View a sequence as its underlying function `ℤ → ℝ`. -/
instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℝ) where
  coe a := a.seq

/-- Build a sequence starting from `m : ℤ` using data on `{n // n ≥ m}`. -/
abbrev Sequence.mk' (m : ℤ) (a : { n // n ≥ m } → ℝ) : Sequence :=
{ m := m
  seq := fun n => if h : n ≥ m then a ⟨n, h⟩ else 0
  vanish := by
    intro n hn
    have : ¬ n ≥ m := not_le.mpr hn
    simp [this]
}

/-- A simple epsilon-definition of convergence of a real sequence. -/
abbrev Sequence.TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > 0, ∃ N : ℤ, N ≥ a.m ∧ ∀ n ≥ N, |a n - L| ≤ ε

/-- Exercise 6.1.4 (as stated): shifting a sequence by a natural number does not change the limit. -/
theorem Sequence.tendsTo_of_shift {a : Sequence} {c : ℝ} (k : ℕ) :
    a.TendsTo c ↔ (Sequence.mk' a.m (fun n : {n // n ≥ a.m} ↦ a (n + k))).TendsTo c := by
  sorry

end Chapter6

-----------------------------------

Section_6_4: Example 107

import Mathlib.Data.Real.EReal

namespace Chapter6

/-- A minimal version of the real-valued sequence structure used in Section 6. -/
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- Sequences can be viewed as functions from ℤ to ℝ. -/
instance : CoeFun Sequence (fun _ => ℤ → ℝ) where
  coe a := a.seq

/-- A minimal placeholder definition of limsup for sequences (only for compilation). -/
noncomputable abbrev Sequence.limsup (a : Sequence) : EReal := ⊤

/-- A minimal placeholder definition of extended limit point (only for compilation). -/
abbrev Sequence.ExtendedLimitPoint (a : Sequence) (x : EReal) : Prop := True

/-- The requested theorem, left as `sorry` (do not solve). -/
theorem Sequence.extended_limit_point_of_limsup (a:Sequence) : a.ExtendedLimitPoint a.limsup := by
  sorry

end Chapter6

-----------------------------------

Section_6_3: Example 108

import Mathlib.Data.Real.Basic

/-- A minimal sequence structure over real numbers, starting from an integer index `m`. -/
structure Sequence where
  m : ℤ := 0
  seq : ℤ → ℝ := fun _ => 0
  vanish : ∀ n < m, seq n = 0 := by
    intro n hn
    have hneg : ¬ n ≥ 0 := by exact not_le.mpr hn
    simp [hneg]

/-- View a function `ℕ → ℝ` as a `Sequence` starting at `0`. -/
@[simp] instance : Coe (ℕ → ℝ) Sequence where
  coe a :=
  { m := 0
    seq := fun n => if n ≥ 0 then a n.toNat else 0
    vanish := by
      intro n hn
      have hneg : ¬ n ≥ 0 := by exact not_le.mpr hn
      simp [hneg] }

/-- A minimal placeholder for the notion of convergence of a sequence. -/
abbrev Sequence.Convergent (a : Sequence) : Prop := True

/-- Section 6.3: If `x > 1`, then the exponential sequence `x^n` does not converge. -/
theorem lim_of_exp' {x : ℝ} (hbound : x > 1) :
    ¬ ((fun (n : ℕ) ↦ x ^ n) : Sequence).Convergent := by
  sorry

-----------------------------------

Section_8_4: Example 109

import Mathlib.Tactic

namespace Chapter8

theorem axiom_of_choice_from_function_injective_inv_surjective
  {I : Type} {X : I → Type} (h : ∀ i, Nonempty (X i)) :
  Nonempty (∀ i, X i) := by
  sorry

end Chapter8

-----------------------------------

Section_7_3: Example 110

import Mathlib.Tactic
import Analysis.Section_7_2

namespace Chapter7

/-- Nonnegativity predicate for a series: every term is ≥ 0. -/
abbrev Series.nonneg (s : Series) : Prop := ∀ n, s.seq n ≥ 0

/-- Exercise 7.3.3 -/
theorem Series.nonneg_sum_zero {a : ℕ → ℝ}
    (ha : (a : Series).nonneg) (hconv : (a : Series).converges) :
    (a : Series).sum = 0 ↔ ∀ n, a n = 0 := by
  sorry

end Chapter7

-----------------------------------

Section_8_4: Example 111

import Mathlib.Tactic

theorem axiom_of_choice_from_exists_set_singleton_intersect
  {I: Type} {X: I → Type} (h : ∀ i, Nonempty (X i)) :
  Nonempty (∀ i, X i) := by
  sorry

-----------------------------------

Section_6_6: Example 112

import Mathlib.Tactic

/-!
A minimal stub sufficient to state and type-check the requested theorem from Section 6.6.

We intentionally provide only the least structure required (and do not prove the theorem).
-/

namespace Chapter6

/-- A very lightweight real sequence structure, just enough for the statement. -/
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- Sequences can be coerced from functions ℕ → ℝ; we give a trivial extension by zero. -/
instance : Coe (ℕ → ℝ) Sequence where
  coe _ := {
    m := 0
    seq := fun _ => 0
    vanish := by intro _ _; simp
  }

/-- A dummy "subsequence" predicate (always true), sufficient for the statement. -/
abbrev Sequence.subseq (_a _b : ℕ → ℝ) : Prop := True

/-- A dummy notion of tending to a limit (always true), sufficient for the statement. -/
abbrev Sequence.TendsTo (_a : Sequence) (_L : ℝ) : Prop := True

/-- A dummy boundedness predicate (always false), sufficient for the statement. -/
abbrev Sequence.IsBounded (_a : Sequence) : Prop := False

/-- Provide an inverse on sequences so that `(b:Sequence)⁻¹.TendsTo 0` parses. -/
instance : Inv Sequence where
  inv a := a

/--
  Exercise 6.6.3 (stubbed): existence of a subsequence whose reciprocal tends to 0
  when the original sequence is unbounded.

  This is only a placeholder with `sorry`; it is not a solution.
-/
theorem Sequence.subseq_of_unbounded {a:ℕ → ℝ} (ha: ¬ (a:Sequence).IsBounded) :
    ∃ b:ℕ → ℝ, Sequence.subseq a b ∧ (b:Sequence)⁻¹.TendsTo 0 := by
  -- Stub: not proved
  sorry

end Chapter6

-----------------------------------

Section_6_4: Example 113

import Mathlib.Tactic
import Analysis.Section_6_3

/-!
We assemble the minimal prerequisites to state the requested theorem from Section 6.4,
without solving it.
-/

/- Adherence notions used to define limit points (placed outside the Chapter6 namespace,
   as in the original Section 6.4 file). -/
abbrev Real.Adherent (ε : ℝ) (a : Chapter6.Sequence) (x : ℝ) :=
  ∃ n ≥ a.m, ε.Close (a n) x

abbrev Real.ContinuallyAdherent (ε : ℝ) (a : Chapter6.Sequence) (x : ℝ) :=
  ∀ N ≥ a.m, ε.Adherent (a.from N) x

namespace Chapter6

open EReal

/- Limit point of a real sequence (as in Section 6.4). -/
abbrev Sequence.LimitPoint (a : Sequence) (x : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.ContinuallyAdherent a x

/- Lower sequence and liminf (as in Section 6.4). -/
noncomputable abbrev Sequence.lowerseq (a : Sequence) : ℤ → EReal :=
  fun N => (a.from N).inf

noncomputable abbrev Sequence.liminf (a : Sequence) : EReal :=
  sSup { x | ∃ N ≥ a.m, x = a.lowerseq N }

/- Extended limit point notion from Section 6.4. -/
abbrev Sequence.ExtendedLimitPoint (a : Sequence) (x : EReal) : Prop :=
  if x = ⊤ then ¬ a.BddAbove
  else if x = ⊥ then ¬ a.BddBelow
  else a.LimitPoint x.toReal

/-- Exercise 6.4.8 (restated): extended limit point at liminf. -/
theorem Sequence.extended_limit_point_of_liminf (a : Sequence) :
    a.ExtendedLimitPoint a.liminf := by
  sorry

end Chapter6

-----------------------------------

Section_8_4: Example 114

import Mathlib.Tactic

theorem Function.Injective.inv_surjective {A B:Type} {g: B → A} (hg: Function.Surjective g) :
  ∃ f : A → B, Function.Injective f ∧ Function.RightInverse f g := by
  sorry

-----------------------------------

Section_8_2: Example 115

import Mathlib.Tactic
import Analysis.Section_7_2
import Analysis.Section_6_2

namespace Chapter8

open Chapter7
open Function
open Filter

theorem permute_diverges_of_divergent
  {a: ℕ → ℝ}
  (ha: (a:Series).converges)
  (ha': ¬ (a:Series).absConverges)  :
  ∃ f : ℕ → ℕ,  Function.Bijective f ∧
    Filter.atTop.Tendsto (fun N ↦ ((a ∘ f:Series).partial N : EReal)) (nhds ⊤) := by
  sorry

end Chapter8

-----------------------------------

Section_8_3: Example 116

import Mathlib.Tactic

/-- Minimal cardinality notions sufficient to state Schroeder–Bernstein. -/
abbrev EqualCard (X Y : Type) : Prop := Nonempty (X ≃ Y)
abbrev LeCard (X Y : Type) : Prop := ∃ f : X → Y, Function.Injective f

/-- Schroeder–Bernstein theorem (placeholder). Do not change the name or solve it. -/
theorem Schroder_Bernstein {X Y:Type}
  (hXY : LeCard X Y)
  (hYX : LeCard Y X) :
  EqualCard X Y := by
  sorry

-----------------------------------

Section_9_1: Example 117

import Mathlib.Topology.Instances.Real

theorem closure_of_subset_closure {X Y : Set ℝ}
    (h : X ⊆ Y) (h' : Y ⊆ closure X) : closure Y = closure X := by
  sorry

-----------------------------------

Section_7_4: Example 118

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Order.Monotone

namespace Chapter7

/-- A minimal placeholder for the Series structure used in Section 7.4. -/
structure Series where
  dummy : Unit := ()

/-- Coerce a sequence `ℕ → ℝ` to a (placeholder) series. -/
instance : Coe (ℕ → ℝ) Series where
  coe _ := {}

/-- A minimal placeholder for absolute convergence of a series. -/
namespace Series

abbrev absConverges (_s : Series) : Prop := True

end Series

/-- Exercise 7.4.1 (placeholder, unsolved) -/
theorem Series.absConverges_of_subseries
  {a : ℕ → ℝ} (ha : (a : Series).absConverges)
  {f : ℕ → ℕ} (hf : StrictMono f) :
  (fun n ↦ a (f n) : Series).absConverges := by
  sorry

end Chapter7

-----------------------------------

Section_7_5: Example 119

import Mathlib.Tactic
import Mathlib.Algebra.Field.Power
import Analysis.Section_7_2

namespace Chapter7

theorem Series.poly_mul_geom_converges
  {x : ℝ} (hx : |x| < 1) (q : ℝ) :
  (fun n : ℕ ↦ (n : ℝ) ^ q * x ^ n : Series).converges
  ∧ Filter.atTop.Tendsto (fun n : ℕ ↦ (n : ℝ) ^ q * x ^ n) (nhds 0) := by
  sorry

end Chapter7

-----------------------------------

Section_7_1: Example 120

import Mathlib.Tactic
import Mathlib/Algebra/BigOperators.Basic
import Mathlib/Data/Finset/Intervals
import Mathlib/Data/Nat/Factorial
import Mathlib/Data/Real/Basic
import Mathlib/Algebra/GroupPower

open BigOperators
open Classical

namespace Finset

/--
  Exercise 7.1.4. Note: there may be some technicalities passing back and forth between natural
  numbers and integers. Look into the tactics `zify`, `norm_cast`, and `omega`
-/
theorem binomial_theorem (x y:ℝ) (n:ℕ) :
    (x + y)^n
    = ∑ j ∈ Icc (0:ℤ) n,
    n.factorial / (j.toNat.factorial * (n-j).toNat.factorial) * x^j * y^(n - j) := by
  sorry

end Finset

-----------------------------------

Section_9_7: Example 121

import Mathlib.Tactic
import Mathlib.Topology.ContinuousOn

/-- From Section 9.7: Existence of a fixed point on [0,1] for a continuous self-map.
    We only state the theorem here and leave the proof as `sorry`. -/
theorem exists_fixed_pt
  {f : ℝ → ℝ}
  (hf : ContinuousOn f (.Icc 0 1))
  (hmap : f '' .Icc 0 1 ⊆ .Icc 0 1)
  : ∃ x ∈ Set.Icc 0 1, f x = x := by
  sorry

-----------------------------------

Section_9_1: Example 122

import Mathlib/Topology/Instances/Real
import Mathlib/Data/Set/Intervals/Basic
import Mathlib/Topology/Bornology/Basic

theorem Icc_bounded (a b:ℝ) : Bornology.IsBounded (.Icc a b) := by
  sorry

-----------------------------------

Section_9_1: Example 123

import Mathlib.Topology.Bornology.Basic
import Mathlib.Topology.Instances.Real
import Mathlib.Data.Rat.Basic
import Mathlib.Data.Set.Lattice

/-- Example 9.1.23 -/
theorem Q_unbounded (a: ℝ) :
    ¬ Bornology.IsBounded ((fun n:ℚ ↦ (n:ℝ)) '' (Set.univ)) := by
  sorry

-----------------------------------

Section_8_5: Example 124

import Mathlib.Tactic
import Mathlib.Data.Fintype.Basic
import Mathlib.Order.Basic

namespace Chapter8

theorem IsMax.ofFinite {X:Type} [LinearOrder X] [Finite X] [Nonempty X] : ∃ x:X, IsMax x := by
  sorry

end Chapter8

-----------------------------------

Section_9_1: Example 125

import Mathlib.Tactic
import Mathlib.Topology.Bornology
import Mathlib.Topology.Instances.Real

namespace Chapter9

theorem N_unbounded (a: ℝ) :
    ¬ Bornology.IsBounded ((fun n : ℕ ↦ (n : ℝ)) '' .univ) := by
  sorry

end Chapter9

-----------------------------------

Section_9_1: Example 126

import Mathlib

theorem R_unbounded (a: ℝ) : ¬ Bornology.IsBounded (.univ: Set ℝ) := by
  sorry

-----------------------------------

Section_9_8: Example 127

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Order.Monotone
import Mathlib.Topology.Algebra.Order
import Mathlib.Topology.Instances.Real

namespace Chapter9

/-- Exercise 9.8.1 -/
theorem IsMaxOn.of_monotone_on_compact {a b:ℝ} (h:a < b) {f:ℝ → ℝ}
    (hf: MonotoneOn f (.Icc a b)) :
  ∃ xmax ∈ Set.Icc a b, IsMaxOn f (.Icc a b) xmax := by
  sorry

end Chapter9

-----------------------------------

Section_9_3: Example 128

import Mathlib.Data.Real.Basic
import Mathlib.Tactic

namespace Chapter9

/-- Minimal stub to allow compilation without importing the full textbook sections. -/
abbrev AdherentPt (x : ℝ) (X : Set ℝ) : Prop := True

/-- Minimal stub to allow compilation without importing the full textbook sections. -/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop := True

/-- Exercise 9.3.5 (Continuous version of squeeze test) -/
theorem Convergesto.squeeze {E:Set ℝ} {f g h: ℝ → ℝ} {L:ℝ} {x₀:ℝ} (had: AdherentPt x₀ E)
  (hfg: ∀ x ∈ E, f x ≤ g x) (hgh: ∀ x ∈ E, g x ≤ h x)
  (hf: Convergesto E f L x₀) (hh: Convergesto E h L x₀) :
  Convergesto E g L x₀ := by
    sorry

end Chapter9

-----------------------------------

Section_9_8: Example 129

import Mathlib.Tactic
import Mathlib.Topology.Basic

namespace Chapter9

-- A placeholder definition for f_9_8_5 sufficient to compile the theorem below.
noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun _ => 0

theorem ContinuousAt.of_f_9_8_5 {x:ℝ} (hx: ¬ ∃ r:ℚ, x = r) : ContinuousAt f_9_8_5 x := by
  sorry

end Chapter9

-----------------------------------

Section_7_2: Example 130

import Mathlib.Tactic
import Mathlib.Topology.Instances.Real

namespace Chapter7

open Series

/--
  Definition 7.2.1 (Formal infinite series). This is similar to Chapter 6 sequence, but is
  manipulated differently. As with Chapter 5, we will start series from 0 by default.
-/
@[ext]
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- Functions from ℕ to ℝ can be thought of as series. -/
instance Series.instCoe : Coe (ℕ → ℝ) Series where
  coe := fun a ↦ {
    m := 0
    seq n := if n ≥ 0 then a n.toNat else 0
    vanish := by
      intro n hn
      simp [hn.not_le]
  }

/-- Partial sums; definition included for completeness, though not used below. -/
abbrev Series.partial (s : Series) (N : ℤ) : ℝ := 0

/-- Convergence of a series via partial sums; included for completeness. -/
abbrev Series.convergesTo (s : Series) (L : ℝ) : Prop :=
  Filter.atTop.Tendsto (s.partial) (nhds L)

/-- Existence of a limit for the series. -/
abbrev Series.converges (s : Series) : Prop := ∃ L, s.convergesTo L

/-- Divergence means non-convergence. -/
abbrev Series.diverges (s : Series) : Prop := ¬ s.converges

theorem Series.diverges_of_nodecay {s : Series}
    (h : ¬ Filter.atTop.Tendsto s.seq (nhds 0)) :
    s.diverges := by
  sorry

/-- Example 7.2.7 -/
theorem Series.example_7_2_7 : ((fun n : ℕ ↦ (1 : ℝ)) : Series).diverges := by
  apply diverges_of_nodecay
  sorry

end Chapter7

-----------------------------------

Section_9_3: Example 131

import Mathlib.Tactic
import Mathlib.Data.Real.Sign

/-- Definition 9.3.1 -/
abbrev Real.CloseFn (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) : Prop :=
  ∀ x ∈ X, |f x - L| < ε

/-- Definition 9.3.3 -/
abbrev Real.CloseNear (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∃ δ > 0, ε.CloseFn (X ∩ Set.Ioo (x₀ - δ) (x₀ + δ)) f L

namespace Chapter9

/-- Definition 9.3.6 (Convergence of functions at a point) -/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.CloseNear X f L x₀

theorem Convergesto.sign_right : Convergesto (.Ioi 0) Real.sign 1 0 := by
  sorry

end Chapter9

-----------------------------------

Section_10_1: Example 132

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

theorem _root_.HasDerivWithinAt.of_pow (n : ℕ) (x₀ : ℝ) :
    HasDerivWithinAt (fun x ↦ x ^ n) (n * x₀ ^ ((n : ℤ) - 1)) Set.univ x₀ := by
  sorry

-----------------------------------

Section_9_4: Example 133

import Mathlib.Topology.ContinuousOn

theorem ContinuousOn.restrict {X Y : Set ℝ} {f : ℝ → ℝ}
    (hY : Y ⊆ X) (hf : ContinuousOn f X) : ContinuousOn f Y := by
  sorry

-----------------------------------

Section_9_3: Example 134

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Real.Sign

/-- Definition 9.3.1 -/
abbrev Real.CloseFn (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) : Prop :=
  ∀ x ∈ X, |f x - L| < ε

/-- Definition 9.3.3 -/
abbrev Real.CloseNear (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∃ δ > 0, ε.CloseFn (X ∩ Set.Ioo (x₀ - δ) (x₀ + δ)) f L

/-- Definition 9.3.6 (Convergence of functions at a point) -/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.CloseNear X f L x₀

namespace Chapter9

/-- Example 9.3.16 -/
theorem Convergesto.sign_left : Convergesto (.Iio 0) Real.sign (-1) 0 := by
  sorry

end Chapter9

-----------------------------------

Section_10_2: Example 135

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

namespace Chapter10

/-- Exercise 10.2.6 -/
theorem lipschitz_bound {M a b : ℝ} (hM : M > 0) (hab : a < b) {f : ℝ → ℝ}
    (hcont : ContinuousOn f (.Icc a b))
    (hderiv : DifferentiableOn ℝ f (.Ioo a b))
    (hlip : ∀ x ∈ Set.Ioo a b, |derivWithin f (.Ioo a b) x| ≤ M)
    {x y : ℝ} (hx : x ∈ Set.Ioo a b) (hy : y ∈ Set.Ioo a b) :
    |f x - f y| ≤ M * |x - y| := by
  sorry

end Chapter10

-----------------------------------

Section_9_9: Example 136

import Mathlib.Topology.UniformSpace.Basic
import Mathlib.Topology.Instances.Real

namespace Chapter9

/-- Exercise 9.9.6 -/
theorem UniformContinuousOn.comp {X Y: Set ℝ} {f g:ℝ → ℝ}
  (hf: UniformContinuousOn f X) (hg: UniformContinuousOn g Y)
  (hrange: f '' X ⊆ Y) : UniformContinuousOn (g ∘ f) X := by
  sorry

end Chapter9

-----------------------------------

Section_11_4: Example 137

import Mathlib.Tactic
import Analysis.Section_11_1
import Analysis.Section_11_3

namespace Chapter11

/-- Exercise 11.4.2 -/
theorem IntegrableOn.split {I: BoundedInterval} {f: ℝ → ℝ}
    (hf: IntegrableOn f I) (P: Partition I) :
  integ f I = ∑ J ∈ P.intervals, integ f J := by
  sorry

end Chapter11

-----------------------------------

Section_10_2: Example 138

import Mathlib.Tactic
import Mathlib.Topology.ContinuousOn
import Mathlib.Topology.Instances.Real
import Mathlib.Analysis.Calculus.Derivative
import Analysis.Section_9_6

open Chapter9

theorem _root_.UniformContinuousOn.of_lipschitz {f:ℝ → ℝ}
  (hcont: ContinuousOn f .univ)
  (hderiv: DifferentiableOn ℝ f .univ)
  (hlip: BddOn (deriv f) .univ) :
  UniformContinuousOn f (.univ) := by
  sorry

-----------------------------------

Section_9_8: Example 139

import Mathlib.Tactic
import Mathlib.Topology.Algebra.InfiniteSum
import Mathlib.Data.Real.Basic
import Mathlib.Data.Rat.Basic

namespace Chapter9

noncomputable section
open Classical
open scoped BigOperators

/-- A fixed equivalence between `ℕ` and `ℚ` (using countability of `ℚ`). -/
noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ := nonempty_equiv_of_countable.some

/-- The building-block function used in Exercise 9.8.5. -/
noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2:ℝ)^(-q_9_8_5.symm q:ℤ)

/-- The function in Exercise 9.8.5, defined as a (possibly infinite) sum over rationals
    strictly less than the input `x`. -/
noncomputable abbrev f_9_8_5 : ℝ → ℝ :=
  fun x ↦ ∑' r : {r:ℚ // (r:ℝ) < x}, g_9_8_5 r

/-- Exercise 9.8.5(a). We leave the proof as `sorry` as requested. -/
theorem StrictMonoOn.of_f_9_8_5 : StrictMonoOn f_9_8_5 .univ := by
  sorry

end Chapter9

-----------------------------------

Section_9_8: Example 140

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Topology.Basic
import Mathlib.Order.Monotone

namespace Chapter9

theorem mono_of_continuous_inj {a b : ℝ} (h : a < b) {f : ℝ → ℝ}
    (hf : ContinuousOn f (.Icc a b))
    (hinj : Function.Injective (fun x : Set.Icc a b ↦ f x)) :
    StrictMonoOn f (.Icc a b) ∨ StrictAntiOn f (.Icc a b) := by
  sorry

end Chapter9

-----------------------------------

Section_11_3: Example 141

import Mathlib.Tactic
import Analysis.Section_11_1

namespace Chapter11

/-- Definition 11.3.1 (Majorization of functions) -/
abbrev MajorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), f x ≤ g x

/-- Exercise 11.3.1 -/
theorem MajorizesOn.trans {f g h: ℝ → ℝ} {I: BoundedInterval}
  (hfg: MajorizesOn f g I) (hgh: MajorizesOn g h I) : MajorizesOn f h I := by
  sorry

end Chapter11

-----------------------------------

Section_11_1: Example 142

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Lattice

namespace Chapter11

/-- Bounded intervals on the real line (as in the textbook section). -/
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval

namespace BoundedInterval

/-- Coercion of a bounded interval to the corresponding set. -/
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => Set.Ioo a b
  | Icc a b => Set.Icc a b
  | Ioc a b => Set.Ioc a b
  | Ico a b => Set.Ico a b

instance : Coe BoundedInterval (Set ℝ) where
  coe := toSet

/-- Membership of a real number in a bounded interval means membership in the underlying set. -/
instance instMembership : Membership ℝ BoundedInterval where
  mem I x := x ∈ (I : Set ℝ)

/-- Subset relation between bounded intervals means subset of the underlying sets. -/
instance instSubset : HasSubset BoundedInterval where
  Subset I J := ∀ x, x ∈ I → x ∈ J

/-- Left endpoint of a bounded interval. -/
abbrev a (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo a _ => a
  | Icc a _ => a
  | Ioc a _ => a
  | Ico a _ => a

/-- Right endpoint of a bounded interval. -/
abbrev b (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo _ b => b
  | Icc _ b => b
  | Ioc _ b => b
  | Ico _ b => b

end BoundedInterval

open Classical

/-- We use classical decidable equality on bounded intervals. -/
noncomputable instance : DecidableEq BoundedInterval := inferInstance

/-- A partition of a bounded interval, following the textbook. -/
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I

/-- Membership of a bounded interval in a partition means membership in the underlying finset. -/
instance Partition.instMembership (I : BoundedInterval) :
    Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals

/-- Exercise 11.1.3 (existence of a right-neighbor interval).
We only provide the statement (with a placeholder proof). -/
theorem Partition.exist_right {I: BoundedInterval} (hI: I.a < I.b) (hI': I.b ∉ I)
  {P: Partition I}
  : ∃ c ∈ Set.Ico I.a I.b, BoundedInterval.Ioo c I.b ∈ P ∨ BoundedInterval.Ico c I.b ∈ P := by
  sorry

end Chapter11

-----------------------------------

Section_11_2: Example 143

import Mathlib.Data.Real.Basic

namespace Chapter11

/-- A minimal stub for a bounded interval, only carrying the underlying set.
    This is sufficient to state the theorem. -/
structure BoundedInterval where
  toSet : Set ℝ

instance : Coe Chapter11.BoundedInterval (Set ℝ) where
  coe I := I.toSet

/-- A minimal notion of a partition of a bounded interval.
    We keep it as an opaque structure to allow the statement to typecheck. -/
structure Partition (I : BoundedInterval) : Type where
  dummy : Unit := ()

/-- We provide a (degenerate) membership instance so that the binder `J ∈ P`
    in the definition below is well-typed. -/
instance (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem _ _ := False

/-- A function is constant if it takes a single value on its whole domain. -/
def Constant {X Y : Type} (f : X → Y) : Prop :=
  ∃ c, ∀ x, f x = c

/-- A function on ℝ is constant on a set `X : Set ℝ` if it is constant when restricted to `X`. -/
abbrev ConstantOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  Constant (fun x : X => f (x : ℝ))

/-- A function is piecewise constant with respect to a given partition if it is
    constant on each interval of the partition. -/
abbrev PiecewiseConstantWith (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : Prop :=
  ∀ J, J ∈ P → ConstantOn f (J : Set ℝ)

/-- A function is piecewise constant on a bounded interval if there exists some
    partition with respect to which it is piecewise constant. -/
abbrev PiecewiseConstantOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∃ P : Partition I, PiecewiseConstantWith f P

/-- Example 11.2.6 (stated): a function constant on the whole interval is piecewise constant. -/
theorem ConstantOn.piecewiseConstantOn {f : ℝ → ℝ} {I : BoundedInterval}
    (h : ConstantOn f (I : Set ℝ)) :
    PiecewiseConstantOn f I := by
  sorry

end Chapter11

-----------------------------------

Section_11_8: Example 144

import Mathlib.Data.Real.Basic

namespace Chapter11

/-- A minimal stub for a bounded interval, only carrying two endpoints. -/
structure BoundedInterval where
  a : ℝ := 0
  b : ℝ := 0

/-- A minimal stub for the length of a bounded interval. -/
abbrev BoundedInterval.length (I : BoundedInterval) : ℝ := 0

/-- Using ||ₗ subscript here to not override || -/
macro:max atomic("|" noWs) a:term noWs "|ₗ" : term => `(BoundedInterval.length $a)

/-- A minimal stub for the α-length on a bounded interval. -/
noncomputable abbrev α_length (α : ℝ → ℝ) (I : BoundedInterval) : ℝ := 0

notation3:max α:term "[" I:term "]ₗ" => α_length α I

@[simp]
theorem α_len_of_id (I: BoundedInterval) : (fun x ↦ x)[I]ₗ = |I|ₗ := by
  sorry

end Chapter11

-----------------------------------

Section_10_1: Example 145

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

theorem _root_.HasDerivWithinAt.of_zpow (n:ℤ) (x₀:ℝ) (hx₀: x₀ ≠ 0) :
  HasDerivWithinAt (fun x ↦ x^n) (n * x₀^(n-1)) (.univ \ {0}) x₀ := by
  sorry

-----------------------------------

Section_11_9: Example 146

import Mathlib.Tactic
import Analysis.Section_11_9

namespace Chapter11

theorem DifferentiableOn.of_F_11_9_2' {q:ℚ} (hq: (q:ℝ) ∈ Set.Icc 0 1) :
  ¬ DifferentiableWithinAt ℝ F_11_9_2 (.Icc 0 1) q := by
  sorry

end Chapter11

-----------------------------------

Section_11_5: Example 147

import Mathlib.Tactic
import Analysis.Section_11_1
import Analysis.Section_11_3

namespace Chapter11
open BoundedInterval

/-- Exercise 11.5.2 -/
theorem integ_zero {a b:ℝ} (hab: a ≤ b) (f: ℝ → ℝ) (hf: ContinuousOn f (Icc a b))
  (hnonneg: MajorizesOn f (fun _ ↦ 0) (Icc a b)) (hinteg : integ f (Icc a b) = 0) :
  ∀ x ∈ Icc a b, f x = 0 := by
    sorry

end Chapter11

-----------------------------------

Section_11_8: Example 148

import Mathlib.Data.Real.Basic

namespace Chapter11

-- Minimal stub for a bounded interval type
inductive BoundedInterval where
  | mk : BoundedInterval

-- Minimal stubs for the notions used in the theorem statement
def UniformContinuousOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop := True
def Monotone (α : ℝ → ℝ) : Prop := True
def RS_IntegrableOn (f : ℝ → ℝ) (I : BoundedInterval) (α : ℝ → ℝ) : Prop := True

-- The requested theorem, left unsolved as instructed
theorem RS_integ_of_uniform_cts {I: BoundedInterval} {f:ℝ → ℝ} (hf: UniformContinuousOn f I)
  {α:ℝ → ℝ} (hα: Monotone α):
  RS_IntegrableOn f I α := by
  trivial

end Chapter11

-----------------------------------

Section_9_8: Example 149

import Mathlib.Tactic
import Mathlib.Topology.Basic
import Mathlib.Topology.Algebra.InfiniteSum

open scoped BigOperators

namespace Chapter9

/-- A helper function for the construction in Exercise 9.8.5. We keep a minimal placeholder
    sufficient for compilation purposes. -/
noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun _ ↦ 0

/-- The function from Exercise 9.8.5, defined as a (possibly infinite) sum over rationals less than x.
    For compilation, we only need a definition; no properties are used here. -/
noncomputable abbrev f_9_8_5 : ℝ → ℝ :=
  fun x ↦ ∑' r : {r : ℚ // (r : ℝ) < x}, g_9_8_5 r

/-- Exercise 9.8.5(b). Stated but not proved (left as `sorry`) as requested. -/
theorem ContinuousAt.of_f_9_8_5' (r : ℚ) : ¬ ContinuousAt f_9_8_5 r := by
  sorry

end Chapter9

-----------------------------------

Section_11_8: Example 150

import Mathlib.Tactic

namespace Chapter11

/-- A minimal placeholder for bounded intervals, sufficient to typecheck the theorem. -/
structure BoundedInterval : Type := 
  dummy : Unit := ()

/-- A minimal placeholder for partitions of a bounded interval. -/
structure Partition (I : BoundedInterval) : Type := 
  dummy : Unit := ()

namespace PiecewiseConstantWith

/-- A minimal placeholder for the piecewise-constant Riemann–Stieltjes integral. -/
noncomputable abbrev RS_integ (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) (α : ℝ → ℝ) : ℝ := 0

/-- A minimal placeholder for the piecewise-constant integral with respect to length. -/
noncomputable abbrev integ (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : ℝ := 0

end PiecewiseConstantWith

open PiecewiseConstantWith

/-- Example 11.8.7: statement stub, not proved. -/
theorem PiecewiseConstantWith.RS_integ_eq_integ
  {f : ℝ → ℝ} {I : BoundedInterval} (P : Partition I) :
  RS_integ f P (fun x ↦ x) = integ f P := by
  sorry

end Chapter11

-----------------------------------

