[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":51},{"state":[],"start":52},{"state":[],"start":56},{"state":[],"start":114},{"state":[],"start":115},{"state":[],"start":211},{"state":[],"start":300},{"state":[],"start":396},{"state":[],"start":489},{"state":[],"start":499},{"state":[],"start":500},{"state":[],"start":548},{"state":[],"start":549},{"state":[],"start":602},{"state":[],"start":603},{"state":[],"start":627},{"state":[],"start":628},{"state":[],"start":772},{"state":[],"start":773},{"state":[],"start":790},{"state":[],"start":791},{"state":[],"start":794},{"state":[],"start":795},{"state":[],"start":814},{"state":[],"start":815},{"state":[],"start":910},{"state":[],"start":1012},{"state":[],"start":1030},{"state":[],"start":1031},{"state":[],"start":1133},{"state":[],"start":1151},{"state":[],"start":1152},{"state":[],"start":1181},{"state":[],"start":1261},{"state":[],"start":1262},{"state":[],"start":1291},{"state":[],"start":1395},{"state":[],"start":1396},{"state":[],"start":1417},{"state":[],"start":1490},{"state":[],"start":1491},{"state":[],"start":1520},{"state":[],"start":1582},{"state":[],"start":1583},{"state":[],"start":1604},{"state":[],"start":1663},{"state":[],"start":1664},{"state":[],"start":1685},{"state":[],"start":1749},{"state":[],"start":1750},{"state":[],"start":1849},{"state":[],"start":1886},{"state":[],"start":1887},{"state":[],"start":1987},{"state":[],"start":2036},{"state":[],"start":2123},{"state":[],"start":2124},{"state":[],"start":2173},{"state":[],"start":2260},{"state":[],"start":2261},{"state":[],"start":2282},{"state":[],"start":2323},{"state":[],"start":2324},{"state":[],"start":2345},{"state":[],"start":2400},{"state":[],"start":2401},{"state":[],"start":2459},{"state":[],"start":2581},{"state":[],"start":2582},{"state":[],"start":2643},{"state":[],"start":2747},{"state":[],"start":2748},{"state":[],"start":2852},{"state":[],"start":2853},{"state":[],"start":2875},{"state":[],"start":2952},{"state":[],"start":3050},{"state":[],"start":3067},{"state":[],"start":3083},{"state":[],"start":3132},{"state":[],"start":3197},{"state":[],"start":3198},{"state":[],"start":3220},{"state":[],"start":3293},{"state":[],"start":3349},{"state":[],"start":3417},{"state":[],"start":3475},{"state":[],"start":3547},{"state":[],"start":3570},{"state":[],"start":3571},{"state":[],"start":3623},{"state":[],"start":3698},{"state":[],"start":3754},{"state":[],"start":3755},{"state":[],"start":3826},{"state":[],"start":3909},{"state":[],"start":3910},{"state":[],"start":3999},{"state":[],"start":4031},{"state":[],"start":4032},{"state":[],"start":4128},{"state":[],"start":4129},{"state":[],"start":4211},{"state":[],"start":4276},{"state":[],"start":4277},{"state":[],"start":4299},{"state":[],"start":4411},{"state":[],"start":4488},{"state":[],"start":4489},{"state":[],"start":4493},{"state":[],"start":4539},{"state":[],"start":4601},{"state":[],"start":4604},{"state":[],"start":4692},{"state":[],"start":4707},{"state":[],"start":4760},{"state":[{"type":"∃! m,\n  (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":[],"mvarId":["_uniq",24208],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",24207],"binderInfo":"default"}]}],"start":4838},{"state":[{"type":"∃! m,\n  (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":[],"mvarId":["_uniq",24221],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",24207],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",24220]}]}],"start":4873},{"state":[{"type":"∃! m,\n  (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":[],"mvarId":["_uniq",75612],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",24207],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",24220]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",75611],"binderInfo":"default"}]}],"start":4902},{"state":[{"type":"∃! m,\n  (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":[],"mvarId":["_uniq",75859],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",24207],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",24220]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",75611],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",75858]}]}],"start":4935},{"state":[{"type":"∃! m,\n  (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":[],"mvarId":["_uniq",75942],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",24207],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",24220]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",75611],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",75858]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg IsPos\n          (Eq.trans (Rat.cast_div 1 ((↑n : ℚ) + 1))\n            (Eq.trans\n              (congr (congrArg HDiv.hDiv Rat.cast_one)\n                (Eq.trans (Rat.cast_add (↑n : ℚ) 1) (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))\n              (one_div ((↑n : Real) + 1)))))\n        (LUB_claim1._simp_1 ((↑n : Real) + 1)⁻¹))\n      (Eq.trans gt_iff_lt._simp_1 inv_pos._simp_1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",75941]}]}],"start":4997},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex"],"mvarId":["_uniq",85548],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",24207],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",24220]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",75611],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",75858]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg IsPos\n          (Eq.trans (Rat.cast_div 1 ((↑n : ℚ) + 1))\n            (Eq.trans\n              (congr (congrArg HDiv.hDiv Rat.cast_one)\n                (Eq.trans (Rat.cast_add (↑n : ℚ) 1) (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))\n              (one_div ((↑n : Real) + 1)))))\n        (LUB_claim1._simp_1 ((↑n : Real) + 1)⁻¹))\n      (Eq.trans gt_iff_lt._simp_1 inv_pos._simp_1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",75941]}]},{"type":"∀ (y₁ y₂ : ℤ),\n  (↑((↑y₁ : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑y₁ : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E →\n    (↑((↑y₂ : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n        (↑((↑y₂ : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E →\n      y₁ = y₂","tag":["hunique"],"mvarId":["_uniq",85549],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",24207],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",24220]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",75611],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",75858]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg IsPos\n          (Eq.trans (Rat.cast_div 1 ((↑n : ℚ) + 1))\n            (Eq.trans\n              (congr (congrArg HDiv.hDiv Rat.cast_one)\n                (Eq.trans (Rat.cast_add (↑n : ℚ) 1) (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))\n              (one_div ((↑n : Real) + 1)))))\n        (LUB_claim1._simp_1 ((↑n : Real) + 1)⁻¹))\n      (Eq.trans gt_iff_lt._simp_1 inv_pos._simp_1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",75941]}]}],"start":5038},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex","intro"],"mvarId":["_uniq",85610],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"}]}],"start":5106},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex","intro"],"mvarId":["_uniq",85628],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"}]}],"start":5144},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex","intro"],"mvarId":["_uniq",85655],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"}]}],"start":5189},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex","intro"],"mvarId":["_uniq",85695],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]}]}],"start":5212},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex","intro"],"mvarId":["_uniq",86561],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]}]}],"start":5271},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex","intro"],"mvarId":["_uniq",91778],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝¹ hK L' h✝ hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]}]}],"start":5345},{"state":[{"type":"(↑K : Real) > (↑L : Real)","tag":[],"mvarId":["_uniq",104362],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝¹ hK L' h✝ hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]}]}],"start":5391},{"state":[{"type":"(↑L : Real) * ε ∈ upperBounds E","tag":[],"mvarId":["_uniq",104483],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"type":"(↑K : Real) ≤ (↑L : Real)","name":["claim1_2"],"isProp":true,"id":["_uniq",104482],"binderInfo":"default"}]}],"start":5418},{"state":[{"type":"(↑L : Real) * ε ∈ upperBounds E","tag":[],"mvarId":["_uniq",104499],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"mul_le_mul_left _fvar.104482 hpos","type":"ε * (↑K : Real) ≤ ε * (↑L : Real)","name":["claim1_2"],"isProp":true,"id":["_uniq",104495]}]}],"start":5474},{"state":[{"type":"(↑L : Real) * ε ∈ upperBounds E","tag":[],"mvarId":["_uniq",104981],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"type":"(↑K : Real) * ε ≤ (↑L : Real) * ε","name":["claim1_2"],"isProp":true,"id":["_uniq",104978],"binderInfo":"default"}]}],"start":5511},{"state":[{"type":"(↑L : Real) * ε ∈ upperBounds E","tag":[],"mvarId":["_uniq",109570],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"Decidable.byContradiction fun a =>\n  ne_of_lt hK\n    (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n      (le_trans _fvar.104978 (le_trans (le_of_not_ge a) (le_refl M))))","type":"M ≤ (↑L : Real) * ε","name":["claim1_2"],"isProp":true,"id":["_uniq",105101]}]}],"start":5561},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex","intro"],"mvarId":["_uniq",104364],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝¹ hK L' h✝ hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_gt_eq (↑K : Real) (↑L : Real))\n        (Mathlib.Tactic.PushNeg.not_not_eq ((↑L : Real) * ε ∈ upperBounds E))))\n    fun claim1_2 =>\n    have claim1_2 := mul_le_mul_left claim1_2 hpos;\n    have claim1_2 :=\n      Decidable.byContradiction fun a =>\n        ne_of_lt hK\n          (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n            (le_trans (Eq.mp (congr (congrArg LE.le (mul_comm ε (↑K : Real))) (mul_comm ε (↑L : Real))) claim1_2)\n              (le_trans (le_of_not_ge a) (le_refl M))));\n    LUB_claim1._proof_3 n hE hpos M hbound K h✝¹ hK L' h✝ hL claim1_1 claim1_2)\n  claim1_2","type":"(↑K : Real) > (↑L : Real)","name":["claim1_3"],"isProp":true,"id":["_uniq",104363]}]}],"start":5592},{"state":[{"type":"∃ m, L < m ∧ m ≤ (↑K : ℤ) ∧ (↑m : Real) * ε ∈ upperBounds E ∧ ((↑m : Real) - 1) * ε ∉ upperBounds E","tag":[],"mvarId":["_uniq",123503],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝¹ hK L' h✝ hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_gt_eq (↑K : Real) (↑L : Real))\n        (Mathlib.Tactic.PushNeg.not_not_eq ((↑L : Real) * ε ∈ upperBounds E))))\n    fun claim1_2 =>\n    have claim1_2 := mul_le_mul_left claim1_2 hpos;\n    have claim1_2 :=\n      Decidable.byContradiction fun a =>\n        ne_of_lt hK\n          (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n            (le_trans (Eq.mp (congr (congrArg LE.le (mul_comm ε (↑K : Real))) (mul_comm ε (↑L : Real))) claim1_2)\n              (le_trans (le_of_not_ge a) (le_refl M))));\n    LUB_claim1._proof_3 n hE hpos M hbound K h✝¹ hK L' h✝ hL claim1_1 claim1_2)\n  claim1_2","type":"(↑K : Real) > (↑L : Real)","name":["claim1_3"],"isProp":true,"id":["_uniq",104363]}]}],"start":5705},{"state":[{"type":"L < (↑K : ℤ)","tag":["convert_2"],"mvarId":["_uniq",123512],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝¹ hK L' h✝ hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_gt_eq (↑K : Real) (↑L : Real))\n        (Mathlib.Tactic.PushNeg.not_not_eq ((↑L : Real) * ε ∈ upperBounds E))))\n    fun claim1_2 =>\n    have claim1_2 := mul_le_mul_left claim1_2 hpos;\n    have claim1_2 :=\n      Decidable.byContradiction fun a =>\n        ne_of_lt hK\n          (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n            (le_trans (Eq.mp (congr (congrArg LE.le (mul_comm ε (↑K : Real))) (mul_comm ε (↑L : Real))) claim1_2)\n              (le_trans (le_of_not_ge a) (le_refl M))));\n    LUB_claim1._proof_3 n hE hpos M hbound K h✝¹ hK L' h✝ hL claim1_1 claim1_2)\n  claim1_2","type":"(↑K : Real) > (↑L : Real)","name":["claim1_3"],"isProp":true,"id":["_uniq",104363]}]},{"type":"(↑(↑K : ℤ) : Real) * (↑(1 / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","tag":["convert_3"],"mvarId":["_uniq",123513],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝¹ hK L' h✝ hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_gt_eq (↑K : Real) (↑L : Real))\n        (Mathlib.Tactic.PushNeg.not_not_eq ((↑L : Real) * ε ∈ upperBounds E))))\n    fun claim1_2 =>\n    have claim1_2 := mul_le_mul_left claim1_2 hpos;\n    have claim1_2 :=\n      Decidable.byContradiction fun a =>\n        ne_of_lt hK\n          (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n            (le_trans (Eq.mp (congr (congrArg LE.le (mul_comm ε (↑K : Real))) (mul_comm ε (↑L : Real))) claim1_2)\n              (le_trans (le_of_not_ge a) (le_refl M))));\n    LUB_claim1._proof_3 n hE hpos M hbound K h✝¹ hK L' h✝ hL claim1_1 claim1_2)\n  claim1_2","type":"(↑K : Real) > (↑L : Real)","name":["claim1_3"],"isProp":true,"id":["_uniq",104363]}]}],"start":5765},{"state":[{"type":"(↑(↑K : ℤ) : Real) * (↑(1 / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","tag":["convert_3"],"mvarId":["_uniq",123513],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝¹ hK L' h✝ hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_gt_eq (↑K : Real) (↑L : Real))\n        (Mathlib.Tactic.PushNeg.not_not_eq ((↑L : Real) * ε ∈ upperBounds E))))\n    fun claim1_2 =>\n    have claim1_2 := mul_le_mul_left claim1_2 hpos;\n    have claim1_2 :=\n      Decidable.byContradiction fun a =>\n        ne_of_lt hK\n          (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n            (le_trans (Eq.mp (congr (congrArg LE.le (mul_comm ε (↑K : Real))) (mul_comm ε (↑L : Real))) claim1_2)\n              (le_trans (le_of_not_ge a) (le_refl M))));\n    LUB_claim1._proof_3 n hE hpos M hbound K h✝¹ hK L' h✝ hL claim1_1 claim1_2)\n  claim1_2","type":"(↑K : Real) > (↑L : Real)","name":["claim1_3"],"isProp":true,"id":["_uniq",104363]}]}],"start":5809},{"state":[{"type":"∃ x,\n  (↑((↑x : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n    (↑((↑x : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["hex","intro"],"mvarId":["_uniq",123505],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝¹"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝¹ hK L' h✝ hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_gt_eq (↑K : Real) (↑L : Real))\n        (Mathlib.Tactic.PushNeg.not_not_eq ((↑L : Real) * ε ∈ upperBounds E))))\n    fun claim1_2 =>\n    have claim1_2 := mul_le_mul_left claim1_2 hpos;\n    have claim1_2 :=\n      Decidable.byContradiction fun a =>\n        ne_of_lt hK\n          (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n            (le_trans (Eq.mp (congr (congrArg LE.le (mul_comm ε (↑K : Real))) (mul_comm ε (↑L : Real))) claim1_2)\n              (le_trans (le_of_not_ge a) (le_refl M))));\n    LUB_claim1._proof_3 n hE hpos M hbound K h✝¹ hK L' h✝ hL claim1_1 claim1_2)\n  claim1_2","type":"(↑K : Real) > (↑L : Real)","name":["claim1_3"],"isProp":true,"id":["_uniq",104363]},{"value":"Eq.mpr (Eq.refl (∃ m, L < m ∧ m ≤ (↑K : ℤ) ∧ (↑m : Real) * ε ∈ upperBounds E ∧ ((↑m : Real) - 1) * ε ∉ upperBounds E))\n  (upperBound_between\n    (Eq.mpr\n      (id\n        (Eq.trans (Mathlib.Tactic.Qify.intCast_lt._simp_1 L (↑K : ℤ)) (congrArg (LT.lt (↑L : ℚ)) (Int.cast_natCast K))))\n      (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext gt_iff_lt))))\n        (Eq.mpr (id (congrArg (fun _a => _a) (propext (gt_of_coe (↑K : ℚ) (↑L : ℚ))))) claim1_3)))\n    (Eq.mpr\n      (id\n        (congrArg (Membership.mem (upperBounds E))\n          (congr (congrArg HMul.hMul (Int.cast_natCast K))\n            (Eq.trans (Eq.trans (congrArg Rat.cast (one_div ((↑n : ℚ) + 1))) (Rat.cast_inv ((↑n : ℚ) + 1)))\n              (congrArg Inv.inv\n                (Eq.trans (Rat.cast_add (↑n : ℚ) 1) (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))))))\n      (upperBound_upper\n        (Decidable.byContradiction fun a =>\n          ne_of_lt\n            (Eq.mp\n              (Eq.trans\n                (congrArg (fun x => (↑K : Real) * x > M)\n                  (Eq.trans (Rat.cast_div 1 ((↑n : ℚ) + 1))\n                    (Eq.trans\n                      (congr (congrArg HDiv.hDiv Rat.cast_one)\n                        (Eq.trans (Rat.cast_add (↑n : ℚ) 1)\n                          (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))\n                      (one_div ((↑n : Real) + 1)))))\n                gt_iff_lt._simp_1)\n              hK)\n            (le_antisymm\n              (le_trans\n                (le_of_lt\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg (fun x => (↑K : Real) * x > M)\n                        (Eq.trans (Rat.cast_div 1 ((↑n : ℚ) + 1))\n                          (Eq.trans\n                            (congr (congrArg HDiv.hDiv Rat.cast_one)\n                              (Eq.trans (Rat.cast_add (↑n : ℚ) 1)\n                                (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))\n                            (one_div ((↑n : Real) + 1)))))\n                      gt_iff_lt._simp_1)\n                    hK))\n                (le_refl ((↑K : Real) * ((↑n : Real) + 1)⁻¹)))\n              (le_trans (le_of_not_ge a) (le_refl M))))\n        hbound))\n    claim1_2)","type":"∃ m, L < m ∧ m ≤ (↑K : ℤ) ∧ (↑m : Real) * ε ∈ upperBounds E ∧ ((↑m : Real) - 1) * ε ∉ upperBounds E","name":["claim1_4"],"isProp":true,"id":["_uniq",123504]}]}],"start":5870},{"state":[{"type":"(↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n  (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["h"],"mvarId":["_uniq",147990],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝³"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝²"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝³ hK L' h✝² hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_gt_eq (↑K : Real) (↑L : Real))\n        (Mathlib.Tactic.PushNeg.not_not_eq ((↑L : Real) * ε ∈ upperBounds E))))\n    fun claim1_2 =>\n    have claim1_2 := mul_le_mul_left claim1_2 hpos;\n    have claim1_2 :=\n      Decidable.byContradiction fun a =>\n        ne_of_lt hK\n          (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n            (le_trans (Eq.mp (congr (congrArg LE.le (mul_comm ε (↑K : Real))) (mul_comm ε (↑L : Real))) claim1_2)\n              (le_trans (le_of_not_ge a) (le_refl M))));\n    LUB_claim1._proof_3 n hE hpos M hbound K h✝³ hK L' h✝² hL claim1_1 claim1_2)\n  claim1_2","type":"(↑K : Real) > (↑L : Real)","name":["claim1_3"],"isProp":true,"id":["_uniq",104363]},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",147952],"binderInfo":"default"},{"type":"L < m","name":["h✝¹"],"isProp":true,"id":["_uniq",147961],"binderInfo":"default"},{"type":"m ≤ (↑K : ℤ)","name":["h✝"],"isProp":true,"id":["_uniq",147970],"binderInfo":"default"},{"type":"(↑m : Real) * ε ∈ upperBounds E","name":["hm"],"isProp":true,"id":["_uniq",147979],"binderInfo":"default"},{"type":"((↑m : Real) - 1) * ε ∉ upperBounds E","name":["hm'"],"isProp":true,"id":["_uniq",147983],"binderInfo":"default"}]}],"start":5916},{"state":[{"type":"(↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n  (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","tag":["h"],"mvarId":["_uniq",149160],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",85575]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",85576],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",85577]},{"type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",85578],"binderInfo":"default"},{"type":"Real","name":["M"],"isProp":false,"id":["_uniq",85608],"binderInfo":"default"},{"type":"M ∈ upperBounds E","name":["hbound"],"isProp":true,"id":["_uniq",85609],"binderInfo":"default"},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",85615],"binderInfo":"default"},{"type":"K > 0","name":["h✝³"],"isProp":true,"id":["_uniq",85623],"binderInfo":"default"},{"type":"(↑K : Real) * ε > M","name":["hK"],"isProp":true,"id":["_uniq",85627],"binderInfo":"default"},{"type":"ℕ","name":["L'"],"isProp":false,"id":["_uniq",85642],"binderInfo":"default"},{"type":"L' > 0","name":["h✝²"],"isProp":true,"id":["_uniq",85650],"binderInfo":"default"},{"type":"(↑L' : Real) * ε > -x₀","name":["hL"],"isProp":true,"id":["_uniq",85654],"binderInfo":"default"},{"value":"-(↑L' : ℤ)","type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",85694]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun x => x < x₀)\n      (Eq.trans (congrArg (fun x => x * ε) (Eq.trans (Int.cast_neg (↑L' : ℤ)) (congrArg Neg.neg (Int.cast_natCast L'))))\n        (neg_mul (↑L' : Real) ε))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x₀ (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                  (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x₀)\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (↑L' : Real))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left (↑L' : Real) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                        (Mathlib.Tactic.Ring.mul_zero ((↑L' : Real) ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑L' : Real) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x₀ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑L' : Real) ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x₀ (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑L' : Real) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.ofNat 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hL)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"(↑L : Real) * ε < x₀","name":["claim1_1"],"isProp":true,"id":["_uniq",86560]},{"value":"LUB_claim1._proof_2 n hE hx₀ hpos M hbound K h✝³ hK L' h✝² hL claim1_1","type":"(↑L : Real) * ε ∉ upperBounds E","name":["claim1_2"],"isProp":true,"id":["_uniq",91777]},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_gt_eq (↑K : Real) (↑L : Real))\n        (Mathlib.Tactic.PushNeg.not_not_eq ((↑L : Real) * ε ∈ upperBounds E))))\n    fun claim1_2 =>\n    have claim1_2 := mul_le_mul_left claim1_2 hpos;\n    have claim1_2 :=\n      Decidable.byContradiction fun a =>\n        ne_of_lt hK\n          (le_antisymm (le_trans (le_of_lt hK) (le_refl ((↑K : Real) * ε)))\n            (le_trans (Eq.mp (congr (congrArg LE.le (mul_comm ε (↑K : Real))) (mul_comm ε (↑L : Real))) claim1_2)\n              (le_trans (le_of_not_ge a) (le_refl M))));\n    LUB_claim1._proof_3 n hE hpos M hbound K h✝³ hK L' h✝² hL claim1_1 claim1_2)\n  claim1_2","type":"(↑K : Real) > (↑L : Real)","name":["claim1_3"],"isProp":true,"id":["_uniq",104363]},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",147952],"binderInfo":"default"},{"type":"L < m","name":["h✝¹"],"isProp":true,"id":["_uniq",147961],"binderInfo":"default"},{"type":"m ≤ (↑K : ℤ)","name":["h✝"],"isProp":true,"id":["_uniq",147970],"binderInfo":"default"},{"type":"(↑m : Real) * ε ∈ upperBounds E","name":["hm"],"isProp":true,"id":["_uniq",147979],"binderInfo":"default"},{"type":"((↑m : Real) - 1) * ε ∉ upperBounds E","name":["hm'"],"isProp":true,"id":["_uniq",147983],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congr\n      (congrArg Eq\n        (Eq.trans (Rat.cast_div (↑m : ℚ) ((↑n : ℚ) + 1))\n          (congr (congrArg HDiv.hDiv (Rat.cast_intCast m))\n            (Eq.trans (Rat.cast_add (↑n : ℚ) 1) (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))))\n      (congrArg (HMul.hMul (↑m : Real))\n        (Eq.trans (Rat.cast_div 1 ((↑n : ℚ) + 1))\n          (Eq.trans\n            (congr (congrArg HDiv.hDiv Rat.cast_one)\n              (Eq.trans (Rat.cast_add (↑n : ℚ) 1) (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))\n            (one_div ((↑n : Real) + 1)))))))\n  (of_eq_true\n    (Eq.trans\n      (Eq.trans\n        (congrArg (Eq ((↑m : Real) / ((↑n : Real) + 1)))\n          (Eq.trans\n            (Eq.trans (congrArg (HMul.hMul (↑m : Real)) (inv_eq_one_div ((↑n : Real) + 1)))\n              (mul_div_assoc' (↑m : Real) 1 ((↑n : Real) + 1)))\n            (congrArg (fun x => x / ((↑n : Real) + 1)) (mul_one (↑m : Real)))))\n        (eq_div_iff._simp_1\n          (ne_of_gt\n            (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))))))\n      (Eq.trans\n        (congrArg (fun x => x = (↑m : Real))\n          (Eq.trans (div_mul_eq_mul_div (↑m : Real) ((↑n : Real) + 1) ((↑n : Real) + 1))\n            (mul_div_cancel_right₀ (↑m : Real)\n              (ne_of_gt\n                (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                  (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one)\n                    (Eq.refl (Nat.ble 1 1))))))))\n        (eq_self (↑m : Real)))))","type":"(↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) = (↑m : Real) * ε","name":["this"],"isProp":true,"id":["_uniq",149159]}]}],"start":5976},{"state":[{"type":"∀ (y₁ y₂ : ℤ),\n  (↑((↑y₁ : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑y₁ : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E →\n    (↑((↑y₂ : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n        (↑((↑y₂ : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E →\n      y₁ = y₂","tag":["hunique"],"mvarId":["_uniq",85549],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",24204],"binderInfo":"default"},{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",24205],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",24206],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",24207],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",24220]},{"type":"hE.some ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",75611],"binderInfo":"default"},{"value":"(↑(1 / ((↑n : ℚ) + 1)) : Real)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",75858]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg IsPos\n          (Eq.trans (Rat.cast_div 1 ((↑n : ℚ) + 1))\n            (Eq.trans\n              (congr (congrArg HDiv.hDiv Rat.cast_one)\n                (Eq.trans (Rat.cast_add (↑n : ℚ) 1) (congr (congrArg HAdd.hAdd (Rat.cast_natCast n)) Rat.cast_one)))\n              (one_div ((↑n : Real) + 1)))))\n        (LUB_claim1._simp_1 ((↑n : Real) + 1)⁻¹))\n      (Eq.trans gt_iff_lt._simp_1 inv_pos._simp_1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"ε.IsPos","name":["hpos"],"isProp":true,"id":["_uniq",75941]}]}],"start":6050},{"state":[],"start":6087},{"state":[],"start":6088},{"state":[],"start":6152},{"state":[],"start":6189},{"state":[],"start":6241},{"state":[],"start":6299},{"state":[{"type":"∀ n ≥ N, ∀ n' ≥ N, |a n - a n'| ≤ 1 / ((↑N : ℚ) + 1)","tag":[],"mvarId":["_uniq",190721],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",190717],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",190718],"binderInfo":"default"}]}],"start":6361},{"state":[{"type":"|a n - a n'| ≤ 1 / ((↑N : ℚ) + 1)","tag":[],"mvarId":["_uniq",190732],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",190717],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",190718],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"}]}],"start":6383},{"state":[{"type":"-(1 / ((↑N : ℚ) + 1)) ≤ a n - a n' ∧ a n - a n' ≤ 1 / ((↑N : ℚ) + 1)","tag":[],"mvarId":["_uniq",191223],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",190717],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",190718],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"}]}],"start":6399},{"state":[{"type":"-(1 / ((↑N : ℚ) + 1)) ≤ a n - a n'","tag":["refine_1"],"mvarId":["_uniq",191267],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",190717],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",190718],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"}]},{"type":"a n - a n' ≤ 1 / ((↑N : ℚ) + 1)","tag":["refine_2"],"mvarId":["_uniq",191268],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",190717],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",190718],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"}]}],"start":6414},{"state":[{"type":"-(1 / ((↑N : ℚ) + 1)) ≤ a n - a n'","tag":["refine_1"],"mvarId":["_uniq",191289],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"},{"type":"(↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",191280],"binderInfo":"default"},{"type":"(↑((a - b) n') : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",191286],"binderInfo":"default"}]}],"start":6456},{"state":[{"type":"-(1 / ((↑N : ℚ) + 1)) ≤ a n - a n'","tag":["refine_1"],"mvarId":["_uniq",191391],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"},{"type":"(↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",191280],"binderInfo":"default"},{"type":"(↑((a - b) n') : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",191286],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (lt_of_coe ((a - b) n') (a n)))))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_lt_eq (↑((a - b) n') : Real) (↑(a n) : Real))\n          (Mathlib.Tactic.PushNeg.not_not_eq ((↑((a - b) n') : Real) ∈ upperBounds E))))\n      fun hm2 => LUB_claim2._proof_1 N hb n hn n' hn' hm1 hm2)\n    hm2)","type":"(a - b) n' < a n","name":["bound1"],"isProp":true,"id":["_uniq",191390]}]}],"start":6557},{"state":[{"type":"-(1 / ((↑N : ℚ) + 1)) ≤ a n - a n'","tag":["refine_1"],"mvarId":["_uniq",196334],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"},{"type":"(↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",191280],"binderInfo":"default"},{"type":"(↑((a - b) n') : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",191286],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (lt_of_coe ((a - b) n') (a n)))))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_lt_eq (↑((a - b) n') : Real) (↑(a n) : Real))\n          (Mathlib.Tactic.PushNeg.not_not_eq ((↑((a - b) n') : Real) ∈ upperBounds E))))\n      fun hm2 => LUB_claim2._proof_1 N hb n hn n' hn' hm1 hm2)\n    hm2)","type":"(a - b) n' < a n","name":["bound1"],"isProp":true,"id":["_uniq",191390]},{"value":"div_le_div₀\n  (le_of_lt\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n  (le_refl 1)\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n  (add_le_add_right (GCongr.natCast_le_natCast hn') 1)","type":"1 / ((↑n' : ℚ) + 1) ≤ 1 / ((↑N : ℚ) + 1)","name":["bound3"],"isProp":true,"id":["_uniq",196333]}]}],"start":6617},{"state":[{"type":"a n - a n' ≤ 1 / ((↑N : ℚ) + 1)","tag":["refine_2"],"mvarId":["_uniq",191268],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑(a n) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",190717],"binderInfo":"default"},{"type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",190718],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"}]}],"start":6692},{"state":[{"type":"a n - a n' ≤ 1 / ((↑N : ℚ) + 1)","tag":["refine_2"],"mvarId":["_uniq",208593],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"},{"type":"(↑(a n') : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",208584],"binderInfo":"default"},{"type":"(↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",208590],"binderInfo":"default"}]}],"start":6732},{"state":[{"type":"a n - a n' ≤ 1 / ((↑N : ℚ) + 1)","tag":["refine_2"],"mvarId":["_uniq",208695],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"},{"type":"(↑(a n') : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",208584],"binderInfo":"default"},{"type":"(↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",208590],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (lt_of_coe ((a - b) n) (a n')))))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_lt_eq (↑((a - b) n) : Real) (↑(a n') : Real))\n          (Mathlib.Tactic.PushNeg.not_not_eq ((↑((a - b) n) : Real) ∈ upperBounds E))))\n      fun hm2 => LUB_claim2._proof_3 N hb n hn n' hn' hm1 hm2)\n    hm2)","type":"(a - b) n < a n'","name":["bound1"],"isProp":true,"id":["_uniq",208694]}]}],"start":6831},{"state":[{"type":"a n - a n' ≤ 1 / ((↑N : ℚ) + 1)","tag":["refine_2"],"mvarId":["_uniq",213631],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"},{"type":"(↑(a n') : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",208584],"binderInfo":"default"},{"type":"(↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",208590],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (lt_of_coe ((a - b) n) (a n')))))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_lt_eq (↑((a - b) n) : Real) (↑(a n') : Real))\n          (Mathlib.Tactic.PushNeg.not_not_eq ((↑((a - b) n) : Real) ∈ upperBounds E))))\n      fun hm2 => LUB_claim2._proof_3 N hb n hn n' hn' hm1 hm2)\n    hm2)","type":"(a - b) n < a n'","name":["bound1"],"isProp":true,"id":["_uniq",208694]},{"value":"of_eq_true\n  (Eq.trans\n    (congr (congrArg (fun x => Eq (a n - x)) (Eq.trans (hb n) (one_div ((↑n : ℚ) + 1))))\n      (congrArg (HSub.hSub (a n)) (one_div ((↑n : ℚ) + 1))))\n    (eq_self (a n - ((↑n : ℚ) + 1)⁻¹)))","type":"(a - b) n = a n - 1 / ((↑n : ℚ) + 1)","name":["bound2"],"isProp":true,"id":["_uniq",213630]}]}],"start":6895},{"state":[{"type":"a n - a n' ≤ 1 / ((↑N : ℚ) + 1)","tag":["refine_2"],"mvarId":["_uniq",214610],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",190712],"binderInfo":"implicit"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",190713],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",190714],"binderInfo":"implicit"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",190715],"binderInfo":"implicit"},{"type":"∀ (n : ℕ), b n = 1 / ((↑n : ℚ) + 1)","name":["hb"],"isProp":true,"id":["_uniq",190716],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",190722],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",190725],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",190728],"binderInfo":"default"},{"type":"n' ≥ N","name":["hn'"],"isProp":true,"id":["_uniq",190731],"binderInfo":"default"},{"type":"(↑(a n') : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",208584],"binderInfo":"default"},{"type":"(↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",208590],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (lt_of_coe ((a - b) n) (a n')))))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_lt_eq (↑((a - b) n) : Real) (↑(a n') : Real))\n          (Mathlib.Tactic.PushNeg.not_not_eq ((↑((a - b) n) : Real) ∈ upperBounds E))))\n      fun hm2 => LUB_claim2._proof_3 N hb n hn n' hn' hm1 hm2)\n    hm2)","type":"(a - b) n < a n'","name":["bound1"],"isProp":true,"id":["_uniq",208694]},{"value":"of_eq_true\n  (Eq.trans\n    (congr (congrArg (fun x => Eq (a n - x)) (Eq.trans (hb n) (one_div ((↑n : ℚ) + 1))))\n      (congrArg (HSub.hSub (a n)) (one_div ((↑n : ℚ) + 1))))\n    (eq_self (a n - ((↑n : ℚ) + 1)⁻¹)))","type":"(a - b) n = a n - 1 / ((↑n : ℚ) + 1)","name":["bound2"],"isProp":true,"id":["_uniq",213630]},{"value":"div_le_div₀\n  (le_of_lt\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n  (le_refl 1)\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n  (add_le_add_right (GCongr.natCast_le_natCast hn) 1)","type":"1 / ((↑n : ℚ) + 1) ≤ 1 / ((↑N : ℚ) + 1)","name":["bound3"],"isProp":true,"id":["_uniq",214609]}]}],"start":6952},{"state":[],"start":6965},{"state":[],"start":6966},{"state":[],"start":7019},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",227968],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"}]}],"start":7122},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",227968],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"}]}],"start":7195},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",227981],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]}]}],"start":7217},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",228123],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]}]}],"start":7258},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",228164],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]}]}],"start":7332},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",228468],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]}]}],"start":7385},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",228719],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]}]}],"start":7430},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",228821],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]}]}],"start":7479},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",228990],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]}]}],"start":7527},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",229021],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]}]}],"start":7581},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",229273],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]}]}],"start":7675},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",229338],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]}]}],"start":7732},{"state":[{"type":"∃ S, IsLUB E S","tag":[],"mvarId":["_uniq",245595],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]}]}],"start":7798},{"state":[{"type":"IsLUB E S","tag":["h"],"mvarId":["_uniq",245762],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]}]}],"start":7822},{"state":[{"type":"S = LIM (a - b)","tag":[],"mvarId":["_uniq",245892],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]}]}],"start":7860},{"state":[{"type":"S = LIM (a - b)","tag":[],"mvarId":["_uniq",245990],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]},{"value":"LIM.harmonic","type":"LIM b = 0","name":["this"],"isProp":true,"id":["_uniq",245989]}]}],"start":7897},{"state":[{"type":"IsLUB E S","tag":["h"],"mvarId":["_uniq",245894],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]},{"value":"have this := LIM.harmonic;\nof_eq_true\n  (Eq.trans\n    (congrArg (Eq (LIM a))\n      (Eq.trans (Eq.symm (LIM_sub claim3 hb)) (Eq.trans (congrArg (HSub.hSub (LIM a)) this) (sub_zero (LIM a)))))\n    (eq_self (LIM a)))","type":"S = LIM (a - b)","name":["claim4"],"isProp":true,"id":["_uniq",245893]}]}],"start":7938},{"state":[{"type":"(∀ x ∈ E, x ≤ S) ∧ ∀ M' ∈ upperBounds E, M' ≥ S","tag":["h"],"mvarId":["_uniq",246263],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]},{"value":"have this := LIM.harmonic;\nof_eq_true\n  (Eq.trans\n    (congrArg (Eq (LIM a))\n      (Eq.trans (Eq.symm (LIM_sub claim3 hb)) (Eq.trans (congrArg (HSub.hSub (LIM a)) this) (sub_zero (LIM a)))))\n    (eq_self (LIM a)))","type":"S = LIM (a - b)","name":["claim4"],"isProp":true,"id":["_uniq",245893]}]}],"start":7971},{"state":[{"type":"∀ x ∈ E, x ≤ S","tag":["h","refine_1"],"mvarId":["_uniq",246277],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]},{"value":"have this := LIM.harmonic;\nof_eq_true\n  (Eq.trans\n    (congrArg (Eq (LIM a))\n      (Eq.trans (Eq.symm (LIM_sub claim3 hb)) (Eq.trans (congrArg (HSub.hSub (LIM a)) this) (sub_zero (LIM a)))))\n    (eq_self (LIM a)))","type":"S = LIM (a - b)","name":["claim4"],"isProp":true,"id":["_uniq",245893]}]},{"type":"∀ M' ∈ upperBounds E, M' ≥ S","tag":["h","refine_2"],"mvarId":["_uniq",246278],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]},{"value":"have this := LIM.harmonic;\nof_eq_true\n  (Eq.trans\n    (congrArg (Eq (LIM a))\n      (Eq.trans (Eq.symm (LIM_sub claim3 hb)) (Eq.trans (congrArg (HSub.hSub (LIM a)) this) (sub_zero (LIM a)))))\n    (eq_self (LIM a)))","type":"S = LIM (a - b)","name":["claim4"],"isProp":true,"id":["_uniq",245893]}]}],"start":7984},{"state":[{"type":"∀ M' ∈ upperBounds E, M' ≥ S","tag":["h","refine_2"],"mvarId":["_uniq",246278],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]},{"value":"have this := LIM.harmonic;\nof_eq_true\n  (Eq.trans\n    (congrArg (Eq (LIM a))\n      (Eq.trans (Eq.symm (LIM_sub claim3 hb)) (Eq.trans (congrArg (HSub.hSub (LIM a)) this) (sub_zero (LIM a)))))\n    (eq_self (LIM a)))","type":"S = LIM (a - b)","name":["claim4"],"isProp":true,"id":["_uniq",245893]}]}],"start":8043},{"state":[{"type":"y ≥ S","tag":["h","refine_2"],"mvarId":["_uniq",262713],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]},{"value":"have this := LIM.harmonic;\nof_eq_true\n  (Eq.trans\n    (congrArg (Eq (LIM a))\n      (Eq.trans (Eq.symm (LIM_sub claim3 hb)) (Eq.trans (congrArg (HSub.hSub (LIM a)) this) (sub_zero (LIM a)))))\n    (eq_self (LIM a)))","type":"S = LIM (a - b)","name":["claim4"],"isProp":true,"id":["_uniq",245893]},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",262709],"binderInfo":"default"},{"type":"y ∈ upperBounds E","name":["hy"],"isProp":true,"id":["_uniq",262712],"binderInfo":"default"}]}],"start":8056},{"state":[{"type":"y ≥ S","tag":["h","refine_2"],"mvarId":["_uniq",262891],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",227965],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",227966],"binderInfo":"default"},{"type":"BddAbove E","name":["hbound"],"isProp":true,"id":["_uniq",227967],"binderInfo":"default"},{"value":"hE.some","type":"Real","name":["x₀"],"isProp":false,"id":["_uniq",227980]},{"value":"Set.Nonempty.some_mem hE","type":"x₀ ∈ E","name":["hx₀"],"isProp":true,"id":["_uniq",228122]},{"value":"fun n => ⋯.choose","type":"ℕ → ℤ","name":["m"],"isProp":false,"id":["_uniq",228163]},{"value":"fun n => (↑(m n) : ℚ) / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",228467]},{"value":"fun n => 1 / ((↑n : ℚ) + 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",228718]},{"value":"fun n => LUB_claim1 n hE hbound","type":"∀ (n : ℕ),\n  ∃! m,\n    (↑((↑m : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E ∧\n      (↑((↑m : ℚ) / ((↑n : ℚ) + 1) - 1 / ((↑n : ℚ) + 1)) : Real) ∉ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",228819]},{"value":"Sequence.IsCauchy.harmonic'","type":"(↑b : Sequence).IsCauchy","name":["hb"],"isProp":true,"id":["_uniq",228987]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).left","type":"∀ (n : ℕ), (↑((↑⋯.choose : ℚ) / ((↑n : ℚ) + 1)) : Real) ∈ upperBounds E","name":["hm1"],"isProp":true,"id":["_uniq",229019]},{"value":"fun n => (Exists.choose_spec (ExistsUnique.exists (claim1 n))).right","type":"∀ (n : ℕ), (↑((a - b) n) : Real) ∉ upperBounds E","name":["hm2"],"isProp":true,"id":["_uniq",229271]},{"value":"fun N =>\n  LUB_claim2 N\n    (fun n =>\n      of_eq_true\n        (Eq.trans\n          (congr (congrArg (fun x => Eq (x n)) (funext fun n => one_div ((↑n : ℚ) + 1))) (one_div ((↑n : ℚ) + 1)))\n          (eq_self ((↑n : ℚ) + 1)⁻¹)))\n    hm1 hm2","type":"∀ (N n : ℕ),\n  n ≥ N → ∀ n' ≥ N, |(↑⋯.choose : ℚ) / ((↑n : ℚ) + 1) - (↑⋯.choose : ℚ) / ((↑n' : ℚ) + 1)| ≤ 1 / ((↑N : ℚ) + 1)","name":["claim2"],"isProp":true,"id":["_uniq",229332]},{"value":"(LIM_of_Cauchy claim2).left","type":"(↑a : Sequence).IsCauchy","name":["claim3"],"isProp":true,"id":["_uniq",245592]},{"value":"LIM a","type":"Real","name":["S"],"isProp":false,"id":["_uniq",245602]},{"value":"have this := LIM.harmonic;\nof_eq_true\n  (Eq.trans\n    (congrArg (Eq (LIM a))\n      (Eq.trans (Eq.symm (LIM_sub claim3 hb)) (Eq.trans (congrArg (HSub.hSub (LIM a)) this) (sub_zero (LIM a)))))\n    (eq_self (LIM a)))","type":"S = LIM (a - b)","name":["claim4"],"isProp":true,"id":["_uniq",245893]},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",262709],"binderInfo":"default"},{"type":"y ∈ upperBounds E","name":["hy"],"isProp":true,"id":["_uniq",262712],"binderInfo":"default"},{"value":"fun n =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_ge_eq y (↑((a - b) n) : Real))\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun n => (↑((a - b) n) : Real) ∉ upperBounds E)\n            (congrArg Exists\n              (funext fun n => Mathlib.Tactic.PushNeg.not_not_eq ((↑((a - b) n) : Real) ∈ upperBounds E))))))\n      fun hm2 =>\n      Exists.intro n\n        (upperBound_upper\n          (Decidable.byContradiction fun a_1 =>\n            ne_of_lt hm2\n              (le_antisymm (le_trans (le_of_lt hm2) (le_refl (↑((a - b) n) : Real)))\n                (le_trans (le_of_not_ge a_1) (le_refl y))))\n          hy))\n    hm2","type":"∀ (n : ℕ), y ≥ (↑((a - b) n) : Real)","name":["claim5"],"isProp":true,"id":["_uniq",262889]}]}],"start":8159},{"state":[],"start":8238},{"state":[],"start":8239},{"state":[],"start":8299},{"state":[],"start":8328},{"state":[],"start":8355},{"state":[],"start":8386},{"state":[],"start":8409},{"state":[],"start":8410},{"state":[],"start":8465},{"state":[],"start":8521},{"state":[],"start":8536},{"state":[],"start":8537},{"state":[],"start":8591},{"state":[],"start":8646},{"state":[],"start":8661},{"state":[],"start":8662},{"state":[],"start":8723},{"state":[],"start":8754},{"state":[],"start":8755},{"state":[],"start":8816},{"state":[],"start":8840},{"state":[],"start":8859},{"state":[],"start":8875},{"state":[],"start":8890},{"state":[],"start":8891},{"state":[],"start":8962},{"state":[],"start":8985},{"state":[],"start":9004},{"state":[],"start":9023},{"state":[],"start":9024},{"state":[],"start":9096},{"state":[{"type":"X =\n  real\n    (match X with\n    | neg_infty => 0\n    | real x => x\n    | infty => 0)","tag":[],"mvarId":["_uniq",279065],"isProp":true,"context":[{"type":"ExtendedReal","name":["X"],"isProp":false,"id":["_uniq",279055],"binderInfo":"implicit"},{"type":"X.IsFinite","name":["hX"],"isProp":true,"id":["_uniq",279056],"binderInfo":"default"}]}],"start":9134},{"state":[{"type":"real x✝ =\n  real\n    (match real x✝ with\n    | neg_infty => 0\n    | real x => x\n    | infty => 0)","tag":["real"],"mvarId":["_uniq",279180],"isProp":true,"context":[{"type":"Real","name":["x✝"],"isProp":false,"id":["_uniq",279117],"binderInfo":"default"},{"type":"True","name":["hX"],"isProp":true,"id":["_uniq",279131],"binderInfo":"default"}]}],"start":9174},{"state":[],"start":9181},{"state":[],"start":9182},{"state":[],"start":9200},{"state":[],"start":9235},{"state":[],"start":9305},{"state":[],"start":9408},{"state":[],"start":9409},{"state":[],"start":9444},{"state":[],"start":9511},{"state":[],"start":9512},{"state":[],"start":9547},{"state":[{"type":"sup E = ⊤","tag":[],"mvarId":["_uniq",280390],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",280388],"binderInfo":"implicit"},{"type":"¬BddAbove E","name":["hb"],"isProp":true,"id":["_uniq",280389],"binderInfo":"default"}]}],"start":9639},{"state":[{"type":"sup E = ⊤","tag":[],"mvarId":["_uniq",280399],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",280388],"binderInfo":"implicit"},{"type":"¬BddAbove E","name":["hb"],"isProp":true,"id":["_uniq",280389],"binderInfo":"default"},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq E) (Mathlib.Tactic.PushNeg.not_not_eq (BddAbove E))))\n    fun hb => of_eq_true (Eq.trans (congrArg BddAbove hb) bddAbove_empty._simp_1))\n  hb","type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",280398]}]}],"start":9694},{"state":[],"start":9715},{"state":[],"start":9716},{"state":[],"start":9751},{"state":[],"start":9839},{"state":[{"type":"IsLUB E\n  (match sup E with\n  | neg_infty => 0\n  | real x => x\n  | infty => 0)","tag":[],"mvarId":["_uniq",282115],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",282112],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",282113],"binderInfo":"default"},{"type":"BddAbove E","name":["hb"],"isProp":true,"id":["_uniq",282114],"binderInfo":"default"}]}],"start":9865},{"state":[],"start":9932},{"state":[],"start":9933},{"state":[],"start":10028},{"state":[],"start":10086},{"state":[],"start":10087},{"state":[],"start":10113},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",284117],"isProp":true,"context":[]}],"start":10169},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",284117],"isProp":true,"context":[]}],"start":10242},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",284525],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]}]}],"start":10286},{"state":[{"type":"2 ∈ upperBounds E","tag":[],"mvarId":["_uniq",284717],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]}]}],"start":10327},{"state":[{"type":"∀ x ∈ E, x ≤ 2","tag":[],"mvarId":["_uniq",284737],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]}]}],"start":10351},{"state":[{"type":"0 ≤ y → 2 ≤ y ^ 2","tag":[],"mvarId":["_uniq",289063],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",284744],"binderInfo":"default"},{"type":"2 < y","name":["hy"],"isProp":true,"id":["_uniq",289062],"binderInfo":"default"}]}],"start":10398},{"state":[{"type":"2 ≤ y ^ 2","tag":[],"mvarId":["_uniq",289066],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",284744],"binderInfo":"default"},{"type":"2 < y","name":["hy"],"isProp":true,"id":["_uniq",289062],"binderInfo":"default"},{"type":"0 ≤ y","name":["hpos"],"isProp":true,"id":["_uniq",289065],"binderInfo":"default"}]}],"start":10413},{"state":[{"type":"2 ≤ y ^ 2","tag":[],"mvarId":["_uniq",289066],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"type":"Real","name":["y"],"isProp":false,"id":["_uniq",284744],"binderInfo":"default"},{"type":"2 < y","name":["hy"],"isProp":true,"id":["_uniq",289062],"binderInfo":"default"},{"type":"0 ≤ y","name":["hpos"],"isProp":true,"id":["_uniq",289065],"binderInfo":"default"}]}],"start":10422},{"state":[],"start":10455},{"state":[],"start":10486},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",284719],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]}]}],"start":10511},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",295188],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]}]}],"start":10570},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",295336],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]}]}],"start":10608},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",301624],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"}]}],"start":10638},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",301712],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]}]}],"start":10677},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",302024],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]}]}],"start":10745},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",308149],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]}]}],"start":10809},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",314303],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]}]}],"start":10857},{"state":[{"type":"∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",319852],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]}]}],"start":10912},{"state":[{"type":"x ^ 2 = 2","tag":["h","inl"],"mvarId":["_uniq",322040],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"}]},{"type":"x ^ 2 = 2","tag":["h","inr","inl"],"mvarId":["_uniq",322063],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"}]},{"type":"x ^ 2 = 2","tag":["h","inr","inr"],"mvarId":["_uniq",322068],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 = 2","name":["h"],"isProp":true,"id":["_uniq",322067],"binderInfo":"default"}]}],"start":10963},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 - 4 * ε > 2","tag":[],"mvarId":["_uniq",322840],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"}]}],"start":11032},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 - 4 * ε > 2","tag":[],"mvarId":["_uniq",323963],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"value":"min (1 / 2) ((x ^ 2 - 2) / 8)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",323962]}]}],"start":11070},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 - 4 * ε > 2","tag":[],"mvarId":["_uniq",324408],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"value":"min (1 / 2) ((x ^ 2 - 2) / 8)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",323962]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_add\n                  (Mathlib.Tactic.Ring.single_pow\n                    (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                  (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                          (Eq.refl (Int.negOfNat 2)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  ((Int.negOfNat 2).rawCast + (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2)) (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"x ^ 2 - 2 > 0","name":["hx"],"isProp":true,"id":["_uniq",324407]}]}],"start":11113},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 - 4 * ε > 2","tag":[],"mvarId":["_uniq",324695],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"value":"min (1 / 2) ((x ^ 2 - 2) / 8)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",323962]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_add\n                  (Mathlib.Tactic.Ring.single_pow\n                    (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                  (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                          (Eq.refl (Int.negOfNat 2)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  ((Int.negOfNat 2).rawCast + (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2)) (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"x ^ 2 - 2 > 0","name":["hx"],"isProp":true,"id":["_uniq",324407]},{"value":"lt_min\n  (div_pos\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n  (div_pos hx\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 8)) (Eq.refl (Nat.ble 1 8))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",324694]}]}],"start":11154},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 - 4 * ε > 2","tag":[],"mvarId":["_uniq",439847],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"value":"min (1 / 2) ((x ^ 2 - 2) / 8)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",323962]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_add\n                  (Mathlib.Tactic.Ring.single_pow\n                    (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                  (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                          (Eq.refl (Int.negOfNat 2)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  ((Int.negOfNat 2).rawCast + (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2)) (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"x ^ 2 - 2 > 0","name":["hx"],"isProp":true,"id":["_uniq",324407]},{"value":"lt_min\n  (div_pos\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n  (div_pos hx\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 8)) (Eq.refl (Nat.ble 1 8))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",324694]},{"type":"min (1 / 2) ((x ^ 2 - 2) / 8) ≤ 1 / 2","name":["hε1"],"isProp":true,"id":["_uniq",439846],"binderInfo":"default"}]}],"start":11185},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 - 4 * ε > 2","tag":[],"mvarId":["_uniq",462896],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"value":"min (1 / 2) ((x ^ 2 - 2) / 8)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",323962]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_add\n                  (Mathlib.Tactic.Ring.single_pow\n                    (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                  (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                          (Eq.refl (Int.negOfNat 2)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  ((Int.negOfNat 2).rawCast + (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2)) (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"x ^ 2 - 2 > 0","name":["hx"],"isProp":true,"id":["_uniq",324407]},{"value":"lt_min\n  (div_pos\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n  (div_pos hx\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 8)) (Eq.refl (Nat.ble 1 8))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",324694]},{"type":"min (1 / 2) ((x ^ 2 - 2) / 8) ≤ 1 / 2","name":["hε1"],"isProp":true,"id":["_uniq",439846],"binderInfo":"default"},{"type":"min (1 / 2) ((x ^ 2 - 2) / 8) ≤ (x ^ 2 - 2) / 8","name":["hε2"],"isProp":true,"id":["_uniq",462895],"binderInfo":"default"}]}],"start":11222},{"state":[{"type":"x ^ 2 = 2","tag":["h","inl"],"mvarId":["_uniq",322842],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"value":"let ε := min (1 / 2) ((x ^ 2 - 2) / 8);\nhave hx :=\n  lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_add\n                      (Mathlib.Tactic.Ring.single_pow\n                        (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                      (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                            (Eq.refl (Int.negOfNat 2)))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((Int.negOfNat 2).rawCast + (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2)) (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)));\nhave hε :=\n  lt_min\n    (div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one)\n        (Eq.refl (Nat.ble 1 1)))\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n        (Eq.refl (Nat.ble 1 2))))\n    (div_pos hx\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 8))\n        (Eq.refl (Nat.ble 1 8))));\nExists.intro ε\n  ⟨hε,\n    ⟨lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.atom_pf (min (1 / 2) ((x ^ 2 - 2) / 8)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                          ⋯)\n                        ⋯))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯),\n      ⋯⟩⟩","type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 - 4 * ε > 2","name":["claim11"],"isProp":true,"id":["_uniq",322841]}]}],"start":11271},{"state":[{"type":"x ^ 2 = 2","tag":["h","inl"],"mvarId":["_uniq",472570],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",472547],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",472556],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",472565],"binderInfo":"default"},{"type":"x ^ 2 - 4 * ε > 2","name":["hε3"],"isProp":true,"id":["_uniq",472569],"binderInfo":"default"}]}],"start":11314},{"state":[{"type":"x ^ 2 = 2","tag":["h","inl"],"mvarId":["_uniq",474412],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",472547],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",472556],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",472565],"binderInfo":"default"},{"type":"x ^ 2 - 4 * ε > 2","name":["hε3"],"isProp":true,"id":["_uniq",472569],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.sub_pf\n              (Mathlib.Tactic.Ring.neg_add\n                (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Eq.refl (Int.negOfNat 1))))))\n                Mathlib.Tactic.Ring.neg_zero)\n              (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero\n              (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (⋯ * ⋯) + ⋯)))\n              ⋯ ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x - ε) ^ 2 > 2","name":["claim12"],"isProp":true,"id":["_uniq",474411]}]}],"start":11353},{"state":[],"start":11401},{"state":[],"start":11451},{"state":[],"start":11485},{"state":[{"type":"x ^ 2 = 2","tag":["h","inl"],"mvarId":["_uniq",474412],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",472547],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",472556],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",472565],"binderInfo":"default"},{"type":"x ^ 2 - 4 * ε > 2","name":["hε3"],"isProp":true,"id":["_uniq",472569],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.sub_pf\n              (Mathlib.Tactic.Ring.neg_add\n                (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Eq.refl (Int.negOfNat 1))))))\n                Mathlib.Tactic.Ring.neg_zero)\n              (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero\n              (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (⋯ * ⋯) + ⋯)))\n              ⋯ ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x - ε) ^ 2 > 2","name":["claim12"],"isProp":true,"id":["_uniq",474411]}]}],"start":11505},{"state":[{"type":"x ^ 2 = 2","tag":["h","inl"],"mvarId":["_uniq",501115],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",472547],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",472556],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",472565],"binderInfo":"default"},{"type":"x ^ 2 - 4 * ε > 2","name":["hε3"],"isProp":true,"id":["_uniq",472569],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.sub_pf\n              (Mathlib.Tactic.Ring.neg_add\n                (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Eq.refl (Int.negOfNat 1))))))\n                Mathlib.Tactic.Ring.neg_zero)\n              (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero\n              (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (⋯ * ⋯) + ⋯)))\n              ⋯ ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x - ε) ^ 2 > 2","name":["claim12"],"isProp":true,"id":["_uniq",474411]},{"value":"fun y hy => sorry","type":"∀ y ∈ E, x - ε ≥ y","name":["why"],"isProp":true,"id":["_uniq",501112]}]}],"start":11568},{"state":[{"type":"x ^ 2 = 2","tag":["h","inl"],"mvarId":["_uniq",501299],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",472547],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",472556],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",472565],"binderInfo":"default"},{"type":"x ^ 2 - 4 * ε > 2","name":["hε3"],"isProp":true,"id":["_uniq",472569],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.sub_pf\n              (Mathlib.Tactic.Ring.neg_add\n                (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Eq.refl (Int.negOfNat 1))))))\n                Mathlib.Tactic.Ring.neg_zero)\n              (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero\n              (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (⋯ * ⋯) + ⋯)))\n              ⋯ ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x - ε) ^ 2 > 2","name":["claim12"],"isProp":true,"id":["_uniq",474411]},{"value":"fun y hy => sorry","type":"∀ y ∈ E, x - ε ≥ y","name":["why"],"isProp":true,"id":["_uniq",501112]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E (x - ε))))) why","type":"x - ε ∈ upperBounds E","name":["claim13"],"isProp":true,"id":["_uniq",501298]}]}],"start":11636},{"state":[{"type":"x ^ 2 = 2","tag":["h","inl"],"mvarId":["_uniq",501370],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 > 2","name":["h"],"isProp":true,"id":["_uniq",322039],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",472547],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",472556],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",472565],"binderInfo":"default"},{"type":"x ^ 2 - 4 * ε > 2","name":["hε3"],"isProp":true,"id":["_uniq",472569],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.sub_pf\n              (Mathlib.Tactic.Ring.neg_add\n                (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Eq.refl (Int.negOfNat 1))))))\n                Mathlib.Tactic.Ring.neg_zero)\n              (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 1).rawCast)))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero\n              (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_one (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (⋯ * ⋯) + ⋯)))\n              ⋯ ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x - ε) ^ 2 > 2","name":["claim12"],"isProp":true,"id":["_uniq",474411]},{"value":"fun y hy => sorry","type":"∀ y ∈ E, x - ε ≥ y","name":["why"],"isProp":true,"id":["_uniq",501112]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E (x - ε))))) why","type":"x - ε ∈ upperBounds E","name":["claim13"],"isProp":true,"id":["_uniq",501298]},{"value":"exist_sqrt_two._proof_6 claim3 claim6 h ε hε1 hε2 hε3 claim12 why claim13","type":"x ≤ x - ε","name":["claim14"],"isProp":true,"id":["_uniq",501369]}]}],"start":11689},{"state":[{"type":"x ^ 2 = 2","tag":["h","inr","inl"],"mvarId":["_uniq",322063],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"}]},{"type":"x ^ 2 = 2","tag":["h","inr","inr"],"mvarId":["_uniq",322068],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 = 2","name":["h"],"isProp":true,"id":["_uniq",322067],"binderInfo":"default"}]}],"start":11702},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 + 5 * ε < 2","tag":[],"mvarId":["_uniq",520707],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"}]}],"start":11771},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 + 5 * ε < 2","tag":[],"mvarId":["_uniq",521867],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"value":"min (1 / 2) ((2 - x ^ 2) / 10)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",521866]}]}],"start":11810},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 + 5 * ε < 2","tag":[],"mvarId":["_uniq",522312],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"value":"min (1 / 2) ((2 - x ^ 2) / 10)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",521866]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_add\n                  (Mathlib.Tactic.Ring.single_pow\n                    (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                  (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                        (Eq.refl (Int.negOfNat 2)))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (Nat.rawCast 2 + (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"2 - x ^ 2 > 0","name":["hx"],"isProp":true,"id":["_uniq",522311]}]}],"start":11853},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 + 5 * ε < 2","tag":[],"mvarId":["_uniq",522602],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"value":"min (1 / 2) ((2 - x ^ 2) / 10)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",521866]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_add\n                  (Mathlib.Tactic.Ring.single_pow\n                    (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                  (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                        (Eq.refl (Int.negOfNat 2)))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (Nat.rawCast 2 + (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"2 - x ^ 2 > 0","name":["hx"],"isProp":true,"id":["_uniq",522311]},{"value":"lt_min\n  (div_pos\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n  (div_pos hx\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 10))\n      (Eq.refl (Nat.ble 1 10))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",522601]}]}],"start":11893},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 + 5 * ε < 2","tag":[],"mvarId":["_uniq",526184],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"value":"min (1 / 2) ((2 - x ^ 2) / 10)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",521866]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_add\n                  (Mathlib.Tactic.Ring.single_pow\n                    (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                  (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                        (Eq.refl (Int.negOfNat 2)))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (Nat.rawCast 2 + (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"2 - x ^ 2 > 0","name":["hx"],"isProp":true,"id":["_uniq",522311]},{"value":"lt_min\n  (div_pos\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n  (div_pos hx\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 10))\n      (Eq.refl (Nat.ble 1 10))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",522601]},{"value":"min_le_left (1 / 2) ((2 - x ^ 2) / 10)","type":"ε ≤ 1 / 2","name":["hε1"],"isProp":true,"id":["_uniq",526183]}]}],"start":11940},{"state":[{"type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 + 5 * ε < 2","tag":[],"mvarId":["_uniq",526608],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"value":"min (1 / 2) ((2 - x ^ 2) / 10)","type":"Real","name":["ε"],"isProp":false,"id":["_uniq",521866]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_add\n                  (Mathlib.Tactic.Ring.single_pow\n                    (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                  (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                        (Eq.refl (Int.negOfNat 2)))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (Nat.rawCast 2 + (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"2 - x ^ 2 > 0","name":["hx"],"isProp":true,"id":["_uniq",522311]},{"value":"lt_min\n  (div_pos\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n  (div_pos hx\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 10))\n      (Eq.refl (Nat.ble 1 10))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",522601]},{"value":"min_le_left (1 / 2) ((2 - x ^ 2) / 10)","type":"ε ≤ 1 / 2","name":["hε1"],"isProp":true,"id":["_uniq",526183]},{"value":"min_le_right (1 / 2) ((2 - x ^ 2) / 10)","type":"ε ≤ (2 - x ^ 2) / 10","name":["hε2"],"isProp":true,"id":["_uniq",526607]}]}],"start":11997},{"state":[{"type":"x ^ 2 = 2","tag":["h","inr","inl"],"mvarId":["_uniq",520709],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"value":"let ε := min (1 / 2) ((2 - x ^ 2) / 10);\nhave hx :=\n  lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_add\n                    (Mathlib.Tactic.Ring.single_pow\n                      (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                    (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                          (Eq.refl (Int.negOfNat 2)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_add\n                      (Mathlib.Tactic.Ring.single_pow\n                        (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                      (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 2)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (Nat.rawCast 2 + (x ^ Nat.rawCast 2 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 2)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)));\nhave hε :=\n  lt_min\n    (div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one)\n        (Eq.refl (Nat.ble 1 1)))\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n        (Eq.refl (Nat.ble 1 2))))\n    (div_pos hx\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 10))\n        (Eq.refl (Nat.ble 1 10))));\nhave hε1 := min_le_left (1 / 2) ((2 - x ^ 2) / 10);\nhave hε2 := min_le_right (1 / 2) ((2 - x ^ 2) / 10);\nExists.intro ε\n  ⟨hε,\n    ⟨lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt ⋯) ⋯)))\n                          ⋯)\n                        ⋯))\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯))\n            ⋯),\n      ⋯⟩⟩","type":"∃ ε, 0 < ε ∧ ε < 1 ∧ x ^ 2 + 5 * ε < 2","name":["claim7"],"isProp":true,"id":["_uniq",520708]}]}],"start":12047},{"state":[{"type":"x ^ 2 = 2","tag":["h","inr","inl"],"mvarId":["_uniq",535780],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",535757],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",535766],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",535775],"binderInfo":"default"},{"type":"x ^ 2 + 5 * ε < 2","name":["hε3"],"isProp":true,"id":["_uniq",535779],"binderInfo":"default"}]}],"start":12089},{"state":[{"type":"x ^ 2 = 2","tag":["h","inr","inl"],"mvarId":["_uniq",537517],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",535757],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",535766],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",535775],"binderInfo":"default"},{"type":"x ^ 2 + 5 * ε < 2","name":["hε3"],"isProp":true,"id":["_uniq",535779],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n              (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw Real 1)\n                            (Mathlib.Meta.NormNum.IsNat.of_raw Real 1) (Eq.refl 2)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1) (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 2)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 2) + 0)))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (⋯ ^ ⋯ * ⋯) ⋯))\n              ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x + ε) ^ 2 < 2","name":["claim8"],"isProp":true,"id":["_uniq",537516]}]}],"start":12128},{"state":[],"start":12172},{"state":[],"start":12219},{"state":[],"start":12251},{"state":[{"type":"x ^ 2 = 2","tag":["h","inr","inl"],"mvarId":["_uniq",537517],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",535757],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",535766],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",535775],"binderInfo":"default"},{"type":"x ^ 2 + 5 * ε < 2","name":["hε3"],"isProp":true,"id":["_uniq",535779],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n              (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw Real 1)\n                            (Mathlib.Meta.NormNum.IsNat.of_raw Real 1) (Eq.refl 2)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1) (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 2)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 2) + 0)))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (⋯ ^ ⋯ * ⋯) ⋯))\n              ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x + ε) ^ 2 < 2","name":["claim8"],"isProp":true,"id":["_uniq",537516]}]}],"start":12271},{"state":[{"type":"x ^ 2 = 2","tag":["h","inr","inl"],"mvarId":["_uniq",560883],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",535757],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",535766],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",535775],"binderInfo":"default"},{"type":"x ^ 2 + 5 * ε < 2","name":["hε3"],"isProp":true,"id":["_uniq",535779],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n              (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw Real 1)\n                            (Mathlib.Meta.NormNum.IsNat.of_raw Real 1) (Eq.refl 2)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1) (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 2)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 2) + 0)))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (⋯ ^ ⋯ * ⋯) ⋯))\n              ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x + ε) ^ 2 < 2","name":["claim8"],"isProp":true,"id":["_uniq",537516]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congrArg (fun x_1 => x + ε ∈ setOf x_1) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n      (Eq.trans (congrArg (And (0 ≤ x + ε)) (eq_true claim8)) (and_true (0 ≤ x + ε)))))\n  (le_of_not_gt fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2)))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_neg\n          (Mathlib.Tactic.Linarith.add_neg\n            (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4)\n              (Mathlib.Tactic.Linarith.mul_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hε1)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero)\n                  (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl false))))\n            (Mathlib.Tactic.Linarith.sub_neg_of_lt hε2))\n          (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))","type":"x + ε ∈ E","name":["claim9"],"isProp":true,"id":["_uniq",560882]}]}],"start":12335},{"state":[{"type":"x ^ 2 = 2","tag":["h","inr","inl"],"mvarId":["_uniq",568602],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 < 2","name":["h"],"isProp":true,"id":["_uniq",322062],"binderInfo":"default"},{"type":"Real","name":["ε"],"isProp":false,"id":["_uniq",535757],"binderInfo":"default"},{"type":"0 < ε","name":["hε1"],"isProp":true,"id":["_uniq",535766],"binderInfo":"default"},{"type":"ε < 1","name":["hε2"],"isProp":true,"id":["_uniq",535775],"binderInfo":"default"},{"type":"x ^ 2 + 5 * ε < 2","name":["hε3"],"isProp":true,"id":["_uniq",535779],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.pow_congr\n          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n              (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n          (Mathlib.Tactic.Ring.pow_add\n            (Mathlib.Tactic.Ring.pow_nat (Mathlib.Tactic.Ring.coeff_one 2)\n              (Mathlib.Tactic.Ring.pow_one_cast\n                (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.pow_bit0\n                (Mathlib.Tactic.Ring.pow_one\n                  (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pp_pf_overlap x\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pp_pf_overlap ε\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.zero_mul\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 1) +\n                        (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Tactic.Ring.add_overlap_pf x (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw Real 1)\n                            (Mathlib.Meta.NormNum.IsNat.of_raw Real 1) (Eq.refl 2)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 2 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n            (Mathlib.Tactic.Ring.pow_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 1) (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 2)))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * (ε ^ Nat.rawCast 1 * Nat.rawCast 2) + 0)))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left ε (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (⋯ ^ ⋯ * ⋯) ⋯))\n              ⋯)))\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"(x + ε) ^ 2 < 2","name":["claim8"],"isProp":true,"id":["_uniq",537516]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congrArg (fun x_1 => x + ε ∈ setOf x_1) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n      (Eq.trans (congrArg (And (0 ≤ x + ε)) (eq_true claim8)) (and_true (0 ≤ x + ε)))))\n  (le_of_not_gt fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2)))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 2))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf ε)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (x ^ Nat.rawCast 1 * Nat.rawCast 1 + (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_neg\n          (Mathlib.Tactic.Linarith.add_neg\n            (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4)\n              (Mathlib.Tactic.Linarith.mul_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hε1)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero)\n                  (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl false))))\n            (Mathlib.Tactic.Linarith.sub_neg_of_lt hε2))\n          (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))","type":"x + ε ∈ E","name":["claim9"],"isProp":true,"id":["_uniq",560882]},{"value":"exist_sqrt_two._proof_7 claim3 claim6 h ε hε1 hε2 hε3 claim8 claim9","type":"x + ε ≤ x","name":["claim10"],"isProp":true,"id":["_uniq",568601]}]}],"start":12407},{"state":[{"type":"x ^ 2 = 2","tag":["h","inr","inr"],"mvarId":["_uniq",322068],"isProp":true,"context":[{"value":"{y | y ≥ 0 ∧ y ^ 2 < 2}","type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",284524]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (upperBound_def E 2)))) fun y hy =>\n  Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id\n        (implies_congr (Mathlib.Tactic.PushNeg.not_le_eq y 2)\n          (Eq.trans (Mathlib.Tactic.PushNeg.not_and_eq (0 ≤ y) (y ^ 2 < 2))\n            (implies_congr (Eq.refl (0 ≤ y)) (Mathlib.Tactic.PushNeg.not_lt_eq (y ^ 2) 2)))))\n      fun hy hpos =>\n      Trans.trans\n        (Trans.trans\n          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n            (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul) (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2)) (Eq.refl 4))\n            (Eq.refl true))\n          (mul_le_mul (le_of_lt hy) (le_of_lt hy)\n            (le_of_lt\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                (Eq.refl (Nat.ble 1 2))))\n            (le_of_lt\n              (_root_.lt_trans\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat Real (Eq.refl 2))\n                  (Eq.refl (Nat.ble 1 2)))\n                hy))))\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y) (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pp_pf_overlap y\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))))\n          (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf y)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.pow_add\n              (Mathlib.Tactic.Ring.single_pow\n                (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                  (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n              (Mathlib.Tactic.Ring.pow_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 2) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))))\n    (Eq.mp (congrArg (fun x => y ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1)) hy)","type":"2 ∈ upperBounds E","name":["claim1"],"isProp":true,"id":["_uniq",284718]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (bddAbove_def E)))) (Exists.intro 2 claim1)","type":"BddAbove E","name":["claim1'"],"isProp":true,"id":["_uniq",295187]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => 1 ∈ setOf x) (funext fun y => congrArg (fun x => x ∧ y ^ 2 < 2) ge_iff_le._simp_1))\n    (Eq.trans\n      (congr (congrArg And zero_le_one._simp_1)\n        (Eq.trans (congrArg (fun x => x < 2) (one_pow 2)) Nat.one_lt_ofNat._simp_1))\n      (and_self True)))","type":"1 ∈ E","name":["claim2"],"isProp":true,"id":["_uniq",295335]},{"type":"E.Nonempty","name":["claim2'"],"isProp":true,"id":["_uniq",301623],"binderInfo":"default"},{"value":"match ExtendedReal.sup E with\n| ExtendedReal.neg_infty => 0\n| ExtendedReal.real x => x\n| ExtendedReal.infty => 0","type":"Real","name":["x"],"isProp":false,"id":["_uniq",301711]},{"value":"exist_sqrt_two._proof_3 claim1' claim2'","type":"IsLUB E x","name":["claim3"],"isProp":true,"id":["_uniq",302023]},{"value":"exist_sqrt_two._proof_4 claim2 claim3","type":"x ≥ 1","name":["claim4"],"isProp":true,"id":["_uniq",308148]},{"value":"exist_sqrt_two._proof_5 claim1 claim3","type":"x ≤ 2","name":["claim5"],"isProp":true,"id":["_uniq",314302]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (isPos_iff x))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf x)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw Real (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw Real 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat Real Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le claim4))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"x.IsPos","name":["claim6"],"isProp":true,"id":["_uniq",319851]},{"type":"x ^ 2 = 2","name":["h"],"isProp":true,"id":["_uniq",322067],"binderInfo":"default"}]}],"start":12420},{"state":[],"start":12433},{"state":[],"start":12434},{"state":[],"start":12455},{"state":[],"start":12538},{"state":[],"start":12539},{"state":[],"start":12579},{"state":[],"start":12662},{"state":[],"start":12663},{"state":[],"start":12684},{"state":[],"start":12773},{"state":[],"start":12774},{"state":[{"type":"∃ S, IsGLB E S","tag":[],"mvarId":["_uniq",588572],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",588569],"binderInfo":"implicit"},{"type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",588570],"binderInfo":"default"},{"type":"BddBelow E","name":["hbound"],"isProp":true,"id":["_uniq",588571],"binderInfo":"default"}]}],"start":12877},{"state":[],"start":12885},{"state":[],"start":12886},{"state":[],"start":12904},{"state":[],"start":12974},{"state":[],"start":13077},{"state":[],"start":13078},{"state":[],"start":13145},{"state":[],"start":13146},{"state":[{"type":"inf E = ⊥","tag":[],"mvarId":["_uniq",589258],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",589256],"binderInfo":"implicit"},{"type":"¬BddBelow E","name":["hb"],"isProp":true,"id":["_uniq",589257],"binderInfo":"default"}]}],"start":13238},{"state":[{"type":"inf E = ⊥","tag":[],"mvarId":["_uniq",589267],"isProp":true,"context":[{"type":"Set Real","name":["E"],"isProp":false,"id":["_uniq",589256],"binderInfo":"implicit"},{"type":"¬BddBelow E","name":["hb"],"isProp":true,"id":["_uniq",589257],"binderInfo":"default"},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq E) (Mathlib.Tactic.PushNeg.not_not_eq (BddBelow E))))\n    fun hb => of_eq_true (Eq.trans (congrArg BddBelow hb) bddBelow_empty._simp_1))\n  hb","type":"E.Nonempty","name":["hE"],"isProp":true,"id":["_uniq",589266]}]}],"start":13293},{"state":[],"start":13314},{"state":[],"start":13315},{"state":[],"start":13403},{"state":[],"start":13494},{"state":[],"start":13495},{"state":[],"start":13590},{"state":[],"start":13648},{"state":[],"start":13649},{"state":[],"start":13671},{"state":[],"start":13724},{"state":[],"start":13794},{"state":[],"start":13795},{"state":[],"start":13881},{"state":[],"start":13941},{"state":[],"start":13981},{"state":[],"start":13982},{"state":[],"start":14075},{"state":[],"start":14139},{"state":[],"start":14180},{"state":[],"start":14231},{"state":[],"start":14290},{"state":[],"start":14291},{"state":[],"start":14380},{"state":[],"start":14427},{"state":[],"start":14428},{"state":[],"start":14441},{"state":[],"start":14441}]
