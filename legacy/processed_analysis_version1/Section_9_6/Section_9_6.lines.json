[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":52},{"state":[],"start":80},{"state":[],"start":108},{"state":[],"start":109},{"state":[],"start":113},{"state":[],"start":162},{"state":[],"start":163},{"state":[],"start":259},{"state":[],"start":348},{"state":[],"start":440},{"state":[],"start":537},{"state":[],"start":547},{"state":[],"start":548},{"state":[],"start":596},{"state":[],"start":664},{"state":[],"start":753},{"state":[],"start":756},{"state":[],"start":757},{"state":[],"start":776},{"state":[],"start":777},{"state":[],"start":801},{"state":[],"start":887},{"state":[],"start":888},{"state":[],"start":975},{"state":[],"start":976},{"state":[],"start":1059},{"state":[],"start":1060},{"state":[],"start":1080},{"state":[{"type":"BddOn f X ↔ BddAboveOn f X ∧ BddBelowOn f X","tag":[],"mvarId":["_uniq",407],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",405],"binderInfo":"default"},{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",406],"binderInfo":"default"}]}],"start":1182},{"state":[],"start":1190},{"state":[],"start":1191},{"state":[{"type":"BddOn f X ↔ Bornology.IsBounded (f '' X)","tag":[],"mvarId":["_uniq",452],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",450],"binderInfo":"default"},{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",451],"binderInfo":"default"}]}],"start":1290},{"state":[],"start":1298},{"state":[],"start":1299},{"state":[],"start":1416},{"state":[],"start":1417},{"state":[],"start":1468},{"state":[],"start":1469},{"state":[],"start":1525},{"state":[],"start":1526},{"state":[],"start":1583},{"state":[],"start":1584},{"state":[],"start":1650},{"state":[],"start":1651},{"state":[],"start":1713},{"state":[],"start":1714},{"state":[],"start":1800},{"state":[],"start":1801},{"state":[],"start":1820},{"state":[],"start":1930},{"state":[{"type":"BddOn f (Set.Icc a b)","tag":[],"mvarId":["_uniq",1912],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",1911],"binderInfo":"default"}]}],"start":1957},{"state":[{"type":"BddOn f (Set.Icc a b)","tag":[],"mvarId":["_uniq",1912],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",1911],"binderInfo":"default"}]}],"start":2030},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",18411],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",1911],"binderInfo":"default"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"}]}],"start":2078},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",18464],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",1911],"binderInfo":"default"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]}]}],"start":2125},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",19613],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",1911],"binderInfo":"default"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]}]}],"start":2215},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",19700],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"ContinuousOn f X","name":["hf"],"isProp":true,"id":["_uniq",19697],"binderInfo":"default"}]}],"start":2238},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",70194],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"ContinuousOn f X","name":["hf"],"isProp":true,"id":["_uniq",19697],"binderInfo":"default"},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"}]}],"start":2270},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",70599],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"ContinuousOn f X","name":["hf"],"isProp":true,"id":["_uniq",19697],"binderInfo":"default"},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"}]}],"start":2314},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",70686],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"ContinuousOn f X","name":["hf"],"isProp":true,"id":["_uniq",19697],"binderInfo":"default"},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]}]}],"start":2383},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76105],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"ContinuousOn f X","name":["hf"],"isProp":true,"id":["_uniq",19697],"binderInfo":"default"},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"}]}],"start":2485},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76302],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"ContinuousOn f X","name":["hf"],"isProp":true,"id":["_uniq",19697],"binderInfo":"default"},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]}]}],"start":2534},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76384],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"value":"ContinuousOn.continuousWithinAt _fvar.19697 hLX","type":"ContinuousWithinAt f X L","name":["hf"],"isProp":true,"id":["_uniq",76380]}]}],"start":2576},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76414],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"type":"Convergesto X f (f L) L","name":["hf"],"isProp":true,"id":["_uniq",76409],"binderInfo":"default"}]}],"start":2612},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76468],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"value":"Convergesto.comp (AdherentPt.of_mem hLX) _fvar.76409 (fun j => haX (n j)) hconv","type":"Filter.Tendsto (fun n_1 => f (x (n n_1))) Filter.atTop (nhds (f L))","name":["hf"],"isProp":true,"id":["_uniq",76464]}]}],"start":2688},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76501],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"type":"Bornology.IsBounded (Set.range fun n_1 => f (x (n n_1)))","name":["hf"],"isProp":true,"id":["_uniq",76498],"binderInfo":"default"}]}],"start":2736},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76540],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",76526],"binderInfo":"default"},{"type":"M > 0","name":["hpos"],"isProp":true,"id":["_uniq",76535],"binderInfo":"default"},{"type":"(Set.range fun n_1 => f (x (n n_1))) ⊆ Set.Icc (-M) M","name":["hM"],"isProp":true,"id":["_uniq",76539],"binderInfo":"default"}]}],"start":2790},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76602],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"fun n => Exists.choose_spec (hunbound (↑n : ℝ))","type":"∀ (n : ℕ), a ≤ x n ∧ x n ≤ b ∧ (↑n : ℝ) < |f (x n)|","name":["hx"],"isProp":true,"id":["_uniq",19612]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"value":"fun n => Eq.mpr (id Set.mem_Icc._simp_1) (of_continuous_on_compact._proof_2 hunbound n (hx n))","type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",76526],"binderInfo":"default"},{"type":"M > 0","name":["hpos"],"isProp":true,"id":["_uniq",76535],"binderInfo":"default"},{"type":"(Set.range fun n_1 => f (x (n n_1))) ⊆ Set.Icc (-M) M","name":["hM"],"isProp":true,"id":["_uniq",76539],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",76598],"binderInfo":"default"},{"type":"M < (↑j : ℝ)","name":["hj"],"isProp":true,"id":["_uniq",76601],"binderInfo":"default"}]}],"start":2826},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",76616],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",76526],"binderInfo":"default"},{"type":"M > 0","name":["hpos"],"isProp":true,"id":["_uniq",76535],"binderInfo":"default"},{"type":"(Set.range fun n_1 => f (x (n n_1))) ⊆ Set.Icc (-M) M","name":["hM"],"isProp":true,"id":["_uniq",76539],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",76598],"binderInfo":"default"},{"type":"M < (↑j : ℝ)","name":["hj"],"isProp":true,"id":["_uniq",76601],"binderInfo":"default"},{"type":"(↑(n j) : ℝ) < |f (x (n j))|","name":["hx"],"isProp":true,"id":["_uniq",76612]}]}],"start":2857},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",79947],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",76526],"binderInfo":"default"},{"type":"M > 0","name":["hpos"],"isProp":true,"id":["_uniq",76535],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",76598],"binderInfo":"default"},{"type":"M < (↑j : ℝ)","name":["hj"],"isProp":true,"id":["_uniq",76601],"binderInfo":"default"},{"type":"(↑(n j) : ℝ) < |f (x (n j))|","name":["hx"],"isProp":true,"id":["_uniq",76612]},{"value":"of_continuous_on_compact._proof_4 hunbound n M _fvar.76539 j","type":"f (x (n j)) ∈ Set.Icc (-M) M","name":["hM"],"isProp":true,"id":["_uniq",76765]}]}],"start":2915},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",83414],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",76526],"binderInfo":"default"},{"type":"M > 0","name":["hpos"],"isProp":true,"id":["_uniq",76535],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",76598],"binderInfo":"default"},{"type":"M < (↑j : ℝ)","name":["hj"],"isProp":true,"id":["_uniq",76601],"binderInfo":"default"},{"type":"(↑(n j) : ℝ) < |f (x (n j))|","name":["hx"],"isProp":true,"id":["_uniq",76612]},{"type":"|f (x (n j))| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",83411],"binderInfo":"default"}]}],"start":2940},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",84466],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",1907],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",1908],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",1909],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",1910],"binderInfo":"implicit"},{"type":"∀ (x : ℝ), ∃ x_1, a ≤ x_1 ∧ x_1 ≤ b ∧ x < |f x_1|","name":["hunbound"],"isProp":true,"id":["_uniq",18408],"binderInfo":"default"},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",18463]},{"value":"Set.Icc a b","type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",19623]},{"type":"IsClosed (Set.Icc a b)","name":["hXclosed"],"isProp":true,"id":["_uniq",70193],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hXbounded"],"isProp":true,"id":["_uniq",70598],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",70684]},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",76090],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",76091],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",76092],"binderInfo":"default"},{"type":"L ∈ X","name":["hLX"],"isProp":true,"id":["_uniq",76093],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)","name":["hconv"],"isProp":true,"id":["_uniq",76094],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["why"],"isProp":true,"id":["_uniq",76300]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",76526],"binderInfo":"default"},{"type":"M > 0","name":["hpos"],"isProp":true,"id":["_uniq",76535],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",76598],"binderInfo":"default"},{"type":"M < (↑j : ℝ)","name":["hj"],"isProp":true,"id":["_uniq",76601],"binderInfo":"default"},{"type":"(↑(n j) : ℝ) < |f (x (n j))|","name":["hx"],"isProp":true,"id":["_uniq",76612]},{"type":"|f (x (n j))| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",83411],"binderInfo":"default"},{"value":"of_eq_true (Eq.trans ge_iff_le._simp_1 (Eq.trans Nat.cast_le._simp_1 (eq_true (why j))))","type":"(↑(n j) : ℝ) ≥ (↑j : ℝ)","name":["this"],"isProp":true,"id":["_uniq",84465]}]}],"start":2984},{"state":[],"start":2995},{"state":[],"start":2996},{"state":[],"start":3053},{"state":[],"start":3072},{"state":[],"start":3091},{"state":[],"start":3092},{"state":[],"start":3112},{"state":[],"start":3228},{"state":[],"start":3229},{"state":[],"start":3345},{"state":[],"start":3346},{"state":[],"start":3391},{"state":[],"start":3502},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",87578],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"}]}],"start":3562},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",87578],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"}]}],"start":3635},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",87605],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"}]}],"start":3691},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",87677],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]}]}],"start":3718},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",87862],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]}]}],"start":3809},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",91591],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]}]}],"start":3893},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",95139],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]}]}],"start":3911},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",95535],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]}]}],"start":4004},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, IsMaxOn f (Set.Icc a b) xmax","tag":[],"mvarId":["_uniq",95624],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h✝"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h✝)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","name":["h"],"isProp":true,"id":["_uniq",95623],"binderInfo":"default"}]},{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",95621],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]}]}],"start":4065},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",95621],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]}]}],"start":4075},{"state":[{"type":"∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","tag":[],"mvarId":["_uniq",96019],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",95628],"binderInfo":"default"}]}],"start":4150},{"state":[{"type":"∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","tag":[],"mvarId":["_uniq",96229],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",95628],"binderInfo":"default"},{"value":"div_pos (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"1 / ((↑n : ℝ) + 1) > 0","name":["this"],"isProp":true,"id":["_uniq",96228]}]}],"start":4194},{"state":[{"type":"∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","tag":[],"mvarId":["_uniq",102380],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",95628],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                      (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          Nat.rawCast 1 +\n                        0)))\n                  (Mathlib.Tactic.Ring.zero_mul\n                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                        Nat.rawCast 1 +\n                      0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                        Nat.rawCast 1 +\n                      0))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                    (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                      (Int.negOfNat 1).rawCast +\n                    0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf m)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"m - 1 / ((↑n : ℝ) + 1) < sSup E","name":["this"],"isProp":true,"id":["_uniq",101163]}]}],"start":4248},{"state":[{"type":"∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","tag":[],"mvarId":["_uniq",102415],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",102404],"binderInfo":"default"},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",102407]},{"type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",102408],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",102409],"binderInfo":"default"},{"type":"m - 1 / ((↑n : ℝ) + 1) < sSup E","name":["this"],"isProp":true,"id":["_uniq",102410],"binderInfo":"default"}]}],"start":4294},{"state":[{"type":"∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","tag":[],"mvarId":["_uniq",102450],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"type":"E.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",102404],"binderInfo":"default"},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",102407]},{"type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",102408],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",102409],"binderInfo":"default"},{"type":"∃ a ∈ E, m - 1 / ((↑n : ℝ) + 1) < a","name":["this"],"isProp":true,"id":["_uniq",102447],"binderInfo":"default"}]}],"start":4339},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",96022],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]}]}],"start":4349},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",105368],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]}]}],"start":4402},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",105687],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]}]}],"start":4470},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",106021],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]}]}],"start":4545},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",106536],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"}]}],"start":4585},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",107145],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"}]}],"start":4637},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, f xmax = m","tag":["h"],"mvarId":["_uniq",107317],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"}]}],"start":4744},{"state":[{"type":"f xmax = m","tag":["right"],"mvarId":["_uniq",107510],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"}]}],"start":4761},{"state":[{"type":"f xmax = m","tag":["right"],"mvarId":["_uniq",107567],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]}]}],"start":4815},{"state":[{"type":"f xmax = m","tag":["right"],"mvarId":["_uniq",107818],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]}]}],"start":4895},{"state":[{"type":"f xmax = m","tag":["right"],"mvarId":["_uniq",107818],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]}]}],"start":4979},{"state":[{"type":"m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","tag":[],"mvarId":["_uniq",108135],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",107822],"binderInfo":"default"}]}],"start":5039},{"state":[{"type":"f xmax = m","tag":["right"],"mvarId":["_uniq",108139],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]}]}],"start":5093},{"state":[{"type":"f xmax = m","tag":["right"],"mvarId":["_uniq",134076],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]}],"start":5202},{"state":[{"type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds m)","tag":[],"mvarId":["_uniq",138037],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]}],"start":5278},{"state":[{"type":"Filter.Tendsto (fun j => m - 1 / ((↑j : ℝ) + 1)) Filter.atTop (nhds m)","tag":["hg"],"mvarId":["_uniq",138386],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]},{"type":"Filter.Tendsto (fun x => m) Filter.atTop (nhds m)","tag":["hh"],"mvarId":["_uniq",138387],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]},{"type":"(fun j => m - 1 / ((↑j : ℝ) + 1)) ≤ fun j => f (x (n j))","tag":["hgf"],"mvarId":["_uniq",138388],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]},{"type":"(fun j => f (x (n j))) ≤ fun x => m","tag":["hfh"],"mvarId":["_uniq",138389],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]}],"start":5392},{"state":[{"type":"Filter.Tendsto (fun x => m) Filter.atTop (nhds m)","tag":["hh"],"mvarId":["_uniq",138387],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]},{"type":"(fun j => m - 1 / ((↑j : ℝ) + 1)) ≤ fun j => f (x (n j))","tag":["hgf"],"mvarId":["_uniq",138388],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]},{"type":"(fun j => f (x (n j))) ≤ fun x => m","tag":["hfh"],"mvarId":["_uniq",138389],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]}],"start":5471},{"state":[{"type":"(fun j => m - 1 / ((↑j : ℝ) + 1)) ≤ fun j => f (x (n j))","tag":["hgf"],"mvarId":["_uniq",138388],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]},{"type":"(fun j => f (x (n j))) ≤ fun x => m","tag":["hfh"],"mvarId":["_uniq",138389],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]}],"start":5502},{"state":[{"type":"(fun j => f (x (n j))) ≤ fun x => m","tag":["hfh"],"mvarId":["_uniq",138389],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]}]}],"start":5523},{"state":[{"type":"f xmax = m","tag":["right"],"mvarId":["_uniq",138039],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",87573],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",87574],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",87575],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",87576],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",87577],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",87599],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",87602],"binderInfo":"default"},{"value":"f '' Set.Icc a b","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",87676]},{"value":"fun ⦃a_1⦄ a_2 =>\n  Exists.casesOn a_2 fun x h =>\n    And.casesOn h fun hx right =>\n      right ▸\n        of_eq_true (Eq.trans Set.mem_Icc._simp_1 (Eq.trans BddOn.of_continuous_on_compact._simp_4 (eq_true (hM x hx))))","type":"E ⊆ Set.Icc (-M) M","name":["hE"],"isProp":true,"id":["_uniq",87861]},{"value":"Eq.mpr (id (congrArg Not Set.image_eq_empty._simp_1))\n  (Mathlib.Tactic.Contrapose.mtr\n    (Eq.mpr\n      (id (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (Set.Icc a b = ∅)) (Mathlib.Tactic.PushNeg.not_lt_eq a b)))\n      fun h => of_continuous_on_compact._proof_1 M h)\n    h)","type":"E ≠ ∅","name":["hnon"],"isProp":true,"id":["_uniq",91590]},{"value":"sSup E","type":"ℝ","name":["m"],"isProp":false,"id":["_uniq",95138]},{"value":"fun {y} hy => le_csSup (BddAbove.mono hE bddAbove_Icc) hy","type":"∀ {y : ℝ}, y ∈ E → y ≤ m","name":["claim1"],"isProp":true,"id":["_uniq",95532]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf m)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ Set.Icc a b, m - 1 / ((↑n : ℝ) + 1) < f x","name":["claim2"],"isProp":true,"id":["_uniq",96021]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",105367]},{"value":"fun n => (Exists.choose_spec (claim2 n)).left","type":"∀ (n : ℕ), x n ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",105685]},{"value":"fun n => (Exists.choose_spec (claim2 n)).right","type":"∀ (n : ℕ), m - 1 / ((↑n : ℝ) + 1) < f (x n)","name":["hfx"],"isProp":true,"id":["_uniq",106019]},{"type":"IsClosed (Set.Icc a b)","name":["hclosed"],"isProp":true,"id":["_uniq",106535],"binderInfo":"default"},{"type":"Bornology.IsBounded (Set.Icc a b)","name":["hbounded"],"isProp":true,"id":["_uniq",107144],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["n"],"isProp":false,"id":["_uniq",107302],"binderInfo":"default"},{"type":"StrictMono n","name":["hn"],"isProp":true,"id":["_uniq",107303],"binderInfo":"default"},{"type":"ℝ","name":["xmax"],"isProp":false,"id":["_uniq",107304],"binderInfo":"default"},{"type":"xmax ∈ Set.Icc a b","name":["hmax"],"isProp":true,"id":["_uniq",107305],"binderInfo":"default"},{"type":"Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)","name":["hconv"],"isProp":true,"id":["_uniq",107306],"binderInfo":"default"},{"value":"fun j => why_7_6_3 hn j","type":"∀ (j : ℕ), n j ≥ j","name":["hn_lower"],"isProp":true,"id":["_uniq",107565]},{"value":"Filter.Tendsto.comp_of_continuous hmax (ContinuousOn.continuousWithinAt hf hmax) (fun j => hx (n j)) hconv","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds (f xmax))","name":["hconv'"],"isProp":true,"id":["_uniq",107817]},{"value":"fun j =>\n  lt_of_le_of_lt\n    (sub_le_sub_left\n      (div_le_div₀\n        (le_of_lt\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (le_refl 1)\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))))\n        (add_le_add_right\n          (GCongr.natCast_le_natCast\n            (of_continuous_on_compact._proof_5 claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' j))\n          1))\n      m)\n    (hfx (n j))","type":"∀ (j : ℕ), m - 1 / ((↑j : ℝ) + 1) < f (x (n j))","name":["hlower"],"isProp":true,"id":["_uniq",108137]},{"value":"fun j =>\n  claim1\n    (Eq.mpr\n      (id\n        (Eq.trans (Set.mem_image._simp_1 f (Set.Icc a b) (f (x (n j))))\n          (congrArg Exists (funext fun x_1 => congrArg (fun x_2 => x_2 ∧ f x_1 = f (x (n j))) Set.mem_Icc._simp_1))))\n      (Exists.intro (x (n j)) ⟨hx (n j), Eq.refl (f (x (n j)))⟩))","type":"∀ (j : ℕ), f (x (n j)) ≤ m","name":["hupper"],"isProp":true,"id":["_uniq",134074]},{"value":"Filter.Tendsto.squeeze\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α β f l₁ l₂ l₂' e'_5 =>\n          Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n            (fun h =>\n              Eq.ndrec (motive := fun l₂' =>\n                ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n            (Eq.refl l₂') (HEq.refl e'_5))\n        ℕ ℝ (fun j => m - 1 / ((↑j : ℝ) + 1)) Filter.atTop (nhds m) (nhds (m - 0))\n        (eq_of_heq\n          ((fun X inst x x' e'_3 =>\n              Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                    (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n                (Eq.refl x') (HEq.refl e'_3))\n            ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace m (m - 0)\n            (of_eq_true (Eq.trans (congrArg (Eq m) (sub_zero m)) (eq_self m)))))))\n    (Filter.Tendsto.const_sub m tendsto_one_div_add_atTop_nhds_zero_nat))\n  tendsto_const_nhds\n  (fun i =>\n    of_continuous_on_compact._proof_6 M claim2 hx hfx hclosed hbounded n hn xmax hmax hconv hn_lower hconv' hlower\n      hupper i)\n  hupper","type":"Filter.Tendsto (fun j => f (x (n j))) Filter.atTop (nhds m)","name":["hconvm"],"isProp":true,"id":["_uniq",138038]}]}],"start":5540},{"state":[],"start":5582},{"state":[],"start":5583},{"state":[],"start":5584},{"state":[],"start":5585},{"state":[],"start":5586},{"state":[],"start":5587},{"state":[],"start":5588},{"state":[],"start":5699},{"state":[{"type":"∃ xmin ∈ Set.Icc a b, IsMinOn f (Set.Icc a b) xmin","tag":[],"mvarId":["_uniq",146970],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",146965],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",146966],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",146967],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",146968],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",146969],"binderInfo":"default"}]}],"start":5759},{"state":[],"start":5767},{"state":[],"start":5768},{"state":[],"start":5830},{"state":[],"start":5831},{"state":[],"start":5896},{"state":[],"start":5897},{"state":[],"start":6004},{"state":[{"type":"sSup (f '' X) = f x₀","tag":[],"mvarId":["_uniq",151326],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",151321],"binderInfo":"implicit"},{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",151322],"binderInfo":"implicit"},{"type":"ℝ","name":["x₀"],"isProp":false,"id":["_uniq",151323],"binderInfo":"implicit"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",151324],"binderInfo":"default"},{"type":"IsMaxOn f X x₀","name":["h"],"isProp":true,"id":["_uniq",151325],"binderInfo":"default"}]}],"start":6035},{"state":[{"type":"IsGreatest (f '' X) (f x₀)","tag":["H"],"mvarId":["_uniq",151337],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",151321],"binderInfo":"implicit"},{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",151322],"binderInfo":"implicit"},{"type":"ℝ","name":["x₀"],"isProp":false,"id":["_uniq",151323],"binderInfo":"implicit"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",151324],"binderInfo":"default"},{"type":"IsMaxOn f X x₀","name":["h"],"isProp":true,"id":["_uniq",151325],"binderInfo":"default"}]}],"start":6063},{"state":[{"type":"(∃ x ∈ X, f x = f x₀) ∧ ∀ a ∈ X, f a ≤ f x₀","tag":["H"],"mvarId":["_uniq",156045],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",151321],"binderInfo":"implicit"},{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",151322],"binderInfo":"implicit"},{"type":"ℝ","name":["x₀"],"isProp":false,"id":["_uniq",151323],"binderInfo":"implicit"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",151324],"binderInfo":"default"},{"type":"IsMaxOn f X x₀","name":["h"],"isProp":true,"id":["_uniq",151325],"binderInfo":"default"}]}],"start":6100},{"state":[],"start":6144},{"state":[],"start":6145},{"state":[],"start":6252},{"state":[{"type":"sInf (f '' X) = f x₀","tag":[],"mvarId":["_uniq",156258],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",156253],"binderInfo":"implicit"},{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",156254],"binderInfo":"implicit"},{"type":"ℝ","name":["x₀"],"isProp":false,"id":["_uniq",156255],"binderInfo":"implicit"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",156256],"binderInfo":"default"},{"type":"IsMinOn f X x₀","name":["h"],"isProp":true,"id":["_uniq",156257],"binderInfo":"default"}]}],"start":6283},{"state":[{"type":"IsLeast (f '' X) (f x₀)","tag":["H"],"mvarId":["_uniq",156269],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",156253],"binderInfo":"implicit"},{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",156254],"binderInfo":"implicit"},{"type":"ℝ","name":["x₀"],"isProp":false,"id":["_uniq",156255],"binderInfo":"implicit"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",156256],"binderInfo":"default"},{"type":"IsMinOn f X x₀","name":["h"],"isProp":true,"id":["_uniq",156257],"binderInfo":"default"}]}],"start":6308},{"state":[{"type":"(∃ x ∈ X, f x = f x₀) ∧ ∀ a ∈ X, f x₀ ≤ f a","tag":["H"],"mvarId":["_uniq",160976],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",156253],"binderInfo":"implicit"},{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",156254],"binderInfo":"implicit"},{"type":"ℝ","name":["x₀"],"isProp":false,"id":["_uniq",156255],"binderInfo":"implicit"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",156256],"binderInfo":"default"},{"type":"IsMinOn f X x₀","name":["h"],"isProp":true,"id":["_uniq",156257],"binderInfo":"default"}]}],"start":6342},{"state":[],"start":6386},{"state":[],"start":6387},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, sSup (f '' Set.Icc a b) = f xmax","tag":[],"mvarId":["_uniq",161425],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",161420],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",161421],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",161422],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",161423],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",161424],"binderInfo":"default"}]}],"start":6557},{"state":[{"type":"∃ xmax ∈ Set.Icc a b, sSup (f '' Set.Icc a b) = f xmax","tag":[],"mvarId":["_uniq",161459],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",161420],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",161421],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",161422],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",161423],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",161424],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",161446],"binderInfo":"default"},{"type":"x ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",161454],"binderInfo":"default"},{"type":"IsMaxOn f (Set.Icc a b) x","name":["h'"],"isProp":true,"id":["_uniq",161458],"binderInfo":"default"}]}],"start":6618},{"state":[],"start":6644},{"state":[],"start":6645},{"state":[{"type":"∃ xmin ∈ Set.Icc a b, sInf (f '' Set.Icc a b) = f xmin","tag":[],"mvarId":["_uniq",164134],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",164129],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",164130],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",164131],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",164132],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",164133],"binderInfo":"default"}]}],"start":6815},{"state":[{"type":"∃ xmin ∈ Set.Icc a b, sInf (f '' Set.Icc a b) = f xmin","tag":[],"mvarId":["_uniq",164168],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",164129],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",164130],"binderInfo":"implicit"},{"type":"a < b","name":["h"],"isProp":true,"id":["_uniq",164131],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",164132],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",164133],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",164155],"binderInfo":"default"},{"type":"x ∈ Set.Icc a b","name":["hx"],"isProp":true,"id":["_uniq",164163],"binderInfo":"default"},{"type":"IsMinOn f (Set.Icc a b) x","name":["h'"],"isProp":true,"id":["_uniq",164167],"binderInfo":"default"}]}],"start":6876},{"state":[],"start":6902},{"state":[],"start":6903},{"state":[],"start":6925},{"state":[],"start":7008},{"state":[],"start":7066},{"state":[],"start":7123},{"state":[],"start":7137},{"state":[],"start":7138},{"state":[],"start":7160},{"state":[],"start":7243},{"state":[],"start":7301},{"state":[],"start":7358},{"state":[],"start":7372},{"state":[],"start":7373},{"state":[],"start":7395},{"state":[],"start":7451},{"state":[],"start":7518},{"state":[],"start":7581},{"state":[],"start":7595},{"state":[],"start":7596},{"state":[],"start":7618},{"state":[],"start":7724},{"state":[],"start":7725},{"state":[],"start":7726},{"state":[],"start":7739},{"state":[],"start":7739}]
