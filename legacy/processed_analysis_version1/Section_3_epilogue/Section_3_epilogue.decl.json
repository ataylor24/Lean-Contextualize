[{"value":{"range":[857,990],"original":true},"type":{"range":[827,856],"original":true},"signature":{"range":[813,856],"pp":" (m n : ℕ) : n < m → ofNat n ∈ ofNat m","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PSet"]],"openDecl":[],"omitVars":[],"levelNames":[["u"]],"includeVars":[],"currNamespace":["PSet"]},"ref":{"range":[690,990],"pp":"/-- A preliminary lemma about `PSet`: their natural numbers are ordered by membership. -/\ntheorem ofNat_mem_ofNat_of_lt (m n : ℕ) : n < m → ofNat n ∈ ofNat m :=\n  by\n  intro h\n  induction h with\n  | refl => rw [ofNat]; apply mem_insert\n  | step _ ih => rw [ofNat]; exact mem_insert_of_mem _ ih","original":true},"params":[{"type":[820,823],"ref":[814,815],"id":[814,815],"bi":"default"},{"type":[820,823],"ref":[816,817],"id":[816,817],"bi":"default"}],"name":["PSet","ofNat_mem_ofNat_of_lt"],"modifiers":null,"kind":"theorem","id":{"range":[786,812],"original":true}},{"value":{"range":[1061,1235],"original":true},"type":{"range":[1031,1060],"original":true},"signature":{"range":[1017,1060],"pp":" (n m : ℕ) : ofNat n ∈ ofNat m ↔ n < m","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PSet"]],"openDecl":[],"omitVars":[],"levelNames":[["u"]],"includeVars":[],"currNamespace":["PSet"]},"ref":{"range":[992,1235],"pp":"theorem mem_ofNat_iff (n m : ℕ) : ofNat n ∈ ofNat m ↔ n < m :=\n  by\n  refine ⟨?_, ofNat_mem_ofNat_of_lt m n⟩\n  contrapose!; rw [le_iff_lt_or_eq]; rintro (h | rfl)\n  · exact mem_asymm (ofNat_mem_ofNat_of_lt _ _ h)\n  apply mem_irrefl","original":false},"params":[{"type":[1024,1027],"ref":[1018,1019],"id":[1018,1019],"bi":"default"},{"type":[1024,1027],"ref":[1020,1021],"id":[1020,1021],"bi":"default"}],"name":["PSet","mem_ofNat_iff"],"modifiers":null,"kind":"theorem","id":{"range":[998,1016],"original":true}},{"value":{"range":[1431,1662],"original":true},"type":{"range":[1387,1430],"original":true},"signature":{"range":[1374,1430],"pp":" (n m : ℕ) : (ofNat.{u} n).Equiv (ofNat.{u} m) → n = m","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PSet"]],"openDecl":[],"omitVars":[],"levelNames":[["u"]],"includeVars":[],"currNamespace":["PSet"]},"ref":{"range":[1237,1662],"pp":"/-- Another preliminary lemma: Natural numbers in `PSet` can only be equivalent\nif they are equal. -/\ntheorem eq_of_ofNat_equiv_ofNat (n m : ℕ) : (ofNat.{u} n).Equiv (ofNat.{u} m) → n = m :=\n  by\n  wlog hmn : m ≤ n generalizing n m\n  · intro heq; rw [this _ _ _ heq.symm]; order\n  intro h; rw [Equiv.eq, Set.ext_iff] at h\n  have : n ≤ m := by specialize h (ofNat m); simpa [mem_irrefl, mem_ofNat_iff] using h\n  order","original":true},"params":[{"type":[1381,1384],"ref":[1375,1376],"id":[1375,1376],"bi":"default"},{"type":[1381,1384],"ref":[1377,1378],"id":[1377,1378],"bi":"default"}],"name":["PSet","eq_of_ofNat_equiv_ofNat"],"modifiers":null,"kind":"theorem","id":{"range":[1345,1373],"original":true}},{"value":{"range":[1835,2182],"original":true},"type":{"range":[1817,1834],"original":true},"signature":{"range":[1815,1834],"pp":" : ℕ ≃ omega.{u}","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["ZFSet"],["PSet"]],"openDecl":[{"simple":{"namespace":["PSet"],"except":[]}}],"omitVars":[],"levelNames":[["u"]],"includeVars":[],"currNamespace":["ZFSet"]},"ref":{"range":[1677,2182],"pp":"/-- Using the above lemmas, we can create a bijection between `ZFSet.omega` and\nthe natural numbers. -/\nnoncomputable def nat_equiv : ℕ ≃ omega.{u} :=\n  Equiv.ofBijective (fun n => ⟨mk (ofNat.{u} n), mk_mem_iff.mpr (Mem.mk _ (ULift.up n))⟩)\n    (by\n      constructor\n      · intro _ _; simp [eq]; apply eq_of_ofNat_equiv_ofNat\n      · intro ⟨x, hx⟩; rw [← mk_out x, omega, mk_mem_iff] at hx; obtain ⟨n, hn⟩ := hx\n        simp [mk_func, PSet.omega] at *; use n.down; rw [← mk_out x, eq]; exact hn.symm)","original":true},"params":[],"name":["ZFSet","nat_equiv"],"modifiers":null,"kind":"definition","id":{"range":[1799,1814],"original":true}},{"value":{"range":[2603,4661],"original":true},"type":{"range":[2570,2602],"original":true},"signature":{"range":[2568,2602],"pp":" : Chapter3.SetTheory.{u + 1, u + 1}","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["ZFSet"],["Classical"]],"openDecl":[{"simple":{"namespace":["Classical"],"except":[]}}],"omitVars":[],"levelNames":[["u"]],"includeVars":[],"currNamespace":["ZFSet"]},"ref":{"range":[2202,4661],"pp":"/-- Show that ZFSet obeys the `Chapter3.SetTheory` axioms.  Most of these axioms were\nessentially already established in Mathlib and are relatively routine to transfer over;\nthe equivalence of `ZF.omega` and `Nat` being the trickiest one in content (and the\npower set axiom also requiring some technical manipulation). -/\nnoncomputable instance inst_SetTheory : Chapter3.SetTheory.{u + 1, u + 1}\n    where\n  Set := ZFSet\n  Object := ZFSet\n  set_to_object := { toFun ⦃a₁⦄ := a₁, inj' _ _ h := h }\n  mem o s := o ∈ s\n  extensionality _ _ := ext\n  emptyset := ∅\n  emptyset_mem := notMem_empty\n  singleton x := { x }\n  singleton_axiom _ _ := mem_singleton\n  union_pair x y := x ∪ y\n  union_pair_axiom _ _ _ := mem_union\n  specify A P := ZFSet.sep (fun s ↦ (h : s ∈ A) → P ⟨s, h⟩) A\n  specification_axiom := by simp +contextual\n  replace A P\n    hp :=\n    @(A.sep (fun s ↦ (hs : s ∈ A) → ∃ z, P ⟨s, hs⟩ z)).image\n      (fun s ↦ if h : ∃ (hs : s ∈ A), ∃ z, P ⟨s, hs⟩ z then h.choose_spec.choose else ∅) (allZFSetDefinable _)\n  replacement_axiom A P hp\n    s := by\n    simp; constructor\n    · intro ⟨z, ⟨hzA, hz⟩, hz'⟩; use z, hzA; simp [hzA, hz hzA] at hz'\n      simp [← hz', Exists.choose_spec]\n    · intro ⟨z, hzA, hz'⟩; use z, ⟨hzA, by aesop⟩\n      apply hp ⟨_, hzA⟩; rw [dif_pos ⟨hzA, ⟨_, hz'⟩⟩]; use Exists.choose_spec _\n  nat := omega\n  nat_equiv := nat_equiv\n  regularity_axiom\n    A := by\n    simp; intro x hx; have ⟨y, hy, _⟩ := regularity A (by aesop)\n    use y, hy; intro z _ _; have : z ∈ A ∩ y := by simp; tauto\n    aesop\n  pow X Y := funs Y X\n  function_to_object X\n    Y :=\n    { toFun f := @map (fun s ↦ if h : s ∈ X then f ⟨s, h⟩ else ∅) (allZFSetDefinable _) X\n      inj' x _\n        h := by\n        ext ⟨s, hs⟩; simp_rw [ZFSet.ext_iff, mem_map] at h\n        specialize h (s.pair (x ⟨_, hs⟩)); aesop }\n  powerset_axiom X Y\n    F := by\n    simp [IsFunc]; constructor\n    · intro ⟨hsub, huniq⟩\n      use (fun x ↦ ⟨(huniq _ x.property).choose, (pair_mem_prod.mp (hsub (huniq _ x.property).choose_spec)).2⟩)\n      ext; simp; constructor\n      · rintro ⟨y, hy, rfl⟩; simp_all [(huniq _ hy).choose_spec]\n      · intro hf; specialize hsub hf; rw [mem_prod] at hsub; obtain ⟨y, hy, x, _, rfl⟩ := hsub\n        use y, hy; simp_all [← (huniq _ hy).choose_eq hf]\n    · rintro ⟨f, rfl⟩; simp; constructor <;> intro _ _ <;> aesop\n  union := sUnion\n  union_axiom _ _ := by simp [And.comm]","original":true},"params":[],"name":["ZFSet","inst_SetTheory"],"modifiers":null,"kind":"instance","id":{"range":[2547,2567],"original":true}}]
