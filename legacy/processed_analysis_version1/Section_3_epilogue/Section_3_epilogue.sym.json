[{"valueReferences":[["ZFSet"],["Eq","refl"],["ZFSet","omega"]],"typeReferences":[["ZFSet","mk"],["ZFSet"],["ZFSet","omega"],["Eq"],["PSet","omega"]],"type":"Eq ZFSet.omega (ZFSet.mk PSet.omega)","name":["ZFSet","omega","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat","casesOn"],["Nat","succ"],["Eq","refl"],["id"],["PSet","ofNat","match_1"],["Eq"],["Unit","unit"]],"typeReferences":[["Nat"],["Nat","succ"],["instOfNatNat"],["PSet","ofNat","match_1"],["Eq"],["OfNat","ofNat"],["Unit"]],"type":"∀ (motive : Nat → Sort u_1) (n : Nat) (h_1 : Unit → motive 0) (h_2 : (n : Nat) → motive n.succ),\n  Eq (PSet.ofNat.match_1 motive n.succ h_1 h_2) (h_2 n)","name":["_private","Analysis","Section_3_epilogue",0,"PSet","ofNat","match_1","eq_2"],"kind":"theorem","isProp":true},{"valueReferences":[["ULift","down"],["PSet"],["ZFSet","mk"],["ULift"],["ZFSet"],["Membership","mem"],["ULift","up"],["PSet","instMembership"],["Nat"],["PSet","Mem","mk"],["Iff","mpr"],["ZFSet","instMembership"],["PSet","ofNat"],["PSet","omega"],["ZFSet","mk_mem_iff"]],"typeReferences":[["Nat"],["ZFSet","mk"],["ZFSet"],["Membership","mem"],["PSet","ofNat"],["ZFSet","instMembership"],["PSet","omega"]],"type":"∀ (n : Nat), ZFSet.instMembership.mem (ZFSet.mk PSet.omega) (ZFSet.mk (PSet.ofNat n))","name":["ZFSet","nat_equiv","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Exists"],["Exists","choose_spec"],["instOfNatNat"],["ZFSet"],["Membership","mem"],["Fin","instOfNat"],["Fin"],["ZFSet","instMembership"],["Subtype","mk"],["ZFSet","Definable₁","_proof_1"],["OfNat","ofNat"]],"typeReferences":[["Subtype"],["Exists"],["ZFSet"],["Membership","mem"],["Fin","instOfNat"],["Fin"],["ZFSet","Definable₁","_proof_1"],["OfNat","ofNat"],["ZFSet","inst_SetTheory","_proof_4"],["Nat"],["instOfNatNat"],["ZFSet","instMembership"],["Subtype","mk"]],"type":"∀ (A : ZFSet) (P : (Subtype fun x => ZFSet.instMembership.mem A x) → ZFSet → Prop) (s : Fin 1 → ZFSet)\n  (h : Exists fun hs => Exists fun z => P ⟨s 0, hs⟩ z), Exists fun z => P ⟨s 0, ⋯⟩ z","name":["ZFSet","inst_SetTheory","_proof_5"],"kind":"theorem","isProp":true},{"valueReferences":[["HasSubset","Subset"],["ZFSet"],["Membership","mem"],["ExistsUnique"],["ZFSet","instMembership"],["ZFSet","hasSubset"],["ZFSet","prod"],["ZFSet","pair"],["And","casesOn"]],"typeReferences":[["And","intro"],["HasSubset","Subset"],["ZFSet"],["Membership","mem"],["And"],["ExistsUnique"],["ZFSet","instMembership"],["ZFSet","hasSubset"],["ZFSet","prod"],["ZFSet","pair"]],"type":"∀ (X Y F : ZFSet)\n  (motive :\n    And (ZFSet.hasSubset.Subset F (Y.prod X))\n        (∀ (z : ZFSet), ZFSet.instMembership.mem Y z → ExistsUnique fun w => ZFSet.instMembership.mem F (z.pair w)) →\n      Prop)\n  (h :\n    And (ZFSet.hasSubset.Subset F (Y.prod X))\n      (∀ (z : ZFSet), ZFSet.instMembership.mem Y z → ExistsUnique fun w => ZFSet.instMembership.mem F (z.pair w))),\n  (∀ (hsub : ZFSet.hasSubset.Subset F (Y.prod X))\n      (huniq :\n        ∀ (z : ZFSet), ZFSet.instMembership.mem Y z → ExistsUnique fun w => ZFSet.instMembership.mem F (z.pair w)),\n      motive ⋯) →\n    motive h","name":["ZFSet","inst_SetTheory","match_14"],"kind":"definition","isProp":true},{"valueReferences":[["Exists"],["Exists","choose_spec"],["ZFSet"],["Membership","mem"],["ZFSet","instMembership"],["Subtype","mk"]],"typeReferences":[["Exists"],["Subtype"],["ZFSet"],["ZFSet","inst_SetTheory","_proof_2"],["Membership","mem"],["ZFSet","instMembership"],["Subtype","mk"]],"type":"∀ (A : ZFSet) (P : (Subtype fun x => ZFSet.instMembership.mem A x) → ZFSet → Prop) (s : ZFSet)\n  (h : Exists fun hs => Exists fun z => P ⟨s, hs⟩ z), Exists fun z => P ⟨s, ⋯⟩ z","name":["ZFSet","inst_SetTheory","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["SetLike","instMembership"],["ZFSet","mk"],["ZFSet"],["Membership","mem"],["ZFSet","nat_equiv","_proof_1"],["ZFSet","instSetLike"],["Nat"],["Equiv","ofBijective"],["ZFSet","omega"],["PSet","ofNat"],["ZFSet","nat_equiv","_proof_2"],["Subtype","mk"]],"typeReferences":[["Nat"],["SetLike","instMembership"],["Subtype"],["ZFSet"],["Membership","mem"],["ZFSet","omega"],["ZFSet","instSetLike"],["Equiv"]],"type":"Equiv Nat (Subtype fun x => SetLike.instMembership.mem ZFSet.omega x)","name":["ZFSet","nat_equiv"],"kind":"definition","isProp":false},{"valueReferences":[["SetLike","instMembership"],["ZFSet"],["Membership","mem"],["ZFSet","omega"],["Subtype","casesOn"],["ZFSet","instSetLike"]],"typeReferences":[["SetLike","instMembership"],["Subtype"],["ZFSet"],["Membership","mem"],["ZFSet","omega"],["Subtype","mk"],["ZFSet","instSetLike"]],"type":"∀ (motive : (Subtype fun x => SetLike.instMembership.mem ZFSet.omega x) → Prop)\n  (h : Subtype fun x => SetLike.instMembership.mem ZFSet.omega x),\n  (∀ (x : ZFSet) (hx : SetLike.instMembership.mem ZFSet.omega x), motive ⟨x, hx⟩) → motive h","name":["ZFSet","nat_equiv","match_2"],"kind":"definition","isProp":true},{"valueReferences":[["PSet","instMembership"],["PSet"],["PSet","mem_irrefl"],["eq_false"],["Membership","mem"]],"typeReferences":[["PSet","instMembership"],["PSet"],["Membership","mem"],["False"],["Eq"]],"type":"∀ (x : PSet), Eq (PSet.instMembership.mem x x) False","name":["PSet","eq_of_ofNat_equiv_ofNat","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Nat","casesOn"],["instOfNatNat"],["Eq","refl"],["id"],["PSet","ofNat","match_1"],["Eq"],["Unit","unit"],["OfNat","ofNat"]],"typeReferences":[["Nat"],["Nat","succ"],["instOfNatNat"],["PSet","ofNat","match_1"],["Eq"],["Unit","unit"],["OfNat","ofNat"],["Unit"]],"type":"∀ (motive : Nat → Sort u_1) (h_1 : Unit → motive 0) (h_2 : (n : Nat) → motive n.succ),\n  Eq (PSet.ofNat.match_1 motive 0 h_1 h_2) (h_1 Unit.unit)","name":["_private","Analysis","Section_3_epilogue",0,"PSet","ofNat","match_1","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat","casesOn"]],"typeReferences":[["Nat"],["Nat","succ"],["instOfNatNat"],["OfNat","ofNat"]],"type":"(motive : Nat → Sort u_1) → (x : Nat) → motive 0 → ((n : Nat) → motive n.succ) → motive x","name":["_private","Analysis","Section_3_epilogue",0,"PSet","ofNat","match_1","splitter"],"kind":"definition","isProp":false},{"valueReferences":[["ExistsUnique","choose"],["Eq","refl"],["ExistsUnique"],["Eq","ndrec"],["Eq"],["Eq","rec"]],"typeReferences":[["ExistsUnique","choose"],["ExistsUnique"],["Eq","ndrec"],["Eq"]],"type":"∀ {α : Sort u_1} {p p_1 : α → Prop} (e_p : Eq p p_1) (h : ExistsUnique fun x => p x), Eq h.choose ⋯.choose","name":["ExistsUnique","choose","congr_simp"],"kind":"theorem","isProp":true},{"valueReferences":[["And"],["And","comm"],["propext"]],"typeReferences":[["And"],["Eq"]],"type":"∀ {a b : Prop}, Eq (And a b) (And b a)","name":["ZFSet","inst_SetTheory","_simp_19"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","substr"],["Subtype"],["Eq","trans"],["Membership","mem"],["eq_true"],["Subtype","val"],["ZFSet","instSetLike"],["congrArg"],["iff_self"],["congr"],["SetLike","coe_mem","_simp_1"],["forall_congr"],["Subtype","coe_eta"],["ZFSet","instMembership"],["forall_prop_domain_congr"],["SetLike","instMembership"],["True"],["ZFSet","sep"],["ZFSet","mem_sep","_simp_1"],["ZFSet"],["And"],["true_and"],["implies_true"],["and_self"],["forall_const","_simp_1"],["of_eq_true"],["instNonemptyOfInhabited"],["Iff"],["Subtype","mk"],["implies_congr_ctx"],["instInhabitedTrue"]],"typeReferences":[["Subtype"],["ZFSet","sep"],["Iff"],["ZFSet"],["Membership","mem"],["And"],["ZFSet","instMembership"],["Subtype","mk"],["Subtype","val"]],"type":"∀ (a : ZFSet) (a_1 : (Subtype fun x => ZFSet.instMembership.mem a x) → Prop),\n  And\n    (∀ (a_2 : ZFSet),\n      ZFSet.instMembership.mem (ZFSet.sep (fun s => ∀ (h : ZFSet.instMembership.mem a s), a_1 ⟨s, h⟩) a) a_2 →\n        ZFSet.instMembership.mem a a_2)\n    (∀ (a_2 : Subtype fun x => ZFSet.instMembership.mem a x),\n      Iff (ZFSet.instMembership.mem (ZFSet.sep (fun s => ∀ (h : ZFSet.instMembership.mem a s), a_1 ⟨s, h⟩) a) a_2.val)\n        (a_1 a_2))","name":["ZFSet","inst_SetTheory","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Eq","trans"],["Membership","mem"],["Iff","mp"],["Classical","allZFSetDefinable"],["Classical","propDecidable"],["existsUnique_eq'","_simp_1"],["Exists","intro"],["Fin"],["ZFSet","funs"],["eq_true"],["ZFSet","mem_prod"],["ZFSet","prod"],["Subtype","val"],["ZFSet","instSetLike"],["true_iff"],["And","intro"],["iff_self"],["SetLike","coe_mem","_simp_1"],["forall_congr"],["funext"],["Eq","symm"],["_private","Mathlib","Tactic","Simproc","ExistsAndEq",0,"existsAndEq","exists_of_imp_eq"],["ZFSet","instMembership"],["Eq","ndrec"],["Function","instFunLikeEmbedding"],["And","left"],["Exists"],["SetLike","instMembership"],["ZFSet"],["ZFSet","mem_funs","_simp_1"],["Function","Embedding"],["And","right"],["And"],["Subtype","ext"],["true_and"],["exists_eq_right'","_simp_1"],["Exists","casesOn"],["Nat"],["HasSubset","Subset"],["Eq","refl"],["Iff"],["id"],["ExistsUnique","choose_spec"],["Eq","mpr"],["ZFSet","mem_map","_simp_1"],["ZFSet","pair_inj","_simp_1"],["Subtype"],["Eq","mp"],["ZFSet","hasSubset"],["ZFSet","Definable₁","_proof_1"],["EmptyCollection","emptyCollection"],["ZFSet","IsFunc"],["DFunLike","coe"],["Iff","intro"],["congrArg"],["instOfNatNat"],["congr"],["Subtype","property"],["ZFSet","ext"],["Eq"],["propext"],["ZFSet","inst_SetTheory","_simp_11"],["ExistsUnique","choose"],["Function","Embedding","mk"],["True"],["SetLike","coe_eq_coe","_simp_1"],["Fin","instOfNat"],["ExistsUnique","choose_eq"],["ZFSet","pair_mem_prod"],["ZFSet","mem_prod","_simp_1"],["exists_eq_right_right'","_simp_1"],["OfNat","ofNat"],["eq_self"],["and_self"],["dite_cond_eq_true"],["ZFSet","instEmptyCollection"],["of_eq_true"],["ZFSet","inst_SetTheory","match_14"],["ZFSet","inst_SetTheory","_simp_12"],["ExistsUnique"],["Subtype","mk"],["Subtype","casesOn"],["dite"],["And","casesOn"],["ZFSet","map"],["ZFSet","pair"]],"typeReferences":[["Subtype"],["Membership","mem"],["Classical","propDecidable"],["Classical","allZFSetDefinable"],["ZFSet","funs"],["Fin"],["ZFSet","Definable₁","_proof_1"],["EmptyCollection","emptyCollection"],["DFunLike","coe"],["Subtype","val"],["instOfNatNat"],["ZFSet","instMembership"],["Function","instFunLikeEmbedding"],["Eq"],["ZFSet","inst_SetTheory","_proof_9"],["Function","Embedding","mk"],["Exists"],["ZFSet"],["Function","Embedding"],["Fin","instOfNat"],["OfNat","ofNat"],["Nat"],["ZFSet","instEmptyCollection"],["Iff"],["Subtype","mk"],["dite"],["ZFSet","map"]],"type":"∀ (X Y F : ZFSet),\n  Iff (ZFSet.instMembership.mem (Y.funs X) F)\n    (Exists fun f =>\n      Eq\n        (Function.instFunLikeEmbedding.coe\n          {\n            toFun := fun f =>\n              ZFSet.map\n                (fun s =>\n                  if h : ZFSet.instMembership.mem Y s then (f ⟨s, h⟩).val\n                  else ZFSet.instEmptyCollection.emptyCollection)\n                Y,\n            inj' := ⋯ }\n          f)\n        F)","name":["ZFSet","inst_SetTheory","_proof_10"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Eq","trans"],["Eq","mp"],["Inter","inter"],["Aesop","BuiltinRules","not_intro"],["Membership","mem"],["Exists","intro"],["ZFSet","instInter"],["EmptyCollection","emptyCollection"],["DFunLike","coe"],["not_exists","_simp_1"],["congrArg"],["And","intro"],["False","elim"],["funext"],["forall_congr"],["Eq","symm"],["ZFSet","instMembership"],["Eq","ndrec"],["Function","instFunLikeEmbedding"],["Eq"],["Not"],["not_and","_simp_1"],["Function","Embedding","mk"],["Exists"],["ZFSet","mem_inter","_simp_1"],["ZFSet"],["Function","Embedding"],["And"],["forall_eq'","_simp_1"],["ZFSet","inst_SetTheory","match_7"],["ZFSet","instEmptyCollection"],["ZFSet","notMem_empty","_simp_1"],["Eq","refl"],["id"],["False"],["Ne"],["Eq","mpr"],["forall_exists_index","_simp_1"],["ZFSet","regularity"]],"typeReferences":[["Not"],["Function","Embedding","mk"],["Exists"],["ZFSet"],["Function","Embedding"],["Membership","mem"],["And"],["ZFSet","instMembership"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"]],"type":"∀ (A : ZFSet),\n  (Exists fun x => ZFSet.instMembership.mem A x) →\n    Exists fun x =>\n      And (ZFSet.instMembership.mem A x)\n        (∀ (S : ZFSet),\n          Eq x (Function.instFunLikeEmbedding.coe { toFun := fun ⦃a₁⦄ => a₁, inj' := ⋯ } S) →\n            Not (Exists fun y => And (ZFSet.instMembership.mem A y) (ZFSet.instMembership.mem S y)))","name":["ZFSet","inst_SetTheory","_proof_7"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["PSet"],["PartialOrder","toPreorder"],["Membership","mem"],["Preorder","toLT"],["Iff","intro"],["congrArg"],["Or"],["Eq","ndrec"],["Preorder","toLE"],["Eq"],["le_iff_lt_or_eq"],["Nat","instLinearOrder"],["PSet","mem_asymm"],["propext"],["Not"],["instLTNat"],["PSet","mem_irrefl"],["Nat","instPartialOrder"],["Mathlib","Tactic","PushNeg","not_lt_eq"],["Mathlib","Tactic","Contrapose","mtr"],["Or","casesOn"],["LT","lt"],["PSet","instMembership"],["LinearOrder","toPartialOrder"],["Nat"],["PSet","ofNat_mem_ofNat_of_lt"],["Eq","refl"],["LE","le"],["id"],["Eq","mpr"],["PSet","ofNat"]],"typeReferences":[["LT","lt"],["PSet","instMembership"],["instLTNat"],["PSet"],["Nat"],["Iff"],["Membership","mem"],["PSet","ofNat"]],"type":"∀ (n m : Nat), Iff (PSet.instMembership.mem (PSet.ofNat m) (PSet.ofNat n)) (instLTNat.lt n m)","name":["PSet","mem_ofNat_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["PSet"],["le_refl"],["not_lt","_simp_1"],["PartialOrder","toPreorder"],["Eq","trans"],["Membership","mem"],["PSet","Equiv"],["PSet","eq_of_ofNat_equiv_ofNat","_simp_1_2"],["PSet","toSet"],["Nat","instLinearOrder"],["instLTNat"],["Nat","instPartialOrder"],["Set","ext_iff"],["Set","instMembership"],["Classical","em"],["PSet","instMembership"],["Nat"],["Decidable","byContradiction"],["PSet","Equiv","eq"],["Iff"],["Eq","refl"],["id"],["PSet","ofNat"],["Eq","mpr"],["PSet","eq_of_ofNat_equiv_ofNat","_simp_1_1"],["Eq","mp"],["le_trans"],["congrArg"],["Nat","instPreorder"],["congr"],["Preorder","toLE"],["Eq"],["le_antisymm"],["propext"],["Not"],["ne_of_not_le"],["Set"],["Nat","decLe"],["PSet","mem_toSet","_simp_1"],["iff_false"],["PSet","Equiv","symm"],["LT","lt"],["Or","casesOn"],["le_of_not_ge"],["LinearOrder","toPartialOrder"],["LE","le"],["False"],["instDecidableEqNat"],["instLENat"]],"typeReferences":[["PSet","Equiv"],["Nat"],["PSet","ofNat"],["Eq"]],"type":"∀ (n m : Nat), (PSet.ofNat n).Equiv (PSet.ofNat m) → Eq n m","name":["PSet","eq_of_ofNat_equiv_ofNat"],"kind":"theorem","isProp":true},{"valueReferences":[["Iff"],["ZFSet"],["Membership","mem"],["ZFSet","instMembership"],["Eq"],["ZFSet","ext_iff"],["propext"]],"typeReferences":[["Iff"],["ZFSet"],["Membership","mem"],["ZFSet","instMembership"],["Eq"]],"type":"∀ {x y : ZFSet}, Eq (Eq x y) (∀ (z : ZFSet), Iff (ZFSet.instMembership.mem x z) (ZFSet.instMembership.mem y z))","name":["ZFSet","inst_SetTheory","_simp_11"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Exists"],["ZFSet"],["Membership","mem"],["Exists","intro"],["ZFSet","instMembership"],["Subtype","mk"]],"typeReferences":[["Exists"],["Subtype"],["ZFSet"],["Membership","mem"],["Exists","intro"],["ZFSet","instMembership"],["Subtype","mk"]],"type":"∀ (A : ZFSet) (P : (Subtype fun x => ZFSet.instMembership.mem A x) → ZFSet → Prop) (s : ZFSet)\n  (motive : (Exists fun a => Exists fun b => P ⟨a, b⟩ s) → Prop) (h : Exists fun a => Exists fun b => P ⟨a, b⟩ s),\n  (∀ (z : ZFSet) (hzA : ZFSet.instMembership.mem A z) (hz' : P ⟨z, hzA⟩ s), motive ⋯) → motive h","name":["ZFSet","inst_SetTheory","match_4"],"kind":"definition","isProp":true},{"valueReferences":[["Exists"],["ZFSet"],["Membership","mem"],["And"],["ZFSet","instMembership"],["Eq"],["propext"],["ZFSet","mem_map"],["ZFSet","pair"],["ZFSet","map"]],"typeReferences":[["Exists"],["ZFSet"],["Membership","mem"],["And"],["ZFSet","instMembership"],["Eq"],["ZFSet","Definable₁"],["ZFSet","pair"],["ZFSet","map"]],"type":"∀ {f : ZFSet → ZFSet} [inst : ZFSet.Definable₁ f] {x y : ZFSet},\n  Eq (ZFSet.instMembership.mem (ZFSet.map f x) y)\n    (Exists fun z => And (ZFSet.instMembership.mem x z) (Eq (z.pair (f z)) y))","name":["ZFSet","inst_SetTheory","_simp_12"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["ZFSet","instEmptyCollection"],["ZFSet"],["Inter","inter"],["Membership","mem"],["And"],["Exists","intro"],["ZFSet","instMembership"],["EmptyCollection","emptyCollection"],["ZFSet","instInter"],["Eq"],["And","casesOn"]],"typeReferences":[["And","intro"],["Exists"],["ZFSet","instEmptyCollection"],["ZFSet"],["Inter","inter"],["Membership","mem"],["And"],["Exists","intro"],["ZFSet","instMembership"],["EmptyCollection","emptyCollection"],["ZFSet","instInter"],["Eq"]],"type":"∀ (A : ZFSet)\n  (motive :\n    (Exists fun y =>\n        And (ZFSet.instMembership.mem A y) (Eq (ZFSet.instInter.inter A y) ZFSet.instEmptyCollection.emptyCollection)) →\n      Prop)\n  (x :\n    Exists fun y =>\n      And (ZFSet.instMembership.mem A y) (Eq (ZFSet.instInter.inter A y) ZFSet.instEmptyCollection.emptyCollection)),\n  (∀ (y : ZFSet) (hy : ZFSet.instMembership.mem A y)\n      (right : Eq (ZFSet.instInter.inter A y) ZFSet.instEmptyCollection.emptyCollection), motive ⋯) →\n    motive x","name":["ZFSet","inst_SetTheory","match_7"],"kind":"definition","isProp":true},{"valueReferences":[["Eq","trans"],["Membership","mem"],["Classical","propDecidable"],["Classical","allZFSetDefinable"],["eq_true"],["Fin"],["Subtype","val"],["ZFSet","instSetLike"],["true_iff"],["iff_self"],["funext"],["forall_congr"],["Eq","symm"],["_private","Mathlib","Tactic","Simproc","ExistsAndEq",0,"existsAndEq","exists_of_imp_eq"],["ZFSet","instMembership"],["And","left"],["Exists"],["SetLike","instMembership"],["ZFSet"],["And","right"],["And"],["Subtype","ext"],["true_and"],["Nat"],["Iff"],["id"],["ZFSet","pair_inj","_simp_1"],["Subtype"],["Eq","mp"],["ZFSet","Definable₁","_proof_1"],["EmptyCollection","emptyCollection"],["congrArg"],["instOfNatNat"],["congr"],["ZFSet","ext"],["Eq"],["ZFSet","inst_SetTheory","_simp_11"],["True"],["SetLike","coe_eq_coe","_simp_1"],["Fin","instOfNat"],["OfNat","ofNat"],["eq_self"],["and_self"],["of_eq_true"],["ZFSet","instEmptyCollection"],["dite_cond_eq_true"],["ZFSet","inst_SetTheory","_simp_12"],["Subtype","casesOn"],["Subtype","mk"],["dite"],["ZFSet","pair"],["ZFSet","map"]],"typeReferences":[["Subtype"],["ZFSet"],["Membership","mem"],["Fin","instOfNat"],["Classical","propDecidable"],["Classical","allZFSetDefinable"],["Fin"],["ZFSet","Definable₁","_proof_1"],["EmptyCollection","emptyCollection"],["Subtype","val"],["OfNat","ofNat"],["Nat"],["ZFSet","instEmptyCollection"],["instOfNatNat"],["ZFSet","instMembership"],["Subtype","mk"],["Eq"],["dite"],["ZFSet","map"]],"type":"∀ (X Y : ZFSet)\n  (x x_1 : (Subtype fun x => ZFSet.instMembership.mem Y x) → Subtype fun x => ZFSet.instMembership.mem X x),\n  Eq\n      (ZFSet.map\n        (fun s =>\n          if h : ZFSet.instMembership.mem Y s then (x ⟨s, h⟩).val else ZFSet.instEmptyCollection.emptyCollection)\n        Y)\n      (ZFSet.map\n        (fun s =>\n          if h : ZFSet.instMembership.mem Y s then (x_1 ⟨s, h⟩).val else ZFSet.instEmptyCollection.emptyCollection)\n        Y) →\n    Eq x x_1","name":["ZFSet","inst_SetTheory","_proof_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["ZFSet"],["Membership","mem"],["ZFSet","instMembership"],["Subtype","mk"],["Exists","choose"]],"typeReferences":[["Exists"],["Subtype"],["ZFSet"],["Membership","mem"],["ZFSet","instMembership"],["Subtype","mk"]],"type":"∀ (A : ZFSet) (P : (Subtype fun x => ZFSet.instMembership.mem A x) → ZFSet → Prop) (s : ZFSet),\n  (Exists fun hs => Exists fun z => P ⟨s, hs⟩ z) → ZFSet.instMembership.mem A s","name":["ZFSet","inst_SetTheory","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["PSet","Equiv"],["ZFSet","eq"],["ZFSet","mk"],["ZFSet"],["Eq"],["propext"]],"typeReferences":[["PSet"],["PSet","Equiv"],["ZFSet","mk"],["ZFSet"],["Eq"]],"type":"∀ {x y : PSet}, Eq (Eq (ZFSet.mk x) (ZFSet.mk y)) (x.Equiv y)","name":["ZFSet","nat_equiv","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["PSet"],["Eq","refl"],["PSet","omega"]],"typeReferences":[["ULift","down"],["PSet","mk"],["PSet"],["Nat"],["ULift"],["PSet","ofNat"],["Eq"],["PSet","omega"]],"type":"Eq PSet.omega (PSet.mk (ULift Nat) fun n => PSet.ofNat n.down)","name":["PSet","omega","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Exists","choose_spec"],["ZFSet"],["Membership","mem"],["And"],["Classical","propDecidable"],["Exists","intro"],["EmptyCollection","emptyCollection"],["Exists","choose"],["Exists","casesOn"],["And","intro"],["ZFSet","instEmptyCollection"],["ZFSet","instMembership"],["exists_prop_decidable"],["Subtype","mk"],["Eq"],["dite"],["And","casesOn"]],"typeReferences":[["Subtype"],["Exists"],["Exists","choose_spec"],["ZFSet"],["Membership","mem"],["And"],["Classical","propDecidable"],["Exists","intro"],["EmptyCollection","emptyCollection"],["Exists","choose"],["And","intro"],["ZFSet","instEmptyCollection"],["ZFSet","instMembership"],["exists_prop_decidable"],["Subtype","mk"],["Eq"],["dite"]],"type":"∀ (A : ZFSet) (P : (Subtype fun x => ZFSet.instMembership.mem A x) → ZFSet → Prop) (s : ZFSet)\n  (motive :\n    (Exists fun z =>\n        And\n          (And (ZFSet.instMembership.mem A z) (∀ (hs : ZFSet.instMembership.mem A z), Exists fun z_1 => P ⟨z, hs⟩ z_1))\n          (Eq\n            (if h : Exists fun hs => Exists fun z_1 => P ⟨z, hs⟩ z_1 then ⋯.choose\n            else ZFSet.instEmptyCollection.emptyCollection)\n            s)) →\n      Prop)\n  (h :\n    Exists fun z =>\n      And (And (ZFSet.instMembership.mem A z) (∀ (hs : ZFSet.instMembership.mem A z), Exists fun z_1 => P ⟨z, hs⟩ z_1))\n        (Eq\n          (if h : Exists fun hs => Exists fun z_1 => P ⟨z, hs⟩ z_1 then ⋯.choose\n          else ZFSet.instEmptyCollection.emptyCollection)\n          s)),\n  (∀ (z : ZFSet) (hzA : ZFSet.instMembership.mem A z)\n      (hz : ∀ (hs : ZFSet.instMembership.mem A z), Exists fun z_1 => P ⟨z, hs⟩ z_1)\n      (hz' :\n        Eq\n          (if h : Exists fun hs => Exists fun z_1 => P ⟨z, hs⟩ z_1 then ⋯.choose\n          else ZFSet.instEmptyCollection.emptyCollection)\n          s),\n      motive ⋯) →\n    motive h","name":["ZFSet","inst_SetTheory","match_1"],"kind":"definition","isProp":true},{"valueReferences":[["Eq","trans"],["Membership","mem"],["exists_const","_simp_1"],["Classical","allZFSetDefinable"],["Classical","propDecidable"],["Fin"],["Exists","intro"],["eq_true"],["And","intro"],["dif_pos"],["ZFSet","image"],["funext"],["Eq","symm"],["Subtype","exists","_simp_1"],["ZFSet","instMembership"],["Exists"],["ZFSet","sep"],["Exists","choose_spec"],["ZFSet"],["And"],["Nat"],["Iff","of_eq"],["instNonemptyOfInhabited"],["Iff"],["id"],["Eq","mpr"],["Subtype"],["Eq","mp"],["ZFSet","Definable₁","_proof_1"],["EmptyCollection","emptyCollection"],["congrArg"],["Iff","intro"],["ZFSet","mem_image","_simp_1"],["instOfNatNat"],["congr"],["exists_prop_decidable"],["ZFSet","inst_SetTheory","match_4"],["Eq"],["propext"],["True"],["ZFSet","mem_sep","_simp_1"],["Fin","instOfNat"],["Exists","choose"],["OfNat","ofNat"],["exists_prop_congr"],["ZFSet","instEmptyCollection"],["ZFSet","inst_SetTheory","match_1"],["of_eq_true"],["dite_cond_eq_true"],["ZFSet","inst_SetTheory","_simp_3"],["Subtype","mk"],["dite"],["instInhabitedTrue"]],"typeReferences":[["Subtype"],["Membership","mem"],["Classical","propDecidable"],["Classical","allZFSetDefinable"],["Fin"],["ZFSet","Definable₁","_proof_1"],["EmptyCollection","emptyCollection"],["ZFSet","inst_SetTheory","_proof_4"],["ZFSet","image"],["instOfNatNat"],["ZFSet","inst_SetTheory","_proof_2"],["exists_prop_decidable"],["ZFSet","instMembership"],["Eq"],["Exists"],["ZFSet","inst_SetTheory","_proof_3"],["ZFSet","sep"],["ZFSet"],["And"],["Fin","instOfNat"],["Exists","choose"],["OfNat","ofNat"],["Nat"],["ZFSet","instEmptyCollection"],["Iff"],["ZFSet","inst_SetTheory","_proof_5"],["Subtype","mk"],["dite"]],"type":"∀ (A : ZFSet) (P : (Subtype fun x => ZFSet.instMembership.mem A x) → ZFSet → Prop),\n  (∀ (x : Subtype fun x => ZFSet.instMembership.mem A x) (y y' : ZFSet), And (P x y) (P x y') → Eq y y') →\n    ∀ (s : ZFSet),\n      Iff\n        (ZFSet.instMembership.mem\n          (ZFSet.image\n            (fun s =>\n              if h : Exists fun hs => Exists fun z => P ⟨s, hs⟩ z then ⋯.choose\n              else ZFSet.instEmptyCollection.emptyCollection)\n            (ZFSet.sep (fun s => ∀ (hs : ZFSet.instMembership.mem A s), Exists fun z => P ⟨s, hs⟩ z) A))\n          s)\n        (Exists fun x => P x s)","name":["ZFSet","inst_SetTheory","_proof_6"],"kind":"theorem","isProp":true},{"valueReferences":[["PSet"],["Membership","mem"],["Insert","insert"],["congrArg"],["PSet","instMembership"],["PSet","instInsert"],["Nat","succ"],["PSet","mem_insert_of_mem"],["PSet","ofNat","eq_2"],["id"],["Nat","le","rec"],["PSet","ofNat"],["Eq","mpr"],["Eq"],["PSet","mem_insert"]],"typeReferences":[["PSet","instMembership"],["LT","lt"],["PSet"],["instLTNat"],["Nat"],["Membership","mem"],["PSet","ofNat"]],"type":"∀ (m n : Nat), instLTNat.lt n m → PSet.instMembership.mem (PSet.ofNat m) (PSet.ofNat n)","name":["PSet","ofNat_mem_ofNat_of_lt"],"kind":"theorem","isProp":true},{"valueReferences":[["ZFSet","mem_sUnion","_simp_1"],["Exists"],["ZFSet","inst_SetTheory","_simp_19"],["ZFSet","sUnion"],["Eq","trans"],["True"],["ZFSet"],["Membership","mem"],["And"],["congrArg"],["iff_self"],["of_eq_true"],["Iff"],["congr"],["funext"],["ZFSet","instMembership"]],"typeReferences":[["Exists"],["ZFSet","sUnion"],["Iff"],["ZFSet"],["Membership","mem"],["And"],["ZFSet","instMembership"]],"type":"∀ (x x_1 : ZFSet),\n  Iff (ZFSet.instMembership.mem x.sUnion x_1)\n    (Exists fun x_2 => And (ZFSet.instMembership.mem x_2 x_1) (ZFSet.instMembership.mem x x_2))","name":["ZFSet","inst_SetTheory","_proof_11"],"kind":"theorem","isProp":true},{"valueReferences":[["PSet"],["Nat","succ"],["Eq","refl"],["PSet","ofNat"]],"typeReferences":[["PSet","instInsert"],["PSet"],["Nat"],["Nat","succ"],["Insert","insert"],["PSet","ofNat"],["Eq"]],"type":"∀ (n : Nat), Eq (PSet.ofNat n.succ) (PSet.instInsert.insert (PSet.ofNat n) (PSet.ofNat n))","name":["PSet","ofNat","eq_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["ZFSet","sUnion"],["Singleton","singleton"],["Membership","mem"],["Classical","allZFSetDefinable"],["Classical","propDecidable"],["ZFSet","funs"],["Fin"],["ZFSet","mem_singleton"],["ZFSet","Definable₁","_proof_1"],["ZFSet","inst_SetTheory","_proof_6"],["Union","union"],["ZFSet","instSingleton"],["EmptyCollection","emptyCollection"],["Subtype","val"],["ZFSet","inst_SetTheory","_proof_7"],["ZFSet","image"],["ZFSet","inst_SetTheory","_proof_1"],["instOfNatNat"],["ZFSet","mem_union"],["ZFSet","inst_SetTheory","_proof_8"],["ZFSet","inst_SetTheory","_proof_2"],["ZFSet","instUnion"],["ZFSet","ext"],["ZFSet","inst_SetTheory","_proof_10"],["ZFSet","instMembership"],["exists_prop_decidable"],["ZFSet","inst_SetTheory","_proof_3"],["Function","Embedding","mk"],["Exists"],["ZFSet","sep"],["ZFSet"],["Fin","instOfNat"],["ZFSet","notMem_empty"],["ZFSet","nat_equiv"],["Exists","choose"],["OfNat","ofNat"],["Nat"],["ZFSet","instEmptyCollection"],["Chapter3","SetTheory","mk"],["ZFSet","inst_SetTheory","_proof_11"],["ZFSet","omega"],["Subtype","mk"],["dite"],["ZFSet","map"]],"typeReferences":[["Chapter3","SetTheory"]],"type":"Chapter3.SetTheory","name":["ZFSet","inst_SetTheory"],"kind":"definition","isProp":false},{"valueReferences":[["LT","lt"],["PSet","instMembership"],["instLTNat"],["PSet"],["Nat"],["PSet","mem_ofNat_iff"],["Membership","mem"],["PSet","ofNat"],["propext"]],"typeReferences":[["LT","lt"],["PSet","instMembership"],["instLTNat"],["PSet"],["Nat"],["Membership","mem"],["PSet","ofNat"],["Eq"]],"type":"∀ (n m : Nat), Eq (PSet.instMembership.mem (PSet.ofNat m) (PSet.ofNat n)) (instLTNat.lt n m)","name":["PSet","eq_of_ofNat_equiv_ofNat","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","choose_spec"],["eq_true"],["Exists","choose"]],"typeReferences":[["Exists"],["True"],["Exists","choose"],["Eq"]],"type":"∀ {α : Sort u_1} {p : α → Prop} (P : Exists fun a => p a), Eq (p P.choose) True","name":["ZFSet","inst_SetTheory","_simp_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Exists"],["instOfNatNat"],["ZFSet"],["Membership","mem"],["Fin","instOfNat"],["Fin"],["ZFSet","instMembership"],["Subtype","mk"],["ZFSet","Definable₁","_proof_1"],["Exists","choose"],["OfNat","ofNat"]],"typeReferences":[["Nat"],["Exists"],["Subtype"],["instOfNatNat"],["ZFSet"],["Membership","mem"],["Fin","instOfNat"],["Fin"],["ZFSet","instMembership"],["Subtype","mk"],["ZFSet","Definable₁","_proof_1"],["OfNat","ofNat"]],"type":"∀ (A : ZFSet) (P : (Subtype fun x => ZFSet.instMembership.mem A x) → ZFSet → Prop) (s : Fin 1 → ZFSet),\n  (Exists fun hs => Exists fun z => P ⟨s 0, hs⟩ z) → ZFSet.instMembership.mem A (s 0)","name":["ZFSet","inst_SetTheory","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["PSet"],["Subtype","mk","injEq"],["Eq","trans"],["ZFSet","mk"],["Membership","mem"],["Exists","intro"],["ZFSet","instSetLike"],["And","intro"],["PSet","Equiv"],["PSet","Type"],["PSet","setoid"],["funext"],["ZFSet","omega","eq_1"],["Eq","symm"],["ZFSet","instMembership"],["ZFSet","nat_equiv","match_2"],["SetLike","instMembership"],["Exists"],["ULift"],["ZFSet"],["PSet","instMembership"],["Exists","casesOn"],["Nat"],["Iff","mpr"],["Eq","refl"],["id"],["Eq","mpr"],["PSet","ofNat"],["ZFSet","mk_out"],["Quotient","out"],["ZFSet","nat_equiv","_simp_1"],["ULift","down"],["Subtype"],["Eq","mp"],["ZFSet","eq"],["ULift","up"],["congrArg"],["Eq"],["PSet","omega"],["propext"],["PSet","Equiv","symm"],["Function","Surjective"],["PSet","eq_of_ofNat_equiv_ofNat"],["PSet","Mem","mk"],["ZFSet","omega"],["Subtype","mk"],["PSet","Func"],["ZFSet","mk_mem_iff"],["Function","Injective"]],"typeReferences":[["Subtype"],["SetLike","instMembership"],["ZFSet","mk"],["ZFSet"],["Membership","mem"],["And"],["ZFSet","nat_equiv","_proof_1"],["Function","Surjective"],["ZFSet","instSetLike"],["Nat"],["ZFSet","omega"],["PSet","ofNat"],["Subtype","mk"],["Function","Injective"]],"type":"And (Function.Injective fun n => ⟨ZFSet.mk (PSet.ofNat n), ⋯⟩)\n  (Function.Surjective fun n => ⟨ZFSet.mk (PSet.ofNat n), ⋯⟩)","name":["ZFSet","nat_equiv","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["PSet"],["Nat"],["instOfNatNat"],["Eq","refl"],["PSet","ofNat"],["OfNat","ofNat"]],"typeReferences":[["PSet","instEmptyCollection"],["PSet"],["Nat"],["instOfNatNat"],["PSet","ofNat"],["EmptyCollection","emptyCollection"],["Eq"],["OfNat","ofNat"]],"type":"Eq (PSet.ofNat 0) PSet.instEmptyCollection.emptyCollection","name":["PSet","ofNat","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Membership","mem"],["Classical","propDecidable"],["Classical","allZFSetDefinable"],["eq_true"],["Fin"],["Subtype","val"],["ZFSet","instSetLike"],["true_iff"],["iff_self"],["funext"],["forall_congr"],["Eq","symm"],["_private","Mathlib","Tactic","Simproc","ExistsAndEq",0,"existsAndEq","exists_of_imp_eq"],["ZFSet","instMembership"],["And","left"],["Exists"],["SetLike","instMembership"],["ZFSet"],["And","right"],["And"],["Subtype","ext"],["true_and"],["Nat"],["Iff"],["id"],["ZFSet","pair_inj","_simp_1"],["Subtype"],["Eq","mp"],["ZFSet","Definable₁","_proof_1"],["EmptyCollection","emptyCollection"],["congrArg"],["instOfNatNat"],["congr"],["ZFSet","ext"],["Eq"],["ZFSet","inst_SetTheory","_simp_11"],["True"],["SetLike","coe_eq_coe","_simp_1"],["Fin","instOfNat"],["OfNat","ofNat"],["eq_self"],["and_self"],["of_eq_true"],["ZFSet","instEmptyCollection"],["dite_cond_eq_true"],["ZFSet","inst_SetTheory","_simp_12"],["Subtype","casesOn"],["Subtype","mk"],["dite"],["ZFSet","pair"],["ZFSet","map"]],"typeReferences":[["Subtype"],["ZFSet"],["Membership","mem"],["Fin","instOfNat"],["Classical","propDecidable"],["Classical","allZFSetDefinable"],["Fin"],["ZFSet","Definable₁","_proof_1"],["EmptyCollection","emptyCollection"],["Subtype","val"],["OfNat","ofNat"],["Nat"],["ZFSet","instEmptyCollection"],["instOfNatNat"],["ZFSet","instMembership"],["Subtype","mk"],["Eq"],["dite"],["ZFSet","map"]],"type":"∀ (X Y : ZFSet)\n  (x x_1 : (Subtype fun x => ZFSet.instMembership.mem X x) → Subtype fun x => ZFSet.instMembership.mem Y x),\n  Eq\n      (ZFSet.map\n        (fun s =>\n          if h : ZFSet.instMembership.mem X s then (x ⟨s, h⟩).val else ZFSet.instEmptyCollection.emptyCollection)\n        X)\n      (ZFSet.map\n        (fun s =>\n          if h : ZFSet.instMembership.mem X s then (x_1 ⟨s, h⟩).val else ZFSet.instEmptyCollection.emptyCollection)\n        X) →\n    Eq x x_1","name":["ZFSet","inst_SetTheory","_proof_8"],"kind":"theorem","isProp":true}]
