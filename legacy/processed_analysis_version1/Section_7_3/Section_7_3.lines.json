[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":57},{"state":[],"start":105},{"state":[],"start":159},{"state":[],"start":187},{"state":[],"start":222},{"state":[],"start":250},{"state":[],"start":251},{"state":[],"start":255},{"state":[],"start":311},{"state":[],"start":312},{"state":[],"start":696},{"state":[],"start":697},{"state":[],"start":745},{"state":[],"start":746},{"state":[],"start":815},{"state":[],"start":843},{"state":[],"start":844},{"state":[],"start":847},{"state":[],"start":848},{"state":[],"start":867},{"state":[],"start":868},{"state":[],"start":878},{"state":[],"start":879},{"state":[],"start":943},{"state":[],"start":944},{"state":[],"start":1035},{"state":[],"start":1036},{"state":[],"start":1061},{"state":[{"type":"s.converges ↔ ∃ M, ∀ (N : ℤ), s.partial N ≤ M","tag":[],"mvarId":["_uniq",333],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"}]}],"start":1182},{"state":[{"type":"s.converges ↔ ∃ M, ∀ (N : ℤ), s.partial N ≤ M","tag":[],"mvarId":["_uniq",333],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"}]}],"start":1322},{"state":[{"type":"s.converges → ∃ M, ∀ (N : ℤ), s.partial N ≤ M","tag":["mp"],"mvarId":["_uniq",340],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"}]},{"type":"(∃ M, ∀ (N : ℤ), s.partial N ≤ M) → s.converges","tag":["mpr"],"mvarId":["_uniq",341],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"}]}],"start":1336},{"state":[{"type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","tag":["mp"],"mvarId":["_uniq",345],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",344],"binderInfo":"default"}]}],"start":1352},{"state":[{"type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","tag":["mp"],"mvarId":["_uniq",632],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",344],"binderInfo":"default"},{"value":"{ m := s.m, seq := s.partial, vanish := ⋯ }","type":"Chapter6.Sequence","name":["S"],"isProp":false,"id":["_uniq",631]}]}],"start":1450},{"state":[{"type":"S.IsBounded","tag":[],"mvarId":["_uniq",686],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",344],"binderInfo":"default"},{"value":"{ m := s.m, seq := s.partial, vanish := ⋯ }","type":"Chapter6.Sequence","name":["S"],"isProp":false,"id":["_uniq",631]}]}],"start":1479},{"state":[{"type":"S.Convergent","tag":[],"mvarId":["_uniq",695],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",344],"binderInfo":"default"},{"value":"{ m := s.m, seq := s.partial, vanish := ⋯ }","type":"Chapter6.Sequence","name":["S"],"isProp":false,"id":["_uniq",631]}]}],"start":1515},{"state":[{"type":"∃ L, Filter.Tendsto S.seq Filter.atTop (nhds L)","tag":[],"mvarId":["_uniq",701],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",344],"binderInfo":"default"},{"value":"{ m := s.m, seq := s.partial, vanish := ⋯ }","type":"Chapter6.Sequence","name":["S"],"isProp":false,"id":["_uniq",631]}]}],"start":1567},{"state":[{"type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","tag":["mp"],"mvarId":["_uniq",688],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",344],"binderInfo":"default"},{"value":"{ m := s.m, seq := s.partial, vanish := ⋯ }","type":"Chapter6.Sequence","name":["S"],"isProp":false,"id":["_uniq",631]},{"value":"Chapter6.Sequence.bounded_of_convergent\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext (Chapter6.Sequence.converges_iff_Tendsto' S))))\n    (converges_of_nonneg_iff._proof_1 hconv))","type":"S.IsBounded","name":["this"],"isProp":true,"id":["_uniq",687]}]}],"start":1579},{"state":[{"type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","tag":["mp"],"mvarId":["_uniq",1746],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",344],"binderInfo":"default"},{"value":"{ m := s.m, seq := s.partial, vanish := ⋯ }","type":"Chapter6.Sequence","name":["S"],"isProp":false,"id":["_uniq",631]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",1731],"binderInfo":"default"},{"type":"M ≥ 0","name":["hpos"],"isProp":true,"id":["_uniq",1740],"binderInfo":"default"},{"type":"S.BoundedBy M","name":["hM"],"isProp":true,"id":["_uniq",1744],"binderInfo":"default"}]}],"start":1611},{"state":[{"type":"s.partial N ≤ M","tag":["h","h"],"mvarId":["_uniq",1828],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",344],"binderInfo":"default"},{"value":"{ m := s.m, seq := s.partial, vanish := ⋯ }","type":"Chapter6.Sequence","name":["S"],"isProp":false,"id":["_uniq",631]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",1731],"binderInfo":"default"},{"type":"M ≥ 0","name":["hpos"],"isProp":true,"id":["_uniq",1740],"binderInfo":"default"},{"type":"S.BoundedBy M","name":["hM✝"],"isProp":true,"id":["_uniq",1744],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1826],"binderInfo":"default"},{"type":"|S.seq N| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1827],"binderInfo":"default"}]}],"start":1640},{"state":[{"type":"(∃ M, ∀ (N : ℤ), s.partial N ≤ M) → s.converges","tag":["mpr"],"mvarId":["_uniq",341],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"}]}],"start":1675},{"state":[{"type":"s.converges","tag":["mpr"],"mvarId":["_uniq",2571],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","name":["hbound"],"isProp":true,"id":["_uniq",2570],"binderInfo":"default"}]}],"start":1690},{"state":[{"type":"s.converges","tag":["mpr","inl"],"mvarId":["_uniq",2842],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","name":["hbound"],"isProp":true,"id":["_uniq",2570],"binderInfo":"default"},{"type":"Filter.Tendsto s.partial Filter.atTop Filter.atTop","name":["hinfin"],"isProp":true,"id":["_uniq",2841],"binderInfo":"default"}]},{"type":"s.converges","tag":["mpr","inr"],"mvarId":["_uniq",2847],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","name":["hbound"],"isProp":true,"id":["_uniq",2570],"binderInfo":"default"},{"type":"∃ l, Filter.Tendsto s.partial Filter.atTop (nhds l)","name":["hfin"],"isProp":true,"id":["_uniq",2846],"binderInfo":"default"}]}],"start":1758},{"state":[{"type":"s.converges","tag":["mpr","inl"],"mvarId":["_uniq",2856],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"Filter.Tendsto s.partial Filter.atTop Filter.atTop","name":["hinfin"],"isProp":true,"id":["_uniq",2841],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",2850],"binderInfo":"default"},{"type":"∀ (N : ℤ), s.partial N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",2854],"binderInfo":"default"}]}],"start":1787},{"state":[{"type":"s.converges","tag":["mpr","inl"],"mvarId":["_uniq",3127],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"Filter.Tendsto s.partial Filter.atTop Filter.atTop","name":["hinfin"],"isProp":true,"id":["_uniq",2841],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",2850],"binderInfo":"default"},{"type":"∀ (N : ℤ), s.partial N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",2854],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",3123],"binderInfo":"default"},{"type":"M < s.partial N","name":["hN"],"isProp":true,"id":["_uniq",3126],"binderInfo":"default"}]}],"start":1847},{"state":[{"type":"s.converges","tag":["mpr","inr"],"mvarId":["_uniq",2847],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",330],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",331],"binderInfo":"default"},{"type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","name":["hbound"],"isProp":true,"id":["_uniq",2570],"binderInfo":"default"},{"type":"∃ l, Filter.Tendsto s.partial Filter.atTop (nhds l)","name":["hfin"],"isProp":true,"id":["_uniq",2846],"binderInfo":"default"}]}],"start":1857},{"state":[],"start":1870},{"state":[],"start":1871},{"state":[{"type":"s.sum ≤ M","tag":[],"mvarId":["_uniq",5577],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",5571],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",5572],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",5573],"binderInfo":"implicit"},{"type":"∀ (N : ℤ), s.partial N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",5574],"binderInfo":"default"}]}],"start":1988},{"state":[{"type":"s.sum ≤ M","tag":[],"mvarId":["_uniq",5602],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",5571],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",5572],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",5573],"binderInfo":"implicit"},{"type":"∀ (N : ℤ), s.partial N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",5574],"binderInfo":"default"},{"value":"Exists.intro M hM","type":"∃ M, ∀ (N : ℤ), s.partial N ≤ M","name":["this"],"isProp":true,"id":["_uniq",5601]}]}],"start":2042},{"state":[{"type":"Exists.choose ⋯ ≤ M","tag":[],"mvarId":["_uniq",6534],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",5571],"binderInfo":"implicit"},{"type":"s.nonneg","name":["h"],"isProp":true,"id":["_uniq",5572],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",5573],"binderInfo":"implicit"},{"type":"∀ (N : ℤ), s.partial N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",5574],"binderInfo":"default"},{"type":"s.converges","name":["this"],"isProp":true,"id":["_uniq",5634],"binderInfo":"default"}]}],"start":2104},{"state":[],"start":2197},{"state":[],"start":2198},{"state":[],"start":2300},{"state":[{"type":"s.partial N ≤ s.sum","tag":[],"mvarId":["_uniq",8131],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",8126],"binderInfo":"implicit"},{"type":"s.nonneg","name":["hnon"],"isProp":true,"id":["_uniq",8127],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",8128],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",8129],"binderInfo":"default"}]}],"start":2330},{"state":[{"type":"Filter.Tendsto s.partial Filter.atTop (nhds s.sum)","tag":["ha"],"mvarId":["_uniq",8463],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",8126],"binderInfo":"implicit"},{"type":"s.nonneg","name":["hnon"],"isProp":true,"id":["_uniq",8127],"binderInfo":"default"},{"type":"s.converges","name":["hconv"],"isProp":true,"id":["_uniq",8128],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",8129],"binderInfo":"default"}]}],"start":2377},{"state":[],"start":2422},{"state":[],"start":2423},{"state":[],"start":2487},{"state":[{"type":"0 ≤ s.partial N","tag":[],"mvarId":["_uniq",9617],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",9613],"binderInfo":"implicit"},{"type":"s.nonneg","name":["hnon"],"isProp":true,"id":["_uniq",9614],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",9615],"binderInfo":"default"}]}],"start":2582},{"state":[],"start":2638},{"state":[],"start":2639},{"state":[{"type":"0 ≤ s.sum","tag":[],"mvarId":["_uniq",14250],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",14247],"binderInfo":"implicit"},{"type":"s.nonneg","name":["hnon"],"isProp":true,"id":["_uniq",14248],"binderInfo":"default"}]}],"start":2716},{"state":[{"type":"0 ≤ Exists.choose ⋯","tag":["pos","_@","_hyg",501],"mvarId":["_uniq",16641],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",14247],"binderInfo":"implicit"},{"type":"s.nonneg","name":["hnon"],"isProp":true,"id":["_uniq",14248],"binderInfo":"default"},{"type":"s.converges","name":["h"],"isProp":true,"id":["_uniq",14532],"binderInfo":"default"}]}],"start":2767},{"state":[],"start":2826},{"state":[],"start":2827},{"state":[],"start":2885},{"state":[],"start":3093},{"state":[],"start":3094},{"state":[],"start":3251},{"state":[],"start":3252},{"state":[],"start":3307},{"state":[],"start":3427},{"state":[],"start":3428},{"state":[],"start":3538},{"state":[],"start":3539},{"state":[],"start":3643},{"state":[],"start":3644},{"state":[],"start":3750},{"state":[],"start":3751},{"state":[],"start":3795},{"state":[{"type":"s.converges ↔\n  { m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }.converges","tag":[],"mvarId":["_uniq",21398],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"}]}],"start":3984},{"state":[{"type":"s.converges ↔\n  { m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }.converges","tag":[],"mvarId":["_uniq",21398],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"}]}],"start":4057},{"state":[{"type":"s.converges ↔ t.converges","tag":[],"mvarId":["_uniq",22347],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]}]}],"start":4105},{"state":[{"type":"s.converges ↔ t.converges","tag":[],"mvarId":["_uniq",22398],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]}]}],"start":4182},{"state":[{"type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","tag":[],"mvarId":["_uniq",30282],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]}]}],"start":4250},{"state":[{"type":"s.seq (n + (↑k : ℤ)) ≤ s.seq n","tag":["intro"],"mvarId":["_uniq",30356],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",30295],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",30298],"binderInfo":"default"},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",30339],"binderInfo":"default"}]}],"start":4321},{"state":[{"type":"s.seq (n + (↑(k + 1) : ℤ)) ≤ s.seq n","tag":["intro","succ"],"mvarId":["_uniq",30376],"isProp":false,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",30295],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",30298],"binderInfo":"default"},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",30372],"binderInfo":"default"},{"type":"s.seq (n + (↑k : ℤ)) ≤ s.seq n","name":["hk"],"isProp":true,"id":["_uniq",30373],"binderInfo":"default"}]}],"start":4354},{"state":[{"type":"s.converges ↔ t.converges","tag":[],"mvarId":["_uniq",30288],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]}]}],"start":4415},{"state":[{"type":"s.converges ↔ t.converges","tag":[],"mvarId":["_uniq",40031],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]}]}],"start":4451},{"state":[{"type":"(∃ M, ∀ (N : ℤ), s.partial N ≤ M) ↔ ∃ M, ∀ (N : ℤ), t.partial N ≤ M","tag":[],"mvarId":["_uniq",40087],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]}]}],"start":4513},{"state":[{"type":"(∃ M, ∀ (N : ℤ), S N ≤ M) ↔ ∃ M, ∀ (N : ℤ), t.partial N ≤ M","tag":[],"mvarId":["_uniq",40175],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]}]}],"start":4534},{"state":[{"type":"(∃ M, ∀ (N : ℤ), S N ≤ M) ↔ ∃ M, ∀ (N : ℤ), T N ≤ M","tag":[],"mvarId":["_uniq",40300],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]}]}],"start":4555},{"state":[{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","tag":[],"mvarId":["_uniq",40850],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40406],"binderInfo":"default"}]}],"start":4638},{"state":[{"type":"S (2 ^ (0 + 1) - 1) ≤ T (↑0 : ℤ) ∧ T (↑0 : ℤ) ≤ 2 * S (2 ^ 0)","tag":["zero"],"mvarId":["_uniq",40870],"isProp":false,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]}]},{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",40875],"isProp":false,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK"],"isProp":true,"id":["_uniq",40872],"binderInfo":"default"}]}],"start":4665},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",40875],"isProp":false,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK"],"isProp":true,"id":["_uniq",40872],"binderInfo":"default"}]}],"start":4711},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",109322],"isProp":false,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK"],"isProp":true,"id":["_uniq",40872],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"}]}],"start":4769},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",109331],"isProp":false,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"}]}],"start":4797},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",109888],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]}]}],"start":4893},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",117251],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]}]}],"start":4968},{"state":[{"type":"S (2 ^ (K + 1)) = S (2 ^ K) + ∑ n ∈ Finset.Ioc (2 ^ K) (2 ^ (K + 1)), s.seq n","tag":[],"mvarId":["_uniq",116563],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]}]}],"start":5034},{"state":[{"type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","tag":[],"mvarId":["_uniq",118039],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]}]}],"start":5116},{"state":[{"type":"S (2 ^ (K + 1)) = S (2 ^ K) + ∑ n ∈ Finset.Ioc (2 ^ K) (2 ^ (K + 1)), s.seq n","tag":[],"mvarId":["_uniq",118041],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf y)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))))\n                ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","name":["this"],"isProp":true,"id":["_uniq",118040]}]}],"start":5196},{"state":[{"type":"Finset.Icc s.m (2 ^ (K + 1)) = Finset.Icc s.m (2 ^ K) ∪ Finset.Ioc (2 ^ K) (2 ^ (K + 1))","tag":["h","e'_2","h"],"mvarId":["_uniq",124624],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf y)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))))\n                ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","name":["this"],"isProp":true,"id":["_uniq",118040]}]}],"start":5234},{"state":[{"type":"s.m ≤ x ∧ x ≤ 2 ^ (K + 1) → s.m ≤ x ∧ x ≤ 2 ^ K ∨ 2 ^ K < x ∧ x ≤ 2 ^ (K + 1)","tag":["h","e'_2","h","h","mp"],"mvarId":["_uniq",131629],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf y)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))))\n                ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","name":["this"],"isProp":true,"id":["_uniq",118040]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",128727],"binderInfo":"default"}]},{"type":"s.m ≤ x ∧ x ≤ 2 ^ K ∨ 2 ^ K < x ∧ x ≤ 2 ^ (K + 1) → s.m ≤ x ∧ x ≤ 2 ^ (K + 1)","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",131630],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf y)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))))\n                ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","name":["this"],"isProp":true,"id":["_uniq",118040]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",128727],"binderInfo":"default"}]}],"start":5267},{"state":[{"type":"s.m ≤ x ∧ x ≤ 2 ^ K ∨ 2 ^ K < x ∧ x ≤ 2 ^ (K + 1) → s.m ≤ x ∧ x ≤ 2 ^ (K + 1)","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",131630],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf y)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))))\n                ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","name":["this"],"isProp":true,"id":["_uniq",118040]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",128727],"binderInfo":"default"}]}],"start":5321},{"state":[{"type":"s.m ≤ x ∧ x ≤ 2 ^ (K + 1)","tag":["h","e'_2","h","h","mpr","inl","intro"],"mvarId":["_uniq",133325],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf y)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))))\n                ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","name":["this"],"isProp":true,"id":["_uniq",118040]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",128727],"binderInfo":"default"},{"type":"s.m ≤ x","name":["h1"],"isProp":true,"id":["_uniq",133323],"binderInfo":"default"},{"type":"x ≤ 2 ^ K","name":["h2"],"isProp":true,"id":["_uniq",133324],"binderInfo":"default"}]},{"type":"s.m ≤ x ∧ x ≤ 2 ^ (K + 1)","tag":["h","e'_2","h","h","mpr","inr","intro"],"mvarId":["_uniq",133343],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf y)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))))\n                ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","name":["this"],"isProp":true,"id":["_uniq",118040]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",128727],"binderInfo":"default"},{"type":"2 ^ K < x","name":["h1"],"isProp":true,"id":["_uniq",133341],"binderInfo":"default"},{"type":"x ≤ 2 ^ (K + 1)","name":["h2"],"isProp":true,"id":["_uniq",133342],"binderInfo":"default"}]}],"start":5370},{"state":[{"type":"s.m ≤ x ∧ x ≤ 2 ^ (K + 1)","tag":["h","e'_2","h","h","mpr","inr","intro"],"mvarId":["_uniq",133343],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf K)\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf y)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))))\n                ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ K)) (Finset.Ioc (2 ^ K) (2 ^ (K + 1)))","name":["this"],"isProp":true,"id":["_uniq",118040]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",128727],"binderInfo":"default"},{"type":"2 ^ K < x","name":["h1"],"isProp":true,"id":["_uniq",133341],"binderInfo":"default"},{"type":"x ≤ 2 ^ (K + 1)","name":["h2"],"isProp":true,"id":["_uniq",133342],"binderInfo":"default"}]}],"start":5410},{"state":[],"start":5439},{"state":[{"type":"S (2 ^ K) + ∑ n ∈ Finset.Ioc (2 ^ K) (2 ^ (K + 1)), s.seq n ≥\n  S (2 ^ K) + ∑ n ∈ Finset.Ioc (2 ^ K) (2 ^ (K + 1)), s.seq (2 ^ (K + 1))","tag":[],"mvarId":["_uniq",117032],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]}]}],"start":5521},{"state":[],"start":5592},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",117251],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]}]}],"start":5653},{"state":[{"type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","tag":[],"mvarId":["_uniq",178245],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]}]}],"start":5737},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",178247],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]}]}],"start":5776},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",187801],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.pow_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                                (Mathlib.Tactic.Ring.pow_add\n                                  (Mathlib.Tactic.Ring.single_pow\n                                    (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2)\n                                      (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                                  (Mathlib.Tactic.Ring.add_mul\n                                    (Mathlib.Tactic.Ring.mul_add\n                                      (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                        (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                      (Mathlib.Tactic.Ring.mul_zero\n                                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 +\n                                          0)))\n                                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0)\n                                      (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                        (Eq.refl (Int.negOfNat 2))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast ⋯) * ⋯ + ⋯))))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1 + 1) - 1) ≤ S (2 ^ (K + 1) - 1) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim3"],"isProp":true,"id":["_uniq",187800]}]}],"start":5866},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) = S (2 ^ (K + 1) - 1) + ∑ n ∈ Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1), s.seq n","tag":[],"mvarId":["_uniq",186554],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]}]}],"start":5946},{"state":[{"type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","tag":[],"mvarId":["_uniq",188930],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]}]}],"start":6042},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) = S (2 ^ (K + 1) - 1) + ∑ n ∈ Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1), s.seq n","tag":[],"mvarId":["_uniq",188932],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.pow_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.pow_add\n                            (Mathlib.Tactic.Ring.single_pow\n                              (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                  (Eq.refl (Int.negOfNat 2))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 2).rawCast +\n                              0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero (Mathlib.Meta.NormNum.IsInt.to_isNat ⋯) ⋯))\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","name":["this"],"isProp":true,"id":["_uniq",188931]}]}],"start":6122},{"state":[{"type":"Finset.Icc s.m (2 ^ (K + 1 + 1) - 1) = Finset.Icc s.m (2 ^ (K + 1) - 1) ∪ Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1)","tag":["h","e'_2","h"],"mvarId":["_uniq",196073],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.pow_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.pow_add\n                            (Mathlib.Tactic.Ring.single_pow\n                              (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                  (Eq.refl (Int.negOfNat 2))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 2).rawCast +\n                              0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero (Mathlib.Meta.NormNum.IsInt.to_isNat ⋯) ⋯))\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","name":["this"],"isProp":true,"id":["_uniq",188931]}]}],"start":6160},{"state":[{"type":"s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1 → s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1) - 1 ∨ 2 ^ (K + 1) ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1","tag":["h","e'_2","h","h","mp"],"mvarId":["_uniq",203965],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.pow_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.pow_add\n                            (Mathlib.Tactic.Ring.single_pow\n                              (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                  (Eq.refl (Int.negOfNat 2))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 2).rawCast +\n                              0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero (Mathlib.Meta.NormNum.IsInt.to_isNat ⋯) ⋯))\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","name":["this"],"isProp":true,"id":["_uniq",188931]},{"type":"ℤ","name":["a✝"],"isProp":false,"id":["_uniq",200344],"binderInfo":"default"}]},{"type":"s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1) - 1 ∨ 2 ^ (K + 1) ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1 → s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",203966],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.pow_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.pow_add\n                            (Mathlib.Tactic.Ring.single_pow\n                              (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                  (Eq.refl (Int.negOfNat 2))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 2).rawCast +\n                              0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero (Mathlib.Meta.NormNum.IsInt.to_isNat ⋯) ⋯))\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","name":["this"],"isProp":true,"id":["_uniq",188931]},{"type":"ℤ","name":["a✝"],"isProp":false,"id":["_uniq",200344],"binderInfo":"default"}]}],"start":6191},{"state":[{"type":"s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1) - 1 ∨ 2 ^ (K + 1) ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1 → s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",203966],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.pow_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.pow_add\n                            (Mathlib.Tactic.Ring.single_pow\n                              (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                  (Eq.refl (Int.negOfNat 2))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 2).rawCast +\n                              0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero (Mathlib.Meta.NormNum.IsInt.to_isNat ⋯) ⋯))\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","name":["this"],"isProp":true,"id":["_uniq",188931]},{"type":"ℤ","name":["a✝"],"isProp":false,"id":["_uniq",200344],"binderInfo":"default"}]}],"start":6242},{"state":[{"type":"s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1","tag":["h","e'_2","h","h","mpr","inl","intro"],"mvarId":["_uniq",206919],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.pow_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.pow_add\n                            (Mathlib.Tactic.Ring.single_pow\n                              (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                  (Eq.refl (Int.negOfNat 2))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 2).rawCast +\n                              0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero (Mathlib.Meta.NormNum.IsInt.to_isNat ⋯) ⋯))\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","name":["this"],"isProp":true,"id":["_uniq",188931]},{"type":"ℤ","name":["a✝"],"isProp":false,"id":["_uniq",200344],"binderInfo":"default"},{"type":"s.m ≤ a✝","name":["h1"],"isProp":true,"id":["_uniq",206917],"binderInfo":"default"},{"type":"a✝ ≤ 2 ^ (K + 1) - 1","name":["h2"],"isProp":true,"id":["_uniq",206918],"binderInfo":"default"}]},{"type":"s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1","tag":["h","e'_2","h","h","mpr","inr","intro"],"mvarId":["_uniq",206937],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.pow_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.pow_add\n                            (Mathlib.Tactic.Ring.single_pow\n                              (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                  (Eq.refl (Int.negOfNat 2))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 2).rawCast +\n                              0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero (Mathlib.Meta.NormNum.IsInt.to_isNat ⋯) ⋯))\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","name":["this"],"isProp":true,"id":["_uniq",188931]},{"type":"ℤ","name":["a✝"],"isProp":false,"id":["_uniq",200344],"binderInfo":"default"},{"type":"2 ^ (K + 1) ≤ a✝","name":["h1"],"isProp":true,"id":["_uniq",206935],"binderInfo":"default"},{"type":"a✝ ≤ 2 ^ (K + 1 + 1) - 1","name":["h2"],"isProp":true,"id":["_uniq",206936],"binderInfo":"default"}]}],"start":6291},{"state":[{"type":"s.m ≤ a✝ ∧ a✝ ≤ 2 ^ (K + 1 + 1) - 1","tag":["h","e'_2","h","h","mpr","inr","intro"],"mvarId":["_uniq",206937],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n  Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.pow_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                          (Mathlib.Tactic.Ring.pow_add\n                            (Mathlib.Tactic.Ring.single_pow\n                              (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                  (Eq.refl (Int.negOfNat 2))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 2).rawCast +\n                              0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero (Mathlib.Meta.NormNum.IsInt.to_isNat ⋯) ⋯))\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯))\n        ⋯)","type":"Disjoint (Finset.Icc s.m (2 ^ (K + 1) - 1)) (Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1))","name":["this"],"isProp":true,"id":["_uniq",188931]},{"type":"ℤ","name":["a✝"],"isProp":false,"id":["_uniq",200344],"binderInfo":"default"},{"type":"2 ^ (K + 1) ≤ a✝","name":["h1"],"isProp":true,"id":["_uniq",206935],"binderInfo":"default"},{"type":"a✝ ≤ 2 ^ (K + 1 + 1) - 1","name":["h2"],"isProp":true,"id":["_uniq",206936],"binderInfo":"default"}]}],"start":6340},{"state":[],"start":6372},{"state":[{"type":"S (2 ^ (K + 1) - 1) + ∑ n ∈ Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1), s.seq n ≤\n  S (2 ^ (K + 1) - 1) + ∑ n ∈ Finset.Icc (2 ^ (K + 1)) (2 ^ (K + 1 + 1) - 1), s.seq (2 ^ (K + 1))","tag":[],"mvarId":["_uniq",187315],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]}]}],"start":6468},{"state":[],"start":6540},{"state":[{"type":"S (2 ^ (K + 1 + 1) - 1) ≤ T (↑(K + 1) : ℤ) ∧ T (↑(K + 1) : ℤ) ≤ 2 * S (2 ^ (K + 1))","tag":["succ"],"mvarId":["_uniq",187801],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",40871],"binderInfo":"default"},{"type":"1 ≤ 2 ^ K","name":["h2K"],"isProp":true,"id":["_uniq",108353],"binderInfo":"default"},{"type":"1 ≤ 2 ^ (K + 1)","name":["h2K'"],"isProp":true,"id":["_uniq",109321],"binderInfo":"default"},{"type":"S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ)","name":["hK1"],"isProp":true,"id":["_uniq",109326],"binderInfo":"default"},{"type":"T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["hK2"],"isProp":true,"id":["_uniq",109330],"binderInfo":"default"},{"value":"partial_succ t (cauchy_criterion._proof_6 hmono ht hmono' htm K h2K h2K' hK1 hK2)","type":"T ((↑K : ℤ) + 1) = T (↑K : ℤ) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim1"],"isProp":true,"id":["_uniq",109887]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                  0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (x ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * (Int.negOfNat 1).rawCast +\n                                0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.pow_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                            (Mathlib.Tactic.Ring.atom_pf K)\n                            (Mathlib.Tactic.Ring.pow_add\n                              (Mathlib.Tactic.Ring.single_pow\n                                (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2) (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                    (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf y)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1)) ≥ S (2 ^ K) + 2 ^ K * s.seq (2 ^ (K + 1))","name":["claim2a"],"isProp":true,"id":["_uniq",117250]},{"value":"Eq.mpr (id (congrArg (fun _a => 2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + _a * s.seq (2 ^ (K + 1))) (pow_succ' 2 K)))\n  (cauchy_criterion._proof_9 hmono ht hmono' htm K h2K h2K' hK1 hK2 claim1 claim2a)","type":"2 * S (2 ^ (K + 1)) ≥ 2 * S (2 ^ K) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim2"],"isProp":true,"id":["_uniq",178246]},{"value":"Trans.trans\n  (Trans.trans\n    (have this :=\n      Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_iff_ne))) fun x hx y hy =>\n        Not.intro fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.neg_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1)))))\n                            Mathlib.Tactic.Ring.neg_zero))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x)\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.pow_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf K)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (K ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.pow_one_cast (Nat.rawCast 2 + 0))\n                                (Mathlib.Tactic.Ring.pow_add\n                                  (Mathlib.Tactic.Ring.single_pow\n                                    (Mathlib.Tactic.Ring.pow_prod_atom (Nat.rawCast 2)\n                                      (K ^ Nat.rawCast 1 * Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.pow_zero (Nat.rawCast 2 + 0))\n                                  (Mathlib.Tactic.Ring.add_mul\n                                    (Mathlib.Tactic.Ring.mul_add\n                                      (Mathlib.Tactic.Ring.mul_pf_left (Nat.rawCast 2 + 0)\n                                        (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                      (Mathlib.Tactic.Ring.mul_zero\n                                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 +\n                                          0)))\n                                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 2 + 0)\n                                      (K ^ Nat.rawCast 1 * Nat.rawCast 1) (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                                    ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.rawCast 2 + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 2 + 0) (K ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                        (Eq.refl (Int.negOfNat 2))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  ((Nat.rawCast 2 + 0) ^ (K ^ Nat.rawCast 1 * Nat.rawCast ⋯) * ⋯ + ⋯))))))\n                        ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯);\n    ⋯)\n    ⋯)\n  ⋯","type":"S (2 ^ (K + 1 + 1) - 1) ≤ S (2 ^ (K + 1) - 1) + 2 ^ (K + 1) * s.seq (2 ^ (K + 1))","name":["claim3"],"isProp":true,"id":["_uniq",187800]}]}],"start":6601},{"state":[{"type":"(∃ M, ∀ (N : ℤ), S N ≤ M) ↔ ∃ M, ∀ (N : ℤ), T N ≤ M","tag":[],"mvarId":["_uniq",40853],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]}]}],"start":6633},{"state":[{"type":"(∃ M, ∀ (N : ℤ), S N ≤ M) → ∃ M, ∀ (N : ℤ), T N ≤ M","tag":["mp"],"mvarId":["_uniq",252096],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]}]},{"type":"(∃ M, ∀ (N : ℤ), T N ≤ M) → ∃ M, ∀ (N : ℤ), S N ≤ M","tag":["mpr"],"mvarId":["_uniq",252097],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]}]}],"start":6647},{"state":[{"type":"T N ≤ 2 * M","tag":["h","inl"],"mvarId":["_uniq",252449],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",252144],"binderInfo":"default"},{"type":"∀ (N : ℤ), S N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",252145],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",252401],"binderInfo":"default"},{"type":"N < 0","name":["hN"],"isProp":true,"id":["_uniq",252448],"binderInfo":"default"}]},{"type":"T N ≤ 2 * M","tag":["h","inr"],"mvarId":["_uniq",252454],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",252144],"binderInfo":"default"},{"type":"∀ (N : ℤ), S N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",252145],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",252401],"binderInfo":"default"},{"type":"0 ≤ N","name":["hN"],"isProp":true,"id":["_uniq",252453],"binderInfo":"default"}]}],"start":6721},{"state":[{"type":"T N ≤ 2 * M","tag":["h","inr"],"mvarId":["_uniq",252454],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",252144],"binderInfo":"default"},{"type":"∀ (N : ℤ), S N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",252145],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",252401],"binderInfo":"default"},{"type":"0 ≤ N","name":["hN"],"isProp":true,"id":["_uniq",252453],"binderInfo":"default"}]}],"start":6805},{"state":[{"type":"(∃ M, ∀ (N : ℤ), T N ≤ M) → ∃ M, ∀ (N : ℤ), S N ≤ M","tag":["mpr"],"mvarId":["_uniq",252097],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]}]}],"start":6886},{"state":[{"type":"S K' ≤ M","tag":["h","inl"],"mvarId":["_uniq",266769],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",266560],"binderInfo":"default"},{"type":"∀ (N : ℤ), T N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",266561],"binderInfo":"default"},{"type":"ℤ","name":["K'"],"isProp":false,"id":["_uniq",266718],"binderInfo":"default"},{"type":"K' < 1","name":["hK'"],"isProp":true,"id":["_uniq",266768],"binderInfo":"default"}]},{"type":"S K' ≤ M","tag":["h","inr"],"mvarId":["_uniq",266774],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",266560],"binderInfo":"default"},{"type":"∀ (N : ℤ), T N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",266561],"binderInfo":"default"},{"type":"ℤ","name":["K'"],"isProp":false,"id":["_uniq",266718],"binderInfo":"default"},{"type":"1 ≤ K'","name":["hK'"],"isProp":true,"id":["_uniq",266773],"binderInfo":"default"}]}],"start":6960},{"state":[{"type":"S K' ≤ M","tag":["h","inr"],"mvarId":["_uniq",266774],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",266560],"binderInfo":"default"},{"type":"∀ (N : ℤ), T N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",266561],"binderInfo":"default"},{"type":"ℤ","name":["K'"],"isProp":false,"id":["_uniq",266718],"binderInfo":"default"},{"type":"1 ≤ K'","name":["hK'"],"isProp":true,"id":["_uniq",266773],"binderInfo":"default"}]}],"start":7015},{"state":[{"type":"S K' ≤ M","tag":["h","inr"],"mvarId":["_uniq",270522],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",266560],"binderInfo":"default"},{"type":"∀ (N : ℤ), T N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",266561],"binderInfo":"default"},{"type":"ℤ","name":["K'"],"isProp":false,"id":["_uniq",266718],"binderInfo":"default"},{"type":"1 ≤ K'","name":["hK'"],"isProp":true,"id":["_uniq",266773],"binderInfo":"default"},{"value":"(K' - 1).toNat","type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",270222]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => K' = _a + 1)\n      (Int.toNat_of_nonneg\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.atom_pf K')\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul K' (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf K')\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1)))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero K' (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le hK'))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))))))\n  (Eq.trans (Mathlib.Tactic.Abel.term_atomg K')\n    (Eq.symm\n      (Mathlib.Tactic.Abel.subst_into_addg (K' - 1) 1\n        (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0)) (Mathlib.Tactic.Abel.termg 1 1 0)\n        (Mathlib.Tactic.Abel.termg 1 K' 0)\n        (Mathlib.Tactic.Abel.unfold_sub K' 1 (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n          (Mathlib.Tactic.Abel.subst_into_addg K' (-1) (Mathlib.Tactic.Abel.termg 1 K' 0)\n            (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n            (Mathlib.Tactic.Abel.term_atomg K')\n            (Mathlib.Tactic.Abel.subst_into_negg 1 (Mathlib.Tactic.Abel.termg 1 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.term_atomg 1)\n              (Mathlib.Tactic.Abel.term_neg 1 1 0 (-1) 0 (Eq.refl (-1)) neg_zero))\n            (Mathlib.Tactic.Abel.term_add_constg 1 K' 0 (Mathlib.Tactic.Abel.termg (-1) 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (zero_add (Mathlib.Tactic.Abel.termg (-1) 1 0)))))\n        (Mathlib.Tactic.Abel.term_atomg 1)\n        (Mathlib.Tactic.Abel.term_add_constg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 1 0)\n          0\n          (Eq.trans\n            (Mathlib.Tactic.Abel.term_add_termg (-1) 1 0 1 0 0 0\n              (Mathlib.Meta.NormNum.IsNat.to_eq\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.isInt_neg (Eq.refl Neg.neg)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Eq.refl (Int.negOfNat 1)))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Eq.refl (Int.ofNat 0))))\n                (Eq.refl 0))\n              (zero_add 0))\n            (Mathlib.Tactic.Abel.zero_termg 1 0))))))","type":"K' = (↑K : ℤ) + 1","name":["hK"],"isProp":true,"id":["_uniq",270521]}]}],"start":7112},{"state":[{"type":"S K' ≤ M","tag":["h","inr"],"mvarId":["_uniq",270522],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",266560],"binderInfo":"default"},{"type":"∀ (N : ℤ), T N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",266561],"binderInfo":"default"},{"type":"ℤ","name":["K'"],"isProp":false,"id":["_uniq",266718],"binderInfo":"default"},{"type":"1 ≤ K'","name":["hK'"],"isProp":true,"id":["_uniq",266773],"binderInfo":"default"},{"value":"(K' - 1).toNat","type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",270222]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => K' = _a + 1)\n      (Int.toNat_of_nonneg\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.atom_pf K')\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul K' (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf K')\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1)))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero K' (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le hK'))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))))))\n  (Eq.trans (Mathlib.Tactic.Abel.term_atomg K')\n    (Eq.symm\n      (Mathlib.Tactic.Abel.subst_into_addg (K' - 1) 1\n        (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0)) (Mathlib.Tactic.Abel.termg 1 1 0)\n        (Mathlib.Tactic.Abel.termg 1 K' 0)\n        (Mathlib.Tactic.Abel.unfold_sub K' 1 (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n          (Mathlib.Tactic.Abel.subst_into_addg K' (-1) (Mathlib.Tactic.Abel.termg 1 K' 0)\n            (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n            (Mathlib.Tactic.Abel.term_atomg K')\n            (Mathlib.Tactic.Abel.subst_into_negg 1 (Mathlib.Tactic.Abel.termg 1 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.term_atomg 1)\n              (Mathlib.Tactic.Abel.term_neg 1 1 0 (-1) 0 (Eq.refl (-1)) neg_zero))\n            (Mathlib.Tactic.Abel.term_add_constg 1 K' 0 (Mathlib.Tactic.Abel.termg (-1) 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (zero_add (Mathlib.Tactic.Abel.termg (-1) 1 0)))))\n        (Mathlib.Tactic.Abel.term_atomg 1)\n        (Mathlib.Tactic.Abel.term_add_constg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 1 0)\n          0\n          (Eq.trans\n            (Mathlib.Tactic.Abel.term_add_termg (-1) 1 0 1 0 0 0\n              (Mathlib.Meta.NormNum.IsNat.to_eq\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.isInt_neg (Eq.refl Neg.neg)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Eq.refl (Int.negOfNat 1)))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Eq.refl (Int.ofNat 0))))\n                (Eq.refl 0))\n              (zero_add 0))\n            (Mathlib.Tactic.Abel.zero_termg 1 0))))))","type":"K' = (↑K : ℤ) + 1","name":["hK"],"isProp":true,"id":["_uniq",270521]}]}],"start":7119},{"state":[{"type":"S K' ≤ S (2 ^ (K + 1) - 1)","tag":[],"mvarId":["_uniq",271910],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",266560],"binderInfo":"default"},{"type":"∀ (N : ℤ), T N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",266561],"binderInfo":"default"},{"type":"ℤ","name":["K'"],"isProp":false,"id":["_uniq",266718],"binderInfo":"default"},{"type":"1 ≤ K'","name":["hK'"],"isProp":true,"id":["_uniq",266773],"binderInfo":"default"},{"value":"(K' - 1).toNat","type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",270222]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => K' = _a + 1)\n      (Int.toNat_of_nonneg\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.atom_pf K')\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul K' (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf K')\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1)))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero K' (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le hK'))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))))))\n  (Eq.trans (Mathlib.Tactic.Abel.term_atomg K')\n    (Eq.symm\n      (Mathlib.Tactic.Abel.subst_into_addg (K' - 1) 1\n        (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0)) (Mathlib.Tactic.Abel.termg 1 1 0)\n        (Mathlib.Tactic.Abel.termg 1 K' 0)\n        (Mathlib.Tactic.Abel.unfold_sub K' 1 (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n          (Mathlib.Tactic.Abel.subst_into_addg K' (-1) (Mathlib.Tactic.Abel.termg 1 K' 0)\n            (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n            (Mathlib.Tactic.Abel.term_atomg K')\n            (Mathlib.Tactic.Abel.subst_into_negg 1 (Mathlib.Tactic.Abel.termg 1 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.term_atomg 1)\n              (Mathlib.Tactic.Abel.term_neg 1 1 0 (-1) 0 (Eq.refl (-1)) neg_zero))\n            (Mathlib.Tactic.Abel.term_add_constg 1 K' 0 (Mathlib.Tactic.Abel.termg (-1) 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (zero_add (Mathlib.Tactic.Abel.termg (-1) 1 0)))))\n        (Mathlib.Tactic.Abel.term_atomg 1)\n        (Mathlib.Tactic.Abel.term_add_constg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 1 0)\n          0\n          (Eq.trans\n            (Mathlib.Tactic.Abel.term_add_termg (-1) 1 0 1 0 0 0\n              (Mathlib.Meta.NormNum.IsNat.to_eq\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.isInt_neg (Eq.refl Neg.neg)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Eq.refl (Int.negOfNat 1)))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Eq.refl (Int.ofNat 0))))\n                (Eq.refl 0))\n              (zero_add 0))\n            (Mathlib.Tactic.Abel.zero_termg 1 0))))))","type":"K' = (↑K : ℤ) + 1","name":["hK"],"isProp":true,"id":["_uniq",270521]}]}],"start":7153},{"state":[{"type":"(↑K : ℤ) + 1 ≤ 2 ^ (K + 1) - 1","tag":["a","_@","Mathlib","Order","Monotone","Defs","_hyg",63],"mvarId":["_uniq",272123],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",266560],"binderInfo":"default"},{"type":"∀ (N : ℤ), T N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",266561],"binderInfo":"default"},{"type":"ℤ","name":["K'"],"isProp":false,"id":["_uniq",266718],"binderInfo":"default"},{"type":"1 ≤ K'","name":["hK'"],"isProp":true,"id":["_uniq",266773],"binderInfo":"default"},{"value":"(K' - 1).toNat","type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",270222]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => K' = _a + 1)\n      (Int.toNat_of_nonneg\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.atom_pf K')\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul K' (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf K')\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1)))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero K' (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le hK'))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))))))\n  (Eq.trans (Mathlib.Tactic.Abel.term_atomg K')\n    (Eq.symm\n      (Mathlib.Tactic.Abel.subst_into_addg (K' - 1) 1\n        (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0)) (Mathlib.Tactic.Abel.termg 1 1 0)\n        (Mathlib.Tactic.Abel.termg 1 K' 0)\n        (Mathlib.Tactic.Abel.unfold_sub K' 1 (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n          (Mathlib.Tactic.Abel.subst_into_addg K' (-1) (Mathlib.Tactic.Abel.termg 1 K' 0)\n            (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n            (Mathlib.Tactic.Abel.term_atomg K')\n            (Mathlib.Tactic.Abel.subst_into_negg 1 (Mathlib.Tactic.Abel.termg 1 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.term_atomg 1)\n              (Mathlib.Tactic.Abel.term_neg 1 1 0 (-1) 0 (Eq.refl (-1)) neg_zero))\n            (Mathlib.Tactic.Abel.term_add_constg 1 K' 0 (Mathlib.Tactic.Abel.termg (-1) 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (zero_add (Mathlib.Tactic.Abel.termg (-1) 1 0)))))\n        (Mathlib.Tactic.Abel.term_atomg 1)\n        (Mathlib.Tactic.Abel.term_add_constg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 1 0)\n          0\n          (Eq.trans\n            (Mathlib.Tactic.Abel.term_add_termg (-1) 1 0 1 0 0 0\n              (Mathlib.Meta.NormNum.IsNat.to_eq\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.isInt_neg (Eq.refl Neg.neg)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Eq.refl (Int.negOfNat 1)))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Eq.refl (Int.ofNat 0))))\n                (Eq.refl 0))\n              (zero_add 0))\n            (Mathlib.Tactic.Abel.zero_termg 1 0))))))","type":"K' = (↑K : ℤ) + 1","name":["hK"],"isProp":true,"id":["_uniq",270521]}]}],"start":7195},{"state":[{"type":"(↑(n + 1) : ℤ) + 1 ≤ 2 ^ (n + 1 + 1) - 1","tag":["a","succ","_@","Mathlib","Order","Monotone","Defs","_hyg",63],"mvarId":["_uniq",272170],"isProp":false,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21391],"binderInfo":"implicit"},{"type":"s.m = 1","name":["hm"],"isProp":true,"id":["_uniq",21392],"binderInfo":"default"},{"type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",21393],"binderInfo":"default"},{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",21394],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }","type":"Series","name":["t"],"isProp":false,"id":["_uniq",22328]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => x ≥ 0)\n              (ite_cond_eq_true ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n            ge_iff_le._simp_1)\n          (mul_nonneg_iff_of_pos_left._simp_1\n            (of_eq_true (pow_pos._simp_1 (of_eq_true Nat.ofNat_pos._simp_1) n.toNat)))))\n      (cauchy_criterion._proof_1 hs hmono n h)\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_cond_eq_false ((fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"t.nonneg","name":["ht"],"isProp":true,"id":["_uniq",22396]},{"value":"fun n hn m hm =>\n  Exists.casesOn (Int.le.dest hm) fun k h =>\n    Eq.ndrec (motive := fun m => m ≥ n → s.seq m ≤ s.seq n)\n      (fun hm =>\n        Nat.recAux\n          (of_eq_true\n            (Eq.trans\n              (congrArg (fun x => s.seq x ≤ s.seq n)\n                (Eq.trans (congrArg (HAdd.hAdd n) (CharP.cast_eq_zero ℤ 0)) (add_zero n)))\n              (le_refl._simp_1 (s.seq n))))\n          (fun k hk =>\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self self' e'_2 a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun self' =>\n                          ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a') (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl self') (HEq.refl e'_2))\n                  ℝ instLE instPreorder.toLE (Eq.refl instLE) (s.seq (n + (↑(k + 1) : ℤ))) (s.seq (n + (↑k : ℤ) + 1))\n                  (eq_of_heq\n                    ((fun self a a' e'_2 =>\n                        Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_2 ≍ x → self.seq a ≍ self.seq a') e'_2\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → self.seq a ≍ self.seq a')\n                              (fun e_2 h => HEq.refl (self.seq a)) (Eq.symm h) e'_2)\n                          (Eq.refl a') (HEq.refl e'_2))\n                      s (n + (↑(k + 1) : ℤ)) (n + (↑k : ℤ) + 1) (cauchy_criterion._proof_4 hmono ht n hn k hk)))\n                  (s.seq n)))\n              (LE.le.trans (hmono (n + (↑k : ℤ)) (cauchy_criterion._proof_3 hmono ht n hn k hk)) hk))\n          k)\n      h hm","type":"∀ n ≥ 1, ∀ m ≥ n, s.seq m ≤ s.seq n","name":["hmono'"],"isProp":true,"id":["_uniq",30283]},{"value":"of_eq_true (eq_self 0)","type":"t.m = 0","name":["htm"],"isProp":true,"id":["_uniq",40030]},{"value":"s.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",40146]},{"value":"t.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",40274]},{"value":"fun K =>\n  Nat.recAux\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (congr\n                  (congrArg LE.le\n                    (Eq.trans\n                      (congrArg (fun x => s.partial (x - 1))\n                        (Eq.trans (congrArg (HPow.hPow 2) (zero_add 1)) (pow_one 2)))\n                      (Eq.trans\n                        (Finset.sum_congr (Eq.trans (congrArg (fun x => Finset.Icc x 1) hm) (Finset.Icc_self 1))\n                          fun x a => Eq.refl (s.seq x))\n                        (Finset.sum_singleton s.seq 1))))\n                  (Eq.trans\n                    (congr\n                      (congrArg «partial»\n                        ((fun m m_1 e_m =>\n                            Eq.rec (motive := fun m_2 e_m =>\n                              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m_2, seq := seq_1,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                              (fun seq seq_1 e_seq =>\n                                Eq.rec (motive := fun seq_2 e_seq =>\n                                  ∀ (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m, seq := seq_2,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                            (Eq.refl m) })\n                                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                              e_m)\n                          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0)\n                          (fun n => if 0 ≤ n then 2 ^ n.toNat * s.seq (2 ^ n.toNat) else 0)\n                          (funext fun n =>\n                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (2 ^ n.toNat * s.seq (2 ^ n.toNat))) fun a =>\n                              Eq.refl 0)\n                          (instCoe._proof_1 fun k => 2 ^ k * s.seq (2 ^ k))))\n                      (CharP.cast_eq_zero ℤ 0))\n                    (Eq.trans ⋯ ⋯)))\n                ⋯))\n            ⋯)\n          ⋯))\n      ⋯)\n    ⋯ ⋯","type":"∀ (K : ℕ), S (2 ^ (K + 1) - 1) ≤ T (↑K : ℤ) ∧ T (↑K : ℤ) ≤ 2 * S (2 ^ K)","name":["Lemma_7_3_6"],"isProp":true,"id":["_uniq",40852]},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",266560],"binderInfo":"default"},{"type":"∀ (N : ℤ), T N ≤ M","name":["hM"],"isProp":true,"id":["_uniq",266561],"binderInfo":"default"},{"type":"ℤ","name":["K'"],"isProp":false,"id":["_uniq",266718],"binderInfo":"default"},{"type":"1 ≤ K'","name":["hK'"],"isProp":true,"id":["_uniq",266773],"binderInfo":"default"},{"value":"(K' - 1).toNat","type":"ℕ","name":["K"],"isProp":false,"id":["_uniq",270222]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => K' = _a + 1)\n      (Int.toNat_of_nonneg\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.atom_pf K')\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul K' (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (K' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf K')\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1)))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.ofNat 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (K' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero K' (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le hK'))\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))))))\n  (Eq.trans (Mathlib.Tactic.Abel.term_atomg K')\n    (Eq.symm\n      (Mathlib.Tactic.Abel.subst_into_addg (K' - 1) 1\n        (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0)) (Mathlib.Tactic.Abel.termg 1 1 0)\n        (Mathlib.Tactic.Abel.termg 1 K' 0)\n        (Mathlib.Tactic.Abel.unfold_sub K' 1 (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n          (Mathlib.Tactic.Abel.subst_into_addg K' (-1) (Mathlib.Tactic.Abel.termg 1 K' 0)\n            (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0))\n            (Mathlib.Tactic.Abel.term_atomg K')\n            (Mathlib.Tactic.Abel.subst_into_negg 1 (Mathlib.Tactic.Abel.termg 1 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.term_atomg 1)\n              (Mathlib.Tactic.Abel.term_neg 1 1 0 (-1) 0 (Eq.refl (-1)) neg_zero))\n            (Mathlib.Tactic.Abel.term_add_constg 1 K' 0 (Mathlib.Tactic.Abel.termg (-1) 1 0)\n              (Mathlib.Tactic.Abel.termg (-1) 1 0) (zero_add (Mathlib.Tactic.Abel.termg (-1) 1 0)))))\n        (Mathlib.Tactic.Abel.term_atomg 1)\n        (Mathlib.Tactic.Abel.term_add_constg 1 K' (Mathlib.Tactic.Abel.termg (-1) 1 0) (Mathlib.Tactic.Abel.termg 1 1 0)\n          0\n          (Eq.trans\n            (Mathlib.Tactic.Abel.term_add_termg (-1) 1 0 1 0 0 0\n              (Mathlib.Meta.NormNum.IsNat.to_eq\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.isInt_neg (Eq.refl Neg.neg)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Eq.refl (Int.negOfNat 1)))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Eq.refl (Int.ofNat 0))))\n                (Eq.refl 0))\n              (zero_add 0))\n            (Mathlib.Tactic.Abel.zero_termg 1 0))))))","type":"K' = (↑K : ℤ) + 1","name":["hK"],"isProp":true,"id":["_uniq",270521]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",272166],"binderInfo":"default"},{"type":"(↑n : ℤ) + 1 ≤ 2 ^ (n + 1) - 1","name":["hn"],"isProp":true,"id":["_uniq",272167],"binderInfo":"default"}]}],"start":7248},{"state":[],"start":7285},{"state":[],"start":7320},{"state":[],"start":7340},{"state":[],"start":7341},{"state":[],"start":7364},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).converges ↔ q > 1","tag":[],"mvarId":["_uniq",296142],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"}]}],"start":7496},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).converges ↔ q > 1","tag":[],"mvarId":["_uniq",296142],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"}]}],"start":7569},{"state":[{"type":"s.converges ↔ q > 1","tag":[],"mvarId":["_uniq",297179],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]}]}],"start":7630},{"state":[{"type":"s.converges ↔ q > 1","tag":[],"mvarId":["_uniq",297212],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]}]}],"start":7722},{"state":[{"type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","tag":[],"mvarId":["_uniq",304316],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]}]}],"start":7780},{"state":[{"type":"s.seq (n + 1) ≤ s.seq n","tag":[],"mvarId":["_uniq",304329],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",304325],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",304328],"binderInfo":"default"}]}],"start":7795},{"state":[{"type":"s.seq (n + 1) ≤ s.seq n","tag":[],"mvarId":["_uniq",304366],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",304325],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",304328],"binderInfo":"default"},{"value":"le_of_lt\n  (lt_of_lt_of_le\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))) hn)","type":"n ≥ 0","name":["hn1"],"isProp":true,"id":["_uniq",304365]}]}],"start":7835},{"state":[{"type":"s.seq (n + 1) ≤ s.seq n","tag":[],"mvarId":["_uniq",305027],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",304325],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",304328],"binderInfo":"default"},{"value":"le_of_lt\n  (lt_of_lt_of_le\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))) hn)","type":"n ≥ 0","name":["hn1"],"isProp":true,"id":["_uniq",304365]},{"value":"Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a","type":"n.toNat > 0","name":["hn3"],"isProp":true,"id":["_uniq",305026]}]}],"start":7874},{"state":[{"type":"(((↑n : ℝ) + 1) ^ q)⁻¹ ≤ ((↑n : ℝ) ^ q)⁻¹","tag":[],"mvarId":["_uniq",308959],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",304325],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",304328],"binderInfo":"default"},{"value":"le_of_lt\n  (lt_of_lt_of_le\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))) hn)","type":"n ≥ 0","name":["hn1"],"isProp":true,"id":["_uniq",304365]},{"value":"Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a","type":"n.toNat > 0","name":["hn3"],"isProp":true,"id":["_uniq",305026]}]}],"start":7896},{"state":[{"type":"(↑n : ℝ) ≤ (↑n : ℝ) + 1","tag":["hba","h₁"],"mvarId":["_uniq",310885],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",304325],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",304328],"binderInfo":"default"},{"value":"le_of_lt\n  (lt_of_lt_of_le\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))) hn)","type":"n ≥ 0","name":["hn1"],"isProp":true,"id":["_uniq",304365]},{"value":"Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a","type":"n.toNat > 0","name":["hn3"],"isProp":true,"id":["_uniq",305026]}]}],"start":7959},{"state":[{"type":"s.converges ↔ q > 1","tag":[],"mvarId":["_uniq",304320],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"value":"fun n hn =>\n  have hn1 :=\n    le_of_lt\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn);\n  have hn3 := Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a;\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg LE.le\n            (Eq.trans\n              (dite_cond_eq_true\n                (Eq.trans ge_iff_le._simp_1 (Eq.trans (le_mul_iff_one_le_left'._simp_4 1) (eq_true hn1))))\n              (Eq.trans\n                (congrArg (fun x => 1 / x ^ q)\n                  (Eq.trans (Int.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℝ)) Int.cast_one)))\n                (one_div (((↑n : ℝ) + 1) ^ q)))))\n          (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hn))) (one_div ((↑n : ℝ) ^ q))))\n        ge_iff_le._simp_1))\n    (inv_anti₀\n      (rpow_pos_of_pos\n        (Int.cast_pos.mpr\n          (lt_of_lt_of_le\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n              (Eq.refl (Nat.ble 1 1)))\n            hn))\n        q)\n      (rpow_le_rpow\n        (le_of_lt\n          (Int.cast_pos.mpr\n            (lt_of_lt_of_le\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                (Eq.refl (Nat.ble 1 1)))\n              hn)))\n        (of_eq_true (Eq.trans (le_mul_iff_one_le_right'._simp_4 (↑n : ℝ)) zero_le_one._simp_1)) (le_of_lt hq)))","type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",304317]}]}],"start":7968},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }.converges ↔ q > 1","tag":[],"mvarId":["_uniq",316932],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"value":"fun n hn =>\n  have hn1 :=\n    le_of_lt\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn);\n  have hn3 := Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a;\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg LE.le\n            (Eq.trans\n              (dite_cond_eq_true\n                (Eq.trans ge_iff_le._simp_1 (Eq.trans (le_mul_iff_one_le_left'._simp_4 1) (eq_true hn1))))\n              (Eq.trans\n                (congrArg (fun x => 1 / x ^ q)\n                  (Eq.trans (Int.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℝ)) Int.cast_one)))\n                (one_div (((↑n : ℝ) + 1) ^ q)))))\n          (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hn))) (one_div ((↑n : ℝ) ^ q))))\n        ge_iff_le._simp_1))\n    (inv_anti₀\n      (rpow_pos_of_pos\n        (Int.cast_pos.mpr\n          (lt_of_lt_of_le\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n              (Eq.refl (Nat.ble 1 1)))\n            hn))\n        q)\n      (rpow_le_rpow\n        (le_of_lt\n          (Int.cast_pos.mpr\n            (lt_of_lt_of_le\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                (Eq.refl (Nat.ble 1 1)))\n              hn)))\n        (of_eq_true (Eq.trans (le_mul_iff_one_le_right'._simp_4 (↑n : ℝ)) zero_le_one._simp_1)) (le_of_lt hq)))","type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",304317]}]}],"start":8015},{"state":[{"type":"2 ^ n * s.seq (2 ^ n) = (2 ^ (1 - q)) ^ n","tag":[],"mvarId":["_uniq",317364],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"value":"fun n hn =>\n  have hn1 :=\n    le_of_lt\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn);\n  have hn3 := Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a;\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg LE.le\n            (Eq.trans\n              (dite_cond_eq_true\n                (Eq.trans ge_iff_le._simp_1 (Eq.trans (le_mul_iff_one_le_left'._simp_4 1) (eq_true hn1))))\n              (Eq.trans\n                (congrArg (fun x => 1 / x ^ q)\n                  (Eq.trans (Int.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℝ)) Int.cast_one)))\n                (one_div (((↑n : ℝ) + 1) ^ q)))))\n          (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hn))) (one_div ((↑n : ℝ) ^ q))))\n        ge_iff_le._simp_1))\n    (inv_anti₀\n      (rpow_pos_of_pos\n        (Int.cast_pos.mpr\n          (lt_of_lt_of_le\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n              (Eq.refl (Nat.ble 1 1)))\n            hn))\n        q)\n      (rpow_le_rpow\n        (le_of_lt\n          (Int.cast_pos.mpr\n            (lt_of_lt_of_le\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                (Eq.refl (Nat.ble 1 1)))\n              hn)))\n        (of_eq_true (Eq.trans (le_mul_iff_one_le_right'._simp_4 (↑n : ℝ)) zero_le_one._simp_1)) (le_of_lt hq)))","type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",304317]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",316959],"binderInfo":"default"}]}],"start":8070},{"state":[{"type":"2 ^ n * s.seq (2 ^ n) = (2 ^ (1 - q)) ^ n","tag":[],"mvarId":["_uniq",317453],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"value":"fun n hn =>\n  have hn1 :=\n    le_of_lt\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn);\n  have hn3 := Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a;\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg LE.le\n            (Eq.trans\n              (dite_cond_eq_true\n                (Eq.trans ge_iff_le._simp_1 (Eq.trans (le_mul_iff_one_le_left'._simp_4 1) (eq_true hn1))))\n              (Eq.trans\n                (congrArg (fun x => 1 / x ^ q)\n                  (Eq.trans (Int.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℝ)) Int.cast_one)))\n                (one_div (((↑n : ℝ) + 1) ^ q)))))\n          (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hn))) (one_div ((↑n : ℝ) ^ q))))\n        ge_iff_le._simp_1))\n    (inv_anti₀\n      (rpow_pos_of_pos\n        (Int.cast_pos.mpr\n          (lt_of_lt_of_le\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n              (Eq.refl (Nat.ble 1 1)))\n            hn))\n        q)\n      (rpow_le_rpow\n        (le_of_lt\n          (Int.cast_pos.mpr\n            (lt_of_lt_of_le\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                (Eq.refl (Nat.ble 1 1)))\n              hn)))\n        (of_eq_true (Eq.trans (le_mul_iff_one_le_right'._simp_4 (↑n : ℝ)) zero_le_one._simp_1)) (le_of_lt hq)))","type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",304317]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",316959],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (congrArg (fun x => x ≤ (↑2 : ℤ) ^ n) (Eq.symm Nat.cast_one))\n      (Eq.trans (congrArg (LE.le (↑1 : ℤ)) (Nat.cast_pow._simp_1 2 n)) Nat.cast_le._simp_1)))\n  Nat.one_le_two_pow","type":"1 ≤ 2 ^ n","name":["this"],"isProp":true,"id":["_uniq",317452]}]}],"start":8139},{"state":[{"type":"2 ^ n * ((2 ^ n) ^ q)⁻¹ = (2 ^ (1 - q)) ^ n","tag":[],"mvarId":["_uniq",319471],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"value":"fun n hn =>\n  have hn1 :=\n    le_of_lt\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn);\n  have hn3 := Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a;\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg LE.le\n            (Eq.trans\n              (dite_cond_eq_true\n                (Eq.trans ge_iff_le._simp_1 (Eq.trans (le_mul_iff_one_le_left'._simp_4 1) (eq_true hn1))))\n              (Eq.trans\n                (congrArg (fun x => 1 / x ^ q)\n                  (Eq.trans (Int.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℝ)) Int.cast_one)))\n                (one_div (((↑n : ℝ) + 1) ^ q)))))\n          (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hn))) (one_div ((↑n : ℝ) ^ q))))\n        ge_iff_le._simp_1))\n    (inv_anti₀\n      (rpow_pos_of_pos\n        (Int.cast_pos.mpr\n          (lt_of_lt_of_le\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n              (Eq.refl (Nat.ble 1 1)))\n            hn))\n        q)\n      (rpow_le_rpow\n        (le_of_lt\n          (Int.cast_pos.mpr\n            (lt_of_lt_of_le\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                (Eq.refl (Nat.ble 1 1)))\n              hn)))\n        (of_eq_true (Eq.trans (le_mul_iff_one_le_right'._simp_4 (↑n : ℝ)) zero_le_one._simp_1)) (le_of_lt hq)))","type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",304317]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",316959],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (congrArg (fun x => x ≤ (↑2 : ℤ) ^ n) (Eq.symm Nat.cast_one))\n      (Eq.trans (congrArg (LE.le (↑1 : ℤ)) (Nat.cast_pow._simp_1 2 n)) Nat.cast_le._simp_1)))\n  Nat.one_le_two_pow","type":"1 ≤ 2 ^ n","name":["this"],"isProp":true,"id":["_uniq",317452]}]}],"start":8158},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun k => 2 ^ k * s.seq (2 ^ k)) n.toNat else 0, vanish := ⋯ }.converges ↔ q > 1","tag":[],"mvarId":["_uniq",317367],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"value":"fun n hn =>\n  have hn1 :=\n    le_of_lt\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn);\n  have hn3 := Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a;\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg LE.le\n            (Eq.trans\n              (dite_cond_eq_true\n                (Eq.trans ge_iff_le._simp_1 (Eq.trans (le_mul_iff_one_le_left'._simp_4 1) (eq_true hn1))))\n              (Eq.trans\n                (congrArg (fun x => 1 / x ^ q)\n                  (Eq.trans (Int.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℝ)) Int.cast_one)))\n                (one_div (((↑n : ℝ) + 1) ^ q)))))\n          (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hn))) (one_div ((↑n : ℝ) ^ q))))\n        ge_iff_le._simp_1))\n    (inv_anti₀\n      (rpow_pos_of_pos\n        (Int.cast_pos.mpr\n          (lt_of_lt_of_le\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n              (Eq.refl (Nat.ble 1 1)))\n            hn))\n        q)\n      (rpow_le_rpow\n        (le_of_lt\n          (Int.cast_pos.mpr\n            (lt_of_lt_of_le\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                (Eq.refl (Nat.ble 1 1)))\n              hn)))\n        (of_eq_true (Eq.trans (le_mul_iff_one_le_right'._simp_4 (↑n : ℝ)) zero_le_one._simp_1)) (le_of_lt hq)))","type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",304317]},{"value":"fun n =>\n  have this :=\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≤ (↑2 : ℤ) ^ n) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (LE.le (↑1 : ℤ)) (Nat.cast_pow._simp_1 2 n)) Nat.cast_le._simp_1)))\n      Nat.one_le_two_pow;\n  Eq.mpr\n    (id\n      (congrArg (fun x => 2 ^ n * x = (2 ^ (1 - q)) ^ n)\n        (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true this)))\n          (Eq.trans\n            (congrArg (fun x => 1 / x ^ q) (Eq.trans (Int.cast_pow 2 n) (congrArg (fun x => x ^ n) (Int.cast_ofNat 2))))\n            (one_div ((2 ^ n) ^ q))))))\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => 2 ^ n * _a = (2 ^ (1 - q)) ^ n)\n          (Eq.symm\n            (rpow_neg\n              (le_of_lt\n                (pow_pos\n                  (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                    (Eq.refl (Nat.ble 1 2)))\n                  n))\n              q))))\n      (Eq.mpr (id (congrArg (fun _a => _a = (2 ^ (1 - q)) ^ n) (mul_comm (2 ^ n) ((2 ^ n) ^ (-q)))))\n        (Eq.mpr\n          (id\n            (congrArg (fun _a => _a = (2 ^ (1 - q)) ^ n)\n              (Eq.symm\n                (rpow_add_one\n                  (ne_of_gt\n                    (pow_pos\n                      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                        (Eq.refl (Nat.ble 1 2)))\n                      n))\n                  (-q)))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => (2 ^ n) ^ (-q + 1) = _a)\n                (rpow_pow_comm\n                  (le_of_lt\n                    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                      (Eq.refl (Nat.ble 1 2))))\n                  (1 - q) n)))\n            (converges_qseries._proof_2 q hs hmono n this)))))","type":"∀ (n : ℕ), 2 ^ n * s.seq (2 ^ n) = (2 ^ (1 - q)) ^ n","name":["this"],"isProp":true,"id":["_uniq",317366]}]}],"start":8249},{"state":[{"type":"|2 ^ (1 - q)| < 1 ↔ 1 < q","tag":[],"mvarId":["_uniq",328942],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"value":"fun n hn =>\n  have hn1 :=\n    le_of_lt\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn);\n  have hn3 := Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a;\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg LE.le\n            (Eq.trans\n              (dite_cond_eq_true\n                (Eq.trans ge_iff_le._simp_1 (Eq.trans (le_mul_iff_one_le_left'._simp_4 1) (eq_true hn1))))\n              (Eq.trans\n                (congrArg (fun x => 1 / x ^ q)\n                  (Eq.trans (Int.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℝ)) Int.cast_one)))\n                (one_div (((↑n : ℝ) + 1) ^ q)))))\n          (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hn))) (one_div ((↑n : ℝ) ^ q))))\n        ge_iff_le._simp_1))\n    (inv_anti₀\n      (rpow_pos_of_pos\n        (Int.cast_pos.mpr\n          (lt_of_lt_of_le\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n              (Eq.refl (Nat.ble 1 1)))\n            hn))\n        q)\n      (rpow_le_rpow\n        (le_of_lt\n          (Int.cast_pos.mpr\n            (lt_of_lt_of_le\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                (Eq.refl (Nat.ble 1 1)))\n              hn)))\n        (of_eq_true (Eq.trans (le_mul_iff_one_le_right'._simp_4 (↑n : ℝ)) zero_le_one._simp_1)) (le_of_lt hq)))","type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",304317]},{"value":"fun n =>\n  have this :=\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≤ (↑2 : ℤ) ^ n) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (LE.le (↑1 : ℤ)) (Nat.cast_pow._simp_1 2 n)) Nat.cast_le._simp_1)))\n      Nat.one_le_two_pow;\n  Eq.mpr\n    (id\n      (congrArg (fun x => 2 ^ n * x = (2 ^ (1 - q)) ^ n)\n        (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true this)))\n          (Eq.trans\n            (congrArg (fun x => 1 / x ^ q) (Eq.trans (Int.cast_pow 2 n) (congrArg (fun x => x ^ n) (Int.cast_ofNat 2))))\n            (one_div ((2 ^ n) ^ q))))))\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => 2 ^ n * _a = (2 ^ (1 - q)) ^ n)\n          (Eq.symm\n            (rpow_neg\n              (le_of_lt\n                (pow_pos\n                  (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                    (Eq.refl (Nat.ble 1 2)))\n                  n))\n              q))))\n      (Eq.mpr (id (congrArg (fun _a => _a = (2 ^ (1 - q)) ^ n) (mul_comm (2 ^ n) ((2 ^ n) ^ (-q)))))\n        (Eq.mpr\n          (id\n            (congrArg (fun _a => _a = (2 ^ (1 - q)) ^ n)\n              (Eq.symm\n                (rpow_add_one\n                  (ne_of_gt\n                    (pow_pos\n                      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                        (Eq.refl (Nat.ble 1 2)))\n                      n))\n                  (-q)))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => (2 ^ n) ^ (-q + 1) = _a)\n                (rpow_pow_comm\n                  (le_of_lt\n                    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                      (Eq.refl (Nat.ble 1 2))))\n                  (1 - q) n)))\n            (converges_qseries._proof_2 q hs hmono n this)))))","type":"∀ (n : ℕ), 2 ^ n * s.seq (2 ^ n) = (2 ^ (1 - q)) ^ n","name":["this"],"isProp":true,"id":["_uniq",317366]}]}],"start":8283},{"state":[{"type":"1 < 2 ∧ 1 - q < 0 ∨ 2 < 1 ∧ 0 < 1 - q ↔ 1 < q","tag":[],"mvarId":["_uniq",329465],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",296140],"binderInfo":"default"},{"type":"q > 0","name":["hq"],"isProp":true,"id":["_uniq",296141],"binderInfo":"default"},{"value":"mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q","type":"Series","name":["s"],"isProp":false,"id":["_uniq",297160]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0) (dite_congr ge_iff_le._simp_1 (fun h => one_div ((↑n : ℝ) ^ q)) fun h => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 1 ≤ n then\n      Eq.mpr (id (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_true ((↑n : ℝ) ^ q)⁻¹ 0 (eq_true h))) inv_nonneg._simp_1))\n        (le_of_lt\n          (rpow_pos_of_pos\n            (Int.cast_pos.mpr\n              (lt_of_lt_of_le\n                (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                  (Eq.refl (Nat.ble 1 1)))\n                h))\n            q))\n    else\n      of_eq_true\n        (Eq.trans (congrArg (LE.le 0) (ite_cond_eq_false ((↑n : ℝ) ^ q)⁻¹ 0 (eq_false h))) (le_refl._simp_1 0)))","type":"s.nonneg","name":["hs"],"isProp":true,"id":["_uniq",297210]},{"value":"fun n hn =>\n  have hn1 :=\n    le_of_lt\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn);\n  have hn3 := Decidable.byContradiction fun a => converges_qseries._proof_1 n hn a;\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg LE.le\n            (Eq.trans\n              (dite_cond_eq_true\n                (Eq.trans ge_iff_le._simp_1 (Eq.trans (le_mul_iff_one_le_left'._simp_4 1) (eq_true hn1))))\n              (Eq.trans\n                (congrArg (fun x => 1 / x ^ q)\n                  (Eq.trans (Int.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℝ)) Int.cast_one)))\n                (one_div (((↑n : ℝ) + 1) ^ q)))))\n          (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hn))) (one_div ((↑n : ℝ) ^ q))))\n        ge_iff_le._simp_1))\n    (inv_anti₀\n      (rpow_pos_of_pos\n        (Int.cast_pos.mpr\n          (lt_of_lt_of_le\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n              (Eq.refl (Nat.ble 1 1)))\n            hn))\n        q)\n      (rpow_le_rpow\n        (le_of_lt\n          (Int.cast_pos.mpr\n            (lt_of_lt_of_le\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                (Eq.refl (Nat.ble 1 1)))\n              hn)))\n        (of_eq_true (Eq.trans (le_mul_iff_one_le_right'._simp_4 (↑n : ℝ)) zero_le_one._simp_1)) (le_of_lt hq)))","type":"∀ n ≥ 1, s.seq (n + 1) ≤ s.seq n","name":["hmono"],"isProp":true,"id":["_uniq",304317]},{"value":"fun n =>\n  have this :=\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≤ (↑2 : ℤ) ^ n) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (LE.le (↑1 : ℤ)) (Nat.cast_pow._simp_1 2 n)) Nat.cast_le._simp_1)))\n      Nat.one_le_two_pow;\n  Eq.mpr\n    (id\n      (congrArg (fun x => 2 ^ n * x = (2 ^ (1 - q)) ^ n)\n        (Eq.trans (dite_cond_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true this)))\n          (Eq.trans\n            (congrArg (fun x => 1 / x ^ q) (Eq.trans (Int.cast_pow 2 n) (congrArg (fun x => x ^ n) (Int.cast_ofNat 2))))\n            (one_div ((2 ^ n) ^ q))))))\n    (Eq.mpr\n      (id\n        (congrArg (fun _a => 2 ^ n * _a = (2 ^ (1 - q)) ^ n)\n          (Eq.symm\n            (rpow_neg\n              (le_of_lt\n                (pow_pos\n                  (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                    (Eq.refl (Nat.ble 1 2)))\n                  n))\n              q))))\n      (Eq.mpr (id (congrArg (fun _a => _a = (2 ^ (1 - q)) ^ n) (mul_comm (2 ^ n) ((2 ^ n) ^ (-q)))))\n        (Eq.mpr\n          (id\n            (congrArg (fun _a => _a = (2 ^ (1 - q)) ^ n)\n              (Eq.symm\n                (rpow_add_one\n                  (ne_of_gt\n                    (pow_pos\n                      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                        (Eq.refl (Nat.ble 1 2)))\n                      n))\n                  (-q)))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => (2 ^ n) ^ (-q + 1) = _a)\n                (rpow_pow_comm\n                  (le_of_lt\n                    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))\n                      (Eq.refl (Nat.ble 1 2))))\n                  (1 - q) n)))\n            (converges_qseries._proof_2 q hs hmono n this)))))","type":"∀ (n : ℕ), 2 ^ n * s.seq (2 ^ n) = (2 ^ (1 - q)) ^ n","name":["this"],"isProp":true,"id":["_uniq",317366]}]}],"start":8347},{"state":[],"start":8354},{"state":[],"start":8355},{"state":[],"start":8375},{"state":[{"type":"(↑(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).sum : ℂ) = riemannZeta (↑q : ℂ)","tag":[],"mvarId":["_uniq",334030],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"}]}],"start":8496},{"state":[{"type":"(↑(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).sum : ℂ) = riemannZeta (↑q : ℂ)","tag":[],"mvarId":["_uniq",334030],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"}]}],"start":8615},{"state":[{"type":"(↑(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).sum : ℂ) = riemannZeta (↑q : ℂ)","tag":[],"mvarId":["_uniq",334371],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]}]}],"start":8654},{"state":[{"type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","tag":[],"mvarId":["_uniq",335259],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]}]}],"start":8690},{"state":[{"type":"(↑L : ℂ) = ∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)","tag":[],"mvarId":["_uniq",335269],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]}]}],"start":8752},{"state":[{"type":"1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ) = (↑(1 / ((↑n : ℝ) + 1) ^ q) : ℂ)","tag":["h","e'_3","h","e'_5","h"],"mvarId":["_uniq",336165],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",336164],"binderInfo":"default"}]}],"start":8793},{"state":[{"type":"(↑(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).sum : ℂ) = riemannZeta (↑q : ℂ)","tag":[],"mvarId":["_uniq",335261],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]}]}],"start":8853},{"state":[{"type":"(↑(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).sum : ℂ) = (↑L : ℂ)","tag":[],"mvarId":["_uniq",339330],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]}]}],"start":8866},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).convergesTo L","tag":["h"],"mvarId":["_uniq",339675],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]}]}],"start":8902},{"state":[{"type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","tag":[],"mvarId":["_uniq",340240],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]}]}],"start":8963},{"state":[{"type":"(↑n : ℝ) + 1 = |(↑n : ℝ) + 1|","tag":["h","e'_5","h","h","e'_6","h","e'_5"],"mvarId":["_uniq",341151],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",340718],"binderInfo":"default"}]}],"start":9033},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).convergesTo L","tag":["h"],"mvarId":["_uniq",340242],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]}]}],"start":9068},{"state":[{"type":"Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","tag":[],"mvarId":["_uniq",343974],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L✝"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L✝ : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L✝ : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L✝ : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L✝ : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",343548],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",343550],"binderInfo":"default"}]}],"start":9199},{"state":[{"type":"Filter.atTop = Filter.map (fun n => (↑n : ℤ)) Filter.atTop","tag":["h","e'_1","h","e'_4"],"mvarId":["_uniq",344790],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L✝"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L✝ : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L✝ : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L✝ : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L✝ : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",343548],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",343550],"binderInfo":"default"}]}],"start":9264},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).convergesTo L","tag":["h"],"mvarId":["_uniq",343977],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]}]}],"start":9273},{"state":[{"type":"Filter.Tendsto (mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).partial Filter.atTop (nhds L)","tag":["h"],"mvarId":["_uniq",347087],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]}]}],"start":9294},{"state":[{"type":"Filter.Tendsto (fun n => (mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).partial (↑n : ℤ)) Filter.atTop (nhds L)","tag":["h"],"mvarId":["_uniq",347097],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]}]}],"start":9310},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ q).partial (↑n : ℤ) = ∑ i ∈ Finset.range n, 1 / ((↑i : ℝ) + 1) ^ q","tag":["h","e'_3","h"],"mvarId":["_uniq",347832],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"}]}],"start":9362},{"state":[{"type":"(∑ x ∈ Finset.Icc 1 (↑n : ℤ), if 1 ≤ x then ((↑x : ℝ) ^ q)⁻¹ else 0) = ∑ x ∈ Finset.range n, (((↑x : ℝ) + 1) ^ q)⁻¹","tag":["h","e'_3","h"],"mvarId":["_uniq",356806],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"}]}],"start":9386},{"state":[{"type":"(∑ x ∈ Finset.Icc 1 (↑n : ℤ), if 1 ≤ x then ((↑x : ℝ) ^ q)⁻¹ else 0) = ∑ x ∈ Finset.range n, (((↑x : ℝ) + 1) ^ q)⁻¹","tag":["h","e'_3","h"],"mvarId":["_uniq",359369],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]}]}],"start":9413},{"state":[{"type":"(∑ x ∈ Finset.Icc 1 (↑n : ℤ), if 1 ≤ x then ((↑x : ℝ) ^ q)⁻¹ else 0) = ∑ x ∈ Finset.range n, (((↑x : ℝ) + 1) ^ q)⁻¹","tag":["h","e'_3","h"],"mvarId":["_uniq",359369],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]}]}],"start":9432},{"state":[],"start":9459},{"state":[{"type":"(∑ x ∈ Finset.Icc 1 (↑n : ℤ), if 1 ≤ x then ((↑x : ℝ) ^ q)⁻¹ else 0) = ∑ x ∈ Finset.range n, (((↑x : ℝ) + 1) ^ q)⁻¹","tag":["h","e'_3","h"],"mvarId":["_uniq",359369],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]}]}],"start":9463},{"state":[{"type":"Finset.Icc 1 (↑n : ℤ) = Finset.map e (Finset.range n)","tag":["h","e'_2","h"],"mvarId":["_uniq",360907],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]}]},{"type":"(((↑m : ℝ) + 1) ^ q)⁻¹ = if 1 ≤ e m then ((↑(e m) : ℝ) ^ q)⁻¹ else 0","tag":["h","e'_3","a"],"mvarId":["_uniq",361412],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",361363],"binderInfo":"default"},{"type":"m ∈ Finset.range n","name":["hm"],"isProp":true,"id":["_uniq",361411],"binderInfo":"default"}]}],"start":9516},{"state":[{"type":"1 ≤ x ∧ x ≤ (↑n : ℤ) → ∃ a < n, (↑a : ℤ) + 1 = x","tag":["h","e'_2","h","h","mp"],"mvarId":["_uniq",366408],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",361688],"binderInfo":"default"}]},{"type":"(∃ a < n, (↑a : ℤ) + 1 = x) → 1 ≤ x ∧ x ≤ (↑n : ℤ)","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",366409],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",361688],"binderInfo":"default"}]}],"start":9549},{"state":[{"type":"(∃ a < n, (↑a : ℤ) + 1 = x) → 1 ≤ x ∧ x ≤ (↑n : ℤ)","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",366409],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",361688],"binderInfo":"default"}]}],"start":9598},{"state":[{"type":"(((↑m : ℝ) + 1) ^ q)⁻¹ = if 1 ≤ e m then ((↑(e m) : ℝ) ^ q)⁻¹ else 0","tag":["h","e'_3","a"],"mvarId":["_uniq",361412],"isProp":true,"context":[{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",334028],"binderInfo":"implicit"},{"type":"q > 1","name":["hq"],"isProp":true,"id":["_uniq",334029],"binderInfo":"default"},{"value":"∑' (n : ℕ), 1 / ((↑n : ℝ) + 1) ^ q","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",334370]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => (↑L : ℂ) = _a)\n      (zeta_eq_tsum_one_div_nat_add_one_cpow\n        (Eq.mpr\n          (id\n            (Eq.trans (congrArg (fun x => x < (↑q : ℂ).re) (Eq.symm Nat.cast_one))\n              (congrArg (fun x => x < q) Nat.cast_one)))\n          hq))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℂ (↑L : ℂ) (↑(∑' (a : ℕ), 1 / ((↑a : ℝ) + 1) ^ q) : ℂ) (Eq.refl (↑L : ℂ))\n        (∑' (n : ℕ), 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ)) (∑' (a : ℕ), (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n        (eq_of_heq\n          ((fun α inst inst_1 β f f' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → tsum f ≍ tsum f') e'_5\n                (fun h =>\n                  Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → tsum f ≍ tsum f')\n                    (fun e_5 h => HEq.refl (tsum f)) (Eq.symm h) e'_5)\n                (Eq.refl f') (HEq.refl e'_5))\n            ℂ NormedAddCommGroup.toENormedAddCommMonoid.toAddCommMonoid\n            PseudoMetricSpace.toUniformSpace.toTopologicalSpace ℕ (fun n => 1 / ((↑n : ℂ) + 1) ^ (↑q : ℂ))\n            (fun a => (↑(1 / ((↑a : ℝ) + 1) ^ q) : ℂ))\n            (funext fun n =>\n              of_eq_true\n                (Eq.trans\n                  (congr (congrArg Eq (one_div (((↑n : ℂ) + 1) ^ (↑q : ℂ))))\n                    (Eq.trans\n                      (Eq.trans (congrArg Complex.ofReal (one_div (((↑n : ℝ) + 1) ^ q)))\n                        (Complex.ofReal_inv (((↑n : ℝ) + 1) ^ q)))\n                      (congrArg Inv.inv\n                        (Eq.trans\n                          ((fun x_0 =>\n                              (fun x_0 =>\n                                  Complex.ofReal_cpow\n                                    (le_of_lt\n                                      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                                        (Mathlib.Meta.Positivity.pos_of_isNat\n                                          (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))\n                                    x_0)\n                                x_0)\n                            q)\n                          (congrArg (fun x => x ^ (↑q : ℂ)) (Complex.ofReal_add (↑n : ℝ) 1))))))\n                  (eq_self (((↑n : ℂ) + 1) ^ (↑q : ℂ))⁻¹)))))))\n    (Complex.ofReal_tsum fun n => 1 / ((↑n : ℝ) + 1) ^ q))","type":"(↑L : ℂ) = riemannZeta (↑q : ℂ)","name":["hL"],"isProp":true,"id":["_uniq",335260]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β inst inst_1 f f' e'_5 =>\n        Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n              (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n          (Eq.refl f') (HEq.refl e'_5))\n      ℝ ℕ instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (fun n => 1 / ((↑n : ℝ) + 1) ^ q)\n      (fun n => 1 / |(↑n : ℝ) + 1| ^ q)\n      (funext fun n =>\n        eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a / a_1 ≍ a / a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a / a_1 ≍ a / a')\n                    (fun e_6 h => HEq.refl (a / a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHDiv 1 (((↑n : ℝ) + 1) ^ q) (|(↑n : ℝ) + 1| ^ q)\n            (eq_of_heq\n              ((fun α β γ self a a' e'_5 a_1 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a_1) e'_5\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a_1)\n                        (fun e_5 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_5)\n                    (Eq.refl a') (HEq.refl e'_5))\n                ℝ ℝ ℝ instHPow ((↑n : ℝ) + 1) |(↑n : ℝ) + 1|\n                (Eq.mpr\n                  (id\n                    (congrArg (fun _a => (↑n : ℝ) + 1 = _a)\n                      (abs_of_nonneg\n                        (le_of_lt\n                          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                              (Eq.refl (Nat.ble 1 1))))))))\n                  (Eq.refl ((↑n : ℝ) + 1)))\n                q))))))\n  ((summable_one_div_nat_add_rpow 1 q).mpr hq)","type":"Summable fun n => 1 / ((↑n : ℝ) + 1) ^ q","name":["this"],"isProp":true,"id":["_uniq",340241]},{"value":"fun a L =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun a a' e'_1 b b' e'_2 =>\n          Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (a ↔ b) ≍ (a' ↔ b')) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (a ↔ b) ≍ (a' ↔ b'))\n                (fun e_1 h =>\n                  Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ↔ b) ≍ (a ↔ b')) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ↔ b) ≍ (a ↔ b'))\n                        (fun e_2 h => HEq.refl (a ↔ b)) (Eq.symm h) e'_2)\n                    (Eq.refl b') (HEq.refl e'_2))\n                (Eq.symm h) e'_1)\n            (Eq.refl a') (HEq.refl e'_1))\n        (Filter.Tendsto a Filter.atTop (nhds L))\n        (Filter.Tendsto a (Filter.map (fun n => (↑n : ℤ)) Filter.atTop) (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ l₂' e'_5 =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂')\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂') e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂')\n                            (fun e_4 h =>\n                              Eq.casesOn (motive := fun a x =>\n                                l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n                                (fun h =>\n                                  Eq.ndrec (motive := fun l₂' =>\n                                    ∀ (e_5 : l₂ = l₂'),\n                                      e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                                    (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n                                (Eq.refl l₂') (HEq.refl e'_5))\n                            (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℤ ℝ a a (Eq.refl a) Filter.atTop (Filter.map (fun n => (↑n : ℤ)) Filter.atTop)\n            (of_eq_true (Eq.trans (congrArg (Eq Filter.atTop) Nat.map_cast_int_atTop) (eq_self Filter.atTop))) (nhds L)\n            (nhds L) (Eq.refl (nhds L))))\n        (Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L))\n        (Filter.Tendsto (a ∘ fun n => (↑n : ℤ)) Filter.atTop (nhds L))\n        (eq_of_heq\n          ((fun α β f f' e'_3 l₁ l₁' e'_4 l₂ =>\n              Eq.casesOn (motive := fun a x => f' = a → e'_3 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun f' =>\n                    ∀ (e_3 : f = f'), e_3 ≍ Eq.refl f → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f' l₁' l₂)\n                    (fun e_3 h =>\n                      Eq.casesOn (motive := fun a x =>\n                        l₁' = a → e'_4 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂) e'_4\n                        (fun h =>\n                          Eq.ndrec (motive := fun l₁' =>\n                            ∀ (e_4 : l₁ = l₁'), e_4 ≍ Eq.refl l₁ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁' l₂)\n                            (fun e_4 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_4)\n                        (Eq.refl l₁') (HEq.refl e'_4))\n                    (Eq.symm h) e'_3)\n                (Eq.refl f') (HEq.refl e'_3))\n            ℕ ℝ (fun n => a (↑n : ℤ)) (a ∘ fun n => (↑n : ℤ)) (funext fun x => Eq.refl (a (↑x : ℤ))) Filter.atTop\n            Filter.atTop (Eq.refl Filter.atTop) (nhds L)))))\n    Filter.tendsto_map'_iff","type":"∀ (a : ℤ → ℝ) (L : ℝ),\n  Filter.Tendsto a Filter.atTop (nhds L) ↔ Filter.Tendsto (fun n => a (↑n : ℤ)) Filter.atTop (nhds L)","name":["tail"],"isProp":true,"id":["_uniq",343976]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",347831],"binderInfo":"default"},{"value":"{ toFun := fun n => (↑n : ℤ) + 1, inj' := ⋯ }","type":"ℕ ↪ ℤ","name":["e"],"isProp":false,"id":["_uniq",359368]},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",361363],"binderInfo":"default"},{"type":"m ∈ Finset.range n","name":["hm"],"isProp":true,"id":["_uniq",361411],"binderInfo":"default"}]}],"start":9608},{"state":[],"start":9619},{"state":[],"start":9620},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ 2).sum = π ^ 2 / 6","tag":[],"mvarId":["_uniq",374600],"isProp":true,"context":[]}],"start":9730},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ 2).sum = π ^ 2 / 6","tag":[],"mvarId":["_uniq",374824],"isProp":true,"context":[{"value":"zeta_eq\n  (have this :=\n    Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false);\n  this)","type":"(↑(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ 2).sum : ℂ) = riemannZeta (↑2 : ℂ)","name":["this"],"isProp":true,"id":["_uniq",374823]}]}],"start":9773},{"state":[{"type":"(mk' fun n => 1 / (↑(↑n : ℤ) : ℝ) ^ 2).sum = π ^ 2 / 6","tag":[],"mvarId":["_uniq",375601],"isProp":true,"context":[{"type":"(↑(mk' fun n => ((↑(↑n : ℤ) : ℝ) ^ 2)⁻¹).sum : ℂ) = (↑π : ℂ) ^ 2 / 6","name":["this"],"isProp":true,"id":["_uniq",375598],"binderInfo":"default"}]}],"start":9828},{"state":[],"start":9860},{"state":[],"start":9861},{"state":[],"start":9883},{"state":[],"start":10036},{"state":[],"start":10037},{"state":[],"start":10038},{"state":[],"start":10051},{"state":[],"start":10051}]
