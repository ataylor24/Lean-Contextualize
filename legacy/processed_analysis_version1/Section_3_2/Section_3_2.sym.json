[{"valueReferences":[["sorryAx"],["Exists"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","axiom_of_universal_specification"],["Chapter3","SetTheory","Set"],["Exists"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.axiom_of_universal_specification →\n    ∀ (x : inst.Object), Exists fun X => ∀ (y : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem X y) (Eq y x)","name":["Chapter3","SetTheory","Set","singleton_exists"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Lean","Name","str"],["Membership","mem"],["Function","Embedding"],["Bool","false"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Function","Embedding"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set),\n  Not (Chapter3.SetTheory.objects_mem_sets.mem A (Function.instFunLikeEmbedding.coe inst.set_to_object A))","name":["Chapter3","SetTheory","Set","not_mem_self"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["sorryAx"],["Exists"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Not"],["Chapter3","axiom_of_universal_specification"],["Chapter3","SetTheory","Set"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.axiom_of_universal_specification →\n    Exists fun X => ∀ (x : inst.Object), Not (Chapter3.SetTheory.objects_mem_sets.mem X x)","name":["Chapter3","SetTheory","Set","emptyset_exists"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Exists"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Or"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Chapter3","axiom_of_universal_specification"],["Exists"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.axiom_of_universal_specification →\n    ∀ (A B : inst.Set),\n      Exists fun Z =>\n        ∀ (z : inst.Object),\n          Iff (Chapter3.SetTheory.objects_mem_sets.mem Z z)\n            (Or (Chapter3.SetTheory.objects_mem_sets.mem A z) (Chapter3.SetTheory.objects_mem_sets.mem B z))","name":["Chapter3","SetTheory","Set","union_exists"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Lean","Name","str"],["Membership","mem"],["Function","Embedding"],["Bool","false"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Or"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Or"],["Function","Embedding"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Or (Not (Chapter3.SetTheory.objects_mem_sets.mem B (Function.instFunLikeEmbedding.coe inst.set_to_object A)))\n    (Not (Chapter3.SetTheory.objects_mem_sets.mem A (Function.instFunLikeEmbedding.coe inst.set_to_object B)))","name":["Chapter3","SetTheory","Set","not_mem_mem"],"kind":"theorem","isProp":true},{"valueReferences":[["Classical","choose_spec"],["implies_congr"],["Chapter3","SetTheory","Set","mem_inter","_simp_1"],["Eq","trans"],["Membership","mem"],["Inter","inter"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Classical","choose"],["And","intro"],["Chapter3","SetTheory","Set","instIntersection"],["Disjoint"],["funext"],["Eq","symm"],["Chapter3","SetTheory","Set","eq_empty_iff_forall_notMem"],["Function","instFunLikeEmbedding"],["Eq","ndrec"],["And","left"],["SemilatticeInf","toPartialOrder"],["Exists"],["Function","Embedding"],["And","right"],["And"],["Exists","casesOn"],["id"],["Eq","mpr"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","set_to_object"],["Eq","mp"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["DFunLike","coe"],["congrArg"],["Chapter3","SetTheory","Set","instOrderBot"],["Chapter3","SetTheory","Set","nonempty_def"],["Eq"],["propext"],["Not"],["Mathlib","Tactic","PushNeg","not_not_eq"],["Chapter3","SetTheory","Set","instDistribLattice"],["Lattice","toSemilatticeInf"],["Mathlib","Tactic","PushNeg","not_forall_eq"],["Mathlib","Tactic","Contrapose","mtr"],["DistribLattice","toLattice"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","disjoint_iff"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","regularity_axiom"],["Subtype","mk"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set","instDistribLattice"],["Lattice","toSemilatticeInf"],["Exists"],["Function","Embedding"],["Membership","mem"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Chapter3","SetTheory","Set","instOrderBot"],["DistribLattice","toLattice"],["Chapter3","SetTheory","Set"],["Disjoint"],["Chapter3","SetTheory","Set","toSubtype"],["Ne"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","set_to_object"],["SemilatticeInf","toPartialOrder"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set},\n  Ne A Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n    Exists fun x => ∀ (S : inst.Set), Eq x.val (Function.instFunLikeEmbedding.coe inst.set_to_object S) → Disjoint S A","name":["Chapter3","SetTheory","Set","axiom_of_regularity"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Exists"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory"]],"type":"[Chapter3.SetTheory] → Prop","name":["Chapter3","axiom_of_universal_specification"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Exists"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Chapter3","axiom_of_universal_specification"],["Exists"],["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.axiom_of_universal_specification →\n    ∀ (A : inst.Set) (P : A.toSubtype → inst.Object → Prop),\n      (∀ (x : A.toSubtype) (y y' : inst.Object), And (P x y) (P x y') → Eq y y') →\n        Exists fun Z => ∀ (y : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Z y) (Exists fun a => P a y)","name":["Chapter3","SetTheory","Set","replace_exists"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["sorryAx"],["Exists"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory], Not (Exists fun U => ∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem U x)","name":["Chapter3","SetTheory","Set","no_univ"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Exists"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Name","num"]],"typeReferences":[["Chapter3","axiom_of_universal_specification"],["Exists"],["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.axiom_of_universal_specification →\n    ∀ (A : inst.Set) (P : A.toSubtype → Prop),\n      Exists fun Z => ∀ (z : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Z z) (Exists fun h => P ⟨z, h⟩)","name":["Chapter3","SetTheory","Set","specify_exists"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","axiom_of_universal_specification"],["sorryAx"],["Exists"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Chapter3","axiom_of_universal_specification"],["Chapter3","SetTheory","Set"],["Exists"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Iff Chapter3.axiom_of_universal_specification\n    (Exists fun U => ∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem U x)","name":["Chapter3","SetTheory","Set","univ_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Classical","choose_spec"],["Eq","mp"],["Membership","mem"],["Classical","propDecidable"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Exists","intro"],["Classical","choose"],["DFunLike","coe"],["Function","instEmbeddingLikeEmbedding"],["congrArg"],["And","intro"],["False","elim"],["Eq","symm"],["Function","instFunLikeEmbedding"],["Eq"],["propext"],["Not"],["Exists"],["Function","Embedding"],["And"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Exists","casesOn"],["Chapter3","SetTheory","Set"],["Iff"],["Eq","refl"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["dite"],["Chapter3","SetTheory","set_to_object"],["And","casesOn"]],"typeReferences":[["Not"],["Chapter3","axiom_of_universal_specification"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory], Not Chapter3.axiom_of_universal_specification","name":["Chapter3","Russells_paradox"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Or"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","axiom_of_universal_specification"],["Chapter3","SetTheory","Set"],["Exists"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.axiom_of_universal_specification →\n    ∀ (x₁ x₂ : inst.Object),\n      Exists fun X => ∀ (y : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem X y) (Or (Eq y x₁) (Eq y x₂))","name":["Chapter3","SetTheory","Set","pair_exists"],"kind":"theorem","isProp":true}]
