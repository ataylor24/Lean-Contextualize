[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":78},{"state":[],"start":106},{"state":[],"start":134},{"state":[],"start":135},{"state":[],"start":139},{"state":[],"start":193},{"state":[],"start":194},{"state":[],"start":290},{"state":[],"start":378},{"state":[],"start":473},{"state":[],"start":566},{"state":[],"start":576},{"state":[],"start":577},{"state":[],"start":625},{"state":[],"start":626},{"state":[],"start":702},{"state":[],"start":754},{"state":[],"start":791},{"state":[],"start":792},{"state":[],"start":885},{"state":[],"start":926},{"state":[],"start":927},{"state":[],"start":1057},{"state":[],"start":1058},{"state":[],"start":1061},{"state":[],"start":1062},{"state":[],"start":1081},{"state":[],"start":1134},{"state":[],"start":1135},{"state":[],"start":1235},{"state":[],"start":1334},{"state":[],"start":1343},{"state":[],"start":1463},{"state":[],"start":1464},{"state":[],"start":1611},{"state":[],"start":1612},{"state":[],"start":1630},{"state":[],"start":1722},{"state":[],"start":1781},{"state":[],"start":1899},{"state":[],"start":1976},{"state":[],"start":1977},{"state":[{"type":"Sum f = ∑ x, f x","tag":[],"mvarId":["_uniq",2251],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",2248],"binderInfo":"implicit"},{"type":"Finite X","name":["hX"],"isProp":true,"id":["_uniq",2249],"binderInfo":"instImplicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",2250],"binderInfo":"default"}]}],"start":2103},{"state":[{"type":"¬AbsConvergent f","tag":[],"mvarId":["_uniq",2257],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",2248],"binderInfo":"implicit"},{"type":"Finite X","name":["hX"],"isProp":true,"id":["_uniq",2249],"binderInfo":"instImplicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",2250],"binderInfo":"default"}]}],"start":2137},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",2288],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",2248],"binderInfo":"implicit"},{"type":"Finite X","name":["hX"],"isProp":true,"id":["_uniq",2249],"binderInfo":"instImplicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",2250],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",2274],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",2283],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["a✝"],"isProp":true,"id":["_uniq",2287],"binderInfo":"default"}]}],"start":2178},{"state":[{"type":"Sum f = ∑ x, f x","tag":[],"mvarId":["_uniq",2259],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",2248],"binderInfo":"implicit"},{"type":"Finite X","name":["hX"],"isProp":true,"id":["_uniq",2249],"binderInfo":"instImplicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",2250],"binderInfo":"default"},{"value":"fun this =>\n  (fun g x =>\n      Eq.mp (congrArg (fun _a => _a) (Eq.symm (propext not_infinite_iff_finite)))\n        (Eq.mp (congrArg (fun _a => _a) (Eq.symm (propext (Bijective.finite_iff x.left)))) hX) inferInstance)\n    (Classical.choose this) (Classical.choose_spec this)","type":"¬AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",2258]}]}],"start":2264},{"state":[],"start":2287},{"state":[],"start":2288},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","tag":[],"mvarId":["_uniq",10862],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",10857],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",10858],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",10859],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",10860],"binderInfo":"default"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",10861],"binderInfo":"default"}]}],"start":2430},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","tag":[],"mvarId":["_uniq",10878],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",10857],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",10858],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",10859],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",10860],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",10864],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",10873],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",10877],"binderInfo":"default"}]}],"start":2462},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","tag":[],"mvarId":["_uniq",10908],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",10857],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",10858],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",10859],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",10860],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",10864],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",10873],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",10877],"binderInfo":"default"},{"type":"X → ℕ","name":["g'_inv"],"isProp":false,"id":["_uniq",10895],"binderInfo":"default"},{"type":"LeftInverse g'_inv g'","name":["hleft"],"isProp":true,"id":["_uniq",10903],"binderInfo":"default"},{"type":"RightInverse g'_inv g'","name":["hright"],"isProp":true,"id":["_uniq",10907],"binderInfo":"default"}]}],"start":2531},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","tag":[],"mvarId":["_uniq",11009],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",10857],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",10858],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",10859],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",10860],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",10864],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",10873],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",10877],"binderInfo":"default"},{"type":"X → ℕ","name":["g'_inv"],"isProp":false,"id":["_uniq",10895],"binderInfo":"default"},{"type":"LeftInverse g'_inv g'","name":["hleft"],"isProp":true,"id":["_uniq",10903],"binderInfo":"default"},{"type":"RightInverse g'_inv g'","name":["hright"],"isProp":true,"id":["_uniq",10907],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ h","type":"Bijective (g'_inv ∘ g)","name":["hG"],"isProp":true,"id":["_uniq",11008]}]}],"start":2620},{"state":[{"type":"(f ∘ g) n.toNat = (fun n => (f ∘ g') ((g'_inv ∘ g) n)) n.toNat","tag":["h","e'_1","h","e'_2","h","h₂"],"mvarId":["_uniq",12139],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",10857],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",10858],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",10859],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",10860],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",10864],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",10873],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",10877],"binderInfo":"default"},{"type":"X → ℕ","name":["g'_inv"],"isProp":false,"id":["_uniq",10895],"binderInfo":"default"},{"type":"LeftInverse g'_inv g'","name":["hleft"],"isProp":true,"id":["_uniq",10903],"binderInfo":"default"},{"type":"RightInverse g'_inv g'","name":["hright"],"isProp":true,"id":["_uniq",10907],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ h","type":"Bijective (g'_inv ∘ g)","name":["hG"],"isProp":true,"id":["_uniq",11008]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",11996],"binderInfo":"default"},{"type":"n ≥ 0","name":["a✝"],"isProp":true,"id":["_uniq",12138],"binderInfo":"default"}]}],"start":2682},{"state":[],"start":2710},{"state":[],"start":2711},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum f)","tag":[],"mvarId":["_uniq",12543],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"}]}],"start":2863},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum f)","tag":[],"mvarId":["_uniq",12562],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"},{"value":"AbsConvergent.mk h hfg","type":"AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",12561]}]}],"start":2901},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then f (g n.toNat) else 0, vanish := ⋯ }.convergesTo\n  { m := 0, seq := fun n => if 0 ≤ n then f (⋯.choose n.toNat) else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",30598],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"},{"value":"AbsConvergent.mk h hfg","type":"AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",12561]}]}],"start":2920},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then f (g n.toNat) else 0, vanish := ⋯ }.convergesTo\n  { m := 0, seq := fun n => if 0 ≤ n then f (⋯.choose n.toNat) else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",30617],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"},{"value":"AbsConvergent.mk h hfg","type":"AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",12561]},{"type":"Bijective (Exists.choose this)","name":["hbij"],"isProp":true,"id":["_uniq",30613],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ Exists.choose this) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",30616],"binderInfo":"default"}]}],"start":2963},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then f (g n.toNat) else 0, vanish := ⋯ }.convergesTo\n  { m := 0, seq := fun n => if 0 ≤ n then f (⋯.choose n.toNat) else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",30913],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"},{"value":"AbsConvergent.mk h hfg","type":"AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",12561]},{"value":"Exists.choose this","type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",30629]},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",30907],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",30910],"binderInfo":"default"}]}],"start":2987},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then f (g n.toNat) else 0, vanish := ⋯ }.convergesTo\n  { m := 0, seq := fun n => if 0 ≤ n then f (⋯.choose n.toNat) else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",31005],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"},{"value":"AbsConvergent.mk h hfg","type":"AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",12561]},{"value":"Exists.choose this","type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",30629]},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",30907],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",30910],"binderInfo":"default"},{"type":"X → ℕ","name":["g'_inv"],"isProp":false,"id":["_uniq",30992],"binderInfo":"default"},{"type":"LeftInverse g'_inv g'","name":["hleft"],"isProp":true,"id":["_uniq",31000],"binderInfo":"default"},{"type":"RightInverse g'_inv g'","name":["hright"],"isProp":true,"id":["_uniq",31004],"binderInfo":"default"}]}],"start":3056},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then f (⋯.choose n.toNat) else 0, vanish := ⋯ }.sum =\n  { m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.sum","tag":["h","e'_2"],"mvarId":["_uniq",31372],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"},{"value":"AbsConvergent.mk h hfg","type":"AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",12561]},{"value":"Exists.choose this","type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",30629]},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",30907],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",30910],"binderInfo":"default"},{"type":"X → ℕ","name":["g'_inv"],"isProp":false,"id":["_uniq",30992],"binderInfo":"default"},{"type":"LeftInverse g'_inv g'","name":["hleft"],"isProp":true,"id":["_uniq",31000],"binderInfo":"default"},{"type":"RightInverse g'_inv g'","name":["hright"],"isProp":true,"id":["_uniq",31004],"binderInfo":"default"}]}],"start":3122},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then f (⋯.choose n.toNat) else 0, vanish := ⋯ }.sum =\n  { m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.sum","tag":["h","e'_2"],"mvarId":["_uniq",34186],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"},{"value":"AbsConvergent.mk h hfg","type":"AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",12561]},{"value":"Exists.choose this","type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",30629]},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",30907],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",30910],"binderInfo":"default"},{"type":"X → ℕ","name":["g'_inv"],"isProp":false,"id":["_uniq",30992],"binderInfo":"default"},{"type":"LeftInverse g'_inv g'","name":["hleft"],"isProp":true,"id":["_uniq",31000],"binderInfo":"default"},{"type":"RightInverse g'_inv g'","name":["hright"],"isProp":true,"id":["_uniq",31004],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ h","type":"Bijective (g'_inv ∘ g)","name":["hG"],"isProp":true,"id":["_uniq",34185]}]}],"start":3211},{"state":[{"type":"(if n ≥ 0 then (f ∘ g) n.toNat else 0) = if n ≥ 0 then (fun n => (f ∘ g') ((g'_inv ∘ g) n)) n.toNat else 0","tag":["h","e'_3","h","e'_1","h","e'_2","h"],"mvarId":["_uniq",36069],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",12538],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",12539],"binderInfo":"implicit"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",12540],"binderInfo":"implicit"},{"type":"Bijective g","name":["h"],"isProp":true,"id":["_uniq",12541],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hfg"],"isProp":true,"id":["_uniq",12542],"binderInfo":"default"},{"value":"AbsConvergent.mk h hfg","type":"AbsConvergent f","name":["this"],"isProp":true,"id":["_uniq",12561]},{"value":"Exists.choose this","type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",30629]},{"type":"Bijective g'","name":["hbij"],"isProp":true,"id":["_uniq",30907],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",30910],"binderInfo":"default"},{"type":"X → ℕ","name":["g'_inv"],"isProp":false,"id":["_uniq",30992],"binderInfo":"default"},{"type":"LeftInverse g'_inv g'","name":["hleft"],"isProp":true,"id":["_uniq",31000],"binderInfo":"default"},{"type":"RightInverse g'_inv g'","name":["hright"],"isProp":true,"id":["_uniq",31004],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ h","type":"Bijective (g'_inv ∘ g)","name":["hG"],"isProp":true,"id":["_uniq",34185]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",36068],"binderInfo":"default"}]}],"start":3275},{"state":[],"start":3333},{"state":[],"start":3334},{"state":[{"type":"AbsConvergent (f ∘ g) ∧ Sum f = Sum (f ∘ g)","tag":[],"mvarId":["_uniq",37521],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",37515],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",37516],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",37517],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["h"],"isProp":true,"id":["_uniq",37518],"binderInfo":"default"},{"type":"Y → X","name":["g"],"isProp":false,"id":["_uniq",37519],"binderInfo":"implicit"},{"type":"Bijective g","name":["hbij"],"isProp":true,"id":["_uniq",37520],"binderInfo":"default"}]}],"start":3491},{"state":[{"type":"AbsConvergent (f ∘ g) ∧ Sum f = Sum (f ∘ g)","tag":[],"mvarId":["_uniq",37537],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",37515],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",37516],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",37517],"binderInfo":"implicit"},{"type":"Y → X","name":["g"],"isProp":false,"id":["_uniq",37519],"binderInfo":"implicit"},{"type":"Bijective g","name":["hbij"],"isProp":true,"id":["_uniq",37520],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",37523],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij'"],"isProp":true,"id":["_uniq",37532],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv'"],"isProp":true,"id":["_uniq",37536],"binderInfo":"default"}]}],"start":3524},{"state":[{"type":"AbsConvergent (f ∘ g) ∧ Sum f = Sum (f ∘ g)","tag":[],"mvarId":["_uniq",37567],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",37515],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",37516],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",37517],"binderInfo":"implicit"},{"type":"Y → X","name":["g"],"isProp":false,"id":["_uniq",37519],"binderInfo":"implicit"},{"type":"Bijective g","name":["hbij"],"isProp":true,"id":["_uniq",37520],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",37523],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij'"],"isProp":true,"id":["_uniq",37532],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv'"],"isProp":true,"id":["_uniq",37536],"binderInfo":"default"},{"type":"X → Y","name":["g_inv"],"isProp":false,"id":["_uniq",37554],"binderInfo":"default"},{"type":"LeftInverse g_inv g","name":["hleft"],"isProp":true,"id":["_uniq",37562],"binderInfo":"default"},{"type":"RightInverse g_inv g","name":["hright"],"isProp":true,"id":["_uniq",37566],"binderInfo":"default"}]}],"start":3592},{"state":[{"type":"AbsConvergent (f ∘ g) ∧ Sum f = Sum (f ∘ g)","tag":[],"mvarId":["_uniq",37668],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",37515],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",37516],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",37517],"binderInfo":"implicit"},{"type":"Y → X","name":["g"],"isProp":false,"id":["_uniq",37519],"binderInfo":"implicit"},{"type":"Bijective g","name":["hbij"],"isProp":true,"id":["_uniq",37520],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",37523],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij'"],"isProp":true,"id":["_uniq",37532],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv'"],"isProp":true,"id":["_uniq",37536],"binderInfo":"default"},{"type":"X → Y","name":["g_inv"],"isProp":false,"id":["_uniq",37554],"binderInfo":"default"},{"type":"LeftInverse g_inv g","name":["hleft"],"isProp":true,"id":["_uniq",37562],"binderInfo":"default"},{"type":"RightInverse g_inv g","name":["hright"],"isProp":true,"id":["_uniq",37566],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ hbij'","type":"Bijective (g_inv ∘ g')","name":["hbij_g_inv_g'"],"isProp":true,"id":["_uniq",37667]}]}],"start":3696},{"state":[{"type":"AbsConvergent (f ∘ g) ∧ Sum f = Sum (f ∘ g)","tag":[],"mvarId":["_uniq",37732],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",37515],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",37516],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",37517],"binderInfo":"implicit"},{"type":"Y → X","name":["g"],"isProp":false,"id":["_uniq",37519],"binderInfo":"implicit"},{"type":"Bijective g","name":["hbij"],"isProp":true,"id":["_uniq",37520],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",37523],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij'"],"isProp":true,"id":["_uniq",37532],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv'"],"isProp":true,"id":["_uniq",37536],"binderInfo":"default"},{"type":"X → Y","name":["g_inv"],"isProp":false,"id":["_uniq",37554],"binderInfo":"default"},{"type":"LeftInverse g_inv g","name":["hleft"],"isProp":true,"id":["_uniq",37562],"binderInfo":"default"},{"type":"RightInverse g_inv g","name":["hright"],"isProp":true,"id":["_uniq",37566],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ hbij'","type":"Bijective (g_inv ∘ g')","name":["hbij_g_inv_g'"],"isProp":true,"id":["_uniq",37667]},{"value":"funext fun n => of_eq_true (Eq.trans (congrArg (fun x => f x = f (g' n)) (hright (g' n))) (eq_self (f (g' n))))","type":"(f ∘ g) ∘ g_inv ∘ g' = f ∘ g'","name":["hident"],"isProp":true,"id":["_uniq",37731]}]}],"start":3784},{"state":[{"type":"Sum f = Sum (f ∘ g)","tag":[],"mvarId":["_uniq",38142],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",37515],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",37516],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",37517],"binderInfo":"implicit"},{"type":"Y → X","name":["g"],"isProp":false,"id":["_uniq",37519],"binderInfo":"implicit"},{"type":"Bijective g","name":["hbij"],"isProp":true,"id":["_uniq",37520],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",37523],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij'"],"isProp":true,"id":["_uniq",37532],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv'"],"isProp":true,"id":["_uniq",37536],"binderInfo":"default"},{"type":"X → Y","name":["g_inv"],"isProp":false,"id":["_uniq",37554],"binderInfo":"default"},{"type":"LeftInverse g_inv g","name":["hleft"],"isProp":true,"id":["_uniq",37562],"binderInfo":"default"},{"type":"RightInverse g_inv g","name":["hright"],"isProp":true,"id":["_uniq",37566],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ hbij'","type":"Bijective (g_inv ∘ g')","name":["hbij_g_inv_g'"],"isProp":true,"id":["_uniq",37667]},{"value":"funext fun n => of_eq_true (Eq.trans (congrArg (fun x => f x = f (g' n)) (hright (g' n))) (eq_self (f (g' n))))","type":"(f ∘ g) ∘ g_inv ∘ g' = f ∘ g'","name":["hident"],"isProp":true,"id":["_uniq",37731]}]}],"start":3868},{"state":[{"type":"Sum f = Sum (f ∘ g)","tag":[],"mvarId":["_uniq",40162],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",37515],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",37516],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",37517],"binderInfo":"implicit"},{"type":"Y → X","name":["g"],"isProp":false,"id":["_uniq",37519],"binderInfo":"implicit"},{"type":"Bijective g","name":["hbij"],"isProp":true,"id":["_uniq",37520],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",37523],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij'"],"isProp":true,"id":["_uniq",37532],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv'"],"isProp":true,"id":["_uniq",37536],"binderInfo":"default"},{"type":"X → Y","name":["g_inv"],"isProp":false,"id":["_uniq",37554],"binderInfo":"default"},{"type":"LeftInverse g_inv g","name":["hleft"],"isProp":true,"id":["_uniq",37562],"binderInfo":"default"},{"type":"RightInverse g_inv g","name":["hright"],"isProp":true,"id":["_uniq",37566],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ hbij'","type":"Bijective (g_inv ∘ g')","name":["hbij_g_inv_g'"],"isProp":true,"id":["_uniq",37667]},{"value":"funext fun n => of_eq_true (Eq.trans (congrArg (fun x => f x = f (g' n)) (hright (g' n))) (eq_self (f (g' n))))","type":"(f ∘ g) ∘ g_inv ∘ g' = f ∘ g'","name":["hident"],"isProp":true,"id":["_uniq",37731]},{"value":"eq hbij_g_inv_g'\n  (Eq.mpr\n    (eq_of_heq\n      ((fun s s' e'_1 =>\n          Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.absConverges ≍ s'.absConverges) e'_1\n            (fun h =>\n              Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.absConverges ≍ s'.absConverges)\n                (fun e_1 h => HEq.refl s.absConverges) (Eq.symm h) e'_1)\n            (Eq.refl s') (HEq.refl e'_1))\n        { m := 0, seq := fun n => if n ≥ 0 then ((f ∘ g) ∘ g_inv ∘ g') n.toNat else 0,\n          vanish := instCoe._proof_1 ((f ∘ g) ∘ g_inv ∘ g') }\n        { m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := AbsConvergent._proof_1 f g' }\n        (eq_of_heq\n          ((fun m seq seq' e'_2 vanish vanish' =>\n              (fun e'_3 =>\n                  Eq.casesOn (motive := fun a x =>\n                    seq' = a →\n                      e'_2 ≍ x → { m := m, seq := seq, vanish := vanish } ≍ { m := m, seq := seq', vanish := vanish' })\n                    e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun seq' =>\n                        ∀ (e_2 : seq = seq') (vanish' : ∀ n < m, seq' n = 0),\n                          vanish ≍ vanish' →\n                            e_2 ≍ Eq.refl seq →\n                              { m := m, seq := seq, vanish := vanish } ≍ { m := m, seq := seq', vanish := vanish' })\n                        (fun e_2 vanish' e_3 h =>\n                          HEq.casesOn (motive := fun {β} a x =>\n                            (∀ n < m, seq n = 0) = β →\n                              vanish' ≍ a →\n                                e_3 ≍ x →\n                                  { m := m, seq := seq, vanish := vanish } ≍ { m := m, seq := seq, vanish := vanish' })\n                            e_3\n                            (fun h h =>\n                              Eq.ndrec (motive := fun vanish' =>\n                                ∀ (e_3 : vanish ≍ vanish'),\n                                  e_3 ≍ HEq.refl vanish →\n                                    { m := m, seq := seq, vanish := vanish } ≍\n                                      { m := m, seq := seq, vanish := vanish' })\n                                (fun e_3 h => HEq.refl { m := m, seq := seq, vanish := vanish }) (Eq.symm (eq_of_heq h))\n                                e_3)\n                            (Eq.refl (∀ n < m, seq n = 0)) (HEq.refl vanish') (HEq.refl e_3))\n                        (Eq.symm h) e'_2 vanish' (e'_3 e'_2))\n                    (Eq.refl seq') (HEq.refl e'_2))\n                fun e_2 =>\n                Eq.casesOn (motive := fun a x => seq' = a → e_2 ≍ x → vanish ≍ vanish') e_2\n                  (fun h =>\n                    Eq.ndrec (motive := fun seq' =>\n                      ∀ (vanish' : ∀ n < m, seq' n = 0) (e_2 : seq = seq'), e_2 ≍ Eq.refl seq → vanish ≍ vanish')\n                      (fun vanish' e_2 h => HEq.refl vanish) (Eq.symm h) vanish' e_2)\n                  (Eq.refl seq') (HEq.refl e_2))\n            0 (fun n => if n ≥ 0 then ((f ∘ g) ∘ g_inv ∘ g') n.toNat else 0)\n            (fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0)\n            (funext fun x =>\n              ite_congr (Eq.refl (x ≥ 0))\n                (fun a =>\n                  eq_of_heq\n                    ((fun e a =>\n                        Eq.casesOn (motive := fun a_1 x => f ∘ g' = a_1 → e ≍ x → ((f ∘ g) ∘ g_inv ∘ g') a ≍ (f ∘ g') a)\n                          e\n                          (fun h =>\n                            Eq.ndrec (motive := fun f' =>\n                              ∀ (e : (f ∘ g) ∘ g_inv ∘ g' = f'),\n                                e ≍ Eq.refl ((f ∘ g) ∘ g_inv ∘ g') → ((f ∘ g) ∘ g_inv ∘ g') a ≍ f' a)\n                              (fun e h => HEq.refl (((f ∘ g) ∘ g_inv ∘ g') a)) (Eq.symm h) e)\n                          (Eq.refl (f ∘ g')) (HEq.refl e))\n                      hident x.toNat))\n                fun a => Eq.refl 0)\n            (instCoe._proof_1 ((f ∘ g) ∘ g_inv ∘ g')) (AbsConvergent._proof_1 f g')))))\n    hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ g) ∘ g_inv ∘ g') n.toNat else 0, vanish := ⋯ }.convergesTo (Sum (f ∘ g))","name":["h"],"isProp":true,"id":["_uniq",40161]}]}],"start":3932},{"state":[{"type":"Sum f = Sum (f ∘ g)","tag":[],"mvarId":["_uniq",42179],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",37515],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",37516],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",37517],"binderInfo":"implicit"},{"type":"Y → X","name":["g"],"isProp":false,"id":["_uniq",37519],"binderInfo":"implicit"},{"type":"Bijective g","name":["hbij"],"isProp":true,"id":["_uniq",37520],"binderInfo":"default"},{"type":"ℕ → X","name":["g'"],"isProp":false,"id":["_uniq",37523],"binderInfo":"default"},{"type":"Bijective g'","name":["hbij'"],"isProp":true,"id":["_uniq",37532],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv'"],"isProp":true,"id":["_uniq",37536],"binderInfo":"default"},{"type":"X → Y","name":["g_inv"],"isProp":false,"id":["_uniq",37554],"binderInfo":"default"},{"type":"LeftInverse g_inv g","name":["hleft"],"isProp":true,"id":["_uniq",37562],"binderInfo":"default"},{"type":"RightInverse g_inv g","name":["hright"],"isProp":true,"id":["_uniq",37566],"binderInfo":"default"},{"value":"Bijective.comp ⟨RightInverse.injective hright, LeftInverse.surjective hleft⟩ hbij'","type":"Bijective (g_inv ∘ g')","name":["hbij_g_inv_g'"],"isProp":true,"id":["_uniq",37667]},{"value":"funext fun n => of_eq_true (Eq.trans (congrArg (fun x => f x = f (g' n)) (hright (g' n))) (eq_self (f (g' n))))","type":"(f ∘ g) ∘ g_inv ∘ g' = f ∘ g'","name":["hident"],"isProp":true,"id":["_uniq",37731]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g') n.toNat else 0, vanish := ⋯ }.convergesTo (Sum (f ∘ g))","name":["h"],"isProp":true,"id":["_uniq",42176],"binderInfo":"default"}]}],"start":3951},{"state":[],"start":3990},{"state":[],"start":3991},{"state":[],"start":3999},{"state":[{"type":"Icc 0 (↑N : ℤ) = Finset.map Nat.castEmbedding (Icc 0 N)","tag":[],"mvarId":["_uniq",43421],"isProp":true,"context":[{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",43420],"binderInfo":"default"}]}],"start":4091},{"state":[{"type":"0 ≤ n ∧ n ≤ (↑N : ℤ) → ∃ a ≤ N, (↑a : ℤ) = n","tag":["h","mp"],"mvarId":["_uniq",48995],"isProp":true,"context":[{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",43420],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",43446],"binderInfo":"default"}]},{"type":"(∃ a ≤ N, (↑a : ℤ) = n) → 0 ≤ n ∧ n ≤ (↑N : ℤ)","tag":["h","mpr"],"mvarId":["_uniq",48996],"isProp":true,"context":[{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",43420],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",43446],"binderInfo":"default"}]}],"start":4118},{"state":[{"type":"(∃ a ≤ N, (↑a : ℤ) = n) → 0 ≤ n ∧ n ≤ (↑N : ℤ)","tag":["h","mpr"],"mvarId":["_uniq",48996],"isProp":true,"context":[{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",43420],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",43446],"binderInfo":"default"}]}],"start":4183},{"state":[],"start":4228},{"state":[],"start":4229},{"state":[{"type":"Icc 0 N = ∅","tag":[],"mvarId":["_uniq",55562],"isProp":true,"context":[{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",55560],"binderInfo":"implicit"},{"type":"¬N ≥ 0","name":["h"],"isProp":true,"id":["_uniq",55561],"binderInfo":"default"}]}],"start":4300},{"state":[],"start":4345},{"state":[],"start":4346},{"state":[],"start":4448},{"state":[],"start":4569},{"state":[],"start":4624},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",59579],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"}]}],"start":4705},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",59633],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]}]}],"start":4722},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",59782],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]}]}],"start":4790},{"state":[{"type":"0 ≤ L","tag":[],"mvarId":["_uniq",59914],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]}]}],"start":4819},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",59916],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]}]}],"start":4912},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",85002],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]}]}],"start":4989},{"state":[{"type":"(a n).partial (↑M : ℤ) ≤ L","tag":[],"mvarId":["_uniq",85052],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",85008],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",85010],"binderInfo":"default"}]}],"start":5045},{"state":[{"type":"∑ x ∈ Icc 0 M, f (n, x) ≤ L","tag":[],"mvarId":["_uniq",90187],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",85008],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",85010],"binderInfo":"default"}]}],"start":5094},{"state":[{"type":"∑ x ∈ Icc 0 M, f (n, x) = ∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x","tag":["h","e'_3"],"mvarId":["_uniq",90543],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",85008],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",85010],"binderInfo":"default"}]},{"type":"∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x ≤ L","tag":[],"mvarId":["_uniq",90308],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",85008],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",85010],"binderInfo":"default"}]}],"start":5170},{"state":[{"type":"∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x ≤ L","tag":[],"mvarId":["_uniq",90308],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",85008],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",85010],"binderInfo":"default"}]}],"start":5181},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",85057],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]}]}],"start":5199},{"state":[{"type":"(a n).nonneg","tag":[],"mvarId":["_uniq",92367],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",92364],"binderInfo":"default"}]}],"start":5240},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",92372],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]}]}],"start":5297},{"state":[{"type":"(a n).converges","tag":[],"mvarId":["_uniq",97783],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",97780],"binderInfo":"default"}]}],"start":5342},{"state":[{"type":"∃ M, ∀ (N : ℤ), (a n).partial N ≤ M","tag":[],"mvarId":["_uniq",97796],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",97780],"binderInfo":"default"}]}],"start":5384},{"state":[{"type":"(a n).partial N ≤ L","tag":["pos","_@","_hyg",2082],"mvarId":["_uniq",97916],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",97780],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",97854],"binderInfo":"default"},{"type":"N ≥ 0","name":["h"],"isProp":true,"id":["_uniq",97915],"binderInfo":"default"}]},{"type":"(a n).partial N ≤ L","tag":["neg","_@","_hyg",2082],"mvarId":["_uniq",97923],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",97780],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",97854],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["h"],"isProp":true,"id":["_uniq",97922],"binderInfo":"default"}]}],"start":5424},{"state":[{"type":"(a n).partial N ≤ L","tag":["neg","_@","_hyg",2082],"mvarId":["_uniq",97923],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",97780],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",97854],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["h"],"isProp":true,"id":["_uniq",97922],"binderInfo":"default"}]}],"start":5467},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",97787],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]}]}],"start":5528},{"state":[{"type":"∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L","tag":[],"mvarId":["_uniq",102472],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",102236],"binderInfo":"default"},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"}]}],"start":5600},{"state":[{"type":"∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L","tag":["neg","_@","_hyg",2223],"mvarId":["_uniq",102548],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",102236],"binderInfo":"default"},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",102547],"binderInfo":"default"}]},{"type":"∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L","tag":["pos","_@","_hyg",2223],"mvarId":["_uniq",102541],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",102236],"binderInfo":"default"},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",102540],"binderInfo":"default"}]}],"start":5632},{"state":[{"type":"∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L","tag":["pos","_@","_hyg",2223],"mvarId":["_uniq",102541],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",102236],"binderInfo":"default"},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",102540],"binderInfo":"default"}]}],"start":5672},{"state":[{"type":"∑ n ∈ Icc 0 (↑N : ℤ), (a n.toNat).partial M ≤ L","tag":["pos","intro","_@","_hyg",2223],"mvarId":["_uniq",103851],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"}]}],"start":5699},{"state":[{"type":"∑ n ∈ Icc 0 (↑N : ℤ), (a n.toNat).partial M ≤ L","tag":["neg","_@","_hyg",2280],"mvarId":["_uniq",103918],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"¬M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",103917],"binderInfo":"default"}]},{"type":"∑ n ∈ Icc 0 (↑N : ℤ), (a n.toNat).partial M ≤ L","tag":["pos","_@","_hyg",2280],"mvarId":["_uniq",103911],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",103910],"binderInfo":"default"}]}],"start":5731},{"state":[{"type":"∑ n ∈ Icc 0 (↑N : ℤ), ∑ n_1 ∈ Icc (a n.toNat).m M, (a n.toNat).seq n_1 = 0","tag":["h","e'_3"],"mvarId":["_uniq",106293],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"¬M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",103917],"binderInfo":"default"}]}],"start":5774},{"state":[{"type":"∑ n_1 ∈ Icc (a n.toNat).m M, (a n.toNat).seq n_1 = 0","tag":["h","e'_3","h"],"mvarId":["_uniq",106335],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"¬M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",103917],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",106331],"binderInfo":"default"},{"type":"n ∈ Icc 0 (↑N : ℤ)","name":["a✝"],"isProp":true,"id":["_uniq",106334],"binderInfo":"default"}]}],"start":5809},{"state":[{"type":"∑ n ∈ Icc 0 (↑N : ℤ), (a n.toNat).partial M ≤ L","tag":["pos","_@","_hyg",2280],"mvarId":["_uniq",103911],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",102238],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",103910],"binderInfo":"default"}]}],"start":5845},{"state":[{"type":"∑ n ∈ Icc 0 (↑N : ℤ), (a n.toNat).partial (↑M : ℤ) ≤ L","tag":["pos","intro","_@","_hyg",2280],"mvarId":["_uniq",108610],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",108593],"binderInfo":"default"}]}],"start":5872},{"state":[{"type":"∑ n ∈ Icc 0 (↑N : ℤ), (a n.toNat).partial (↑M : ℤ) = ∑ x ∈ Icc 0 N ×ˢ Icc 0 M, f x","tag":["h","e'_3"],"mvarId":["_uniq",109014],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",108593],"binderInfo":"default"}]},{"type":"∑ x ∈ Icc 0 N ×ˢ Icc 0 M, f x ≤ L","tag":["pos","intro","_@","_hyg",2280],"mvarId":["_uniq",108779],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",108593],"binderInfo":"default"}]}],"start":5934},{"state":[{"type":"∑ x ∈ Icc 0 N ×ˢ Icc 0 M, f x ≤ L","tag":["pos","intro","_@","_hyg",2280],"mvarId":["_uniq",108779],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",103834],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",108593],"binderInfo":"default"}]}],"start":5978},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",102477],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun N M =>\n  if hN : N ≥ 0 then\n    Exists.casesOn (CanLift.prf N hN) fun N_1 h =>\n      Eq.ndrec (motive := fun N => N ≥ 0 → ∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L)\n        (fun hN =>\n          if hM : M ≥ 0 then\n            Exists.casesOn (CanLift.prf M hM) fun M_1 h =>\n              Eq.ndrec (motive := fun M => M ≥ 0 → ∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial M ≤ L)\n                (fun hM =>\n                  Eq.mpr\n                    (eq_of_heq\n                      ((fun α self a a' e'_3 a_1 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a') (HEq.refl e'_3))\n                        ℝ Real.instLE (∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial (↑M_1 : ℤ))\n                        (∑ x ∈ Icc 0 N_1 ×ˢ Icc 0 M_1, f x)\n                        (of_eq_true\n                          (Eq.trans\n                            (congr\n                              (congrArg Eq\n                                (Eq.trans\n                                  (Eq.trans\n                                    (sum_congr (Finset.Icc_eq_cast N_1) fun x a_1 =>\n                                      Eq.trans\n                                        (Eq.trans\n                                          (sum_congr (Finset.Icc_eq_cast M_1) fun x_1 a =>\n                                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (x.toNat, x_1.toNat)))\n                                              fun a => Eq.refl 0)\n                                          (sum_map (Icc 0 M_1) Nat.castEmbedding fun x_1 =>\n                                            if 0 ≤ x_1 then f (x.toNat, x_1.toNat) else 0))\n                                        (sum_congr (Eq.refl (Icc 0 M_1)) fun x_1 a =>\n                                          ite_cond_eq_true (f (x.toNat, (Nat.castEmbedding x_1).toNat)) 0\n                                            (Nat.cast_nonneg._simp_1 x_1)))\n                                    (sum_map (Icc 0 N_1) Nat.castEmbedding fun x =>\n                                      ∑ x_1 ∈ Icc 0 M_1, f (x.toNat, x_1)))\n                                  (sum_congr (Eq.refl (Icc 0 N_1)) fun x a =>\n                                    sum_congr (Eq.refl (Icc 0 M_1)) fun x_1 a => Eq.refl (f (x, x_1)))))\n                              (sum_product (Icc 0 N_1) (Icc 0 M_1) f))\n                            (eq_self (∑ x ∈ Icc 0 N_1, ∑ x_1 ∈ Icc 0 M_1, f (x, x_1)))))\n                        L))\n                    (id (hfinsum (Icc 0 N_1 ×ˢ Icc 0 M_1))))\n                h hM\n          else\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  ℝ Real.instLE (∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial M) 0\n                  (id\n                    (sum_eq_zero fun n a_1 =>\n                      of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            (sum_congr (Finset.Icc_empty hM) fun x a =>\n                              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n.toNat, x.toNat))) fun a => Eq.refl 0))\n                          (eq_self 0))))\n                  L))\n              hLpos)\n        h hN\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ L) (sum_congr (Finset.Icc_empty hN) fun x a_1 => Eq.refl ((a x.toNat).partial M)))\n        (eq_true hLpos))","type":"∀ (N M : ℤ), ∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L","name":["this"],"isProp":true,"id":["_uniq",102474]}]}],"start":5996},{"state":[{"type":"∑ n ∈ Icc 0 N, (a n.toNat).sum ≤ L","tag":[],"mvarId":["_uniq",118394],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun N M =>\n  if hN : N ≥ 0 then\n    Exists.casesOn (CanLift.prf N hN) fun N_1 h =>\n      Eq.ndrec (motive := fun N => N ≥ 0 → ∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L)\n        (fun hN =>\n          if hM : M ≥ 0 then\n            Exists.casesOn (CanLift.prf M hM) fun M_1 h =>\n              Eq.ndrec (motive := fun M => M ≥ 0 → ∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial M ≤ L)\n                (fun hM =>\n                  Eq.mpr\n                    (eq_of_heq\n                      ((fun α self a a' e'_3 a_1 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a') (HEq.refl e'_3))\n                        ℝ Real.instLE (∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial (↑M_1 : ℤ))\n                        (∑ x ∈ Icc 0 N_1 ×ˢ Icc 0 M_1, f x)\n                        (of_eq_true\n                          (Eq.trans\n                            (congr\n                              (congrArg Eq\n                                (Eq.trans\n                                  (Eq.trans\n                                    (sum_congr (Finset.Icc_eq_cast N_1) fun x a_1 =>\n                                      Eq.trans\n                                        (Eq.trans\n                                          (sum_congr (Finset.Icc_eq_cast M_1) fun x_1 a =>\n                                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (x.toNat, x_1.toNat)))\n                                              fun a => Eq.refl 0)\n                                          (sum_map (Icc 0 M_1) Nat.castEmbedding fun x_1 =>\n                                            if 0 ≤ x_1 then f (x.toNat, x_1.toNat) else 0))\n                                        (sum_congr (Eq.refl (Icc 0 M_1)) fun x_1 a =>\n                                          ite_cond_eq_true (f (x.toNat, (Nat.castEmbedding x_1).toNat)) 0\n                                            (Nat.cast_nonneg._simp_1 x_1)))\n                                    (sum_map (Icc 0 N_1) Nat.castEmbedding fun x =>\n                                      ∑ x_1 ∈ Icc 0 M_1, f (x.toNat, x_1)))\n                                  (sum_congr (Eq.refl (Icc 0 N_1)) fun x a =>\n                                    sum_congr (Eq.refl (Icc 0 M_1)) fun x_1 a => Eq.refl (f (x, x_1)))))\n                              (sum_product (Icc 0 N_1) (Icc 0 M_1) f))\n                            (eq_self (∑ x ∈ Icc 0 N_1, ∑ x_1 ∈ Icc 0 M_1, f (x, x_1)))))\n                        L))\n                    (id (hfinsum (Icc 0 N_1 ×ˢ Icc 0 M_1))))\n                h hM\n          else\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  ℝ Real.instLE (∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial M) 0\n                  (id\n                    (sum_eq_zero fun n a_1 =>\n                      of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            (sum_congr (Finset.Icc_empty hM) fun x a =>\n                              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n.toNat, x.toNat))) fun a => Eq.refl 0))\n                          (eq_self 0))))\n                  L))\n              hLpos)\n        h hN\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ L) (sum_congr (Finset.Icc_empty hN) fun x a_1 => Eq.refl ((a x.toNat).partial M)))\n        (eq_true hLpos))","type":"∀ (N M : ℤ), ∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L","name":["this"],"isProp":true,"id":["_uniq",102474]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",118171],"binderInfo":"default"}]}],"start":6063},{"state":[{"type":"∀ i ∈ Icc 0 N, Tendsto (a i.toNat).partial atTop (nhds (a i.toNat).sum)","tag":[],"mvarId":["_uniq",118532],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun N M =>\n  if hN : N ≥ 0 then\n    Exists.casesOn (CanLift.prf N hN) fun N_1 h =>\n      Eq.ndrec (motive := fun N => N ≥ 0 → ∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L)\n        (fun hN =>\n          if hM : M ≥ 0 then\n            Exists.casesOn (CanLift.prf M hM) fun M_1 h =>\n              Eq.ndrec (motive := fun M => M ≥ 0 → ∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial M ≤ L)\n                (fun hM =>\n                  Eq.mpr\n                    (eq_of_heq\n                      ((fun α self a a' e'_3 a_1 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a') (HEq.refl e'_3))\n                        ℝ Real.instLE (∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial (↑M_1 : ℤ))\n                        (∑ x ∈ Icc 0 N_1 ×ˢ Icc 0 M_1, f x)\n                        (of_eq_true\n                          (Eq.trans\n                            (congr\n                              (congrArg Eq\n                                (Eq.trans\n                                  (Eq.trans\n                                    (sum_congr (Finset.Icc_eq_cast N_1) fun x a_1 =>\n                                      Eq.trans\n                                        (Eq.trans\n                                          (sum_congr (Finset.Icc_eq_cast M_1) fun x_1 a =>\n                                            ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (x.toNat, x_1.toNat)))\n                                              fun a => Eq.refl 0)\n                                          (sum_map (Icc 0 M_1) Nat.castEmbedding fun x_1 =>\n                                            if 0 ≤ x_1 then f (x.toNat, x_1.toNat) else 0))\n                                        (sum_congr (Eq.refl (Icc 0 M_1)) fun x_1 a =>\n                                          ite_cond_eq_true (f (x.toNat, (Nat.castEmbedding x_1).toNat)) 0\n                                            (Nat.cast_nonneg._simp_1 x_1)))\n                                    (sum_map (Icc 0 N_1) Nat.castEmbedding fun x =>\n                                      ∑ x_1 ∈ Icc 0 M_1, f (x.toNat, x_1)))\n                                  (sum_congr (Eq.refl (Icc 0 N_1)) fun x a =>\n                                    sum_congr (Eq.refl (Icc 0 M_1)) fun x_1 a => Eq.refl (f (x, x_1)))))\n                              (sum_product (Icc 0 N_1) (Icc 0 M_1) f))\n                            (eq_self (∑ x ∈ Icc 0 N_1, ∑ x_1 ∈ Icc 0 M_1, f (x, x_1)))))\n                        L))\n                    (id (hfinsum (Icc 0 N_1 ×ˢ Icc 0 M_1))))\n                h hM\n          else\n            Eq.mpr\n              (eq_of_heq\n                ((fun α self a a' e'_3 a_1 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                          (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  ℝ Real.instLE (∑ n ∈ Icc 0 (↑N_1 : ℤ), (a n.toNat).partial M) 0\n                  (id\n                    (sum_eq_zero fun n a_1 =>\n                      of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            (sum_congr (Finset.Icc_empty hM) fun x a =>\n                              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n.toNat, x.toNat))) fun a => Eq.refl 0))\n                          (eq_self 0))))\n                  L))\n              hLpos)\n        h hN\n  else\n    of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x ≤ L) (sum_congr (Finset.Icc_empty hN) fun x a_1 => Eq.refl ((a x.toNat).partial M)))\n        (eq_true hLpos))","type":"∀ (N M : ℤ), ∑ n ∈ Icc 0 N, (a n.toNat).partial M ≤ L","name":["this"],"isProp":true,"id":["_uniq",102474]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",118171],"binderInfo":"default"}]}],"start":6136},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",120843],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), ∑ n ∈ Icc 0 N, (a n.toNat).sum ≤ L","name":["this"],"isProp":true,"id":["_uniq",118396]}]}],"start":6172},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","tag":[],"mvarId":["_uniq",120946],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), ∑ n ∈ Icc 0 N, (a n.toNat).sum ≤ L","name":["this"],"isProp":true,"id":["_uniq",118396]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",120845],"binderInfo":"default"}]}],"start":6243},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",132072],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","name":["this"],"isProp":true,"id":["_uniq",120948]}]}],"start":6282},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","tag":[],"mvarId":["_uniq",132169],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","name":["this"],"isProp":true,"id":["_uniq",120948]}]}],"start":6339},{"state":[{"type":"0 ≤ (a n.toNat).sum","tag":["pos","_@","_hyg",2640],"mvarId":["_uniq",134715],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","name":["this"],"isProp":true,"id":["_uniq",120948]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",132176],"binderInfo":"default"},{"type":"0 ≤ n","name":["h✝"],"isProp":true,"id":["_uniq",134437],"binderInfo":"default"}]},{"type":"0 ≤ 0","tag":["neg","_@","_hyg",2640],"mvarId":["_uniq",135008],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","name":["this"],"isProp":true,"id":["_uniq",120948]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",132176],"binderInfo":"default"},{"type":"¬0 ≤ n","name":["h✝"],"isProp":true,"id":["_uniq",134444],"binderInfo":"default"}]}],"start":6368},{"state":[{"type":"0 ≤ 0","tag":["neg","_@","_hyg",2640],"mvarId":["_uniq",135008],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","name":["this"],"isProp":true,"id":["_uniq",120948]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",132176],"binderInfo":"default"},{"type":"¬0 ≤ n","name":["h✝"],"isProp":true,"id":["_uniq",134444],"binderInfo":"default"}]}],"start":6409},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",132172],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","name":["this"],"isProp":true,"id":["_uniq",120948]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]}]}],"start":6418},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","tag":[],"mvarId":["_uniq",135140],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","name":["this"],"isProp":true,"id":["_uniq",120948]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]}]}],"start":6479},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",135142],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"type":"∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.partial N ≤ L","name":["this"],"isProp":true,"id":["_uniq",120948]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L this)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]}]}],"start":6525},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",135855],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"value":"le_of_tendsto' (convergesTo_sum hconv') _fvar.120948","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum ≤ L","name":["this"],"isProp":true,"id":["_uniq",135851]}]}],"start":6624},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum = L","tag":[],"mvarId":["_uniq",135867],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"value":"le_of_tendsto' (convergesTo_sum hconv') _fvar.120948","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum ≤ L","name":["this"],"isProp":true,"id":["_uniq",135851]}]}],"start":6679},{"state":[{"type":"L - ε ≤ { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",136094],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"value":"le_of_tendsto' (convergesTo_sum hconv') _fvar.120948","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum ≤ L","name":["this"],"isProp":true,"id":["_uniq",135851]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"}]}],"start":6744},{"state":[{"type":"∃ X, ∑ p ∈ X, f p ≥ L - ε","tag":[],"mvarId":["_uniq",136176],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"value":"le_of_tendsto' (convergesTo_sum hconv') _fvar.120948","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum ≤ L","name":["this"],"isProp":true,"id":["_uniq",135851]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"}]}],"start":6799},{"state":[{"type":"L - ε ≤ { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",136182],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"value":"sorry","type":"∃ X, ∑ p ∈ X, f p ≥ L - ε","name":["this"],"isProp":true,"id":["_uniq",136177]}]}],"start":6811},{"state":[{"type":"L - ε ≤ { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",136189],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"type":"Finset (ℕ × ℕ)","name":["X"],"isProp":false,"id":["_uniq",136184],"binderInfo":"default"},{"type":"∑ p ∈ X, f p ≥ L - ε","name":["hX"],"isProp":true,"id":["_uniq",136188],"binderInfo":"default"}]}],"start":6838},{"state":[{"type":"∃ N M, X ⊆ Icc 0 N ×ˢ Icc 0 M","tag":[],"mvarId":["_uniq",136603],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"type":"Finset (ℕ × ℕ)","name":["X"],"isProp":false,"id":["_uniq",136184],"binderInfo":"default"},{"type":"∑ p ∈ X, f p ≥ L - ε","name":["hX"],"isProp":true,"id":["_uniq",136188],"binderInfo":"default"}]}],"start":6900},{"state":[{"type":"L - ε ≤ { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",136605],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"type":"Finset (ℕ × ℕ)","name":["X"],"isProp":false,"id":["_uniq",136184],"binderInfo":"default"},{"type":"∑ p ∈ X, f p ≥ L - ε","name":["hX"],"isProp":true,"id":["_uniq",136188],"binderInfo":"default"},{"value":"sorry","type":"∃ N M, X ⊆ Icc 0 N ×ˢ Icc 0 M","name":["this"],"isProp":true,"id":["_uniq",136604]}]}],"start":6912},{"state":[{"type":"L - ε ≤ { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",136623],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"type":"Finset (ℕ × ℕ)","name":["X"],"isProp":false,"id":["_uniq",136184],"binderInfo":"default"},{"type":"∑ p ∈ X, f p ≥ L - ε","name":["hX"],"isProp":true,"id":["_uniq",136188],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",136610],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",136618],"binderInfo":"default"},{"type":"X ⊆ Icc 0 N ×ˢ Icc 0 M","name":["hX'"],"isProp":true,"id":["_uniq",136622],"binderInfo":"default"}]}],"start":6942},{"state":[{"type":"L - ε ≤ { m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",136623],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"type":"Finset (ℕ × ℕ)","name":["X"],"isProp":false,"id":["_uniq",136184],"binderInfo":"default"},{"type":"∑ p ∈ X, f p ≥ L - ε","name":["hX"],"isProp":true,"id":["_uniq",136188],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",136610],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",136618],"binderInfo":"default"},{"type":"X ⊆ Icc 0 N ×ˢ Icc 0 M","name":["hX'"],"isProp":true,"id":["_uniq",136622],"binderInfo":"default"}]}],"start":6951},{"state":[],"start":6986},{"state":[],"start":7095},{"state":[],"start":7173},{"state":[{"type":"∑ n ∈ Icc 0 N, ∑ m ∈ Icc 0 M, f (n, m) ≤ ∑ n ∈ Icc 0 N, (a n).sum","tag":[],"mvarId":["_uniq",137806],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"type":"Finset (ℕ × ℕ)","name":["X"],"isProp":false,"id":["_uniq",136184],"binderInfo":"default"},{"type":"∑ p ∈ X, f p ≥ L - ε","name":["hX"],"isProp":true,"id":["_uniq",136188],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",136610],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",136618],"binderInfo":"default"},{"type":"X ⊆ Icc 0 N ×ˢ Icc 0 M","name":["hX'"],"isProp":true,"id":["_uniq",136622],"binderInfo":"default"}]}],"start":7220},{"state":[{"type":"∑ m ∈ Icc 0 M, f (n, m) ≤ (a n).sum","tag":["h"],"mvarId":["_uniq",142805],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"type":"Finset (ℕ × ℕ)","name":["X"],"isProp":false,"id":["_uniq",136184],"binderInfo":"default"},{"type":"∑ p ∈ X, f p ≥ L - ε","name":["hX"],"isProp":true,"id":["_uniq",136188],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",136610],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",136618],"binderInfo":"default"},{"type":"X ⊆ Icc 0 N ×ˢ Icc 0 M","name":["hX'"],"isProp":true,"id":["_uniq",136622],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",142801],"binderInfo":"default"},{"type":"n ∈ Icc 0 N","name":["a✝"],"isProp":true,"id":["_uniq",142804],"binderInfo":"default"}]}],"start":7256},{"state":[{"type":"∑ m ∈ Icc 0 M, f (n, m) = (a n).partial (↑M : ℤ)","tag":["h","e'_3"],"mvarId":["_uniq",143201],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",136090],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",136093],"binderInfo":"default"},{"type":"Finset (ℕ × ℕ)","name":["X"],"isProp":false,"id":["_uniq",136184],"binderInfo":"default"},{"type":"∑ p ∈ X, f p ≥ L - ε","name":["hX"],"isProp":true,"id":["_uniq",136188],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",136610],"binderInfo":"default"},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",136618],"binderInfo":"default"},{"type":"X ⊆ Icc 0 N ×ˢ Icc 0 M","name":["hX'"],"isProp":true,"id":["_uniq",136622],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",142801],"binderInfo":"default"},{"type":"n ∈ Icc 0 N","name":["a✝"],"isProp":true,"id":["_uniq",142804],"binderInfo":"default"}]}],"start":7318},{"state":[],"start":7351},{"state":[],"start":7428},{"state":[{"type":"(∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    L","tag":[],"mvarId":["_uniq",155526],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",59574],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",59575],"binderInfo":"default"},{"type":"∀ (n m : ℕ), 0 ≤ f (n, m)","name":["hpos"],"isProp":true,"id":["_uniq",59576],"binderInfo":"default"},{"value":"Sum f","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",59585]},{"value":"fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }","type":"ℕ → Series","name":["a"],"isProp":false,"id":["_uniq",59781]},{"value":"Eq.mpr (id ⋯) ⋯","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",59915]},{"value":"fun X => sorry","type":"∀ (X : Finset (ℕ × ℕ)), ∑ p ∈ X, f p ≤ L","name":["hfinsum"],"isProp":true,"id":["_uniq",85000]},{"value":"fun n M =>\n  Eq.mpr\n    (id\n      (congrArg (fun x => x ≤ L)\n        (Eq.trans\n          (Eq.trans\n            (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n              ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a => Eq.refl 0)\n            (sum_map (Icc 0 M) Nat.castEmbedding fun x => if 0 ≤ x then f (n, x.toNat) else 0))\n          (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n            ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0 (Nat.cast_nonneg._simp_1 x)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                  (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.instLE (∑ x ∈ Icc 0 M, f (n, x)) (∑ x ∈ Finset.map (Embedding.sectR n ℕ) (Icc 0 M), f x)\n          (of_eq_true\n            (Eq.trans\n              (congrArg (Eq (∑ x ∈ Icc 0 M, f (n, x)))\n                (Eq.trans (sum_map (Icc 0 M) (Embedding.sectR n ℕ) f)\n                  (sum_congr (Eq.refl (Icc 0 M)) fun x a => Eq.refl (f (n, x)))))\n              (eq_self (∑ x ∈ Icc 0 M, f (n, x)))))\n          L))\n      (id (hfinsum (Finset.map (Embedding.sectR n ℕ) (Icc 0 M)))))","type":"∀ (n M : ℕ), (a n).partial (↑M : ℤ) ≤ L","name":["hfinsum'"],"isProp":true,"id":["_uniq",85054]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (forall_congr fun n_1 =>\n        Eq.trans\n          (congrArg (fun x => x ≥ 0)\n            (ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, n_1.toNat))) fun a => Eq.refl 0))\n          ge_iff_le._simp_1))\n    fun m =>\n    if h : 0 ≤ m then\n      Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (of_eq_true ((fun n m => eq_true (hpos n m)) n m.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0))","type":"∀ (n : ℕ), (a n).nonneg","name":["hnon"],"isProp":true,"id":["_uniq",92369]},{"value":"fun n =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff (hnon n)))))\n    (Exists.intro L fun N =>\n      if h : N ≥ 0 then\n        Exists.casesOn (CanLift.prf N h) fun N_1 h_1 =>\n          Eq.ndrec (motive := fun N => N ≥ 0 → (a n).partial N ≤ L) (fun h => hfinsum' n N_1) h_1 h\n      else\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a ≤ L)\n              (partial_of_lt\n                (id\n                  (lt_of_not_ge fun a =>\n                    Mathlib.Tactic.Linarith.lt_irrefl\n                      (Eq.mp\n                        (congrArg (fun _a => _a < 0)\n                          (Mathlib.Tactic.Ring.of_eq\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.neg_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1)))))\n                                    Mathlib.Tactic.Ring.neg_zero))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                                      (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.ofNat 0))))\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.sub_congr\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                (Mathlib.Tactic.Ring.atom_pf N)\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                            (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge h))))\n                          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))))))\n          hLpos)","type":"∀ (n : ℕ), (a n).converges","name":["hconv"],"isProp":true,"id":["_uniq",97785]},{"value":"fun n =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => x ≥ 0)\n          (ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat).sum) fun a => Eq.refl 0))\n        ge_iff_le._simp_1))\n    (if h : 0 ≤ n then Eq.mpr (id (congrArg (LE.le 0) (if_pos h))) (sum_of_nonneg (hnon n.toNat))\n    else Eq.mpr (id (congrArg (LE.le 0) (if_neg h))) (of_eq_true (le_refl._simp_1 0)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.nonneg","name":["hnon'"],"isProp":true,"id":["_uniq",132170]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (converges_of_nonneg_iff hnon')))) (Exists.intro L _fvar.120948)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.converges","name":["hconv'"],"isProp":true,"id":["_uniq",135141]},{"value":"le_antisymm _fvar.135851\n  (le_of_forall_sub_le fun ε hε =>\n    have this := sorry;\n    (fun X hX =>\n        have this := sorry;\n        (fun N x =>\n            (fun M hX' =>\n                Trans.trans\n                  (Trans.trans\n                    (Trans.trans\n                      (Trans.trans (Trans.trans hX (sum_le_sum_of_subset_of_nonneg hX' fun i a a => hpos i.1 i.2))\n                        (sum_product (Icc 0 N) (Icc 0 M) f))\n                      (sum_le_sum fun n a_1 =>\n                        Eq.mpr\n                          (eq_of_heq\n                            ((fun α self self' e'_2 a a' e'_3 a_2 =>\n                                Eq.casesOn (motive := fun a_3 x => self' = a_3 → e'_2 ≍ x → (a ≤ a_2) ≍ (a' ≤ a_2)) e'_2\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun self' =>\n                                      ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_2) ≍ (a' ≤ a_2))\n                                      (fun e_2 h =>\n                                        Eq.casesOn (motive := fun a_3 x => a' = a_3 → e'_3 ≍ x → (a ≤ a_2) ≍ (a' ≤ a_2))\n                                          e'_3\n                                          (fun h =>\n                                            Eq.ndrec (motive := fun a' =>\n                                              ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_2) ≍ (a' ≤ a_2))\n                                              (fun e_3 h => HEq.refl (a ≤ a_2)) (Eq.symm h) e'_3)\n                                          (Eq.refl a') (HEq.refl e'_3))\n                                      (Eq.symm h) e'_2)\n                                  (Eq.refl self') (HEq.refl e'_2))\n                              ℝ Real.partialOrder.toLE Real.instLE (Eq.refl Real.partialOrder.toLE)\n                              (∑ m ∈ Icc 0 M, f (n, m)) ((a n).partial (↑M : ℤ))\n                              (of_eq_true\n                                (Eq.trans\n                                  (congrArg (Eq (∑ m ∈ Icc 0 M, f (n, m)))\n                                    (Eq.trans\n                                      (Eq.trans\n                                        (sum_congr (Finset.Icc_eq_cast M) fun x a =>\n                                          ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (f (n, x.toNat))) fun a =>\n                                            Eq.refl 0)\n                                        (sum_map (Icc 0 M) Nat.castEmbedding fun x =>\n                                          if 0 ≤ x then f (n, x.toNat) else 0))\n                                      (sum_congr (Eq.refl (Icc 0 M)) fun x a =>\n                                        ite_cond_eq_true (f (n, (Nat.castEmbedding x).toNat)) 0\n                                          (Nat.cast_nonneg._simp_1 x))))\n                                  (eq_self (∑ m ∈ Icc 0 M, f (n, m)))))\n                              (a n).sum))\n                          (partial_le_sum_of_nonneg (hnon n) (hconv n) (↑M : ℤ))))\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (Eq (∑ n ∈ Icc 0 N, (a n).sum))\n                          (Eq.trans\n                            (Eq.trans\n                              (sum_congr (Finset.Icc_eq_cast N) fun x a_1 =>\n                                ite_congr ge_iff_le._simp_1 (fun a_2 => Eq.refl (a x.toNat).sum) fun a => Eq.refl 0)\n                              (sum_map (Icc 0 N) Nat.castEmbedding fun x => if 0 ≤ x then (a x.toNat).sum else 0))\n                            (sum_congr (Eq.refl (Icc 0 N)) fun x a_1 =>\n                              ite_cond_eq_true (a (Nat.castEmbedding x).toNat).sum 0 (Nat.cast_nonneg._simp_1 x))))\n                        (eq_self (∑ n ∈ Icc 0 N, (a n).sum)))))\n                  (partial_le_sum_of_nonneg hnon' hconv' (↑N : ℤ)))\n              (Classical.choose x) (Classical.choose_spec x))\n          (Classical.choose this) (Classical.choose_spec this))\n      (Classical.choose this) (Classical.choose_spec this))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (a n).sum) n.toNat else 0, vanish := ⋯ }.sum = L","name":["this"],"isProp":true,"id":["_uniq",135868]}]}],"start":7485},{"state":[],"start":7544},{"state":[],"start":7545},{"state":[],"start":7582},{"state":[],"start":7664},{"state":[],"start":7722},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",168248],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"}]}],"start":7803},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",168331],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]}]}],"start":7826},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",168423],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]}]}],"start":7853},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",168545],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]}]}],"start":7934},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",182546],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]}]}],"start":8018},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",196507],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]}]}],"start":8064},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",196521],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]}]}],"start":8117},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",196532],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]}]}],"start":8172},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",196553],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"}]}],"start":8272},{"state":[{"type":"(∀ (n : ℕ),\n    { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun n =>\n                { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",196569],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8376},{"state":[{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges","tag":["refine_1"],"mvarId":["_uniq",196573],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum f)","tag":["refine_2"],"mvarId":["_uniq",196574],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8389},{"state":[{"type":"{ m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.absConverges","tag":["refine_1"],"mvarId":["_uniq",196589],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",196588],"binderInfo":"default"}]}],"start":8401},{"state":[{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum f)","tag":["refine_2"],"mvarId":["_uniq",196574],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8411},{"state":[{"type":"{ m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        (fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } -\n    { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",196931],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]},{"type":"Sum f = Sum fplus - Sum fminus","tag":["h","e'_2"],"mvarId":["_uniq",196932],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8468},{"state":[{"type":"{ m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        (fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } -\n    { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",196931],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8544},{"state":[{"type":"{ m := 0,\n    seq := fun n =>\n      if 0 ≤ n then\n        { m := 0, seq := fun n_1 => if 0 ≤ n_1 then fplus (n.toNat, n_1.toNat) - fminus (n.toNat, n_1.toNat) else 0,\n            vanish := ⋯ }.sum\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n      seq := fun n =>\n        if 0 ≤ n then { m := 0, seq := fun n_1 => if 0 ≤ n_1 then fplus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.sum\n        else 0,\n      vanish := ⋯ } -\n    { m := 0,\n      seq := fun n =>\n        if 0 ≤ n then { m := 0, seq := fun n_1 => if 0 ≤ n_1 then fminus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.sum\n        else 0,\n      vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",214257],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8561},{"state":[{"type":"{ m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        (fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => (fplus - fminus) (n, m)) n_1.toNat else 0,\n                vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } -\n    { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",215024],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8642},{"state":[{"type":"{ m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        (fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => (fplus - fminus) (n, m)) n_1.toNat else 0,\n                vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } -\n    { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",215024],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8705},{"state":[{"type":"{ m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        (fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => (fplus - fminus) (n, m)) n_1.toNat else 0,\n                vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } -\n    { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",215024],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8773},{"state":[{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } -\n    { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } =\n  { m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        ((fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum) -\n            fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ }","tag":["h","e'_3"],"mvarId":["_uniq",215763],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]},{"type":"{ m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        (fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => (fplus - fminus) (n, m)) n_1.toNat else 0,\n                vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        ((fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum) -\n            fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",215550],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8858},{"state":[{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } -\n    { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ } =\n  { m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        ((fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum) -\n            fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ }","tag":["h","e'_3"],"mvarId":["_uniq",215763],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]},{"type":"{ m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        (fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => (fplus - fminus) (n, m)) n_1.toNat else 0,\n                vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        ((fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum) -\n            fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",215550],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":8992},{"state":[{"type":"{ m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        (fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => (fplus - fminus) (n, m)) n_1.toNat else 0,\n                vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ } =\n  { m := 0,\n    seq := fun n =>\n      if n ≥ 0 then\n        ((fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum) -\n            fun n =>\n            { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n          n.toNat\n      else 0,\n    vanish := ⋯ }","tag":["h","e'_1"],"mvarId":["_uniq",215550],"isProp":false,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":9018},{"state":[{"type":"{ m := 0, seq := fun n_1 => if 0 ≤ n_1 then fplus (n.toNat, n_1.toNat) - fminus (n.toNat, n_1.toNat) else 0,\n      vanish := ⋯ }.sum =\n  { m := 0, seq := fun n_1 => if 0 ≤ n_1 then fplus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.sum -\n    { m := 0, seq := fun n_1 => if 0 ≤ n_1 then fminus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.sum","tag":["h","e'_1","seq","h","e_self","e_seq","h","e_t"],"mvarId":["_uniq",231787],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℤ","name":["x✝"],"isProp":false,"id":["_uniq",220942],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",221342],"binderInfo":"default"}]}],"start":9039},{"state":[{"type":"(if 0 ≤ m then fplus (n.toNat, m.toNat) - fminus (n.toNat, m.toNat) else 0) =\n  ({ m := 0, seq := fun n_1 => if 0 ≤ n_1 then fplus (n.toNat, n_1.toNat) else 0, vanish := ⋯ } -\n        { m := 0, seq := fun n_1 => if 0 ≤ n_1 then fminus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }).seq\n    m","tag":["h","e'_2","h","e'_1","h","e'_2","h"],"mvarId":["_uniq",233862],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℤ","name":["x✝"],"isProp":false,"id":["_uniq",220942],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",221342],"binderInfo":"default"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",233861],"binderInfo":"default"}]},{"type":"{ m := 0, seq := fun n_1 => if 0 ≤ n_1 then fplus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.converges","tag":["h","e'_1","seq","h","e_self","e_seq","h","e_t","convert_3"],"mvarId":["_uniq",231791],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℤ","name":["x✝"],"isProp":false,"id":["_uniq",220942],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",221342],"binderInfo":"default"}]},{"type":"{ m := 0, seq := fun n_1 => if 0 ≤ n_1 then fminus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.converges","tag":["h","e'_1","seq","h","e_self","e_seq","h","e_t","convert_4"],"mvarId":["_uniq",231792],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℤ","name":["x✝"],"isProp":false,"id":["_uniq",220942],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",221342],"binderInfo":"default"}]}],"start":9075},{"state":[{"type":"{ m := 0, seq := fun n_1 => if 0 ≤ n_1 then fplus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.converges","tag":["h","e'_1","seq","h","e_self","e_seq","h","e_t","convert_3"],"mvarId":["_uniq",231791],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℤ","name":["x✝"],"isProp":false,"id":["_uniq",220942],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",221342],"binderInfo":"default"}]},{"type":"{ m := 0, seq := fun n_1 => if 0 ≤ n_1 then fminus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.converges","tag":["h","e'_1","seq","h","e_self","e_seq","h","e_t","convert_4"],"mvarId":["_uniq",231792],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℤ","name":["x✝"],"isProp":false,"id":["_uniq",220942],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",221342],"binderInfo":"default"}]}],"start":9129},{"state":[{"type":"{ m := 0, seq := fun n_1 => if 0 ≤ n_1 then fminus (n.toNat, n_1.toNat) else 0, vanish := ⋯ }.converges","tag":["h","e'_1","seq","h","e_self","e_seq","h","e_t","convert_4"],"mvarId":["_uniq",231792],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℤ","name":["x✝"],"isProp":false,"id":["_uniq",220942],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",221342],"binderInfo":"default"}]}],"start":9149},{"state":[{"type":"Sum f = Sum fplus - Sum fminus","tag":["h","e'_2"],"mvarId":["_uniq",196932],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"}]}],"start":9183},{"state":[{"type":"Sum f = Sum fplus - Sum fminus","tag":["h","e'_2"],"mvarId":["_uniq",243494],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",243486],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",243487],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["right✝"],"isProp":true,"id":["_uniq",243488],"binderInfo":"default"}]}],"start":9213},{"state":[{"type":"Sum f = Sum fplus - Sum fminus","tag":["h","e'_2"],"mvarId":["_uniq",243649],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",243486],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",243487],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["right✝"],"isProp":true,"id":["_uniq",243488],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hf)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum f)","name":["h1"],"isProp":true,"id":["_uniq",243648]}]}],"start":9249},{"state":[{"type":"Sum f = Sum fplus - Sum fminus","tag":["h","e'_2"],"mvarId":["_uniq",243673],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",243486],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",243487],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["right✝"],"isProp":true,"id":["_uniq",243488],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hf)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum f)","name":["h1"],"isProp":true,"id":["_uniq",243648]},{"value":"Sum.eq hg (AbsConvergent.comp hg hfplus_conv)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fplus ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum fplus)","name":["hplus"],"isProp":true,"id":["_uniq",243672]}]}],"start":9297},{"state":[{"type":"Sum f = Sum fplus - Sum fminus","tag":["h","e'_2"],"mvarId":["_uniq",243697],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",243486],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",243487],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["right✝"],"isProp":true,"id":["_uniq",243488],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hf)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum f)","name":["h1"],"isProp":true,"id":["_uniq",243648]},{"value":"Sum.eq hg (AbsConvergent.comp hg hfplus_conv)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fplus ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum fplus)","name":["hplus"],"isProp":true,"id":["_uniq",243672]},{"value":"Sum.eq hg (AbsConvergent.comp hg hfminus_conv)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fminus ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum fminus)","name":["hminus"],"isProp":true,"id":["_uniq",243696]}]}],"start":9347},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum fplus - Sum fminus)","tag":[],"mvarId":["_uniq",243705],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",243486],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",243487],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["right✝"],"isProp":true,"id":["_uniq",243488],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hf)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum f)","name":["h1"],"isProp":true,"id":["_uniq",243648]},{"value":"Sum.eq hg (AbsConvergent.comp hg hfplus_conv)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fplus ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum fplus)","name":["hplus"],"isProp":true,"id":["_uniq",243672]},{"value":"Sum.eq hg (AbsConvergent.comp hg hfminus_conv)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fminus ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum fminus)","name":["hminus"],"isProp":true,"id":["_uniq",243696]}]}],"start":9377},{"state":[{"type":"(if n ≥ 0 then (f ∘ g) n.toNat else 0) =\n  ({ m := 0, seq := fun n => if n ≥ 0 then (fplus ∘ g) n.toNat else 0, vanish := ⋯ } -\n        { m := 0, seq := fun n => if n ≥ 0 then (fminus ∘ g) n.toNat else 0, vanish := ⋯ }).seq\n    n","tag":["h","e'_1","h","e'_2","h"],"mvarId":["_uniq",245539],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",168246],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",168247],"binderInfo":"default"},{"value":"f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",168330]},{"value":"-f ⊔ 0","type":"ℕ × ℕ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",168422]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fplus (n, m)","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",168542]},{"value":"fun n m => of_eq_true le_sup_right._simp_1","type":"∀ (n m : ℕ), 0 ≤ fminus (n, m)","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",182543]},{"value":"sorry","type":"f = fplus - fminus","name":["hdiff"],"isProp":true,"id":["_uniq",196506]},{"value":"sorry","type":"AbsConvergent fplus","name":["hfplus_conv"],"isProp":true,"id":["_uniq",196520]},{"value":"sorry","type":"AbsConvergent fminus","name":["hfminus_conv"],"isProp":true,"id":["_uniq",196531]},{"type":"∀ (n : ℕ), { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfplus_conv'"],"isProp":true,"id":["_uniq",196548],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fplus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fplus)","name":["hfplus_sum"],"isProp":true,"id":["_uniq",196552],"binderInfo":"default"},{"type":"∀ (n : ℕ),\n  { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.converges","name":["hfminus_conv'"],"isProp":true,"id":["_uniq",196564],"binderInfo":"default"},{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n =>\n              { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => fminus (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.convergesTo\n  (Sum fminus)","name":["hfminus_sum"],"isProp":true,"id":["_uniq",196568],"binderInfo":"default"},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",243486],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",243487],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["right✝"],"isProp":true,"id":["_uniq",243488],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hf)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum f)","name":["h1"],"isProp":true,"id":["_uniq",243648]},{"value":"Sum.eq hg (AbsConvergent.comp hg hfplus_conv)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fplus ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum fplus)","name":["hplus"],"isProp":true,"id":["_uniq",243672]},{"value":"Sum.eq hg (AbsConvergent.comp hg hfminus_conv)","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fminus ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum fminus)","name":["hminus"],"isProp":true,"id":["_uniq",243696]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",245538],"binderInfo":"default"}]}],"start":9433},{"state":[],"start":9492},{"state":[],"start":9493},{"state":[],"start":9529},{"state":[],"start":9612},{"state":[],"start":9670},{"state":[{"type":"(∀ (m : ℕ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun m => { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",254270],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",254268],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",254269],"binderInfo":"default"}]}],"start":9751},{"state":[{"type":"(∀ (m : ℕ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun m => { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",254301],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",254268],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",254269],"binderInfo":"default"},{"value":"fun p => (p.2, p.1)","type":"ℕ × ℕ → ℕ × ℕ","name":["π"],"isProp":false,"id":["_uniq",254300]}]}],"start":9811},{"state":[{"type":"(∀ (m : ℕ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun m => { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",254396],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",254268],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",254269],"binderInfo":"default"},{"value":"fun p => (p.2, p.1)","type":"ℕ × ℕ → ℕ × ℕ","name":["π"],"isProp":false,"id":["_uniq",254300]},{"value":"Involutive.bijective (congrFun rfl)","type":"Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",254395]}]}],"start":9875},{"state":[{"type":"(∀ (m : ℕ), { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.absConverges) ∧\n  { m := 0,\n        seq := fun n =>\n          if n ≥ 0 then\n            (fun m => { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.sum)\n              n.toNat\n          else 0,\n        vanish := ⋯ }.convergesTo\n    (Sum f)","tag":[],"mvarId":["_uniq",254485],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",254268],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",254269],"binderInfo":"default"},{"value":"fun p => (p.2, p.1)","type":"ℕ × ℕ → ℕ × ℕ","name":["π"],"isProp":false,"id":["_uniq",254300]},{"value":"Involutive.bijective (congrFun rfl)","type":"Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",254395]},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",254477],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",254478],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",254479],"binderInfo":"default"}]}],"start":9909},{"state":[{"type":"Sum f = Sum (f ∘ π)","tag":["h","e'_2","h","e'_2"],"mvarId":["_uniq",255596],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",254268],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",254269],"binderInfo":"default"},{"value":"fun p => (p.2, p.1)","type":"ℕ × ℕ → ℕ × ℕ","name":["π"],"isProp":false,"id":["_uniq",254300]},{"value":"Involutive.bijective (congrFun rfl)","type":"Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",254395]},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",254477],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",254478],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",254479],"binderInfo":"default"}]},{"type":"AbsConvergent (f ∘ π)","tag":[],"mvarId":["_uniq",254600],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",254268],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",254269],"binderInfo":"default"},{"value":"fun p => (p.2, p.1)","type":"ℕ × ℕ → ℕ × ℕ","name":["π"],"isProp":false,"id":["_uniq",254300]},{"value":"Involutive.bijective (congrFun rfl)","type":"Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",254395]},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",254477],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",254478],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",254479],"binderInfo":"default"}]}],"start":9973},{"state":[{"type":"AbsConvergent (f ∘ π)","tag":[],"mvarId":["_uniq",254600],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",254268],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",254269],"binderInfo":"default"},{"value":"fun p => (p.2, p.1)","type":"ℕ × ℕ → ℕ × ℕ","name":["π"],"isProp":false,"id":["_uniq",254300]},{"value":"Involutive.bijective (congrFun rfl)","type":"Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",254395]},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",254477],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",254478],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",254479],"binderInfo":"default"}]}],"start":10006},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ π) ∘ π ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","tag":[],"mvarId":["_uniq",261182],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",254268],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",254269],"binderInfo":"default"},{"value":"fun p => (p.2, p.1)","type":"ℕ × ℕ → ℕ × ℕ","name":["π"],"isProp":false,"id":["_uniq",254300]},{"value":"Involutive.bijective (congrFun rfl)","type":"Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",254395]},{"type":"ℕ → ℕ × ℕ","name":["g"],"isProp":false,"id":["_uniq",254477],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",254478],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["hconv"],"isProp":true,"id":["_uniq",254479],"binderInfo":"default"}]}],"start":10042},{"state":[],"start":10066},{"state":[],"start":10067},{"state":[],"start":10104},{"state":[],"start":10167},{"state":[{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun n => { m := 0, seq := fun n_1 => if n_1 ≥ 0 then (fun m => f (n, m)) n_1.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.sum =\n  { m := 0,\n      seq := fun n =>\n        if n ≥ 0 then\n          (fun m => { m := 0, seq := fun n => if n ≥ 0 then (fun n => f (n, m)) n.toNat else 0, vanish := ⋯ }.sum)\n            n.toNat\n        else 0,\n      vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",262205],"isProp":true,"context":[{"type":"ℕ × ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",262203],"binderInfo":"implicit"},{"type":"AbsConvergent f","name":["hf"],"isProp":true,"id":["_uniq",262204],"binderInfo":"default"}]}],"start":10291},{"state":[],"start":10352},{"state":[],"start":10414},{"state":[],"start":10415},{"state":[],"start":10451},{"state":[],"start":10529},{"state":[{"type":"AbsConvergent f ↔ BddAbove ((fun A => ∑ x ∈ A, |f x|) '' Set.univ)","tag":[],"mvarId":["_uniq",273018],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",273015],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",273016],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",273017],"binderInfo":"default"}]}],"start":10610},{"state":[],"start":10620},{"state":[],"start":10621},{"state":[],"start":10730},{"state":[],"start":10731},{"state":[{"type":"AbsConvergent' f","tag":[],"mvarId":["_uniq",273412],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",273409],"binderInfo":"implicit"},{"type":"Finite X","name":["inst✝"],"isProp":true,"id":["_uniq",273410],"binderInfo":"instImplicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",273411],"binderInfo":"default"}]}],"start":10823},{"state":[{"type":"AbsConvergent' f","tag":[],"mvarId":["_uniq",273425],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",273409],"binderInfo":"implicit"},{"type":"Finite X","name":["inst✝"],"isProp":true,"id":["_uniq",273410],"binderInfo":"instImplicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",273411],"binderInfo":"default"},{"value":"Fintype.ofFinite X","type":"Fintype X","name":["x✝"],"isProp":false,"id":["_uniq",273424]}]}],"start":10854},{"state":[],"start":10949},{"state":[],"start":10950},{"state":[],"start":11005},{"state":[],"start":11091},{"state":[{"type":"AbsConvergent' f ↔ AbsConvergent f","tag":[],"mvarId":["_uniq",281892],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"}]}],"start":11136},{"state":[{"type":"AbsConvergent' f → AbsConvergent f","tag":["mp"],"mvarId":["_uniq",281899],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"}]},{"type":"AbsConvergent f → AbsConvergent' f","tag":["mpr"],"mvarId":["_uniq",281900],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"}]}],"start":11150},{"state":[{"type":"AbsConvergent f","tag":["mp"],"mvarId":["_uniq",287755],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"}]}],"start":11212},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","tag":["mp"],"mvarId":["_uniq",287889],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"}]}],"start":11272},{"state":[{"type":"∃ M, ∀ (N : ℤ), { m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.partial N ≤ M","tag":["mp"],"mvarId":["_uniq",287898],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"}]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.nonneg","tag":["mp"],"mvarId":["_uniq",287894],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"}]}],"start":11326},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.partial N ≤ L","tag":["pos","_@","_hyg",5172],"mvarId":["_uniq",288015],"isProp":false,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",287953],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",288014],"binderInfo":"default"}]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.partial N ≤ L","tag":["neg","_@","_hyg",5172],"mvarId":["_uniq",288022],"isProp":false,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",287953],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",288021],"binderInfo":"default"}]}],"start":11369},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.partial (↑N : ℤ) ≤ L","tag":["pos","intro","_@","_hyg",5172],"mvarId":["_uniq",288125],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",288108],"binderInfo":"default"}]}],"start":11400},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.partial (↑N : ℤ) ≤ L","tag":["pos","intro","_@","_hyg",5172],"mvarId":["_uniq",288143],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",288108],"binderInfo":"default"},{"value":"{ toFun := g, inj' := ⋯ }","type":"ℕ ↪ X","name":["g'"],"isProp":false,"id":["_uniq",288142]}]}],"start":11437},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.partial (↑N : ℤ) =\n  ∑ x ∈ Finset.map g' (Icc 0 N), |f x|","tag":["h","e'_3"],"mvarId":["_uniq",290227],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",288108],"binderInfo":"default"},{"value":"{ toFun := g, inj' := ⋯ }","type":"ℕ ↪ X","name":["g'"],"isProp":false,"id":["_uniq",288142]}]}],"start":11475},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.partial N ≤ L","tag":["neg","_@","_hyg",5172],"mvarId":["_uniq",288022],"isProp":false,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",287953],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",288021],"binderInfo":"default"}]}],"start":11510},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.partial N = ∑ x ∈ ∅, |f x|","tag":["h","e'_3"],"mvarId":["_uniq",300504],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",287953],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",288021],"binderInfo":"default"}]}],"start":11531},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (f ∘ g) n.toNat else 0, vanish := ⋯ }.abs.nonneg","tag":["mp"],"mvarId":["_uniq",287894],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"}]}],"start":11570},{"state":[{"type":"∀ (n : ℤ), 0 ≤ if 0 ≤ n then |if 0 ≤ n then f (g n.toNat) else 0| else 0","tag":["mp"],"mvarId":["_uniq",310921],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",287749],"binderInfo":"default"},{"type":"∀ (a : Finset X), ∑ x ∈ a, |f x| ≤ L","name":["hL"],"isProp":true,"id":["_uniq",287753],"binderInfo":"default"},{"type":"ℕ → X","name":["g"],"isProp":false,"id":["_uniq",287797],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",287798],"binderInfo":"default"}]}],"start":11588},{"state":[{"type":"AbsConvergent f → AbsConvergent' f","tag":["mpr"],"mvarId":["_uniq",281900],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",281889],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",281890],"binderInfo":"default"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",281891],"binderInfo":"implicit"}]}],"start":11634},{"state":[],"start":11681},{"state":[],"start":11682},{"state":[],"start":11717},{"state":[],"start":11803},{"state":[{"type":"AtMostCountable (↑{x | f x ≠ 0} : Type)","tag":[],"mvarId":["_uniq",313467],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",313464],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",313465],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",313466],"binderInfo":"default"}]}],"start":11845},{"state":[],"start":11855},{"state":[],"start":11856},{"state":[],"start":11904},{"state":[],"start":11994},{"state":[{"type":"AbsConvergent' fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",313597],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",313593],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",313594],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",313595],"binderInfo":"default"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",313596],"binderInfo":"default"}]}],"start":12035},{"state":[{"type":"(fun A_1 => ∑ x ∈ A_1, |(fun x => f (↑x : X)) x|) '' Set.univ ⊆ (fun A => ∑ x ∈ A, |f x|) '' Set.univ","tag":[],"mvarId":["_uniq",313603],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",313593],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",313594],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",313595],"binderInfo":"default"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",313596],"binderInfo":"default"}]}],"start":12062},{"state":[{"type":"∃ y, ∑ x ∈ y, |f x| = z","tag":[],"mvarId":["_uniq",317204],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",313593],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",313594],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",313595],"binderInfo":"default"},{"type":"Set X","name":["A✝"],"isProp":false,"id":["_uniq",313596],"binderInfo":"default"},{"type":"ℝ","name":["z"],"isProp":false,"id":["_uniq",313636],"binderInfo":"strictImplicit"},{"type":"Finset (↑A✝ : Type)","name":["A"],"isProp":false,"id":["_uniq",317199],"binderInfo":"default"},{"type":"∑ x ∈ A, |f (↑x : X)| = z","name":["hA"],"isProp":true,"id":["_uniq",317203],"binderInfo":"default"}]}],"start":12108},{"state":[],"start":12153},{"state":[],"start":12154},{"state":[],"start":12250},{"state":[],"start":12349},{"state":[],"start":12350},{"state":[],"start":12443},{"state":[],"start":12473},{"state":[{"type":"Sum' f = ∑ x ∈ A, f x","tag":[],"mvarId":["_uniq",318133],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",318129],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",318130],"binderInfo":"implicit"},{"type":"Finset X","name":["A"],"isProp":false,"id":["_uniq",318131],"binderInfo":"implicit"},{"type":"∀ x ∉ A, f x = 0","name":["h"],"isProp":true,"id":["_uniq",318132],"binderInfo":"default"}]}],"start":12594},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑ x ∈ A, f x","tag":[],"mvarId":["_uniq",318134],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",318129],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",318130],"binderInfo":"implicit"},{"type":"Finset X","name":["A"],"isProp":false,"id":["_uniq",318131],"binderInfo":"implicit"},{"type":"∀ x ∉ A, f x = 0","name":["h"],"isProp":true,"id":["_uniq",318132],"binderInfo":"default"}]}],"start":12608},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑ x ∈ A, f x","tag":[],"mvarId":["_uniq",318213],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",318129],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",318130],"binderInfo":"implicit"},{"type":"Finset X","name":["A"],"isProp":false,"id":["_uniq",318131],"binderInfo":"implicit"},{"type":"∀ x ∉ A, f x = 0","name":["h"],"isProp":true,"id":["_uniq",318132],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",318187]}]}],"start":12637},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑ x ∈ A, f x","tag":[],"mvarId":["_uniq",318383],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",318129],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",318130],"binderInfo":"implicit"},{"type":"Finset X","name":["A"],"isProp":false,"id":["_uniq",318131],"binderInfo":"implicit"},{"type":"∀ x ∉ A, f x = 0","name":["h"],"isProp":true,"id":["_uniq",318132],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",318187]},{"value":"fun ⦃a⦄ => Eq.mpr (id (implies_congr (Eq.refl ¬f a = 0) mem_coe._simp_1)) (of_finsupp._proof_1 h)","type":"E ⊆ (↑A : Set X)","name":["hE"],"isProp":true,"id":["_uniq",318382]}]}],"start":12688},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑ x ∈ A, f x","tag":[],"mvarId":["_uniq",321924],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",318129],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",318130],"binderInfo":"implicit"},{"type":"Finset X","name":["A"],"isProp":false,"id":["_uniq",318131],"binderInfo":"implicit"},{"type":"∀ x ∉ A, f x = 0","name":["h"],"isProp":true,"id":["_uniq",318132],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",318187]},{"value":"fun ⦃a⦄ => Eq.mpr (id (implies_congr (Eq.refl ¬f a = 0) mem_coe._simp_1)) (of_finsupp._proof_1 h)","type":"E ⊆ (↑A : Set X)","name":["hE"],"isProp":true,"id":["_uniq",318382]},{"value":"Finite.Set.subset (↑A : Set X) hE","type":"Finite (↑E : Type)","name":["hfin"],"isProp":true,"id":["_uniq",321923]}]}],"start":12737},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑ x ∈ A, f x","tag":[],"mvarId":["_uniq",321954],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",318129],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",318130],"binderInfo":"implicit"},{"type":"Finset X","name":["A"],"isProp":false,"id":["_uniq",318131],"binderInfo":"implicit"},{"type":"∀ x ∉ A, f x = 0","name":["h"],"isProp":true,"id":["_uniq",318132],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",318187]},{"value":"fun ⦃a⦄ => Eq.mpr (id (implies_congr (Eq.refl ¬f a = 0) mem_coe._simp_1)) (of_finsupp._proof_1 h)","type":"E ⊆ (↑A : Set X)","name":["hE"],"isProp":true,"id":["_uniq",318382]},{"value":"Finite.Set.subset (↑A : Set X) hE","type":"Finite (↑E : Type)","name":["hfin"],"isProp":true,"id":["_uniq",321923]},{"value":"⋯.toFinset","type":"Finset X","name":["E'"],"isProp":false,"id":["_uniq",321953]}]}],"start":12769},{"state":[{"type":"∑ a ∈ E', f a = ∑ x ∈ A, f x","tag":[],"mvarId":["_uniq",322476],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",318129],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",318130],"binderInfo":"implicit"},{"type":"Finset X","name":["A"],"isProp":false,"id":["_uniq",318131],"binderInfo":"implicit"},{"type":"∀ x ∉ A, f x = 0","name":["h"],"isProp":true,"id":["_uniq",318132],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",318187]},{"value":"fun ⦃a⦄ => Eq.mpr (id (implies_congr (Eq.refl ¬f a = 0) mem_coe._simp_1)) (of_finsupp._proof_1 h)","type":"E ⊆ (↑A : Set X)","name":["hE"],"isProp":true,"id":["_uniq",318382]},{"value":"Finite.Set.subset (↑A : Set X) hE","type":"Finite (↑E : Type)","name":["hfin"],"isProp":true,"id":["_uniq",321923]},{"value":"⋯.toFinset","type":"Finset X","name":["E'"],"isProp":false,"id":["_uniq",321953]}]}],"start":12842},{"state":[{"type":"∑ a ∈ E', f a = ∑ x ∈ A, f x","tag":[],"mvarId":["_uniq",329327],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",318129],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",318130],"binderInfo":"implicit"},{"type":"Finset X","name":["A"],"isProp":false,"id":["_uniq",318131],"binderInfo":"implicit"},{"type":"∀ x ∉ A, f x = 0","name":["h"],"isProp":true,"id":["_uniq",318132],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",318187]},{"value":"Finite.Set.subset (↑A : Set X) _fvar.318382","type":"Finite (↑E : Type)","name":["hfin"],"isProp":true,"id":["_uniq",321923]},{"value":"⋯.toFinset","type":"Finset X","name":["E'"],"isProp":false,"id":["_uniq",321953]},{"value":"of_eq_true (Eq.trans Set.Finite.toFinset_subset._simp_1 (eq_true (id (id _fvar.318382))))","type":"E' ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",323705]}]}],"start":12878},{"state":[],"start":12907},{"state":[],"start":12908},{"state":[],"start":13001},{"state":[],"start":13031},{"state":[],"start":13122},{"state":[],"start":13180},{"state":[{"type":"(AbsConvergent' fun x => f (↑x : X)) ∧ Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337508],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"}]}],"start":13256},{"state":[{"type":"(AbsConvergent' fun x => f (↑x : X)) ∧ Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337508],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"}]}],"start":13357},{"state":[{"type":"(AbsConvergent' fun x => f (↑x : X)) ∧ Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337636],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]}]}],"start":13408},{"state":[{"type":"(AbsConvergent' fun x => f (↑x : X)) ∧ Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337636],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]}]}],"start":13466},{"state":[{"type":"(AbsConvergent fun x => f (↑x : X)) ∧ Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337651],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]}]}],"start":13504},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337664],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]}]}],"start":13532},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337718],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]}]}],"start":13561},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337718],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]}]}],"start":13660},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337841],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]}]}],"start":13723},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",337841],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]}]}],"start":13815},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",442864],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"}]}],"start":13843},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",442915],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]}]}],"start":13885},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",443025],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]}]}],"start":13920},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",487102],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]}]}],"start":13987},{"state":[{"type":"Bijective ι","tag":[],"mvarId":["_uniq",487290],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]}]}],"start":14018},{"state":[{"type":"Injective ι","tag":["refine_1"],"mvarId":["_uniq",487297],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]}]},{"type":"Surjective ι","tag":["refine_2"],"mvarId":["_uniq",487298],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]}]}],"start":14033},{"state":[{"type":"Surjective ι","tag":["refine_2"],"mvarId":["_uniq",487298],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]}]}],"start":14124},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",487292],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]}]}],"start":14223},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",487292],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]}]}],"start":14288},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inl"],"mvarId":["_uniq",691348],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"}]},{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inr"],"mvarId":["_uniq",691353],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"}]}],"start":14340},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inl"],"mvarId":["_uniq",691348],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"}]}],"start":14399},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inl"],"mvarId":["_uniq",691348],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"}]}],"start":14479},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inl"],"mvarId":["_uniq",691587],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]}]}],"start":14524},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inl"],"mvarId":["_uniq",691808],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"}]}],"start":14600},{"state":[{"type":"Tendsto (Nat.cast ∘ Subtype.val ∘ a) atTop atTop","tag":[],"mvarId":["_uniq",692125],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"}]}],"start":14683},{"state":[{"type":"StrictMono (Subtype.val ∘ a)","tag":[],"mvarId":["_uniq",692400],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"}]}],"start":14757},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inl"],"mvarId":["_uniq",692127],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Tendsto.comp tendsto_natCast_atTop_atTop\n  (StrictMono.tendsto_atTop fun ⦃a_1 b⦄ hnm => of_eq_true (Eq.trans Subtype.coe_lt_coe._simp_1 (eq_true (ha_mono hnm))))","type":"Tendsto (Nat.cast ∘ Subtype.val ∘ a) atTop atTop","name":["this"],"isProp":true,"id":["_uniq",692126]}]}],"start":14797},{"state":[{"type":"Tendsto\n  ({ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.partial ∘\n    Nat.cast ∘ Subtype.val ∘ a)\n  atTop (nhds (Sum' f))","tag":[],"mvarId":["_uniq",693368],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Tendsto.comp tendsto_natCast_atTop_atTop\n  (StrictMono.tendsto_atTop fun ⦃a_1 b⦄ hnm => of_eq_true (Eq.trans Subtype.coe_lt_coe._simp_1 (eq_true (ha_mono hnm))))","type":"Tendsto (Nat.cast ∘ Subtype.val ∘ a) atTop atTop","name":["this"],"isProp":true,"id":["_uniq",692126]}]}],"start":14847},{"state":[{"type":"AbsConvergent fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",693717],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Tendsto.comp tendsto_natCast_atTop_atTop\n  (StrictMono.tendsto_atTop fun ⦃a_1 b⦄ hnm => of_eq_true (Eq.trans Subtype.coe_lt_coe._simp_1 (eq_true (ha_mono hnm))))","type":"Tendsto (Nat.cast ∘ Subtype.val ∘ a) atTop atTop","name":["this"],"isProp":true,"id":["_uniq",692126]}]}],"start":14904},{"state":[{"type":"AbsConvergent' fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",693733],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Tendsto.comp tendsto_natCast_atTop_atTop\n  (StrictMono.tendsto_atTop fun ⦃a_1 b⦄ hnm => of_eq_true (Eq.trans Subtype.coe_lt_coe._simp_1 (eq_true (ha_mono hnm))))","type":"Tendsto (Nat.cast ∘ Subtype.val ∘ a) atTop atTop","name":["this"],"isProp":true,"id":["_uniq",692126]}]},{"type":"CountablyInfinite (↑E : Type)","tag":["hX"],"mvarId":["_uniq",693725],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Tendsto.comp tendsto_natCast_atTop_atTop\n  (StrictMono.tendsto_atTop fun ⦃a_1 b⦄ hnm => of_eq_true (Eq.trans Subtype.coe_lt_coe._simp_1 (eq_true (ha_mono hnm))))","type":"Tendsto (Nat.cast ∘ Subtype.val ∘ a) atTop atTop","name":["this"],"isProp":true,"id":["_uniq",692126]}]}],"start":14946},{"state":[{"type":"CountablyInfinite (↑E : Type)","tag":["hX"],"mvarId":["_uniq",693725],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Tendsto.comp tendsto_natCast_atTop_atTop\n  (StrictMono.tendsto_atTop fun ⦃a_1 b⦄ hnm => of_eq_true (Eq.trans Subtype.coe_lt_coe._simp_1 (eq_true (ha_mono hnm))))","type":"Tendsto (Nat.cast ∘ Subtype.val ∘ a) atTop atTop","name":["this"],"isProp":true,"id":["_uniq",692126]}]}],"start":14976},{"state":[{"type":"Tendsto\n  ({ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.partial ∘\n    Nat.cast ∘ Subtype.val ∘ a)\n  atTop (nhds (Sum' f))","tag":[],"mvarId":["_uniq",693719],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Tendsto.comp tendsto_natCast_atTop_atTop\n  (StrictMono.tendsto_atTop fun ⦃a_1 b⦄ hnm => of_eq_true (Eq.trans Subtype.coe_lt_coe._simp_1 (eq_true (ha_mono hnm))))","type":"Tendsto (Nat.cast ∘ Subtype.val ∘ a) atTop atTop","name":["this"],"isProp":true,"id":["_uniq",692126]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]}]}],"start":15031},{"state":[{"type":"Tendsto\n  ({ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.partial ∘\n    Nat.cast ∘ Subtype.val ∘ a)\n  atTop (nhds (Sum' f))","tag":[],"mvarId":["_uniq",693873],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]}]}],"start":15104},{"state":[{"type":"({ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.partial ∘\n      Nat.cast ∘ Subtype.val ∘ a)\n    N =\n  ({ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.partial ∘\n      Nat.cast)\n    N","tag":["h","e'_3","h"],"mvarId":["_uniq",696751],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]}],"start":15169},{"state":[{"type":"∑ x ∈ Icc 0 (↑(a N) : ℕ), f (↑(g x) : X) = ∑ x ∈ Icc 0 N, f (↑(g (↑(a x) : ℕ)) : X)","tag":["h","e'_3","h"],"mvarId":["_uniq",710963],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]}],"start":15199},{"state":[{"type":"∑ x ∈ Icc 0 (↑(a N) : ℕ), f (↑(g x) : X) = ∑ x ∈ Icc 0 N, f (↑(g (↑(a x) : ℕ)) : X)","tag":["h","e'_3","h"],"mvarId":["_uniq",710963],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]}],"start":15208},{"state":[{"type":"∑ x ∈ Icc 0 (↑(a N) : ℕ), f (↑(g x) : X) = ∑ x ∈ image (Subtype.val ∘ a) (Icc 0 N), f (↑(g x) : X)","tag":[],"mvarId":["_uniq",711301],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]}],"start":15284},{"state":[{"type":"image (Subtype.val ∘ a) (Icc 0 N) ⊆ Icc 0 (↑(a N) : ℕ)","tag":["h"],"mvarId":["_uniq",711403],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]},{"type":"∀ x ∈ Icc 0 (↑(a N) : ℕ), x ∉ image (Subtype.val ∘ a) (Icc 0 N) → f (↑(g x) : X) = 0","tag":["hf"],"mvarId":["_uniq",711404],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]}],"start":15315},{"state":[{"type":"(↑(a n) : ℕ) ≤ (↑(a N) : ℕ)","tag":["h","intro","intro"],"mvarId":["_uniq",715178],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",715144],"binderInfo":"default"},{"type":"n ≤ N","name":["hn"],"isProp":true,"id":["_uniq",715166],"binderInfo":"default"}]}],"start":15385},{"state":[{"type":"∀ x ∈ Icc 0 (↑(a N) : ℕ), x ∉ image (Subtype.val ∘ a) (Icc 0 N) → f (↑(g x) : X) = 0","tag":["hf"],"mvarId":["_uniq",711404],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]}],"start":15422},{"state":[{"type":"∃ x_1 ≤ N, (↑(a x_1) : ℕ) = x","tag":["hf"],"mvarId":["_uniq",721890],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",716263],"binderInfo":"default"},{"type":"x ≤ (↑(a N) : ℕ)","name":["hx"],"isProp":true,"id":["_uniq",721808],"binderInfo":"default"},{"type":"f (↑(g x) : X) ≠ 0","name":["hx'"],"isProp":true,"id":["_uniq",721889],"binderInfo":"default"}]}],"start":15478},{"state":[{"type":"∃ x_1 ≤ N, (↑(a x_1) : ℕ) = x","tag":["hf"],"mvarId":["_uniq",722014],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",716263],"binderInfo":"default"},{"type":"x ≤ (↑(a N) : ℕ)","name":["hx"],"isProp":true,"id":["_uniq",721808],"binderInfo":"default"},{"type":"f (↑(g x) : X) ≠ 0","name":["hx'"],"isProp":true,"id":["_uniq",721889],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",722010],"binderInfo":"default"},{"type":"(ι ∘ a) n = ⟨(↑(g x) : X), hx'⟩","name":["hn"],"isProp":true,"id":["_uniq",722013],"binderInfo":"default"}]}],"start":15541},{"state":[{"type":"∃ x_1 ≤ N, (↑(a x_1) : ℕ) = x","tag":["hf"],"mvarId":["_uniq",723850],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",716263],"binderInfo":"default"},{"type":"x ≤ (↑(a N) : ℕ)","name":["hx"],"isProp":true,"id":["_uniq",721808],"binderInfo":"default"},{"type":"f (↑(g x) : X) ≠ 0","name":["hx'"],"isProp":true,"id":["_uniq",721889],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",722010],"binderInfo":"default"},{"type":"g (↑(a n) : ℕ) = g x","name":["hn"],"isProp":true,"id":["_uniq",723847],"binderInfo":"default"}]}],"start":15582},{"state":[{"type":"∃ x ≤ N, (↑(a x) : ℕ) = (↑(a n) : ℕ)","tag":["hf"],"mvarId":["_uniq",723875],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",722010],"binderInfo":"default"},{"type":"(↑(a n) : ℕ) ≤ (↑(a N) : ℕ)","name":["hx"],"isProp":true,"id":["_uniq",723873],"binderInfo":"default"},{"type":"f (↑(g (↑(a n) : ℕ)) : X) ≠ 0","name":["hx'"],"isProp":true,"id":["_uniq",723874],"binderInfo":"default"}]}],"start":15617},{"state":[],"start":15667},{"state":[{"type":"∑ x ∈ image (Subtype.val ∘ a) (Icc 0 N), f (↑(g x) : X) = ∑ x ∈ Icc 0 N, f (↑(g (↑(a x) : ℕ)) : X)","tag":[],"mvarId":["_uniq",711311],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]}],"start":15685},{"state":[{"type":"Set.InjOn (Subtype.val ∘ a) (↑(Icc 0 N) : Set ℕ)","tag":["a","_@","Mathlib","Algebra","BigOperators","Group","Finset","Basic","_hyg",692],"mvarId":["_uniq",725899],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"CountablyInfinite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691347],"binderInfo":"default"},{"value":"CountablyInfinite.toInfinite hE'","type":"Infinite (↑E' : Type)","name":["hinf"],"isProp":true,"id":["_uniq",691586]},{"type":"ℕ → (↑E' : Type)","name":["a"],"isProp":false,"id":["_uniq",691794],"binderInfo":"default"},{"type":"Bijective a","name":["ha_bij"],"isProp":true,"id":["_uniq",691803],"binderInfo":"default"},{"type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",691807],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (Eq.symm (propext (AbsConvergent'.of_countable ((CountablyInfinite.equiv (Exists.intro ι hι)).mp hE'))))))\n  (AbsConvergent'.subtype hconv E)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv''"],"isProp":true,"id":["_uniq",693718]},{"value":"Sum.eq (Bijective.comp hι ha_bij) (AbsConvergent.comp (Bijective.comp hι ha_bij) hconv'')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ ι ∘ a) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["this"],"isProp":true,"id":["_uniq",693869]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",696750],"binderInfo":"default"}]}],"start":15709},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inr"],"mvarId":["_uniq",691353],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"}]}],"start":15780},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inr"],"mvarId":["_uniq",691353],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"}]}],"start":15871},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inr"],"mvarId":["_uniq",691353],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"}]}],"start":15891},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inr"],"mvarId":["_uniq",726632],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]}]}],"start":15939},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inr"],"mvarId":["_uniq",726967],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]}]}],"start":15984},{"state":[{"type":"Sum' f = Sum fun x => f (↑x : X)","tag":["inr"],"mvarId":["_uniq",727290],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]}]}],"start":16027},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo (Sum' f)","tag":[],"mvarId":["_uniq",727296],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]}]}],"start":16059},{"state":[{"type":"Tendsto { m := 0, seq := fun n => if 0 ≤ n then f (↑(g n.toNat) : X) else 0, vanish := ⋯ }.partial atTop\n  (nhds (∑ x, f (↑x : X)))","tag":[],"mvarId":["_uniq",736980],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]}]}],"start":16102},{"state":[{"type":"∀ᶠ (x' : ℤ) in atTop,\n  { m := 0, seq := fun n => if 0 ≤ n then f (↑(g n.toNat) : X) else 0, vanish := ⋯ }.partial x' = ∑ x, f (↑x : X)","tag":["h"],"mvarId":["_uniq",737000],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]}]}],"start":16140},{"state":[{"type":"∀ᶠ (x' : ℤ) in atTop,\n  { m := 0, seq := fun n => if 0 ≤ n then f (↑(g n.toNat) : X) else 0, vanish := ⋯ }.partial x' = ∑ x, f (↑x : X)","tag":["h"],"mvarId":["_uniq",737416],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"value":"Set.Finite.bddAbove hE'","type":"BddAbove E'","name":["hE'bound"],"isProp":true,"id":["_uniq",737415]}]}],"start":16197},{"state":[{"type":"∀ᶠ (x' : ℤ) in atTop,\n  { m := 0, seq := fun n => if 0 ≤ n then f (↑(g n.toNat) : X) else 0, vanish := ⋯ }.partial x' = ∑ x, f (↑x : X)","tag":["h"],"mvarId":["_uniq",737554],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"}]}],"start":16257},{"state":[{"type":"∃ a,\n  ∀ b ≥ a,\n    { m := 0, seq := fun n => if 0 ≤ n then f (↑(g n.toNat) : X) else 0, vanish := ⋯ }.partial b = ∑ x, f (↑x : X)","tag":["h"],"mvarId":["_uniq",737952],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"}]}],"start":16281},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then f (↑(g n.toNat) : X) else 0, vanish := ⋯ }.partial N' = ∑ x, f (↑x : X)","tag":["h"],"mvarId":["_uniq",738262],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",738258],"binderInfo":"default"},{"type":"N' ≥ (↑N : ℤ)","name":["hN'"],"isProp":true,"id":["_uniq",738261],"binderInfo":"default"}]}],"start":16303},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then f (↑(g n.toNat) : X) else 0, vanish := ⋯ }.partial (↑N' : ℤ) = ∑ x, f (↑x : X)","tag":["h","intro"],"mvarId":["_uniq",746267],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"},{"type":"ℕ","name":["N'"],"isProp":false,"id":["_uniq",746252],"binderInfo":"default"},{"type":"(↑N' : ℤ) ≥ (↑N : ℤ)","name":["hN'"],"isProp":true,"id":["_uniq",746266],"binderInfo":"default"}]}],"start":16360},{"state":[{"type":"∑ x ∈ Icc 0 N', f (↑(g x) : X) = ∑ x, f (↑x : X)","tag":["h","intro"],"mvarId":["_uniq",756393],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"},{"type":"ℕ","name":["N'"],"isProp":false,"id":["_uniq",746252],"binderInfo":"default"},{"type":"N ≤ N'","name":["hN'"],"isProp":true,"id":["_uniq",756390],"binderInfo":"default"}]}],"start":16395},{"state":[{"type":"∑ x ∈ Icc 0 N', f (↑(g x) : X) = ∑ x, f (↑x : X)","tag":["h","intro"],"mvarId":["_uniq",756393],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"},{"type":"ℕ","name":["N'"],"isProp":false,"id":["_uniq",746252],"binderInfo":"default"},{"type":"N ≤ N'","name":["hN'"],"isProp":true,"id":["_uniq",756390],"binderInfo":"default"}]}],"start":16402},{"state":[{"type":"∑ x ∈ Icc 0 N', f (↑(g x) : X) = ∑ n ∈ E'.toFinset, f (↑(g n) : X)","tag":[],"mvarId":["_uniq",756518],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"},{"type":"ℕ","name":["N'"],"isProp":false,"id":["_uniq",746252],"binderInfo":"default"},{"type":"N ≤ N'","name":["hN'"],"isProp":true,"id":["_uniq",756390],"binderInfo":"default"}]}],"start":16438},{"state":[{"type":"E'.toFinset ⊆ Icc 0 N'","tag":["h"],"mvarId":["_uniq",757962],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"},{"type":"ℕ","name":["N'"],"isProp":false,"id":["_uniq",746252],"binderInfo":"default"},{"type":"N ≤ N'","name":["hN'"],"isProp":true,"id":["_uniq",756390],"binderInfo":"default"}]},{"type":"∀ x ∈ Icc 0 N', x ∉ E'.toFinset → f (↑(g x) : X) = 0","tag":["hf"],"mvarId":["_uniq",757963],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"},{"type":"ℕ","name":["N'"],"isProp":false,"id":["_uniq",746252],"binderInfo":"default"},{"type":"N ≤ N'","name":["hN'"],"isProp":true,"id":["_uniq",756390],"binderInfo":"default"}]}],"start":16467},{"state":[{"type":"∀ x ∈ Icc 0 N', x ∉ E'.toFinset → f (↑(g x) : X) = 0","tag":["hf"],"mvarId":["_uniq",757963],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",337502],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",337503],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",337504],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",337505],"binderInfo":"default"},{"type":"∀ x ∉ A, f x = 0","name":["hfA"],"isProp":true,"id":["_uniq",337506],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["hconv"],"isProp":true,"id":["_uniq",337507],"binderInfo":"default"},{"value":"(AbsConvergent'.of_countable hA).mp (AbsConvergent'.subtype hconv A)","type":"AbsConvergent fun x => f (↑x : X)","name":["hconv'"],"isProp":true,"id":["_uniq",337635]},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",337717]},{"value":"fun ⦃a⦄ =>\n  id\n    (Classical.byContradiction fun this =>\n      Exists.casesOn hA fun w h =>\n        Exists.casesOn hconv' fun w_1 h_1 =>\n          And.casesOn (id (Eq.mp (Mathlib.Tactic.PushNeg.not_implies_eq (¬f a = 0) (a ∈ A)) this)) fun left right =>\n            And.casesOn h_1 fun left_1 right_1 =>\n              Exists.casesOn right_1 fun w_2 h_1 =>\n                False.elim\n                  (Eq.mp\n                    (Eq.trans\n                      (congrArg Not\n                        (Eq.trans\n                          (congrArg (fun x => x = 0)\n                            ((fun x a => hfA x a) a\n                              (of_eq_true (Eq.trans (congrArg Not (eq_false right)) not_false_eq_true))))\n                          (eq_self 0)))\n                      not_true_eq_false)\n                    left))","type":"E ⊆ A","name":["hE"],"isProp":true,"id":["_uniq",337840]},{"type":"ℕ → (↑A : Type)","name":["g"],"isProp":false,"id":["_uniq",442859],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",442863],"binderInfo":"default"},{"value":"Sum.eq hg (AbsConvergent.comp hg hconv')","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((fun x => f (↑x : X)) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum fun x => f (↑x : X))","name":["hsum"],"isProp":true,"id":["_uniq",442914]},{"value":"{n | (↑(g n) : X) ∈ E}","type":"Set ℕ","name":["E'"],"isProp":false,"id":["_uniq",443024]},{"value":"fun x =>\n  match x with\n  | ⟨n, hn⟩ => ⟨(↑(g n) : X), ⋯⟩","type":"(↑E' : Type) → (↑E : Type)","name":["ι"],"isProp":false,"id":["_uniq",487100]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨val, property⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨val_1, property_1⟩ => fun h =>\n      Eq.mpr (id (Subtype.mk.injEq val property val_1 property_1))\n        (hg.left\n          (Eq.mp\n            (Eq.trans\n              (Subtype.mk.injEq (↑(g val) : X)\n                (of_eq_true (Eq.trans (congrArg Not (eq_false (id (id ⟨val, property⟩.property)))) not_false_eq_true))\n                (↑(g val_1) : X)\n                (of_eq_true\n                  (Eq.trans (congrArg Not (eq_false (id (id ⟨val_1, property_1⟩.property)))) not_false_eq_true)))\n              of_countable_supp._simp_4)\n            h)),\n  fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    (fun n hn =>\n        Exists.intro\n          ⟨n,\n            Eq.mpr (id (congrArg (fun x => ¬f (↑x : X) = 0) hn))\n              (Exists.casesOn hA fun w h =>\n                Exists.casesOn hconv' fun w_1 h_1 =>\n                  And.casesOn h_1 fun left right => Exists.casesOn right fun w_2 h_1 => hx)⟩\n          (of_countable_supp._proof_8 hA hfA hconv hconv' hE g hg hsum x hx n hn))\n      (Classical.choose (hg.right ⟨x, hE hx⟩)) (Classical.choose_spec (hg.right ⟨x, hE hx⟩))⟩","type":"Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",487291]},{"type":"Finite (↑E' : Type)","name":["hE'"],"isProp":true,"id":["_uniq",691352],"binderInfo":"default"},{"value":"(Bijective.finite_iff hι).mp hE'","type":"Finite (↑E : Type)","name":["hEfin"],"isProp":true,"id":["_uniq",726631]},{"value":"Fintype.ofFinite (↑E' : Type)","type":"Fintype (↑E' : Type)","name":["hE'fintype"],"isProp":false,"id":["_uniq",726966]},{"value":"Fintype.ofFinite (↑E : Type)","type":"Fintype (↑E : Type)","name":["hEfintype"],"isProp":false,"id":["_uniq",727289]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",737547],"binderInfo":"default"},{"type":"∀ y ∈ E', y ≤ N","name":["hN"],"isProp":true,"id":["_uniq",737551],"binderInfo":"default"},{"type":"ℕ","name":["N'"],"isProp":false,"id":["_uniq",746252],"binderInfo":"default"},{"type":"N ≤ N'","name":["hN'"],"isProp":true,"id":["_uniq",756390],"binderInfo":"default"}]}],"start":16517},{"state":[],"start":16561},{"state":[],"start":16622},{"state":[],"start":16674},{"state":[],"start":16721},{"state":[],"start":16722},{"state":[],"start":16812},{"state":[],"start":16832},{"state":[{"type":"AbsConvergent' f ↔ Summable f","tag":[],"mvarId":["_uniq",815324],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"}]}],"start":16931},{"state":[{"type":"BddAbove (Set.range fun A => ∑ x ∈ A, |f x|) ↔ Summable fun x => |(|f x|)|","tag":[],"mvarId":["_uniq",818401],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"}]}],"start":16976},{"state":[{"type":"BddAbove (Set.range fun A => ∑ x ∈ A, |f x|) ↔\n  ∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","tag":[],"mvarId":["_uniq",829091],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"}]}],"start":17013},{"state":[{"type":"BddAbove (Set.range fun A => ∑ x ∈ A, |f x|) ↔\n  ∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","tag":[],"mvarId":["_uniq",829091],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"}]}],"start":17025},{"state":[{"type":"BddAbove (Set.range fun A => ∑ x ∈ A, |f x|) →\n  ∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","tag":["mp"],"mvarId":["_uniq",829103],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"}]},{"type":"(∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε) →\n  BddAbove (Set.range fun A => ∑ x ∈ A, |f x|)","tag":["mpr"],"mvarId":["_uniq",829104],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"}]}],"start":17039},{"state":[{"type":"∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","tag":["mp"],"mvarId":["_uniq",829116],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"BddAbove (Set.range fun A => ∑ x ∈ A, |f x|)","name":["h"],"isProp":true,"id":["_uniq",829109],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"}]}],"start":17058},{"state":[{"type":"∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","tag":["mp"],"mvarId":["_uniq",829533],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"}]}],"start":17110},{"state":[{"type":"∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","tag":["mp"],"mvarId":["_uniq",829562],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"},{"value":"id (Exists.intro 0 (Exists.intro ∅ (of_eq_true (eq_self 0))))","type":"s.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",829561]}]}],"start":17170},{"state":[{"type":"∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","tag":["mp"],"mvarId":["_uniq",830564],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"},{"value":"id (Exists.intro 0 (Exists.intro ∅ (of_eq_true (eq_self 0))))","type":"s.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",829561]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.atom_pf ε)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (sSup s))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (sSup s)) (Mathlib.Tactic.Ring.atom_pf ε)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup s ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (sSup s) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (sSup s) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"sSup s - ε < sSup s","name":["this"],"isProp":true,"id":["_uniq",830563]}]}],"start":17217},{"state":[{"type":"∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","tag":["mp"],"mvarId":["_uniq",836581],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"},{"value":"id (Exists.intro 0 (Exists.intro ∅ (of_eq_true (eq_self 0))))","type":"s.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",829561]},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",836576],"binderInfo":"default"},{"type":"sSup (Set.range fun A => ∑ x ∈ A, |f x|) - ε < ∑ x ∈ S, |f x|","name":["hS"],"isProp":true,"id":["_uniq",836580],"binderInfo":"default"}]}],"start":17282},{"state":[{"type":"|∑ x ∈ T, |f x|| < ε","tag":["h"],"mvarId":["_uniq",836639],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"},{"value":"id (Exists.intro 0 (Exists.intro ∅ (of_eq_true (eq_self 0))))","type":"s.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",829561]},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",836576],"binderInfo":"default"},{"type":"sSup (Set.range fun A => ∑ x ∈ A, |f x|) - ε < ∑ x ∈ S, |f x|","name":["hS"],"isProp":true,"id":["_uniq",836580],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",836635],"binderInfo":"default"},{"type":"Disjoint T S","name":["hT"],"isProp":true,"id":["_uniq",836638],"binderInfo":"default"}]}],"start":17304},{"state":[{"type":"∑ x ∈ T, |f x| < ε","tag":["h"],"mvarId":["_uniq",836990],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"},{"value":"id (Exists.intro 0 (Exists.intro ∅ (of_eq_true (eq_self 0))))","type":"s.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",829561]},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",836576],"binderInfo":"default"},{"type":"sSup (Set.range fun A => ∑ x ∈ A, |f x|) - ε < ∑ x ∈ S, |f x|","name":["hS"],"isProp":true,"id":["_uniq",836580],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",836635],"binderInfo":"default"},{"type":"Disjoint T S","name":["hT"],"isProp":true,"id":["_uniq",836638],"binderInfo":"default"}]}],"start":17343},{"state":[{"type":"∑ x ∈ T, |f x| + ∑ x ∈ S, |f x| ≤ sSup s","tag":[],"mvarId":["_uniq",843849],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"},{"value":"id (Exists.intro 0 (Exists.intro ∅ (of_eq_true (eq_self 0))))","type":"s.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",829561]},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",836576],"binderInfo":"default"},{"type":"sSup (Set.range fun A => ∑ x ∈ A, |f x|) - ε < ∑ x ∈ S, |f x|","name":["hS"],"isProp":true,"id":["_uniq",836580],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",836635],"binderInfo":"default"},{"type":"Disjoint T S","name":["hT"],"isProp":true,"id":["_uniq",836638],"binderInfo":"default"}]}],"start":17411},{"state":[{"type":"∑ x ∈ T, |f x| + ∑ x ∈ S, |f x| ∈ s","tag":[],"mvarId":["_uniq",843892],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"},{"value":"id (Exists.intro 0 (Exists.intro ∅ (of_eq_true (eq_self 0))))","type":"s.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",829561]},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",836576],"binderInfo":"default"},{"type":"sSup (Set.range fun A => ∑ x ∈ A, |f x|) - ε < ∑ x ∈ S, |f x|","name":["hS"],"isProp":true,"id":["_uniq",836580],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",836635],"binderInfo":"default"},{"type":"Disjoint T S","name":["hT"],"isProp":true,"id":["_uniq",836638],"binderInfo":"default"}]}],"start":17467},{"state":[{"type":"∑ x ∈ T, |f x| < ε","tag":["h"],"mvarId":["_uniq",843851],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",829112],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",829115],"binderInfo":"default"},{"value":"Set.range fun A => ∑ x ∈ A, |f x|","type":"Set ℝ","name":["s"],"isProp":false,"id":["_uniq",829463]},{"type":"BddAbove s","name":["h"],"isProp":true,"id":["_uniq",829530],"binderInfo":"default"},{"value":"id (Exists.intro 0 (Exists.intro ∅ (of_eq_true (eq_self 0))))","type":"s.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",829561]},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",836576],"binderInfo":"default"},{"type":"sSup (Set.range fun A => ∑ x ∈ A, |f x|) - ε < ∑ x ∈ S, |f x|","name":["hS"],"isProp":true,"id":["_uniq",836580],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",836635],"binderInfo":"default"},{"type":"Disjoint T S","name":["hT"],"isProp":true,"id":["_uniq",836638],"binderInfo":"default"},{"value":"ConditionallyCompleteLattice.le_csSup s (∑ x ∈ T, |f x| + ∑ x ∈ S, |f x|) h\n  (Eq.mpr (id Set.mem_range._simp_1) (Exists.intro (T ∪ S) (sum_union hT)))","type":"∑ x ∈ T, |f x| + ∑ x ∈ S, |f x| ≤ sSup s","name":["this"],"isProp":true,"id":["_uniq",843850]}]}],"start":17519},{"state":[{"type":"(∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε) →\n  BddAbove (Set.range fun A => ∑ x ∈ A, |f x|)","tag":["mpr"],"mvarId":["_uniq",829104],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"}]}],"start":17532},{"state":[{"type":"BddAbove (Set.range fun A => ∑ x ∈ A, |f x|)","tag":["mpr"],"mvarId":["_uniq",847150],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","name":["h"],"isProp":true,"id":["_uniq",846928],"binderInfo":"default"},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",847144],"binderInfo":"default"},{"type":"∀ (t : Finset X), Disjoint t S → |∑ x ∈ t, |f x|| < 1","name":["hS"],"isProp":true,"id":["_uniq",847147],"binderInfo":"default"}]}],"start":17579},{"state":[{"type":"∃ x, ∀ y ∈ Set.range fun A => ∑ x ∈ A, |f x|, y ≤ x","tag":["mpr"],"mvarId":["_uniq",847272],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","name":["h"],"isProp":true,"id":["_uniq",846928],"binderInfo":"default"},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",847144],"binderInfo":"default"},{"type":"∀ (t : Finset X), Disjoint t S → |∑ x ∈ t, |f x|| < 1","name":["hS"],"isProp":true,"id":["_uniq",847147],"binderInfo":"default"}]}],"start":17599},{"state":[{"type":"∑ x ∈ T, |f x| ≤ ∑ x ∈ S, |f x| + 1","tag":["h"],"mvarId":["_uniq",852671],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","name":["h"],"isProp":true,"id":["_uniq",846928],"binderInfo":"default"},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",847144],"binderInfo":"default"},{"type":"∀ (t : Finset X), Disjoint t S → |∑ x ∈ t, |f x|| < 1","name":["hS"],"isProp":true,"id":["_uniq",847147],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",852670],"binderInfo":"default"}]}],"start":17643},{"state":[{"type":"∑ x ∈ T, |f x| ≤ ∑ x ∈ S, |f x| + 1","tag":["h"],"mvarId":["_uniq",852671],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","name":["h"],"isProp":true,"id":["_uniq",846928],"binderInfo":"default"},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",847144],"binderInfo":"default"},{"type":"∀ (t : Finset X), Disjoint t S → |∑ x ∈ t, |f x|| < 1","name":["hS"],"isProp":true,"id":["_uniq",847147],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",852670],"binderInfo":"default"}]}],"start":17650},{"state":[],"start":17751},{"state":[{"type":"∑ x ∈ T ∩ S, |f x| + ∑ x ∈ T \\ S, |f x| ≤ ∑ x ∈ S, |f x| + 1","tag":[],"mvarId":["_uniq",853642],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","name":["h"],"isProp":true,"id":["_uniq",846928],"binderInfo":"default"},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",847144],"binderInfo":"default"},{"type":"∀ (t : Finset X), Disjoint t S → |∑ x ∈ t, |f x|| < 1","name":["hS"],"isProp":true,"id":["_uniq",847147],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",852670],"binderInfo":"default"}]}],"start":17769},{"state":[{"type":"T ∩ S ⊆ S","tag":["h₁","h"],"mvarId":["_uniq",855734],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","name":["h"],"isProp":true,"id":["_uniq",846928],"binderInfo":"default"},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",847144],"binderInfo":"default"},{"type":"∀ (t : Finset X), Disjoint t S → |∑ x ∈ t, |f x|| < 1","name":["hS"],"isProp":true,"id":["_uniq",847147],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",852670],"binderInfo":"default"}]},{"type":"∑ x ∈ T \\ S, |f x| ≤ 1","tag":["h₂"],"mvarId":["_uniq",854798],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","name":["h"],"isProp":true,"id":["_uniq",846928],"binderInfo":"default"},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",847144],"binderInfo":"default"},{"type":"∀ (t : Finset X), Disjoint t S → |∑ x ∈ t, |f x|| < 1","name":["hS"],"isProp":true,"id":["_uniq",847147],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",852670],"binderInfo":"default"}]}],"start":17782},{"state":[{"type":"∑ x ∈ T \\ S, |f x| ≤ 1","tag":["h₂"],"mvarId":["_uniq",854798],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",815322],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",815323],"binderInfo":"default"},{"type":"∀ (ε : ℝ), 0 < ε → ∃ s, ∀ (t : Finset X), Disjoint t s → |∑ x ∈ t, |f x|| < ε","name":["h"],"isProp":true,"id":["_uniq",846928],"binderInfo":"default"},{"type":"Finset X","name":["S"],"isProp":false,"id":["_uniq",847144],"binderInfo":"default"},{"type":"∀ (t : Finset X), Disjoint t S → |∑ x ∈ t, |f x|| < 1","name":["hS"],"isProp":true,"id":["_uniq",847147],"binderInfo":"default"},{"type":"Finset X","name":["T"],"isProp":false,"id":["_uniq",852670],"binderInfo":"default"}]}],"start":17815},{"state":[],"start":17883},{"state":[],"start":17884},{"state":[],"start":17929},{"state":[],"start":17993},{"state":[{"type":"(∀ᶠ (n : ℤ) in atTop, p n) ↔ ∀ᶠ (n : ℕ) in atTop, p (↑n : ℤ)","tag":[],"mvarId":["_uniq",862084],"isProp":true,"context":[{"type":"ℤ → Prop","name":["p"],"isProp":false,"id":["_uniq",862083],"binderInfo":"default"}]}],"start":18062},{"state":[{"type":"(∀ᶠ (n : ℕ) in atTop, p (↑n : ℤ)) → ∀ᶠ (n : ℤ) in atTop, p n","tag":[],"mvarId":["_uniq",862585],"isProp":true,"context":[{"type":"ℤ → Prop","name":["p"],"isProp":false,"id":["_uniq",862083],"binderInfo":"default"}]}],"start":18108},{"state":[{"type":"∀ (x : ℕ), (∀ (b : ℕ), x ≤ b → p (↑b : ℤ)) → ∃ a, ∀ (b : ℤ), a ≤ b → p b","tag":[],"mvarId":["_uniq",879104],"isProp":true,"context":[{"type":"ℤ → Prop","name":["p"],"isProp":false,"id":["_uniq",862083],"binderInfo":"default"}]}],"start":18134},{"state":[{"type":"p n","tag":["h"],"mvarId":["_uniq",879212],"isProp":true,"context":[{"type":"ℤ → Prop","name":["p"],"isProp":false,"id":["_uniq",862083],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",879107],"binderInfo":"default"},{"type":"∀ (b : ℕ), N ≤ b → p (↑b : ℤ)","name":["hN"],"isProp":true,"id":["_uniq",879110],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",879208],"binderInfo":"default"},{"type":"(↑N : ℤ) ≤ n","name":["hn"],"isProp":true,"id":["_uniq",879211],"binderInfo":"default"}]}],"start":18166},{"state":[{"type":"p (↑n : ℤ)","tag":["h","intro"],"mvarId":["_uniq",879410],"isProp":true,"context":[{"type":"ℤ → Prop","name":["p"],"isProp":false,"id":["_uniq",862083],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",879107],"binderInfo":"default"},{"type":"∀ (b : ℕ), N ≤ b → p (↑b : ℤ)","name":["hN"],"isProp":true,"id":["_uniq",879110],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",879395],"binderInfo":"default"},{"type":"(↑N : ℤ) ≤ (↑n : ℤ)","name":["hn"],"isProp":true,"id":["_uniq",879409],"binderInfo":"default"}]}],"start":18199},{"state":[],"start":18227},{"state":[],"start":18228},{"state":[],"start":18309},{"state":[{"type":"Tendsto f atTop l ↔ Tendsto (f ∘ Nat.cast) atTop l","tag":[],"mvarId":["_uniq",881773],"isProp":true,"context":[{"type":"Type","name":["R"],"isProp":false,"id":["_uniq",881770],"binderInfo":"implicit"},{"type":"ℤ → R","name":["f"],"isProp":false,"id":["_uniq",881771],"binderInfo":"default"},{"type":"Filter R","name":["l"],"isProp":false,"id":["_uniq",881772],"binderInfo":"default"}]}],"start":18370},{"state":[{"type":"(∀ ⦃p : R → Prop⦄, (∀ᶠ (y : R) in l, p y) → ∃ a, ∀ (b : ℤ), a ≤ b → p (f b)) ↔\n  ∀ ⦃p : R → Prop⦄, (∀ᶠ (y : R) in l, p y) → ∃ a, ∀ (b : ℕ), a ≤ b → p (f (↑b : ℤ))","tag":[],"mvarId":["_uniq",895386],"isProp":true,"context":[{"type":"Type","name":["R"],"isProp":false,"id":["_uniq",881770],"binderInfo":"implicit"},{"type":"ℤ → R","name":["f"],"isProp":false,"id":["_uniq",881771],"binderInfo":"default"},{"type":"Filter R","name":["l"],"isProp":false,"id":["_uniq",881772],"binderInfo":"default"}]}],"start":18402},{"state":[{"type":"(∃ a, ∀ (b : ℤ), a ≤ b → p (f b)) ↔ ∃ a, ∀ (b : ℕ), a ≤ b → p (f (↑b : ℤ))","tag":["h","h"],"mvarId":["_uniq",895426],"isProp":true,"context":[{"type":"Type","name":["R"],"isProp":false,"id":["_uniq",881770],"binderInfo":"implicit"},{"type":"ℤ → R","name":["f"],"isProp":false,"id":["_uniq",881771],"binderInfo":"default"},{"type":"Filter R","name":["l"],"isProp":false,"id":["_uniq",881772],"binderInfo":"default"},{"type":"R → Prop","name":["p"],"isProp":false,"id":["_uniq",895407],"binderInfo":"default"},{"type":"∀ᶠ (y : R) in l, p y","name":["h"],"isProp":true,"id":["_uniq",895425],"binderInfo":"default"}]}],"start":18418},{"state":[{"type":"(∀ᶠ (x : ℤ) in atTop, p (f x)) ↔ ∀ᶠ (x : ℕ) in atTop, p (f (↑x : ℤ))","tag":["h","h"],"mvarId":["_uniq",898813],"isProp":true,"context":[{"type":"Type","name":["R"],"isProp":false,"id":["_uniq",881770],"binderInfo":"implicit"},{"type":"ℤ → R","name":["f"],"isProp":false,"id":["_uniq",881771],"binderInfo":"default"},{"type":"Filter R","name":["l"],"isProp":false,"id":["_uniq",881772],"binderInfo":"default"},{"type":"R → Prop","name":["p"],"isProp":false,"id":["_uniq",895407],"binderInfo":"default"},{"type":"∀ᶠ (y : R) in l, p y","name":["h"],"isProp":true,"id":["_uniq",895425],"binderInfo":"default"}]}],"start":18447},{"state":[],"start":18488},{"state":[],"start":18489},{"state":[],"start":18490},{"state":[],"start":18551},{"state":[],"start":18619},{"state":[{"type":"Sum' f = ∑' (x : X), f x","tag":[],"mvarId":["_uniq",898930],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"}]}],"start":18648},{"state":[{"type":"Sum' f = ∑' (x : X), f x","tag":[],"mvarId":["_uniq",898984],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]}]}],"start":18675},{"state":[{"type":"Sum' f = ∑' (x : X), f x","tag":["inl"],"mvarId":["_uniq",899084],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"}]},{"type":"Sum' f = ∑' (x : X), f x","tag":["inr"],"mvarId":["_uniq",899089],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"Finite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899088],"binderInfo":"default"}]}],"start":18712},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑' (x : X), f x","tag":["inl"],"mvarId":["_uniq",901528],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"}]}],"start":18728},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑' (x : X), f x","tag":["inl"],"mvarId":["_uniq",901543],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"}]}],"start":18758},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","tag":[],"mvarId":["_uniq",901674],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"}]}],"start":18823},{"state":[{"type":"AbsConvergent (f ∘ Subtype.val)","tag":[],"mvarId":["_uniq",901689],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"}]}],"start":18857},{"state":[{"type":"AbsConvergent' (f ∘ Subtype.val)","tag":[],"mvarId":["_uniq",912708],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"}]}],"start":18905},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑' (x : X), f x","tag":["inl"],"mvarId":["_uniq",901676],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"AbsConvergent.comp hg\n  (Eq.mpr (id ((fun x_0 => Eq.symm (propext ((fun x_0 => AbsConvergent'.of_countable hE) x_0))) (f ∘ Subtype.val)))\n    (AbsConvergent'.subtype h E))","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.absConverges","name":["this"],"isProp":true,"id":["_uniq",901675]}]}],"start":18929},{"state":[{"type":"(Sum fun x => f (↑x : X)) = ∑' (x : X), f x","tag":["inl"],"mvarId":["_uniq",912848],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Sum.eq hg _fvar.901675","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum (f ∘ Subtype.val))","name":["this"],"isProp":true,"id":["_uniq",912844]}]}],"start":18964},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (∑' (x : X), f x)","tag":["inl","convert_2"],"mvarId":["_uniq",912855],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Sum.eq hg _fvar.901675","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum (f ∘ Subtype.val))","name":["this"],"isProp":true,"id":["_uniq",912844]}]}],"start":19000},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (∑' (x : X), f x)","tag":["inl","convert_2"],"mvarId":["_uniq",1001901],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Trans.trans\n  (Eq.mpr (id (congrArg (fun _a => _a = ∑' (x : (↑E : Type)), f (↑x : X)) (Eq.symm (tsum_univ f))))\n    (have hcompl :=\n      id\n        (Exists.casesOn (id hE) fun w h_1 =>\n          Set.ext fun x =>\n            of_eq_true\n              (Eq.trans\n                (congrArg (Iff ¬f x = 0)\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (Eq.trans (congrArg (fun x_1 => x_1 ∧ ¬f x = 0) (Set.mem_univ._simp_1 x)) (true_and ¬f x = 0))))\n                (iff_self ¬f x = 0)));\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (∑' (x : (↑Set.univ : Type)), f (↑x : X)) (∑' (a : (↑Set.univ : Type)), f (↑a : X))\n          (Eq.refl (∑' (x : (↑Set.univ : Type)), f (↑x : X))) (∑' (x : (↑E : Type)), f (↑x : X))\n          (∑' (a : (↑(Set.univ \\ {x | f x = 0}) : Type)), f (↑a : X))\n          (eq_of_heq\n            ((fun α inst inst_1 β β' e'_4 f f' e'_5 =>\n                Eq.casesOn (motive := fun a x => β' = a → e'_4 ≍ x → tsum f ≍ tsum f') e'_4\n                  (fun h =>\n                    Eq.ndrec (motive := fun β' =>\n                      ∀ (e_4 : β = β') (f' : β' → α), f ≍ f' → e_4 ≍ Eq.refl β → tsum f ≍ tsum f')\n                      (fun e_4 f' e_5 h =>\n                        HEq.casesOn (motive := fun {β_1} a x => (β → α) = β_1 → f' ≍ a → e_5 ≍ x → tsum f ≍ tsum f') e_5\n                          (fun h h =>\n                            Eq.ndrec (motive := fun f' => ∀ (e_5 : f ≍ f'), e_5 ≍ HEq.refl f → tsum f ≍ tsum f')\n                              (fun e_5 h => HEq.refl (tsum f)) (Eq.symm (eq_of_heq h)) e_5)\n                          (Eq.refl (β → α)) (HEq.refl f') (HEq.refl e_5))\n                      (Eq.symm h) e'_4 f' (e'_5 e'_4))\n                  (Eq.refl β') (HEq.refl e'_4))\n              ℝ Real.instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (↑E : Type)\n              (↑(Set.univ \\ {x | f x = 0}) : Type)\n              (eq_of_heq\n                ((fun α s s' e'_2 =>\n                    Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                          (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n                      (Eq.refl s') (HEq.refl e'_2))\n                  X E (Set.univ \\ {x | f x = 0}) hcompl))\n              (fun x => f (↑x : X)) (fun a => f (↑a : X)) fun e_4 =>\n              hfunext e_4 fun a a' a_1 =>\n                heq_of_eq\n                  (eq_of_heq\n                    ((fun a a' e'_1 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_1 ≍ x → f a ≍ f a') e'_1\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → f a ≍ f a')\n                              (fun e_1 h => HEq.refl (f a)) (Eq.symm h) e'_1)\n                          (Eq.refl a') (HEq.refl e'_1))\n                      (↑a : X) (↑a' : X)\n                      (eq_of_heq\n                        ((fun α p p' e'_2 self self' e'_3 =>\n                            Eq.casesOn (motive := fun a x => p' = a → e'_2 ≍ x → (↑self : α) ≍ (↑self' : α)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun p' =>\n                                  ∀ (e_2 : p = p') (self' : Subtype p'),\n                                    self ≍ self' → e_2 ≍ Eq.refl p → (↑self : α) ≍ (↑self' : α))\n                                  (fun e_2 self' e_3 h =>\n                                    HEq.casesOn (motive := fun {β} a x =>\n                                      Subtype p = β → self' ≍ a → e_3 ≍ x → (↑self : α) ≍ (↑self' : α)) e_3\n                                      (fun h h =>\n                                        Eq.ndrec (motive := fun self' =>\n                                          ∀ (e_3 : self ≍ self'), e_3 ≍ HEq.refl self → (↑self : α) ≍ (↑self' : α))\n                                          (fun e_3 h => HEq.refl (↑self : α)) (Eq.symm (eq_of_heq h)) e_3)\n                                      (Eq.refl (Subtype p)) (HEq.refl self') (HEq.refl e_3))\n                                  (Eq.symm h) e'_2 self' (e'_3 e'_2))\n                              (Eq.refl p') (HEq.refl e'_2))\n                          X (fun x => x ∈ E) (fun x => x ∈ Set.univ \\ {x | f x = 0})\n                          (funext fun x =>\n                            eq_of_heq\n                              ((fun α γ self a a' e'_4 a_2 =>\n                                  Eq.casesOn (motive := fun a_3 x => a' = a_3 → e'_4 ≍ x → (a_2 ∈ a) ≍ (a_2 ∈ a')) e'_4\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_4 : a = a'), e_4 ≍ Eq.refl a → (a_2 ∈ a) ≍ (a_2 ∈ a'))\n                                        (fun e_4 h => HEq.refl (a_2 ∈ a)) (Eq.symm h) e'_4)\n                                    (Eq.refl a') (HEq.refl e'_4))\n                                X (Set X) Set.instMembership E (Set.univ \\ {x | f x = 0}) hcompl x))\n                          a a' fun e_2 => a_1))))))))\n      (tsum_setElem_eq_tsum_setElem_diff Set.univ {x | f x = 0} fun b a => id a)))\n  (Eq.symm (Equiv.tsum_eq (Equiv.ofBijective g hg) fun x => f (↑x : X)))","type":"∑' (x : X), f x = ∑' (n : ℕ), f (↑(g n) : X)","name":["this"],"isProp":true,"id":["_uniq",917065]}]}],"start":19052},{"state":[{"type":"∑' (x : X), f x = ∑' (x : (↑E : Type)), f (↑x : X)","tag":[],"mvarId":["_uniq",916719],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Sum.eq hg _fvar.901675","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum (f ∘ Subtype.val))","name":["this"],"isProp":true,"id":["_uniq",912844]}]}],"start":19082},{"state":[{"type":"∑' (x : (↑Set.univ : Type)), f (↑x : X) = ∑' (x : (↑E : Type)), f (↑x : X)","tag":[],"mvarId":["_uniq",917131],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Sum.eq hg _fvar.901675","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum (f ∘ Subtype.val))","name":["this"],"isProp":true,"id":["_uniq",912844]}]}],"start":19110},{"state":[{"type":"∑' (x : (↑Set.univ : Type)), f (↑x : X) = ∑' (x : (↑E : Type)), f (↑x : X)","tag":[],"mvarId":["_uniq",917245],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Sum.eq hg _fvar.901675","type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (Sum (f ∘ Subtype.val))","name":["this"],"isProp":true,"id":["_uniq",912844]},{"value":"id\n  (Exists.casesOn (id hE) fun w h_1 =>\n    Set.ext fun x =>\n      of_eq_true\n        (Eq.trans\n          (congrArg (Iff ¬f x = 0)\n            (Eq.trans (Set.mem_diff._simp_1 x)\n              (Eq.trans (congrArg (fun x_1 => x_1 ∧ ¬f x = 0) (Set.mem_univ._simp_1 x)) (true_and ¬f x = 0))))\n          (iff_self ¬f x = 0)))","type":"E = Set.univ \\ {x | f x = 0}","name":["hcompl"],"isProp":true,"id":["_uniq",917244]}]}],"start":19171},{"state":[],"start":19250},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (∑' (x : X), f x)","tag":["inl","convert_2"],"mvarId":["_uniq",1001901],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Trans.trans\n  (Eq.mpr (id (congrArg (fun _a => _a = ∑' (x : (↑E : Type)), f (↑x : X)) (Eq.symm (tsum_univ f))))\n    (have hcompl :=\n      id\n        (Exists.casesOn (id hE) fun w h_1 =>\n          Set.ext fun x =>\n            of_eq_true\n              (Eq.trans\n                (congrArg (Iff ¬f x = 0)\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (Eq.trans (congrArg (fun x_1 => x_1 ∧ ¬f x = 0) (Set.mem_univ._simp_1 x)) (true_and ¬f x = 0))))\n                (iff_self ¬f x = 0)));\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (∑' (x : (↑Set.univ : Type)), f (↑x : X)) (∑' (a : (↑Set.univ : Type)), f (↑a : X))\n          (Eq.refl (∑' (x : (↑Set.univ : Type)), f (↑x : X))) (∑' (x : (↑E : Type)), f (↑x : X))\n          (∑' (a : (↑(Set.univ \\ {x | f x = 0}) : Type)), f (↑a : X))\n          (eq_of_heq\n            ((fun α inst inst_1 β β' e'_4 f f' e'_5 =>\n                Eq.casesOn (motive := fun a x => β' = a → e'_4 ≍ x → tsum f ≍ tsum f') e'_4\n                  (fun h =>\n                    Eq.ndrec (motive := fun β' =>\n                      ∀ (e_4 : β = β') (f' : β' → α), f ≍ f' → e_4 ≍ Eq.refl β → tsum f ≍ tsum f')\n                      (fun e_4 f' e_5 h =>\n                        HEq.casesOn (motive := fun {β_1} a x => (β → α) = β_1 → f' ≍ a → e_5 ≍ x → tsum f ≍ tsum f') e_5\n                          (fun h h =>\n                            Eq.ndrec (motive := fun f' => ∀ (e_5 : f ≍ f'), e_5 ≍ HEq.refl f → tsum f ≍ tsum f')\n                              (fun e_5 h => HEq.refl (tsum f)) (Eq.symm (eq_of_heq h)) e_5)\n                          (Eq.refl (β → α)) (HEq.refl f') (HEq.refl e_5))\n                      (Eq.symm h) e'_4 f' (e'_5 e'_4))\n                  (Eq.refl β') (HEq.refl e'_4))\n              ℝ Real.instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (↑E : Type)\n              (↑(Set.univ \\ {x | f x = 0}) : Type)\n              (eq_of_heq\n                ((fun α s s' e'_2 =>\n                    Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                          (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n                      (Eq.refl s') (HEq.refl e'_2))\n                  X E (Set.univ \\ {x | f x = 0}) hcompl))\n              (fun x => f (↑x : X)) (fun a => f (↑a : X)) fun e_4 =>\n              hfunext e_4 fun a a' a_1 =>\n                heq_of_eq\n                  (eq_of_heq\n                    ((fun a a' e'_1 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_1 ≍ x → f a ≍ f a') e'_1\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → f a ≍ f a')\n                              (fun e_1 h => HEq.refl (f a)) (Eq.symm h) e'_1)\n                          (Eq.refl a') (HEq.refl e'_1))\n                      (↑a : X) (↑a' : X)\n                      (eq_of_heq\n                        ((fun α p p' e'_2 self self' e'_3 =>\n                            Eq.casesOn (motive := fun a x => p' = a → e'_2 ≍ x → (↑self : α) ≍ (↑self' : α)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun p' =>\n                                  ∀ (e_2 : p = p') (self' : Subtype p'),\n                                    self ≍ self' → e_2 ≍ Eq.refl p → (↑self : α) ≍ (↑self' : α))\n                                  (fun e_2 self' e_3 h =>\n                                    HEq.casesOn (motive := fun {β} a x =>\n                                      Subtype p = β → self' ≍ a → e_3 ≍ x → (↑self : α) ≍ (↑self' : α)) e_3\n                                      (fun h h =>\n                                        Eq.ndrec (motive := fun self' =>\n                                          ∀ (e_3 : self ≍ self'), e_3 ≍ HEq.refl self → (↑self : α) ≍ (↑self' : α))\n                                          (fun e_3 h => HEq.refl (↑self : α)) (Eq.symm (eq_of_heq h)) e_3)\n                                      (Eq.refl (Subtype p)) (HEq.refl self') (HEq.refl e_3))\n                                  (Eq.symm h) e'_2 self' (e'_3 e'_2))\n                              (Eq.refl p') (HEq.refl e'_2))\n                          X (fun x => x ∈ E) (fun x => x ∈ Set.univ \\ {x | f x = 0})\n                          (funext fun x =>\n                            eq_of_heq\n                              ((fun α γ self a a' e'_4 a_2 =>\n                                  Eq.casesOn (motive := fun a_3 x => a' = a_3 → e'_4 ≍ x → (a_2 ∈ a) ≍ (a_2 ∈ a')) e'_4\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_4 : a = a'), e_4 ≍ Eq.refl a → (a_2 ∈ a) ≍ (a_2 ∈ a'))\n                                        (fun e_4 h => HEq.refl (a_2 ∈ a)) (Eq.symm h) e'_4)\n                                    (Eq.refl a') (HEq.refl e'_4))\n                                X (Set X) Set.instMembership E (Set.univ \\ {x | f x = 0}) hcompl x))\n                          a a' fun e_2 => a_1))))))))\n      (tsum_setElem_eq_tsum_setElem_diff Set.univ {x | f x = 0} fun b a => id a)))\n  (Eq.symm (Equiv.tsum_eq (Equiv.ofBijective g hg) fun x => f (↑x : X)))","type":"∑' (x : X), f x = ∑' (n : ℕ), f (↑(g n) : X)","name":["this"],"isProp":true,"id":["_uniq",917065]}]}],"start":19313},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.convergesTo\n  (∑' (n : ℕ), f (↑(g n) : X))","tag":["inl","convert_2"],"mvarId":["_uniq",1001912],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Trans.trans\n  (Eq.mpr (id (congrArg (fun _a => _a = ∑' (x : (↑E : Type)), f (↑x : X)) (Eq.symm (tsum_univ f))))\n    (have hcompl :=\n      id\n        (Exists.casesOn (id hE) fun w h_1 =>\n          Set.ext fun x =>\n            of_eq_true\n              (Eq.trans\n                (congrArg (Iff ¬f x = 0)\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (Eq.trans (congrArg (fun x_1 => x_1 ∧ ¬f x = 0) (Set.mem_univ._simp_1 x)) (true_and ¬f x = 0))))\n                (iff_self ¬f x = 0)));\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (∑' (x : (↑Set.univ : Type)), f (↑x : X)) (∑' (a : (↑Set.univ : Type)), f (↑a : X))\n          (Eq.refl (∑' (x : (↑Set.univ : Type)), f (↑x : X))) (∑' (x : (↑E : Type)), f (↑x : X))\n          (∑' (a : (↑(Set.univ \\ {x | f x = 0}) : Type)), f (↑a : X))\n          (eq_of_heq\n            ((fun α inst inst_1 β β' e'_4 f f' e'_5 =>\n                Eq.casesOn (motive := fun a x => β' = a → e'_4 ≍ x → tsum f ≍ tsum f') e'_4\n                  (fun h =>\n                    Eq.ndrec (motive := fun β' =>\n                      ∀ (e_4 : β = β') (f' : β' → α), f ≍ f' → e_4 ≍ Eq.refl β → tsum f ≍ tsum f')\n                      (fun e_4 f' e_5 h =>\n                        HEq.casesOn (motive := fun {β_1} a x => (β → α) = β_1 → f' ≍ a → e_5 ≍ x → tsum f ≍ tsum f') e_5\n                          (fun h h =>\n                            Eq.ndrec (motive := fun f' => ∀ (e_5 : f ≍ f'), e_5 ≍ HEq.refl f → tsum f ≍ tsum f')\n                              (fun e_5 h => HEq.refl (tsum f)) (Eq.symm (eq_of_heq h)) e_5)\n                          (Eq.refl (β → α)) (HEq.refl f') (HEq.refl e_5))\n                      (Eq.symm h) e'_4 f' (e'_5 e'_4))\n                  (Eq.refl β') (HEq.refl e'_4))\n              ℝ Real.instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (↑E : Type)\n              (↑(Set.univ \\ {x | f x = 0}) : Type)\n              (eq_of_heq\n                ((fun α s s' e'_2 =>\n                    Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                          (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n                      (Eq.refl s') (HEq.refl e'_2))\n                  X E (Set.univ \\ {x | f x = 0}) hcompl))\n              (fun x => f (↑x : X)) (fun a => f (↑a : X)) fun e_4 =>\n              hfunext e_4 fun a a' a_1 =>\n                heq_of_eq\n                  (eq_of_heq\n                    ((fun a a' e'_1 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_1 ≍ x → f a ≍ f a') e'_1\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → f a ≍ f a')\n                              (fun e_1 h => HEq.refl (f a)) (Eq.symm h) e'_1)\n                          (Eq.refl a') (HEq.refl e'_1))\n                      (↑a : X) (↑a' : X)\n                      (eq_of_heq\n                        ((fun α p p' e'_2 self self' e'_3 =>\n                            Eq.casesOn (motive := fun a x => p' = a → e'_2 ≍ x → (↑self : α) ≍ (↑self' : α)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun p' =>\n                                  ∀ (e_2 : p = p') (self' : Subtype p'),\n                                    self ≍ self' → e_2 ≍ Eq.refl p → (↑self : α) ≍ (↑self' : α))\n                                  (fun e_2 self' e_3 h =>\n                                    HEq.casesOn (motive := fun {β} a x =>\n                                      Subtype p = β → self' ≍ a → e_3 ≍ x → (↑self : α) ≍ (↑self' : α)) e_3\n                                      (fun h h =>\n                                        Eq.ndrec (motive := fun self' =>\n                                          ∀ (e_3 : self ≍ self'), e_3 ≍ HEq.refl self → (↑self : α) ≍ (↑self' : α))\n                                          (fun e_3 h => HEq.refl (↑self : α)) (Eq.symm (eq_of_heq h)) e_3)\n                                      (Eq.refl (Subtype p)) (HEq.refl self') (HEq.refl e_3))\n                                  (Eq.symm h) e'_2 self' (e'_3 e'_2))\n                              (Eq.refl p') (HEq.refl e'_2))\n                          X (fun x => x ∈ E) (fun x => x ∈ Set.univ \\ {x | f x = 0})\n                          (funext fun x =>\n                            eq_of_heq\n                              ((fun α γ self a a' e'_4 a_2 =>\n                                  Eq.casesOn (motive := fun a_3 x => a' = a_3 → e'_4 ≍ x → (a_2 ∈ a) ≍ (a_2 ∈ a')) e'_4\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_4 : a = a'), e_4 ≍ Eq.refl a → (a_2 ∈ a) ≍ (a_2 ∈ a'))\n                                        (fun e_4 h => HEq.refl (a_2 ∈ a)) (Eq.symm h) e'_4)\n                                    (Eq.refl a') (HEq.refl e'_4))\n                                X (Set X) Set.instMembership E (Set.univ \\ {x | f x = 0}) hcompl x))\n                          a a' fun e_2 => a_1))))))))\n      (tsum_setElem_eq_tsum_setElem_diff Set.univ {x | f x = 0} fun b a => id a)))\n  (Eq.symm (Equiv.tsum_eq (Equiv.ofBijective g hg) fun x => f (↑x : X)))","type":"∑' (x : X), f x = ∑' (n : ℕ), f (↑(g n) : X)","name":["this"],"isProp":true,"id":["_uniq",917065]}]}],"start":19327},{"state":[{"type":"Tendsto\n  ({ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.partial ∘ Nat.cast)\n  atTop (nhds (∑' (n : ℕ), f (↑(g n) : X)))","tag":["inl","convert_2"],"mvarId":["_uniq",1001933],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Trans.trans\n  (Eq.mpr (id (congrArg (fun _a => _a = ∑' (x : (↑E : Type)), f (↑x : X)) (Eq.symm (tsum_univ f))))\n    (have hcompl :=\n      id\n        (Exists.casesOn (id hE) fun w h_1 =>\n          Set.ext fun x =>\n            of_eq_true\n              (Eq.trans\n                (congrArg (Iff ¬f x = 0)\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (Eq.trans (congrArg (fun x_1 => x_1 ∧ ¬f x = 0) (Set.mem_univ._simp_1 x)) (true_and ¬f x = 0))))\n                (iff_self ¬f x = 0)));\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (∑' (x : (↑Set.univ : Type)), f (↑x : X)) (∑' (a : (↑Set.univ : Type)), f (↑a : X))\n          (Eq.refl (∑' (x : (↑Set.univ : Type)), f (↑x : X))) (∑' (x : (↑E : Type)), f (↑x : X))\n          (∑' (a : (↑(Set.univ \\ {x | f x = 0}) : Type)), f (↑a : X))\n          (eq_of_heq\n            ((fun α inst inst_1 β β' e'_4 f f' e'_5 =>\n                Eq.casesOn (motive := fun a x => β' = a → e'_4 ≍ x → tsum f ≍ tsum f') e'_4\n                  (fun h =>\n                    Eq.ndrec (motive := fun β' =>\n                      ∀ (e_4 : β = β') (f' : β' → α), f ≍ f' → e_4 ≍ Eq.refl β → tsum f ≍ tsum f')\n                      (fun e_4 f' e_5 h =>\n                        HEq.casesOn (motive := fun {β_1} a x => (β → α) = β_1 → f' ≍ a → e_5 ≍ x → tsum f ≍ tsum f') e_5\n                          (fun h h =>\n                            Eq.ndrec (motive := fun f' => ∀ (e_5 : f ≍ f'), e_5 ≍ HEq.refl f → tsum f ≍ tsum f')\n                              (fun e_5 h => HEq.refl (tsum f)) (Eq.symm (eq_of_heq h)) e_5)\n                          (Eq.refl (β → α)) (HEq.refl f') (HEq.refl e_5))\n                      (Eq.symm h) e'_4 f' (e'_5 e'_4))\n                  (Eq.refl β') (HEq.refl e'_4))\n              ℝ Real.instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (↑E : Type)\n              (↑(Set.univ \\ {x | f x = 0}) : Type)\n              (eq_of_heq\n                ((fun α s s' e'_2 =>\n                    Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                          (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n                      (Eq.refl s') (HEq.refl e'_2))\n                  X E (Set.univ \\ {x | f x = 0}) hcompl))\n              (fun x => f (↑x : X)) (fun a => f (↑a : X)) fun e_4 =>\n              hfunext e_4 fun a a' a_1 =>\n                heq_of_eq\n                  (eq_of_heq\n                    ((fun a a' e'_1 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_1 ≍ x → f a ≍ f a') e'_1\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → f a ≍ f a')\n                              (fun e_1 h => HEq.refl (f a)) (Eq.symm h) e'_1)\n                          (Eq.refl a') (HEq.refl e'_1))\n                      (↑a : X) (↑a' : X)\n                      (eq_of_heq\n                        ((fun α p p' e'_2 self self' e'_3 =>\n                            Eq.casesOn (motive := fun a x => p' = a → e'_2 ≍ x → (↑self : α) ≍ (↑self' : α)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun p' =>\n                                  ∀ (e_2 : p = p') (self' : Subtype p'),\n                                    self ≍ self' → e_2 ≍ Eq.refl p → (↑self : α) ≍ (↑self' : α))\n                                  (fun e_2 self' e_3 h =>\n                                    HEq.casesOn (motive := fun {β} a x =>\n                                      Subtype p = β → self' ≍ a → e_3 ≍ x → (↑self : α) ≍ (↑self' : α)) e_3\n                                      (fun h h =>\n                                        Eq.ndrec (motive := fun self' =>\n                                          ∀ (e_3 : self ≍ self'), e_3 ≍ HEq.refl self → (↑self : α) ≍ (↑self' : α))\n                                          (fun e_3 h => HEq.refl (↑self : α)) (Eq.symm (eq_of_heq h)) e_3)\n                                      (Eq.refl (Subtype p)) (HEq.refl self') (HEq.refl e_3))\n                                  (Eq.symm h) e'_2 self' (e'_3 e'_2))\n                              (Eq.refl p') (HEq.refl e'_2))\n                          X (fun x => x ∈ E) (fun x => x ∈ Set.univ \\ {x | f x = 0})\n                          (funext fun x =>\n                            eq_of_heq\n                              ((fun α γ self a a' e'_4 a_2 =>\n                                  Eq.casesOn (motive := fun a_3 x => a' = a_3 → e'_4 ≍ x → (a_2 ∈ a) ≍ (a_2 ∈ a')) e'_4\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_4 : a = a'), e_4 ≍ Eq.refl a → (a_2 ∈ a) ≍ (a_2 ∈ a'))\n                                        (fun e_4 h => HEq.refl (a_2 ∈ a)) (Eq.symm h) e'_4)\n                                    (Eq.refl a') (HEq.refl e'_4))\n                                X (Set X) Set.instMembership E (Set.univ \\ {x | f x = 0}) hcompl x))\n                          a a' fun e_2 => a_1))))))))\n      (tsum_setElem_eq_tsum_setElem_diff Set.univ {x | f x = 0} fun b a => id a)))\n  (Eq.symm (Equiv.tsum_eq (Equiv.ofBijective g hg) fun x => f (↑x : X)))","type":"∑' (x : X), f x = ∑' (n : ℕ), f (↑(g n) : X)","name":["this"],"isProp":true,"id":["_uniq",917065]}]}],"start":19389},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then ((f ∘ Subtype.val) ∘ g) n.toNat else 0, vanish := ⋯ }.partial ∘ Nat.cast =\n  (fun n => ∑ i ∈ range n, f (↑(g i) : X)) ∘ fun a => a + 1","tag":["h","e'_3"],"mvarId":["_uniq",1003821],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Trans.trans\n  (Eq.mpr (id (congrArg (fun _a => _a = ∑' (x : (↑E : Type)), f (↑x : X)) (Eq.symm (tsum_univ f))))\n    (have hcompl :=\n      id\n        (Exists.casesOn (id hE) fun w h_1 =>\n          Set.ext fun x =>\n            of_eq_true\n              (Eq.trans\n                (congrArg (Iff ¬f x = 0)\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (Eq.trans (congrArg (fun x_1 => x_1 ∧ ¬f x = 0) (Set.mem_univ._simp_1 x)) (true_and ¬f x = 0))))\n                (iff_self ¬f x = 0)));\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (∑' (x : (↑Set.univ : Type)), f (↑x : X)) (∑' (a : (↑Set.univ : Type)), f (↑a : X))\n          (Eq.refl (∑' (x : (↑Set.univ : Type)), f (↑x : X))) (∑' (x : (↑E : Type)), f (↑x : X))\n          (∑' (a : (↑(Set.univ \\ {x | f x = 0}) : Type)), f (↑a : X))\n          (eq_of_heq\n            ((fun α inst inst_1 β β' e'_4 f f' e'_5 =>\n                Eq.casesOn (motive := fun a x => β' = a → e'_4 ≍ x → tsum f ≍ tsum f') e'_4\n                  (fun h =>\n                    Eq.ndrec (motive := fun β' =>\n                      ∀ (e_4 : β = β') (f' : β' → α), f ≍ f' → e_4 ≍ Eq.refl β → tsum f ≍ tsum f')\n                      (fun e_4 f' e_5 h =>\n                        HEq.casesOn (motive := fun {β_1} a x => (β → α) = β_1 → f' ≍ a → e_5 ≍ x → tsum f ≍ tsum f') e_5\n                          (fun h h =>\n                            Eq.ndrec (motive := fun f' => ∀ (e_5 : f ≍ f'), e_5 ≍ HEq.refl f → tsum f ≍ tsum f')\n                              (fun e_5 h => HEq.refl (tsum f)) (Eq.symm (eq_of_heq h)) e_5)\n                          (Eq.refl (β → α)) (HEq.refl f') (HEq.refl e_5))\n                      (Eq.symm h) e'_4 f' (e'_5 e'_4))\n                  (Eq.refl β') (HEq.refl e'_4))\n              ℝ Real.instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (↑E : Type)\n              (↑(Set.univ \\ {x | f x = 0}) : Type)\n              (eq_of_heq\n                ((fun α s s' e'_2 =>\n                    Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                          (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n                      (Eq.refl s') (HEq.refl e'_2))\n                  X E (Set.univ \\ {x | f x = 0}) hcompl))\n              (fun x => f (↑x : X)) (fun a => f (↑a : X)) fun e_4 =>\n              hfunext e_4 fun a a' a_1 =>\n                heq_of_eq\n                  (eq_of_heq\n                    ((fun a a' e'_1 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_1 ≍ x → f a ≍ f a') e'_1\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → f a ≍ f a')\n                              (fun e_1 h => HEq.refl (f a)) (Eq.symm h) e'_1)\n                          (Eq.refl a') (HEq.refl e'_1))\n                      (↑a : X) (↑a' : X)\n                      (eq_of_heq\n                        ((fun α p p' e'_2 self self' e'_3 =>\n                            Eq.casesOn (motive := fun a x => p' = a → e'_2 ≍ x → (↑self : α) ≍ (↑self' : α)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun p' =>\n                                  ∀ (e_2 : p = p') (self' : Subtype p'),\n                                    self ≍ self' → e_2 ≍ Eq.refl p → (↑self : α) ≍ (↑self' : α))\n                                  (fun e_2 self' e_3 h =>\n                                    HEq.casesOn (motive := fun {β} a x =>\n                                      Subtype p = β → self' ≍ a → e_3 ≍ x → (↑self : α) ≍ (↑self' : α)) e_3\n                                      (fun h h =>\n                                        Eq.ndrec (motive := fun self' =>\n                                          ∀ (e_3 : self ≍ self'), e_3 ≍ HEq.refl self → (↑self : α) ≍ (↑self' : α))\n                                          (fun e_3 h => HEq.refl (↑self : α)) (Eq.symm (eq_of_heq h)) e_3)\n                                      (Eq.refl (Subtype p)) (HEq.refl self') (HEq.refl e_3))\n                                  (Eq.symm h) e'_2 self' (e'_3 e'_2))\n                              (Eq.refl p') (HEq.refl e'_2))\n                          X (fun x => x ∈ E) (fun x => x ∈ Set.univ \\ {x | f x = 0})\n                          (funext fun x =>\n                            eq_of_heq\n                              ((fun α γ self a a' e'_4 a_2 =>\n                                  Eq.casesOn (motive := fun a_3 x => a' = a_3 → e'_4 ≍ x → (a_2 ∈ a) ≍ (a_2 ∈ a')) e'_4\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_4 : a = a'), e_4 ≍ Eq.refl a → (a_2 ∈ a) ≍ (a_2 ∈ a'))\n                                        (fun e_4 h => HEq.refl (a_2 ∈ a)) (Eq.symm h) e'_4)\n                                    (Eq.refl a') (HEq.refl e'_4))\n                                X (Set X) Set.instMembership E (Set.univ \\ {x | f x = 0}) hcompl x))\n                          a a' fun e_2 => a_1))))))))\n      (tsum_setElem_eq_tsum_setElem_diff Set.univ {x | f x = 0} fun b a => id a)))\n  (Eq.symm (Equiv.tsum_eq (Equiv.ofBijective g hg) fun x => f (↑x : X)))","type":"∑' (x : X), f x = ∑' (n : ℕ), f (↑(g n) : X)","name":["this"],"isProp":true,"id":["_uniq",917065]}]},{"type":"Summable fun n => f (↑(g n) : X)","tag":["inl","convert_2","convert_4"],"mvarId":["_uniq",1001944],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Trans.trans\n  (Eq.mpr (id (congrArg (fun _a => _a = ∑' (x : (↑E : Type)), f (↑x : X)) (Eq.symm (tsum_univ f))))\n    (have hcompl :=\n      id\n        (Exists.casesOn (id hE) fun w h_1 =>\n          Set.ext fun x =>\n            of_eq_true\n              (Eq.trans\n                (congrArg (Iff ¬f x = 0)\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (Eq.trans (congrArg (fun x_1 => x_1 ∧ ¬f x = 0) (Set.mem_univ._simp_1 x)) (true_and ¬f x = 0))))\n                (iff_self ¬f x = 0)));\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (∑' (x : (↑Set.univ : Type)), f (↑x : X)) (∑' (a : (↑Set.univ : Type)), f (↑a : X))\n          (Eq.refl (∑' (x : (↑Set.univ : Type)), f (↑x : X))) (∑' (x : (↑E : Type)), f (↑x : X))\n          (∑' (a : (↑(Set.univ \\ {x | f x = 0}) : Type)), f (↑a : X))\n          (eq_of_heq\n            ((fun α inst inst_1 β β' e'_4 f f' e'_5 =>\n                Eq.casesOn (motive := fun a x => β' = a → e'_4 ≍ x → tsum f ≍ tsum f') e'_4\n                  (fun h =>\n                    Eq.ndrec (motive := fun β' =>\n                      ∀ (e_4 : β = β') (f' : β' → α), f ≍ f' → e_4 ≍ Eq.refl β → tsum f ≍ tsum f')\n                      (fun e_4 f' e_5 h =>\n                        HEq.casesOn (motive := fun {β_1} a x => (β → α) = β_1 → f' ≍ a → e_5 ≍ x → tsum f ≍ tsum f') e_5\n                          (fun h h =>\n                            Eq.ndrec (motive := fun f' => ∀ (e_5 : f ≍ f'), e_5 ≍ HEq.refl f → tsum f ≍ tsum f')\n                              (fun e_5 h => HEq.refl (tsum f)) (Eq.symm (eq_of_heq h)) e_5)\n                          (Eq.refl (β → α)) (HEq.refl f') (HEq.refl e_5))\n                      (Eq.symm h) e'_4 f' (e'_5 e'_4))\n                  (Eq.refl β') (HEq.refl e'_4))\n              ℝ Real.instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (↑E : Type)\n              (↑(Set.univ \\ {x | f x = 0}) : Type)\n              (eq_of_heq\n                ((fun α s s' e'_2 =>\n                    Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                          (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n                      (Eq.refl s') (HEq.refl e'_2))\n                  X E (Set.univ \\ {x | f x = 0}) hcompl))\n              (fun x => f (↑x : X)) (fun a => f (↑a : X)) fun e_4 =>\n              hfunext e_4 fun a a' a_1 =>\n                heq_of_eq\n                  (eq_of_heq\n                    ((fun a a' e'_1 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_1 ≍ x → f a ≍ f a') e'_1\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → f a ≍ f a')\n                              (fun e_1 h => HEq.refl (f a)) (Eq.symm h) e'_1)\n                          (Eq.refl a') (HEq.refl e'_1))\n                      (↑a : X) (↑a' : X)\n                      (eq_of_heq\n                        ((fun α p p' e'_2 self self' e'_3 =>\n                            Eq.casesOn (motive := fun a x => p' = a → e'_2 ≍ x → (↑self : α) ≍ (↑self' : α)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun p' =>\n                                  ∀ (e_2 : p = p') (self' : Subtype p'),\n                                    self ≍ self' → e_2 ≍ Eq.refl p → (↑self : α) ≍ (↑self' : α))\n                                  (fun e_2 self' e_3 h =>\n                                    HEq.casesOn (motive := fun {β} a x =>\n                                      Subtype p = β → self' ≍ a → e_3 ≍ x → (↑self : α) ≍ (↑self' : α)) e_3\n                                      (fun h h =>\n                                        Eq.ndrec (motive := fun self' =>\n                                          ∀ (e_3 : self ≍ self'), e_3 ≍ HEq.refl self → (↑self : α) ≍ (↑self' : α))\n                                          (fun e_3 h => HEq.refl (↑self : α)) (Eq.symm (eq_of_heq h)) e_3)\n                                      (Eq.refl (Subtype p)) (HEq.refl self') (HEq.refl e_3))\n                                  (Eq.symm h) e'_2 self' (e'_3 e'_2))\n                              (Eq.refl p') (HEq.refl e'_2))\n                          X (fun x => x ∈ E) (fun x => x ∈ Set.univ \\ {x | f x = 0})\n                          (funext fun x =>\n                            eq_of_heq\n                              ((fun α γ self a a' e'_4 a_2 =>\n                                  Eq.casesOn (motive := fun a_3 x => a' = a_3 → e'_4 ≍ x → (a_2 ∈ a) ≍ (a_2 ∈ a')) e'_4\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_4 : a = a'), e_4 ≍ Eq.refl a → (a_2 ∈ a) ≍ (a_2 ∈ a'))\n                                        (fun e_4 h => HEq.refl (a_2 ∈ a)) (Eq.symm h) e'_4)\n                                    (Eq.refl a') (HEq.refl e'_4))\n                                X (Set X) Set.instMembership E (Set.univ \\ {x | f x = 0}) hcompl x))\n                          a a' fun e_2 => a_1))))))))\n      (tsum_setElem_eq_tsum_setElem_diff Set.univ {x | f x = 0} fun b a => id a)))\n  (Eq.symm (Equiv.tsum_eq (Equiv.ofBijective g hg) fun x => f (↑x : X)))","type":"∑' (x : X), f x = ∑' (n : ℕ), f (↑(g n) : X)","name":["this"],"isProp":true,"id":["_uniq",917065]}]}],"start":19474},{"state":[{"type":"Summable fun n => f (↑(g n) : X)","tag":["inl","convert_2","convert_4"],"mvarId":["_uniq",1001944],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899083],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",901538],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",901542],"binderInfo":"default"},{"value":"Trans.trans\n  (Eq.mpr (id (congrArg (fun _a => _a = ∑' (x : (↑E : Type)), f (↑x : X)) (Eq.symm (tsum_univ f))))\n    (have hcompl :=\n      id\n        (Exists.casesOn (id hE) fun w h_1 =>\n          Set.ext fun x =>\n            of_eq_true\n              (Eq.trans\n                (congrArg (Iff ¬f x = 0)\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (Eq.trans (congrArg (fun x_1 => x_1 ∧ ¬f x = 0) (Set.mem_univ._simp_1 x)) (true_and ¬f x = 0))))\n                (iff_self ¬f x = 0)));\n    Eq.mpr\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                      (Eq.refl a'_1) (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ (∑' (x : (↑Set.univ : Type)), f (↑x : X)) (∑' (a : (↑Set.univ : Type)), f (↑a : X))\n          (Eq.refl (∑' (x : (↑Set.univ : Type)), f (↑x : X))) (∑' (x : (↑E : Type)), f (↑x : X))\n          (∑' (a : (↑(Set.univ \\ {x | f x = 0}) : Type)), f (↑a : X))\n          (eq_of_heq\n            ((fun α inst inst_1 β β' e'_4 f f' e'_5 =>\n                Eq.casesOn (motive := fun a x => β' = a → e'_4 ≍ x → tsum f ≍ tsum f') e'_4\n                  (fun h =>\n                    Eq.ndrec (motive := fun β' =>\n                      ∀ (e_4 : β = β') (f' : β' → α), f ≍ f' → e_4 ≍ Eq.refl β → tsum f ≍ tsum f')\n                      (fun e_4 f' e_5 h =>\n                        HEq.casesOn (motive := fun {β_1} a x => (β → α) = β_1 → f' ≍ a → e_5 ≍ x → tsum f ≍ tsum f') e_5\n                          (fun h h =>\n                            Eq.ndrec (motive := fun f' => ∀ (e_5 : f ≍ f'), e_5 ≍ HEq.refl f → tsum f ≍ tsum f')\n                              (fun e_5 h => HEq.refl (tsum f)) (Eq.symm (eq_of_heq h)) e_5)\n                          (Eq.refl (β → α)) (HEq.refl f') (HEq.refl e_5))\n                      (Eq.symm h) e'_4 f' (e'_5 e'_4))\n                  (Eq.refl β') (HEq.refl e'_4))\n              ℝ Real.instAddCommMonoid PseudoMetricSpace.toUniformSpace.toTopologicalSpace (↑E : Type)\n              (↑(Set.univ \\ {x | f x = 0}) : Type)\n              (eq_of_heq\n                ((fun α s s' e'_2 =>\n                    Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                          (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n                      (Eq.refl s') (HEq.refl e'_2))\n                  X E (Set.univ \\ {x | f x = 0}) hcompl))\n              (fun x => f (↑x : X)) (fun a => f (↑a : X)) fun e_4 =>\n              hfunext e_4 fun a a' a_1 =>\n                heq_of_eq\n                  (eq_of_heq\n                    ((fun a a' e'_1 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_1 ≍ x → f a ≍ f a') e'_1\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → f a ≍ f a')\n                              (fun e_1 h => HEq.refl (f a)) (Eq.symm h) e'_1)\n                          (Eq.refl a') (HEq.refl e'_1))\n                      (↑a : X) (↑a' : X)\n                      (eq_of_heq\n                        ((fun α p p' e'_2 self self' e'_3 =>\n                            Eq.casesOn (motive := fun a x => p' = a → e'_2 ≍ x → (↑self : α) ≍ (↑self' : α)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun p' =>\n                                  ∀ (e_2 : p = p') (self' : Subtype p'),\n                                    self ≍ self' → e_2 ≍ Eq.refl p → (↑self : α) ≍ (↑self' : α))\n                                  (fun e_2 self' e_3 h =>\n                                    HEq.casesOn (motive := fun {β} a x =>\n                                      Subtype p = β → self' ≍ a → e_3 ≍ x → (↑self : α) ≍ (↑self' : α)) e_3\n                                      (fun h h =>\n                                        Eq.ndrec (motive := fun self' =>\n                                          ∀ (e_3 : self ≍ self'), e_3 ≍ HEq.refl self → (↑self : α) ≍ (↑self' : α))\n                                          (fun e_3 h => HEq.refl (↑self : α)) (Eq.symm (eq_of_heq h)) e_3)\n                                      (Eq.refl (Subtype p)) (HEq.refl self') (HEq.refl e_3))\n                                  (Eq.symm h) e'_2 self' (e'_3 e'_2))\n                              (Eq.refl p') (HEq.refl e'_2))\n                          X (fun x => x ∈ E) (fun x => x ∈ Set.univ \\ {x | f x = 0})\n                          (funext fun x =>\n                            eq_of_heq\n                              ((fun α γ self a a' e'_4 a_2 =>\n                                  Eq.casesOn (motive := fun a_3 x => a' = a_3 → e'_4 ≍ x → (a_2 ∈ a) ≍ (a_2 ∈ a')) e'_4\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_4 : a = a'), e_4 ≍ Eq.refl a → (a_2 ∈ a) ≍ (a_2 ∈ a'))\n                                        (fun e_4 h => HEq.refl (a_2 ∈ a)) (Eq.symm h) e'_4)\n                                    (Eq.refl a') (HEq.refl e'_4))\n                                X (Set X) Set.instMembership E (Set.univ \\ {x | f x = 0}) hcompl x))\n                          a a' fun e_2 => a_1))))))))\n      (tsum_setElem_eq_tsum_setElem_diff Set.univ {x | f x = 0} fun b a => id a)))\n  (Eq.symm (Equiv.tsum_eq (Equiv.ofBijective g hg) fun x => f (↑x : X)))","type":"∑' (x : X), f x = ∑' (n : ℕ), f (↑(g n) : X)","name":["this"],"isProp":true,"id":["_uniq",917065]}]}],"start":19537},{"state":[{"type":"Summable fun n => f (↑(g n) : X)","tag":["inl","convert_2","convert_4"],"mvarId":["_uniq",1015713],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"Summable f","name":["h"],"isProp":true,"id":["_uniq",1015702],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",1015705]},{"type":"CountablyInfinite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",1015706],"binderInfo":"default"},{"type":"ℕ → (↑{x | f x ≠ 0} : Type)","name":["g"],"isProp":false,"id":["_uniq",1015707],"binderInfo":"default"},{"type":"Bijective g","name":["hg"],"isProp":true,"id":["_uniq",1015708],"binderInfo":"default"},{"type":"∑' (x : X), f x = ∑' (n : ℕ), f (↑(g n) : X)","name":["this"],"isProp":true,"id":["_uniq",1015709],"binderInfo":"default"}]}],"start":19579},{"state":[{"type":"Sum' f = ∑' (x : X), f x","tag":["inr"],"mvarId":["_uniq",899089],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"Finite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899088],"binderInfo":"default"}]}],"start":19665},{"state":[{"type":"∀ b ∉ ⋯.toFinset, f b = 0","tag":["inr","hf"],"mvarId":["_uniq",1016089],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"Finite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899088],"binderInfo":"default"}]},{"type":"∀ x ∉ ⋯.toFinset, f x = 0","tag":["inr"],"mvarId":["_uniq",1016049],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",898927],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",898928],"binderInfo":"default"},{"type":"AbsConvergent' f","name":["h"],"isProp":true,"id":["_uniq",898929],"binderInfo":"default"},{"value":"{x | f x ≠ 0}","type":"Set X","name":["E"],"isProp":false,"id":["_uniq",898983]},{"type":"Finite (↑{x | f x ≠ 0} : Type)","name":["hE"],"isProp":true,"id":["_uniq",899088],"binderInfo":"default"}]}],"start":19735},{"state":[],"start":19756},{"state":[],"start":19757},{"state":[],"start":19758},{"state":[],"start":19840},{"state":[],"start":19930},{"state":[{"type":"AbsConvergent' (f + g) ∧ Sum' (f + g) = Sum' f + Sum' g","tag":[],"mvarId":["_uniq",1019876],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1019871],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1019872],"binderInfo":"implicit"},{"type":"X → ℝ","name":["g"],"isProp":false,"id":["_uniq",1019873],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1019874],"binderInfo":"default"},{"type":"AbsConvergent' g","name":["hg"],"isProp":true,"id":["_uniq",1019875],"binderInfo":"default"}]}],"start":19994},{"state":[],"start":20002},{"state":[],"start":20003},{"state":[],"start":20085},{"state":[],"start":20160},{"state":[{"type":"AbsConvergent' (c • f) ∧ Sum' (c • f) = c * Sum' f","tag":[],"mvarId":["_uniq",1020160],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1020156],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1020157],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1020158],"binderInfo":"default"},{"type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",1020159],"binderInfo":"default"}]}],"start":20225},{"state":[],"start":20233},{"state":[],"start":20234},{"state":[],"start":20339},{"state":[],"start":20429},{"state":[{"type":"AbsConvergent' (f - g) ∧ Sum' (f - g) = Sum' f - Sum' g","tag":[],"mvarId":["_uniq",1020394],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1020389],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1020390],"binderInfo":"implicit"},{"type":"X → ℝ","name":["g"],"isProp":false,"id":["_uniq",1020391],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1020392],"binderInfo":"default"},{"type":"AbsConvergent' g","name":["hg"],"isProp":true,"id":["_uniq",1020393],"binderInfo":"default"}]}],"start":20493},{"state":[{"type":"f - g = f + -1 • g","tag":["h","e'_1","h","e'_2"],"mvarId":["_uniq",1021066],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1020389],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1020390],"binderInfo":"implicit"},{"type":"X → ℝ","name":["g"],"isProp":false,"id":["_uniq",1020391],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1020392],"binderInfo":"default"},{"type":"AbsConvergent' g","name":["hg"],"isProp":true,"id":["_uniq",1020393],"binderInfo":"default"}]},{"type":"Sum' (f - g) = Sum' (f + -1 • g)","tag":["h","e'_2","h","e'_2"],"mvarId":["_uniq",1021503],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1020389],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1020390],"binderInfo":"implicit"},{"type":"X → ℝ","name":["g"],"isProp":false,"id":["_uniq",1020391],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1020392],"binderInfo":"default"},{"type":"AbsConvergent' g","name":["hg"],"isProp":true,"id":["_uniq",1020393],"binderInfo":"default"}]},{"type":"Sum' f - Sum' g = Sum' f + Sum' (-1 • g)","tag":["h","e'_2","h","e'_3"],"mvarId":["_uniq",1021504],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1020389],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1020390],"binderInfo":"implicit"},{"type":"X → ℝ","name":["g"],"isProp":false,"id":["_uniq",1020391],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1020392],"binderInfo":"default"},{"type":"AbsConvergent' g","name":["hg"],"isProp":true,"id":["_uniq",1020393],"binderInfo":"default"}]}],"start":20535},{"state":[{"type":"Sum' (f - g) = Sum' (f + -1 • g)","tag":["h","e'_2","h","e'_2"],"mvarId":["_uniq",1021503],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1020389],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1020390],"binderInfo":"implicit"},{"type":"X → ℝ","name":["g"],"isProp":false,"id":["_uniq",1020391],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1020392],"binderInfo":"default"},{"type":"AbsConvergent' g","name":["hg"],"isProp":true,"id":["_uniq",1020393],"binderInfo":"default"}]},{"type":"Sum' f - Sum' g = Sum' f + Sum' (-1 • g)","tag":["h","e'_2","h","e'_3"],"mvarId":["_uniq",1021504],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1020389],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1020390],"binderInfo":"implicit"},{"type":"X → ℝ","name":["g"],"isProp":false,"id":["_uniq",1020391],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1020392],"binderInfo":"default"},{"type":"AbsConvergent' g","name":["hg"],"isProp":true,"id":["_uniq",1020393],"binderInfo":"default"}]}],"start":20550},{"state":[{"type":"Sum' f - Sum' g = Sum' f + Sum' (-1 • g)","tag":["h","e'_2","h","e'_3"],"mvarId":["_uniq",1021504],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1020389],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1020390],"binderInfo":"implicit"},{"type":"X → ℝ","name":["g"],"isProp":false,"id":["_uniq",1020391],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1020392],"binderInfo":"default"},{"type":"AbsConvergent' g","name":["hg"],"isProp":true,"id":["_uniq",1020393],"binderInfo":"default"}]}],"start":20572},{"state":[],"start":20602},{"state":[],"start":20603},{"state":[],"start":20694},{"state":[],"start":20770},{"state":[],"start":20896},{"state":[{"type":"(Sum' fun x => f (↑x : X)) = (Sum' fun x => f (↑x : X)) + Sum' fun x => f (↑x : X)","tag":[],"mvarId":["_uniq",1025324],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1025318],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1025319],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1025320],"binderInfo":"default"},{"type":"Set X","name":["X₁"],"isProp":false,"id":["_uniq",1025321],"binderInfo":"implicit"},{"type":"Set X","name":["X₂"],"isProp":false,"id":["_uniq",1025322],"binderInfo":"implicit"},{"type":"Disjoint X₁ X₂","name":["hdisj"],"isProp":true,"id":["_uniq",1025323],"binderInfo":"default"}]}],"start":21009},{"state":[],"start":21017},{"state":[],"start":21018},{"state":[],"start":21116},{"state":[],"start":21128},{"state":[],"start":21197},{"state":[{"type":"(Sum' fun x => f (↑x : X)) = Sum' f","tag":[],"mvarId":["_uniq",1025465],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1025462],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1025463],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1025464],"binderInfo":"default"}]}],"start":21252},{"state":[],"start":21260},{"state":[],"start":21261},{"state":[],"start":21344},{"state":[],"start":21377},{"state":[{"type":"AbsConvergent' (f ∘ φ) ∧ Sum' f = Sum' (f ∘ φ)","tag":[],"mvarId":["_uniq",1025544],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1025538],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",1025539],"binderInfo":"implicit"},{"type":"X → ℝ","name":["f"],"isProp":false,"id":["_uniq",1025540],"binderInfo":"implicit"},{"type":"AbsConvergent' f","name":["hf"],"isProp":true,"id":["_uniq",1025541],"binderInfo":"default"},{"type":"Y → X","name":["φ"],"isProp":false,"id":["_uniq",1025542],"binderInfo":"implicit"},{"type":"Bijective φ","name":["hφ"],"isProp":true,"id":["_uniq",1025543],"binderInfo":"default"}]}],"start":21440},{"state":[],"start":21448},{"state":[],"start":21449},{"state":[],"start":21485},{"state":[],"start":21566},{"state":[],"start":21604},{"state":[],"start":21710},{"state":[{"type":"(¬AbsConvergent fun n => a (↑n : ℕ)) ∧ ¬AbsConvergent fun n => a (↑n : ℕ)","tag":[],"mvarId":["_uniq",1025918],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1025915],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1025916],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1025917],"binderInfo":"default"}]}],"start":21718},{"state":[],"start":21726},{"state":[],"start":21727},{"state":[],"start":21797},{"state":[],"start":21882},{"state":[],"start":21928},{"state":[],"start":21998},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1026123],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"}]}],"start":22006},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1026123],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"}]}],"start":22079},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1026146],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026142],"binderInfo":"default"},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026145],"binderInfo":"default"}]}],"start":22136},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1026277],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026145],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"}]}],"start":22170},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1026431],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"}]}],"start":22202},{"state":[{"type":"Disjoint A_plus A_minus","tag":[],"mvarId":["_uniq",1026800],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"}]}],"start":22247},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1026802],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]}]}],"start":22317},{"state":[{"type":"A_plus ∪ A_minus = Set.univ","tag":[],"mvarId":["_uniq",1031786],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]}]}],"start":22366},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1031788],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]}]}],"start":22405},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1041610],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]}]}],"start":22451},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":[],"mvarId":["_uniq",1041827],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]}]}],"start":22499},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro"],"mvarId":["_uniq",1041945],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"}]}],"start":22599},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1042022],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"}]}],"start":22703},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1043784],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]}]}],"start":22768},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1043784],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]}]}],"start":22825},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1043784],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]}]}],"start":22892},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1043784],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]}]}],"start":22901},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1043784],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]}]}],"start":22969},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1044278],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]}]}],"start":23011},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1046121],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]}]}],"start":23069},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1046121],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]}]}],"start":23126},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1046121],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]}]}],"start":23135},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1046121],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]}]}],"start":23193},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1046121],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]}]}],"start":23225},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1046515],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]}]}],"start":23319},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1046906],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_minus_inf"],"isProp":true,"id":["_uniq",1046905]}]}],"start":23415},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1046920],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_minus_inf"],"isProp":true,"id":["_uniq",1046905]},{"value":"sorry","type":"Injective n'","name":["hn'_inj"],"isProp":true,"id":["_uniq",1046919]}]}],"start":23457},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1048402],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_minus_inf"],"isProp":true,"id":["_uniq",1046905]},{"value":"sorry","type":"Injective n'","name":["hn'_inj"],"isProp":true,"id":["_uniq",1046919]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L} : Type)","name":["h_case_I"],"isProp":true,"id":["_uniq",1048401]}]}],"start":23526},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1049881],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_minus_inf"],"isProp":true,"id":["_uniq",1046905]},{"value":"sorry","type":"Injective n'","name":["hn'_inj"],"isProp":true,"id":["_uniq",1046919]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L} : Type)","name":["h_case_I"],"isProp":true,"id":["_uniq",1048401]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) ≤ L} : Type)","name":["h_case_II"],"isProp":true,"id":["_uniq",1049880]}]}],"start":23598},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1049895],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_minus_inf"],"isProp":true,"id":["_uniq",1046905]},{"value":"sorry","type":"Injective n'","name":["hn'_inj"],"isProp":true,"id":["_uniq",1046919]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L} : Type)","name":["h_case_I"],"isProp":true,"id":["_uniq",1048401]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) ≤ L} : Type)","name":["h_case_II"],"isProp":true,"id":["_uniq",1049880]},{"value":"sorry","type":"Surjective n'","name":["hn'_surj"],"isProp":true,"id":["_uniq",1049894]}]}],"start":23642},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1050116],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_minus_inf"],"isProp":true,"id":["_uniq",1046905]},{"value":"sorry","type":"Injective n'","name":["hn'_inj"],"isProp":true,"id":["_uniq",1046919]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L} : Type)","name":["h_case_I"],"isProp":true,"id":["_uniq",1048401]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) ≤ L} : Type)","name":["h_case_II"],"isProp":true,"id":["_uniq",1049880]},{"value":"sorry","type":"Surjective n'","name":["hn'_surj"],"isProp":true,"id":["_uniq",1049894]},{"value":"sorry","type":"Tendsto (a ∘ n') atTop (nhds 0)","name":["hconv"],"isProp":true,"id":["_uniq",1050115]}]}],"start":23703},{"state":[{"type":"∃ f, Bijective f ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["intro","intro","intro","intro"],"mvarId":["_uniq",1050211],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_minus_inf"],"isProp":true,"id":["_uniq",1046905]},{"value":"sorry","type":"Injective n'","name":["hn'_inj"],"isProp":true,"id":["_uniq",1046919]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L} : Type)","name":["h_case_I"],"isProp":true,"id":["_uniq",1048401]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) ≤ L} : Type)","name":["h_case_II"],"isProp":true,"id":["_uniq",1049880]},{"value":"sorry","type":"Surjective n'","name":["hn'_surj"],"isProp":true,"id":["_uniq",1049894]},{"value":"sorry","type":"Tendsto (a ∘ n') atTop (nhds 0)","name":["hconv"],"isProp":true,"id":["_uniq",1050115]},{"value":"sorry","type":"{ m := 0, seq := fun n => if n ≥ 0 then (a ∘ n') n.toNat else 0, vanish := ⋯ }.convergesTo L","name":["hsum"],"isProp":true,"id":["_uniq",1050210]}]}],"start":23761},{"state":[{"type":"Bijective n' ∧ { m := 0, seq := fun n => if n ≥ 0 then (a ∘ n') n.toNat else 0, vanish := ⋯ }.convergesTo L","tag":["h"],"mvarId":["_uniq",1050219],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1026119],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1026120],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1026121],"binderInfo":"default"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1026122],"binderInfo":"default"},{"value":"{n | a n ≥ 0}","type":"Set ℕ","name":["A_plus"],"isProp":false,"id":["_uniq",1026204]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h1"],"isProp":true,"id":["_uniq",1026274],"binderInfo":"default"},{"value":"{n | a n < 0}","type":"Set ℕ","name":["A_minus"],"isProp":false,"id":["_uniq",1026357]},{"type":"¬AbsConvergent fun n => a (↑n : ℕ)","name":["h2"],"isProp":true,"id":["_uniq",1026428],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty)))\n  (Set.ext fun x =>\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congr\n            (congrArg Iff\n              (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∩ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n                (Set.mem_inter_iff._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n            (Set.mem_empty_iff_false._simp_1 x))\n          (iff_false (0 ≤ a x ∧ a x < 0)))\n        (Eq.trans not_and._simp_1 (Eq.trans (implies_congr (Eq.refl (0 ≤ a x)) not_lt._simp_1) imp_self._simp_1))))","type":"Disjoint A_plus A_minus","name":["hdisj"],"isProp":true,"id":["_uniq",1026801]},{"value":"Set.ext fun x =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congr\n          (congrArg Iff\n            (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | a n < 0}) (funext fun n => ge_iff_le._simp_1))\n              (Set.mem_union._simp_1 x {n | 0 ≤ a n} {n | a n < 0})))\n          (Set.mem_univ._simp_1 x))\n        (iff_true (0 ≤ a x ∨ a x < 0))))\n    (permute_convergesTo_of_divergent._proof_1 ha ha' L h1 h2 hdisj x)","type":"A_plus ∪ A_minus = Set.univ","name":["hunion"],"isProp":true,"id":["_uniq",1031787]},{"value":"sorry","type":"Infinite (↑A_plus : Type)","name":["hA_plus_inf"],"isProp":true,"id":["_uniq",1041609]},{"value":"sorry","type":"Infinite (↑A_minus : Type)","name":["hA_minus_inf"],"isProp":true,"id":["_uniq",1041826]},{"type":"ℕ → (↑A_plus : Type)","name":["a_plus"],"isProp":false,"id":["_uniq",1041920],"binderInfo":"default"},{"type":"Bijective a_plus","name":["ha_plus_bij"],"isProp":true,"id":["_uniq",1041943],"binderInfo":"default"},{"type":"StrictMono a_plus","name":["ha_plus_mono"],"isProp":true,"id":["_uniq",1041944],"binderInfo":"default"},{"type":"ℕ → (↑A_minus : Type)","name":["a_minus"],"isProp":false,"id":["_uniq",1042001],"binderInfo":"default"},{"type":"Bijective a_minus","name":["ha_minus_bij"],"isProp":true,"id":["_uniq",1042020],"binderInfo":"default"},{"type":"StrictMono a_minus","name":["ha_minus_mono"],"isProp":true,"id":["_uniq",1042021],"binderInfo":"default"},{"value":"fun j n' =>\n  if (↑(∑ i, n' (↑i : ℕ) ⋯) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}\n  else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ) ⋯}","type":"(n : ℕ) → ((m : ℕ) → m < n → ℕ) → ℕ","name":["F"],"isProp":false,"id":["_uniq",1043783]},{"value":"fun t => Nat.strongRec F t","type":"ℕ → ℕ","name":["n'"],"isProp":false,"id":["_uniq",1044277]},{"value":"fun j => Nat.strongRec.eq_def F j","type":"∀ (j : ℕ),\n  n' j =\n    if (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L then Nat.min {n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}\n    else Nat.min {n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)}","name":["hn'"],"isProp":true,"id":["_uniq",1046120]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_plus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_plus_inf"],"isProp":true,"id":["_uniq",1046514]},{"value":"fun j => sorry","type":"∀ (j : ℕ), Infinite (↑{n | n ∈ A_minus ∧ ∀ (i : Fin j), n ≠ n' (↑i : ℕ)} : Type)","name":["hn'_minus_inf"],"isProp":true,"id":["_uniq",1046905]},{"value":"sorry","type":"Injective n'","name":["hn'_inj"],"isProp":true,"id":["_uniq",1046919]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) > L} : Type)","name":["h_case_I"],"isProp":true,"id":["_uniq",1048401]},{"value":"sorry","type":"Infinite (↑{j | (↑(∑ i, n' (↑i : ℕ)) : ℝ) ≤ L} : Type)","name":["h_case_II"],"isProp":true,"id":["_uniq",1049880]},{"value":"sorry","type":"Surjective n'","name":["hn'_surj"],"isProp":true,"id":["_uniq",1049894]},{"value":"sorry","type":"Tendsto (a ∘ n') atTop (nhds 0)","name":["hconv"],"isProp":true,"id":["_uniq",1050115]},{"value":"sorry","type":"{ m := 0, seq := fun n => if n ≥ 0 then (a ∘ n') n.toNat else 0, vanish := ⋯ }.convergesTo L","name":["hsum"],"isProp":true,"id":["_uniq",1050210]}]}],"start":23770},{"state":[],"start":23831},{"state":[],"start":23832},{"state":[],"start":23854},{"state":[],"start":23936},{"state":[],"start":23975},{"state":[{"type":"∃ f,\n  Bijective f ∧\n    Tendsto\n      (fun N => (↑({ m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.partial N) : EReal))\n      atTop (nhds ⊤)","tag":[],"mvarId":["_uniq",1050963],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1050960],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1050961],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1050962],"binderInfo":"default"}]}],"start":24095},{"state":[],"start":24103},{"state":[],"start":24104},{"state":[],"start":24187},{"state":[],"start":24226},{"state":[{"type":"∃ f,\n  Bijective f ∧\n    Tendsto\n      (fun N => (↑({ m := 0, seq := fun n => if n ≥ 0 then (a ∘ f) n.toNat else 0, vanish := ⋯ }.partial N) : EReal))\n      atTop (nhds ⊥)","tag":[],"mvarId":["_uniq",1051558],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",1051555],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["ha"],"isProp":true,"id":["_uniq",1051556],"binderInfo":"default"},{"type":"¬{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha'"],"isProp":true,"id":["_uniq",1051557],"binderInfo":"default"}]}],"start":24346},{"state":[],"start":24354},{"state":[],"start":24355},{"state":[],"start":24368},{"state":[],"start":24368}]
