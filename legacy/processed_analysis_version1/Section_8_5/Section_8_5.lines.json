[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":51},{"state":[],"start":55},{"state":[],"start":95},{"state":[],"start":96},{"state":[],"start":192},{"state":[],"start":280},{"state":[],"start":375},{"state":[],"start":468},{"state":[],"start":478},{"state":[],"start":479},{"state":[],"start":527},{"state":[],"start":528},{"state":[],"start":607},{"state":[],"start":627},{"state":[],"start":643},{"state":[],"start":644},{"state":[],"start":647},{"state":[],"start":648},{"state":[],"start":667},{"state":[],"start":668},{"state":[],"start":748},{"state":[],"start":749},{"state":[],"start":812},{"state":[],"start":916},{"state":[],"start":1024},{"state":[],"start":1118},{"state":[],"start":1119},{"state":[],"start":1155},{"state":[],"start":1183},{"state":[],"start":1239},{"state":[],"start":1316},{"state":[],"start":1318},{"state":[],"start":1338},{"state":[],"start":1357},{"state":[],"start":1384},{"state":[],"start":1405},{"state":[],"start":1407},{"state":[],"start":1408},{"state":[],"start":1469},{"state":[],"start":1531},{"state":[],"start":1532},{"state":[],"start":1611},{"state":[],"start":1682},{"state":[],"start":1761},{"state":[],"start":1818},{"state":[],"start":1819},{"state":[],"start":1837},{"state":[],"start":1896},{"state":[],"start":1937},{"state":[],"start":1939},{"state":[],"start":1961},{"state":[],"start":1994},{"state":[],"start":1996},{"state":[],"start":1997},{"state":[],"start":2018},{"state":[],"start":2059},{"state":[],"start":2100},{"state":[],"start":2141},{"state":[],"start":2184},{"state":[],"start":2185},{"state":[],"start":2186},{"state":[],"start":2279},{"state":[{"type":"IsTotal (↑A : Type)","tag":[],"mvarId":["_uniq",3667],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",3544],"binderInfo":"implicit"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",3545],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",3546],"binderInfo":"default"}]}],"start":2298},{"state":[],"start":2306},{"state":[],"start":2310},{"state":[],"start":2311},{"state":[{"type":"IsTotal (↑A : Type)","tag":[],"mvarId":["_uniq",4171],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",4167],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",4168],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",4169],"binderInfo":"implicit"},{"type":"IsTotal X","name":["hA"],"isProp":true,"id":["_uniq",4170],"binderInfo":"default"}]}],"start":2406},{"state":[{"type":"⟨x, hx⟩ ≤ ⟨y, hy⟩ ∨ ⟨y, hy⟩ ≤ ⟨x, hx⟩","tag":[],"mvarId":["_uniq",4363],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",4167],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",4168],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",4169],"binderInfo":"implicit"},{"type":"IsTotal X","name":["hA"],"isProp":true,"id":["_uniq",4170],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",4206],"binderInfo":"default"},{"type":"x ∈ A","name":["hx"],"isProp":true,"id":["_uniq",4207],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",4305],"binderInfo":"default"},{"type":"y ∈ A","name":["hy"],"isProp":true,"id":["_uniq",4306],"binderInfo":"default"}]}],"start":2442},{"state":[],"start":2472},{"state":[],"start":2473},{"state":[{"type":"IsTotal (↑B : Type)","tag":[],"mvarId":["_uniq",7331],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7325],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",7326],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",7327],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",7328],"binderInfo":"implicit"},{"type":"IsTotal (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",7329],"binderInfo":"default"},{"type":"B ⊆ A","name":["hAB"],"isProp":true,"id":["_uniq",7330],"binderInfo":"default"}]}],"start":2584},{"state":[{"type":"⟨x, hx⟩ ≤ ⟨y, hy⟩ ∨ ⟨y, hy⟩ ≤ ⟨x, hx⟩","tag":[],"mvarId":["_uniq",7509],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7325],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",7326],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",7327],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",7328],"binderInfo":"implicit"},{"type":"IsTotal (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",7329],"binderInfo":"default"},{"type":"B ⊆ A","name":["hAB"],"isProp":true,"id":["_uniq",7330],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",7366],"binderInfo":"default"},{"type":"x ∈ B","name":["hx"],"isProp":true,"id":["_uniq",7367],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",7451],"binderInfo":"default"},{"type":"y ∈ B","name":["hy"],"isProp":true,"id":["_uniq",7452],"binderInfo":"default"}]}],"start":2620},{"state":[],"start":2682},{"state":[],"start":2683},{"state":[],"start":2753},{"state":[],"start":2794},{"state":[],"start":2795},{"state":[],"start":2895},{"state":[],"start":2947},{"state":[],"start":3019},{"state":[],"start":3020},{"state":[],"start":3072},{"state":[],"start":3144},{"state":[],"start":3145},{"state":[],"start":3167},{"state":[],"start":3229},{"state":[],"start":3293},{"state":[],"start":3359},{"state":[],"start":3465},{"state":[],"start":3581},{"state":[],"start":3582},{"state":[],"start":3603},{"state":[],"start":3639},{"state":[],"start":3680},{"state":[],"start":3735},{"state":[],"start":3736},{"state":[],"start":3836},{"state":[],"start":3889},{"state":[{"type":"WellFoundedLT X ↔ ∀ (A : Set X), A.Nonempty → ∃ x, IsMin x","tag":[],"mvarId":["_uniq",31653],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",31651],"binderInfo":"default"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",31652],"binderInfo":"instImplicit"}]}],"start":3962},{"state":[{"type":"(IsWellFounded X fun x1 x2 => x1 < x2) ↔ ∀ (A : Set X), A.Nonempty → ∃ x, ∀ ⦃b : (↑A : Type)⦄, b ≤ x → x ≤ b","tag":[],"mvarId":["_uniq",31657],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",31651],"binderInfo":"default"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",31652],"binderInfo":"instImplicit"}]}],"start":3991},{"state":[{"type":"(∀ (s : Set X), s.Nonempty → ∃ m ∈ s, ∀ x ∈ s, ¬x < m) ↔\n  ∀ (A : Set X), A.Nonempty → ∃ x, ∀ ⦃b : (↑A : Type)⦄, b ≤ x → x ≤ b","tag":[],"mvarId":["_uniq",31708],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",31651],"binderInfo":"default"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",31652],"binderInfo":"instImplicit"}]}],"start":4053},{"state":[{"type":"(∃ m ∈ A, ∀ x ∈ A, ¬x < m) → ∃ x, ∀ ⦃b : (↑A : Type)⦄, b ≤ x → x ≤ b","tag":["h","h","mp"],"mvarId":["_uniq",31785],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",31651],"binderInfo":"default"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",31652],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",31758],"binderInfo":"default"},{"type":"A.Nonempty","name":["hA"],"isProp":true,"id":["_uniq",31776],"binderInfo":"default"}]},{"type":"(∃ x, ∀ ⦃b : (↑A : Type)⦄, b ≤ x → x ≤ b) → ∃ m ∈ A, ∀ x ∈ A, ¬x < m","tag":["h","h","mpr"],"mvarId":["_uniq",31786],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",31651],"binderInfo":"default"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",31652],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",31758],"binderInfo":"default"},{"type":"A.Nonempty","name":["hA"],"isProp":true,"id":["_uniq",31776],"binderInfo":"default"}]}],"start":4083},{"state":[{"type":"⟨x, hxA⟩ ≤ ⟨y, hy⟩","tag":["h"],"mvarId":["_uniq",32180],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",31651],"binderInfo":"default"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",31652],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",31758],"binderInfo":"default"},{"type":"A.Nonempty","name":["hA"],"isProp":true,"id":["_uniq",31776],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",31856],"binderInfo":"default"},{"type":"x ∈ A","name":["hxA"],"isProp":true,"id":["_uniq",31857],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",32112],"binderInfo":"default"},{"type":"y ∈ A","name":["hy"],"isProp":true,"id":["_uniq",32113],"binderInfo":"default"},{"type":"⟨y, hy⟩ ≤ ⟨x, hxA⟩","name":["this"],"isProp":true,"id":["_uniq",32172],"binderInfo":"default"},{"type":"¬y < x","name":["h"],"isProp":true,"id":["_uniq",32177],"binderInfo":"default"}]}],"start":4176},{"state":[{"type":"(∃ x, ∀ ⦃b : (↑A : Type)⦄, b ≤ x → x ≤ b) → ∃ m ∈ A, ∀ x ∈ A, ¬x < m","tag":["h","h","mpr"],"mvarId":["_uniq",31786],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",31651],"binderInfo":"default"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",31652],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",31758],"binderInfo":"default"},{"type":"A.Nonempty","name":["hA"],"isProp":true,"id":["_uniq",31776],"binderInfo":"default"}]}],"start":4197},{"state":[{"type":"¬y < x","tag":["h","h","mpr"],"mvarId":["_uniq",37611],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",31651],"binderInfo":"default"},{"type":"LinearOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",31652],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",31758],"binderInfo":"default"},{"type":"A.Nonempty","name":["hA"],"isProp":true,"id":["_uniq",31776],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",37360],"binderInfo":"default"},{"type":"x ∈ A","name":["hx"],"isProp":true,"id":["_uniq",37361],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",37581],"binderInfo":"default"},{"type":"y ∈ A","name":["hy"],"isProp":true,"id":["_uniq",37584],"binderInfo":"default"},{"type":"⟨y, hy⟩ ≤ ⟨x, hx⟩ → ⟨x, hx⟩ ≤ ⟨y, hy⟩","name":["h"],"isProp":true,"id":["_uniq",37607],"binderInfo":"default"}]}],"start":4303},{"state":[],"start":4347},{"state":[],"start":4348},{"state":[],"start":4418},{"state":[],"start":4514},{"state":[],"start":4515},{"state":[],"start":4536},{"state":[{"type":"WellFoundedLT ℕ","tag":[],"mvarId":["_uniq",44018],"isProp":true,"context":[]}],"start":4570},{"state":[{"type":"∀ (A : Set ℕ), A.Nonempty → ∃ x, IsMin x","tag":[],"mvarId":["_uniq",44044],"isProp":true,"context":[]}],"start":4595},{"state":[{"type":"IsMin ⟨Nat.min A, ⋯⟩","tag":["h"],"mvarId":["_uniq",44061],"isProp":true,"context":[{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",44051],"binderInfo":"default"},{"type":"A.Nonempty","name":["hA"],"isProp":true,"id":["_uniq",44054],"binderInfo":"default"}]}],"start":4644},{"state":[],"start":4681},{"state":[],"start":4682},{"state":[],"start":4704},{"state":[],"start":4747},{"state":[],"start":4790},{"state":[],"start":4833},{"state":[],"start":4834},{"state":[],"start":4856},{"state":[],"start":4959},{"state":[],"start":4960},{"state":[],"start":5063},{"state":[],"start":5064},{"state":[],"start":5086},{"state":[],"start":5183},{"state":[],"start":5184},{"state":[],"start":5276},{"state":[],"start":5277},{"state":[{"type":"WellFoundedLT (↑B : Type)","tag":[],"mvarId":["_uniq",63127],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",63120],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",63121],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",63122],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",63123],"binderInfo":"implicit"},{"type":"IsTotal (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",63124],"binderInfo":"default"},{"type":"WellFoundedLT (↑A : Type)","name":["hwell"],"isProp":true,"id":["_uniq",63125],"binderInfo":"instImplicit"},{"type":"B ⊆ A","name":["hAB"],"isProp":true,"id":["_uniq",63126],"binderInfo":"default"}]}],"start":5425},{"state":[{"type":"WellFoundedLT (↑B : Type)","tag":[],"mvarId":["_uniq",63484],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",63120],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",63121],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",63122],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",63123],"binderInfo":"implicit"},{"type":"IsTotal (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",63124],"binderInfo":"default"},{"type":"WellFoundedLT (↑A : Type)","name":["hwell"],"isProp":true,"id":["_uniq",63125],"binderInfo":"instImplicit"},{"type":"B ⊆ A","name":["hAB"],"isProp":true,"id":["_uniq",63126],"binderInfo":"default"},{"value":"LinearOrder.mk hA","type":"LinearOrder (↑A : Type)","name":["hAlin"],"isProp":false,"id":["_uniq",63483]}]}],"start":5474},{"state":[{"type":"WellFoundedLT (↑B : Type)","tag":[],"mvarId":["_uniq",63940],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",63120],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",63121],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",63122],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",63123],"binderInfo":"implicit"},{"type":"IsTotal (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",63124],"binderInfo":"default"},{"type":"WellFoundedLT (↑A : Type)","name":["hwell"],"isProp":true,"id":["_uniq",63125],"binderInfo":"instImplicit"},{"type":"B ⊆ A","name":["hAB"],"isProp":true,"id":["_uniq",63126],"binderInfo":"default"},{"value":"LinearOrder.mk hA","type":"LinearOrder (↑A : Type)","name":["hAlin"],"isProp":false,"id":["_uniq",63483]},{"value":"LinearOrder.mk ⋯","type":"LinearOrder (↑B : Type)","name":["hBlin"],"isProp":false,"id":["_uniq",63939]}]}],"start":5536},{"state":[{"type":"∃ x, IsMin x","tag":[],"mvarId":["_uniq",64132],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",63120],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",63121],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",63122],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",63123],"binderInfo":"implicit"},{"type":"IsTotal (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",63124],"binderInfo":"default"},{"type":"B ⊆ A","name":["hAB"],"isProp":true,"id":["_uniq",63126],"binderInfo":"default"},{"value":"LinearOrder.mk hA","type":"LinearOrder (↑A : Type)","name":["hAlin"],"isProp":false,"id":["_uniq",63483]},{"type":"∀ (A_1 : Set (↑A : Type)), A_1.Nonempty → ∃ x, IsMin x","name":["hwell"],"isProp":true,"id":["_uniq",64099],"binderInfo":"default"},{"value":"LinearOrder.mk ⋯","type":"LinearOrder (↑B : Type)","name":["hBlin"],"isProp":false,"id":["_uniq",64102]},{"type":"Set (↑B : Type)","name":["C"],"isProp":false,"id":["_uniq",64128],"binderInfo":"default"},{"type":"C.Nonempty","name":["hC"],"isProp":true,"id":["_uniq",64131],"binderInfo":"default"}]}],"start":5572},{"state":[{"type":"∃ x, IsMin x","tag":[],"mvarId":["_uniq",64315],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",63120],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",63121],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",63122],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",63123],"binderInfo":"implicit"},{"type":"IsTotal (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",63124],"binderInfo":"default"},{"type":"B ⊆ A","name":["hAB"],"isProp":true,"id":["_uniq",63126],"binderInfo":"default"},{"value":"LinearOrder.mk hA","type":"LinearOrder (↑A : Type)","name":["hAlin"],"isProp":false,"id":["_uniq",63483]},{"type":"∀ (A_1 : Set (↑A : Type)), A_1.Nonempty → ∃ x, IsMin x","name":["hwell"],"isProp":true,"id":["_uniq",64099],"binderInfo":"default"},{"value":"LinearOrder.mk ⋯","type":"LinearOrder (↑B : Type)","name":["hBlin"],"isProp":false,"id":["_uniq",64102]},{"type":"Set (↑B : Type)","name":["C"],"isProp":false,"id":["_uniq",64128],"binderInfo":"default"},{"type":"C.Nonempty","name":["hC"],"isProp":true,"id":["_uniq",64131],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",64302],"binderInfo":"default"},{"type":"x ∈ A","name":["hx"],"isProp":true,"id":["_uniq",64303],"binderInfo":"default"},{"type":"⟨x, hx⟩ ∈ (⇑(B.embeddingOfSubset A hAB) : (↑B : Type) → (↑A : Type)) '' C","name":["hx'"],"isProp":true,"id":["_uniq",64304],"binderInfo":"default"},{"type":"IsMin ⟨⟨x, hx⟩, hx'⟩","name":["hmin"],"isProp":true,"id":["_uniq",64305],"binderInfo":"default"}]}],"start":5675},{"state":[{"type":"IsMin ⟨⟨y, hy⟩, hyC⟩","tag":["h"],"mvarId":["_uniq",182828],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",63120],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",63121],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",63122],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",63123],"binderInfo":"implicit"},{"type":"IsTotal (↑A : Type)","name":["hA"],"isProp":true,"id":["_uniq",63124],"binderInfo":"default"},{"type":"B ⊆ A","name":["hAB"],"isProp":true,"id":["_uniq",63126],"binderInfo":"default"},{"value":"LinearOrder.mk hA","type":"LinearOrder (↑A : Type)","name":["hAlin"],"isProp":false,"id":["_uniq",63483]},{"type":"∀ (A_1 : Set (↑A : Type)), A_1.Nonempty → ∃ x, IsMin x","name":["hwell"],"isProp":true,"id":["_uniq",64099],"binderInfo":"default"},{"value":"LinearOrder.mk ⋯","type":"LinearOrder (↑B : Type)","name":["hBlin"],"isProp":false,"id":["_uniq",64102]},{"type":"Set (↑B : Type)","name":["C"],"isProp":false,"id":["_uniq",64128],"binderInfo":"default"},{"type":"C.Nonempty","name":["hC"],"isProp":true,"id":["_uniq",64131],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",64302],"binderInfo":"default"},{"type":"x ∈ A","name":["hx"],"isProp":true,"id":["_uniq",64303],"binderInfo":"default"},{"type":"⟨x, hx⟩ ∈ (⇑(B.embeddingOfSubset A hAB) : (↑B : Type) → (↑A : Type)) '' C","name":["hx'"],"isProp":true,"id":["_uniq",64304],"binderInfo":"default"},{"type":"IsMin ⟨⟨x, hx⟩, hx'⟩","name":["hmin"],"isProp":true,"id":["_uniq",64305],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",182800],"binderInfo":"default"},{"type":"y ∈ B","name":["hy"],"isProp":true,"id":["_uniq",182808],"binderInfo":"default"},{"type":"⟨y, hy⟩ ∈ C","name":["hyC"],"isProp":true,"id":["_uniq",182817],"binderInfo":"default"},{"type":"(B.embeddingOfSubset A hAB) ⟨y, hy⟩ = ⟨x, hx⟩","name":["this"],"isProp":true,"id":["_uniq",182821],"binderInfo":"default"}]}],"start":5741},{"state":[],"start":5790},{"state":[],"start":5791},{"state":[],"start":5835},{"state":[],"start":5932},{"state":[{"type":"∀ (n : X), P n","tag":[],"mvarId":["_uniq",469505],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",469500],"binderInfo":"implicit"},{"type":"LinearOrder X","name":["inst✝¹"],"isProp":false,"id":["_uniq",469501],"binderInfo":"instImplicit"},{"type":"WellFoundedLT X","name":["inst✝"],"isProp":true,"id":["_uniq",469502],"binderInfo":"instImplicit"},{"type":"X → Prop","name":["P"],"isProp":false,"id":["_uniq",469503],"binderInfo":"implicit"},{"type":"∀ (n : X), (∀ m < n, P m) → P n","name":["h"],"isProp":true,"id":["_uniq",469504],"binderInfo":"default"}]}],"start":5990},{"state":[],"start":5998},{"state":[],"start":5999},{"state":[],"start":6063},{"state":[],"start":6135},{"state":[],"start":6158},{"state":[],"start":6159},{"state":[],"start":6206},{"state":[],"start":6275},{"state":[],"start":6357},{"state":[],"start":6358},{"state":[],"start":6436},{"state":[],"start":6467},{"state":[],"start":6468},{"state":[],"start":6543},{"state":[],"start":6603},{"state":[],"start":6604},{"state":[],"start":6680},{"state":[{"type":"IsStrictUpperBound A x ↔ x ∈ upperBounds A \\ A","tag":[],"mvarId":["_uniq",473708],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",473704],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",473705],"binderInfo":"instImplicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",473706],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",473707],"binderInfo":"default"}]}],"start":6739},{"state":[],"start":6785},{"state":[],"start":6786},{"state":[],"start":6843},{"state":[],"start":6844},{"state":[],"start":6910},{"state":[],"start":6911},{"state":[],"start":6974},{"state":[],"start":6975},{"state":[],"start":7060},{"state":[{"type":"(∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ↔ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","tag":[],"mvarId":["_uniq",477062],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",477057],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",477058],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",477059],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",477060],"binderInfo":"default"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",477061],"binderInfo":"default"}]}],"start":7260},{"state":[{"type":"(∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) → x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","tag":["mp"],"mvarId":["_uniq",477069],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",477057],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",477058],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",477059],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",477060],"binderInfo":"default"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",477061],"binderInfo":"default"}]},{"type":"(x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x) → ∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩","tag":["mpr"],"mvarId":["_uniq",477070],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",477057],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",477058],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",477059],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",477060],"binderInfo":"default"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",477061],"binderInfo":"default"}]}],"start":7274},{"state":[{"type":"∀ x ∈ Y, x₀ ≤ x","tag":["mp","intro"],"mvarId":["_uniq",494714],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",477057],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",477058],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",477059],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",477060],"binderInfo":"default"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",477061],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["hx₀"],"isProp":true,"id":["_uniq",477095],"binderInfo":"default"},{"type":"∀ a ∈ Y, a ≤ x₀ → x₀ ≤ a","name":["hmin"],"isProp":true,"id":["_uniq",494708],"binderInfo":"default"}]}],"start":7331},{"state":[{"type":"(x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x) → ∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩","tag":["mpr"],"mvarId":["_uniq",477070],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",477057],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",477058],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",477059],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",477060],"binderInfo":"default"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",477061],"binderInfo":"default"}]}],"start":7410},{"state":[],"start":7450},{"state":[],"start":7451},{"state":[{"type":"(∃ x₀, IsMin x₀) ↔ ∃ x₀ ∈ Y, ∀ x ∈ Y, x₀ ≤ x","tag":[],"mvarId":["_uniq",545982],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",545978],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",545979],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",545980],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",545981],"binderInfo":"default"}]}],"start":7622},{"state":[{"type":"(∃ x₀, IsMin x₀) → ∃ x₀ ∈ Y, ∀ x ∈ Y, x₀ ≤ x","tag":["mp"],"mvarId":["_uniq",545989],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",545978],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",545979],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",545980],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",545981],"binderInfo":"default"}]},{"type":"(∃ x₀ ∈ Y, ∀ x ∈ Y, x₀ ≤ x) → ∃ x₀, IsMin x₀","tag":["mpr"],"mvarId":["_uniq",545990],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",545978],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",545979],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",545980],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",545981],"binderInfo":"default"}]}],"start":7636},{"state":[{"type":"∃ x₀ ∈ Y, ∀ x ∈ Y, x₀ ≤ x","tag":["mp"],"mvarId":["_uniq",546166],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",545978],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",545979],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",545980],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",545981],"binderInfo":"default"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",546054],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["hx₀"],"isProp":true,"id":["_uniq",546055],"binderInfo":"default"},{"type":"IsMin ⟨x₀, hx₀⟩","name":["hmin"],"isProp":true,"id":["_uniq",546056],"binderInfo":"default"}]}],"start":7680},{"state":[{"type":"∃ x₀ ∈ Y, ∀ x ∈ Y, x₀ ≤ x","tag":["mp"],"mvarId":["_uniq",546327],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",545978],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",545979],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",545980],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",545981],"binderInfo":"default"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",546054],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["hx₀"],"isProp":true,"id":["_uniq",546055],"binderInfo":"default"},{"type":"IsMin ⟨x₀, hx₀⟩","name":["hmin"],"isProp":true,"id":["_uniq",546056],"binderInfo":"default"},{"value":"Exists.intro hx₀ hmin","type":"∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩","name":["this"],"isProp":true,"id":["_uniq",546326]}]}],"start":7760},{"state":[{"type":"(∃ x₀ ∈ Y, ∀ x ∈ Y, x₀ ≤ x) → ∃ x₀, IsMin x₀","tag":["mpr"],"mvarId":["_uniq",545990],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",545978],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",545979],"binderInfo":"instImplicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",545980],"binderInfo":"implicit"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",545981],"binderInfo":"default"}]}],"start":7810},{"state":[],"start":7937},{"state":[],"start":7938},{"state":[],"start":7961},{"state":[],"start":8178},{"state":[],"start":8179},{"state":[],"start":8198},{"state":[{"type":"∃ Y,\n  IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":[],"mvarId":["_uniq",548713],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"}]}],"start":8421},{"state":[{"type":"∃ Y,\n  IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":[],"mvarId":["_uniq",548713],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"}]}],"start":8504},{"state":[{"type":"∃ Y,\n  IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":[],"mvarId":["_uniq",548713],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"}]}],"start":8505},{"state":[{"type":"∃ Y,\n  IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":[],"mvarId":["_uniq",548713],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"}]}],"start":8622},{"state":[{"type":"∃ Y,\n  IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":[],"mvarId":["_uniq",548713],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"}]}],"start":8738},{"state":[{"type":"∃ Y,\n  IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":[],"mvarId":["_uniq",548713],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"}]}],"start":8778},{"state":[{"type":"∃ Y,\n  IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":[],"mvarId":["_uniq",549300],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]}]}],"start":8881},{"state":[{"type":"∃ Y,\n  IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":[],"mvarId":["_uniq",549349],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∃ Y ∈ Ω₀, ¬∃ x, IsStrictUpperBound Y x","name":["this"],"isProp":true,"id":["_uniq",549348],"binderInfo":"default"}]},{"type":"∃ Y ∈ Ω₀, ¬∃ x, IsStrictUpperBound Y x","tag":["this"],"mvarId":["_uniq",549346],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]}]}],"start":8944},{"state":[{"type":"WellFoundedLT (↑Y : Type) ∧ (∃ (hx₀ : x₀ ∈ Y), IsMin ⟨x₀, hx₀⟩) ∧ ¬∃ x, IsStrictUpperBound Y x","tag":["right"],"mvarId":["_uniq",549619],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∃ Y ∈ Ω₀, ¬∃ x, IsStrictUpperBound Y x","name":["this"],"isProp":true,"id":["_uniq",549348],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",549427],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",549428],"binderInfo":"default"},{"type":"WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hY'"],"isProp":true,"id":["_uniq",549429],"binderInfo":"default"},{"type":"¬∃ x, IsStrictUpperBound Y x","name":["hstrict"],"isProp":true,"id":["_uniq",549430],"binderInfo":"default"}]}],"start":9007},{"state":[{"type":"∃ Y ∈ Ω₀, ¬∃ x, IsStrictUpperBound Y x","tag":["this"],"mvarId":["_uniq",549346],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]}]}],"start":9052},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",551105],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"}]}],"start":9068},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",551234],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]}]}],"start":9128},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",551529],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]}]}],"start":9213},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",551529],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]}]}],"start":9214},{"state":[{"type":"{x₀} ∈ Ω₀","tag":[],"mvarId":["_uniq",551759],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]}]}],"start":9249},{"state":[{"type":"{x₀} ∈ Ω₀","tag":[],"mvarId":["_uniq",552027],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"of_eq_true\n  (Eq.trans\n    (forall_congr fun x =>\n      Eq.trans\n        (forall_congr fun y =>\n          Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n        (implies_true (↑{x₀} : Type)))\n    (implies_true (↑{x₀} : Type)))","type":"IsTotal (↑{x₀} : Type)","name":["htotal"],"isProp":true,"id":["_uniq",552026]}]}],"start":9312},{"state":[{"type":"{x₀} ∈ Ω₀","tag":[],"mvarId":["_uniq",552854],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"of_eq_true\n  (Eq.trans\n    (forall_congr fun x =>\n      Eq.trans\n        (forall_congr fun y =>\n          Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n        (implies_true (↑{x₀} : Type)))\n    (implies_true (↑{x₀} : Type)))","type":"IsTotal (↑{x₀} : Type)","name":["htotal"],"isProp":true,"id":["_uniq",552026]},{"value":"LinearOrder.mk htotal","type":"LinearOrder (↑{x₀} : Type)","name":["_lin"],"isProp":false,"id":["_uniq",552853]}]}],"start":9380},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",551761],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]}]}],"start":9435},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",557232],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]}]}],"start":9470},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",557232],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]}]}],"start":9471},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",557232],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]}]}],"start":9580},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",557232],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]}]}],"start":9690},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",557232],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]}]}],"start":9714},{"state":[{"type":"{y | y ∈ Y ∧ y < x} ∈ Ω₀","tag":[],"mvarId":["_uniq",557579],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",557237],"binderInfo":"implicit"},{"type":"Y ∈ Ω₀","name":["hY"],"isProp":true,"id":["_uniq",557317],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",557319],"binderInfo":"implicit"},{"type":"x ∈ Y \\ {x₀}","name":["hxy"],"isProp":true,"id":["_uniq",557466],"binderInfo":"default"}]}],"start":9819},{"state":[{"type":"WellFoundedLT { x_1 // x_1 ∈ Y ∧ x_1 < x } ∧ x₀ < x","tag":[],"mvarId":["_uniq",645120],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",557237],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",557319],"binderInfo":"implicit"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",645105],"binderInfo":"default"},{"type":"x ∈ Y ∧ ¬x = x₀","name":["hxy"],"isProp":true,"id":["_uniq",645106],"binderInfo":"default"},{"type":"(∀ a ∈ Y, ∀ a_1 ∈ Y, a ≤ a_1 ∨ a_1 ≤ a) ∧ WellFoundedLT (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",645107],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["h✝"],"isProp":true,"id":["_uniq",645108],"binderInfo":"default"},{"type":"∀ x ∈ Y, x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",645109],"binderInfo":"default"}]}],"start":9893},{"state":[{"type":"WellFoundedLT { x_1 // x_1 ∈ Y ∧ x_1 < x }","tag":["refine_1"],"mvarId":["_uniq",645123],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",557237],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",557319],"binderInfo":"implicit"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",645105],"binderInfo":"default"},{"type":"x ∈ Y ∧ ¬x = x₀","name":["hxy"],"isProp":true,"id":["_uniq",645106],"binderInfo":"default"},{"type":"(∀ a ∈ Y, ∀ a_1 ∈ Y, a ≤ a_1 ∨ a_1 ≤ a) ∧ WellFoundedLT (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",645107],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["h✝"],"isProp":true,"id":["_uniq",645108],"binderInfo":"default"},{"type":"∀ x ∈ Y, x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",645109],"binderInfo":"default"}]},{"type":"x₀ < x","tag":["refine_2"],"mvarId":["_uniq",645124],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",557237],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",557319],"binderInfo":"implicit"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",645105],"binderInfo":"default"},{"type":"x ∈ Y ∧ ¬x = x₀","name":["hxy"],"isProp":true,"id":["_uniq",645106],"binderInfo":"default"},{"type":"(∀ a ∈ Y, ∀ a_1 ∈ Y, a ≤ a_1 ∨ a_1 ≤ a) ∧ WellFoundedLT (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",645107],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["h✝"],"isProp":true,"id":["_uniq",645108],"binderInfo":"default"},{"type":"∀ x ∈ Y, x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",645109],"binderInfo":"default"}]}],"start":9908},{"state":[{"type":"IsTotal (↑Y : Type)","tag":["refine_1","convert_1"],"mvarId":["_uniq",645195],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",557237],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",557319],"binderInfo":"implicit"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",645105],"binderInfo":"default"},{"type":"x ∈ Y ∧ ¬x = x₀","name":["hxy"],"isProp":true,"id":["_uniq",645106],"binderInfo":"default"},{"type":"(∀ a ∈ Y, ∀ a_1 ∈ Y, a ≤ a_1 ∨ a_1 ≤ a) ∧ WellFoundedLT (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",645107],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["h✝"],"isProp":true,"id":["_uniq",645108],"binderInfo":"default"},{"type":"∀ x ∈ Y, x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",645109],"binderInfo":"default"}]},{"type":"{y | y ∈ Y ∧ y < x} ⊆ Y","tag":["refine_1","convert_2"],"mvarId":["_uniq",645223],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",557237],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",557319],"binderInfo":"implicit"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",645105],"binderInfo":"default"},{"type":"x ∈ Y ∧ ¬x = x₀","name":["hxy"],"isProp":true,"id":["_uniq",645106],"binderInfo":"default"},{"type":"(∀ a ∈ Y, ∀ a_1 ∈ Y, a ≤ a_1 ∨ a_1 ≤ a) ∧ WellFoundedLT (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",645107],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["h✝"],"isProp":true,"id":["_uniq",645108],"binderInfo":"default"},{"type":"∀ x ∈ Y, x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",645109],"binderInfo":"default"}]}],"start":9988},{"state":[{"type":"{y | y ∈ Y ∧ y < x} ⊆ Y","tag":["refine_1","convert_2"],"mvarId":["_uniq",645223],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",557237],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",557319],"binderInfo":"implicit"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",645105],"binderInfo":"default"},{"type":"x ∈ Y ∧ ¬x = x₀","name":["hxy"],"isProp":true,"id":["_uniq",645106],"binderInfo":"default"},{"type":"(∀ a ∈ Y, ∀ a_1 ∈ Y, a ≤ a_1 ∨ a_1 ≤ a) ∧ WellFoundedLT (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",645107],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["h✝"],"isProp":true,"id":["_uniq",645108],"binderInfo":"default"},{"type":"∀ x ∈ Y, x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",645109],"binderInfo":"default"}]}],"start":10056},{"state":[{"type":"x₀ < x","tag":["refine_2"],"mvarId":["_uniq",645124],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",557237],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",557319],"binderInfo":"implicit"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",645105],"binderInfo":"default"},{"type":"x ∈ Y ∧ ¬x = x₀","name":["hxy"],"isProp":true,"id":["_uniq",645106],"binderInfo":"default"},{"type":"(∀ a ∈ Y, ∀ a_1 ∈ Y, a ≤ a_1 ∨ a_1 ≤ a) ∧ WellFoundedLT (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",645107],"binderInfo":"default"},{"type":"x₀ ∈ Y","name":["h✝"],"isProp":true,"id":["_uniq",645108],"binderInfo":"default"},{"type":"∀ x ∈ Y, x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",645109],"binderInfo":"default"}]}],"start":10083},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",557586],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF"],"isProp":true,"id":["_uniq",557581]}]}],"start":10132},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",557586],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF"],"isProp":true,"id":["_uniq",557581]}]}],"start":10144},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",654850],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]}]}],"start":10287},{"state":[{"type":"(↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","tag":[],"mvarId":["_uniq",664492],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"type":"(↑Ω₀ : Type)","name":["Y"],"isProp":false,"id":["_uniq",654870],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",654872],"binderInfo":"implicit"},{"type":"x ∈ (↑Y : Set X) \\ {x₀}","name":["hxy"],"isProp":true,"id":["_uniq",655064],"binderInfo":"default"}]}],"start":10397},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",664495],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]}]}],"start":10414},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",664495],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]}]}],"start":10415},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",664495],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]}]}],"start":10470},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",684490],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]}]}],"start":10542},{"state":[{"type":"pt ∈ Ω","tag":[],"mvarId":["_uniq",684710],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]}]}],"start":10571},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",684712],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]}]}],"start":10581},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",684712],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]}]}],"start":10582},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",684712],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]}]}],"start":10603},{"state":[{"type":"IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","tag":[],"mvarId":["_uniq",685359],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"type":"(↑Ω : Type)","name":["Y"],"isProp":false,"id":["_uniq",684732],"binderInfo":"implicit"},{"type":"(↑Ω : Type)","name":["Y'"],"isProp":false,"id":["_uniq",684748],"binderInfo":"implicit"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",684750],"binderInfo":"default"},{"type":"x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X)","name":["h"],"isProp":true,"id":["_uniq",685106],"binderInfo":"default"}]}],"start":10693},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",685366],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]}]}],"start":10703},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",685366],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]}]}],"start":10704},{"state":[{"type":"IsTotal (↑Ω : Type)","tag":[],"mvarId":["_uniq",685635],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]}]}],"start":10730},{"state":[{"type":"False","tag":["intro","mk","mk","intro","mk","mk","intro"],"mvarId":["_uniq",689069],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",688977],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hY1"],"isProp":true,"id":["_uniq",688978],"binderInfo":"default"},{"type":"⟨Y, hY1⟩ ∈ Ω","name":["hY2"],"isProp":true,"id":["_uniq",688981],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",689041],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'1"],"isProp":true,"id":["_uniq",689042],"binderInfo":"default"},{"type":"⟨Y', hY'1⟩ ∈ Ω","name":["hY'2"],"isProp":true,"id":["_uniq",689045],"binderInfo":"default"},{"type":"¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨⟨Y', hY'1⟩, hY'2⟩","name":["h1"],"isProp":true,"id":["_uniq",689067],"binderInfo":"default"},{"type":"¬⟨⟨Y', hY'1⟩, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩","name":["h2"],"isProp":true,"id":["_uniq",689068],"binderInfo":"default"}]}],"start":10852},{"state":[{"type":"False","tag":["intro","mk","mk","intro","mk","mk","intro"],"mvarId":["_uniq",899373],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",688977],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hY1"],"isProp":true,"id":["_uniq",688978],"binderInfo":"default"},{"type":"⟨Y, hY1⟩ ∈ Ω","name":["hY2"],"isProp":true,"id":["_uniq",688981],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",689041],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'1"],"isProp":true,"id":["_uniq",689042],"binderInfo":"default"},{"type":"⟨Y', hY'1⟩ ∈ Ω","name":["hY'2"],"isProp":true,"id":["_uniq",689045],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",899349],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀) {x : X}, x ∈ a → ¬x = x₀ → (↑(F ⟨a, b⟩ x) : Set X) = {y | y ∈ a ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",899350],"binderInfo":"default"},{"type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",899351],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀),\n  ⟨a, b⟩ ∈ Ω → ∀ (a_1 : Set X) (b : a_1 ∈ Ω₀), ⟨a_1, b⟩ ∈ Ω → ∀ x ∈ a_1, x ∉ a → IsStrictUpperBound a x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",899352],"binderInfo":"default"},{"type":"∃ a ∈ Y, a ∉ Y'","name":["h1"],"isProp":true,"id":["_uniq",899353],"binderInfo":"default"},{"type":"∃ a ∈ Y', a ∉ Y","name":["h2"],"isProp":true,"id":["_uniq",899354],"binderInfo":"default"}]}],"start":10882},{"state":[{"type":"False","tag":["intro","mk","mk","intro","mk","mk","intro"],"mvarId":["_uniq",899406],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",688977],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hY1"],"isProp":true,"id":["_uniq",688978],"binderInfo":"default"},{"type":"⟨Y, hY1⟩ ∈ Ω","name":["hY2"],"isProp":true,"id":["_uniq",688981],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",689041],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'1"],"isProp":true,"id":["_uniq",689042],"binderInfo":"default"},{"type":"⟨Y', hY'1⟩ ∈ Ω","name":["hY'2"],"isProp":true,"id":["_uniq",689045],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",899349],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀) {x : X}, x ∈ a → ¬x = x₀ → (↑(F ⟨a, b⟩ x) : Set X) = {y | y ∈ a ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",899350],"binderInfo":"default"},{"type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",899351],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀),\n  ⟨a, b⟩ ∈ Ω → ∀ (a_1 : Set X) (b : a_1 ∈ Ω₀), ⟨a_1, b⟩ ∈ Ω → ∀ x ∈ a_1, x ∉ a → IsStrictUpperBound a x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",899352],"binderInfo":"default"},{"type":"X","name":["x₁"],"isProp":false,"id":["_uniq",899375],"binderInfo":"default"},{"type":"x₁ ∈ Y","name":["hx₁"],"isProp":true,"id":["_uniq",899384],"binderInfo":"default"},{"type":"x₁ ∉ Y'","name":["hx₁'"],"isProp":true,"id":["_uniq",899388],"binderInfo":"default"},{"type":"X","name":["x₂"],"isProp":false,"id":["_uniq",899392],"binderInfo":"default"},{"type":"x₂ ∈ Y'","name":["hx₂"],"isProp":true,"id":["_uniq",899401],"binderInfo":"default"},{"type":"x₂ ∉ Y","name":["hx₂'"],"isProp":true,"id":["_uniq",899405],"binderInfo":"default"}]}],"start":10955},{"state":[{"type":"False","tag":["intro","mk","mk","intro","mk","mk","intro"],"mvarId":["_uniq",900272],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",688977],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hY1"],"isProp":true,"id":["_uniq",688978],"binderInfo":"default"},{"type":"⟨Y, hY1⟩ ∈ Ω","name":["hY2"],"isProp":true,"id":["_uniq",688981],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",689041],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'1"],"isProp":true,"id":["_uniq",689042],"binderInfo":"default"},{"type":"⟨Y', hY'1⟩ ∈ Ω","name":["hY'2"],"isProp":true,"id":["_uniq",689045],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",899349],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀) {x : X}, x ∈ a → ¬x = x₀ → (↑(F ⟨a, b⟩ x) : Set X) = {y | y ∈ a ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",899350],"binderInfo":"default"},{"type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",899351],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀),\n  ⟨a, b⟩ ∈ Ω → ∀ (a_1 : Set X) (b : a_1 ∈ Ω₀), ⟨a_1, b⟩ ∈ Ω → ∀ x ∈ a_1, x ∉ a → IsStrictUpperBound a x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",899352],"binderInfo":"default"},{"type":"X","name":["x₁"],"isProp":false,"id":["_uniq",899375],"binderInfo":"default"},{"type":"x₁ ∈ Y","name":["hx₁"],"isProp":true,"id":["_uniq",899384],"binderInfo":"default"},{"type":"x₁ ∉ Y'","name":["hx₁'"],"isProp":true,"id":["_uniq",899388],"binderInfo":"default"},{"type":"X","name":["x₂"],"isProp":false,"id":["_uniq",899392],"binderInfo":"default"},{"type":"x₂ ∈ Y'","name":["hx₂"],"isProp":true,"id":["_uniq",899401],"binderInfo":"default"},{"type":"x₂ ∉ Y","name":["hx₂'"],"isProp":true,"id":["_uniq",899405],"binderInfo":"default"},{"type":"IsStrictUpperBound Y x₂","name":["h1"],"isProp":true,"id":["_uniq",900271],"binderInfo":"default"}]}],"start":10998},{"state":[{"type":"False","tag":["intro","mk","mk","intro","mk","mk","intro"],"mvarId":["_uniq",900971],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",688977],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hY1"],"isProp":true,"id":["_uniq",688978],"binderInfo":"default"},{"type":"⟨Y, hY1⟩ ∈ Ω","name":["hY2"],"isProp":true,"id":["_uniq",688981],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",689041],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'1"],"isProp":true,"id":["_uniq",689042],"binderInfo":"default"},{"type":"⟨Y', hY'1⟩ ∈ Ω","name":["hY'2"],"isProp":true,"id":["_uniq",689045],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",899349],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀) {x : X}, x ∈ a → ¬x = x₀ → (↑(F ⟨a, b⟩ x) : Set X) = {y | y ∈ a ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",899350],"binderInfo":"default"},{"type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",899351],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀),\n  ⟨a, b⟩ ∈ Ω → ∀ (a_1 : Set X) (b : a_1 ∈ Ω₀), ⟨a_1, b⟩ ∈ Ω → ∀ x ∈ a_1, x ∉ a → IsStrictUpperBound a x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",899352],"binderInfo":"default"},{"type":"X","name":["x₁"],"isProp":false,"id":["_uniq",899375],"binderInfo":"default"},{"type":"x₁ ∈ Y","name":["hx₁"],"isProp":true,"id":["_uniq",899384],"binderInfo":"default"},{"type":"x₁ ∉ Y'","name":["hx₁'"],"isProp":true,"id":["_uniq",899388],"binderInfo":"default"},{"type":"X","name":["x₂"],"isProp":false,"id":["_uniq",899392],"binderInfo":"default"},{"type":"x₂ ∈ Y'","name":["hx₂"],"isProp":true,"id":["_uniq",899401],"binderInfo":"default"},{"type":"x₂ ∉ Y","name":["hx₂'"],"isProp":true,"id":["_uniq",899405],"binderInfo":"default"},{"type":"IsStrictUpperBound Y x₂","name":["h1"],"isProp":true,"id":["_uniq",900271],"binderInfo":"default"},{"type":"IsStrictUpperBound Y' x₁","name":["h2"],"isProp":true,"id":["_uniq",900970],"binderInfo":"default"}]}],"start":11042},{"state":[{"type":"False","tag":["intro","mk","mk","intro","mk","mk","intro"],"mvarId":["_uniq",903916],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",688977],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hY1"],"isProp":true,"id":["_uniq",688978],"binderInfo":"default"},{"type":"⟨Y, hY1⟩ ∈ Ω","name":["hY2"],"isProp":true,"id":["_uniq",688981],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",689041],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'1"],"isProp":true,"id":["_uniq",689042],"binderInfo":"default"},{"type":"⟨Y', hY'1⟩ ∈ Ω","name":["hY'2"],"isProp":true,"id":["_uniq",689045],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀), IsStrictUpperBound a (s ⟨a, b⟩)","name":["hs"],"isProp":true,"id":["_uniq",899349],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀) {x : X}, x ∈ a → ¬x = x₀ → (↑(F ⟨a, b⟩ x) : Set X) = {y | y ∈ a ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",899350],"binderInfo":"default"},{"type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",899351],"binderInfo":"default"},{"type":"∀ (a : Set X) (b : a ∈ Ω₀),\n  ⟨a, b⟩ ∈ Ω → ∀ (a_1 : Set X) (b : a_1 ∈ Ω₀), ⟨a_1, b⟩ ∈ Ω → ∀ x ∈ a_1, x ∉ a → IsStrictUpperBound a x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",899352],"binderInfo":"default"},{"type":"X","name":["x₁"],"isProp":false,"id":["_uniq",899375],"binderInfo":"default"},{"type":"x₁ ∈ Y","name":["hx₁"],"isProp":true,"id":["_uniq",899384],"binderInfo":"default"},{"type":"x₁ ∉ Y'","name":["hx₁'"],"isProp":true,"id":["_uniq",899388],"binderInfo":"default"},{"type":"X","name":["x₂"],"isProp":false,"id":["_uniq",899392],"binderInfo":"default"},{"type":"x₂ ∈ Y'","name":["hx₂"],"isProp":true,"id":["_uniq",899401],"binderInfo":"default"},{"type":"x₂ ∉ Y","name":["hx₂'"],"isProp":true,"id":["_uniq",899405],"binderInfo":"default"},{"type":"∀ y ∈ Y, y < x₂","name":["h1"],"isProp":true,"id":["_uniq",903907],"binderInfo":"default"},{"type":"∀ y ∈ Y', y < x₁","name":["h2"],"isProp":true,"id":["_uniq",903908],"binderInfo":"default"}]}],"start":11085},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",685637],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]}]}],"start":11141},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",908528],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]}]}],"start":11178},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",908795],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]}]}],"start":11245},{"state":[{"type":"x₀ ≤ x","tag":[],"mvarId":["_uniq",952395],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",952288],"binderInfo":"implicit"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",952369],"binderInfo":"default"}]}],"start":11302},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",952400],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]}]}],"start":11312},{"state":[{"type":"IsTotal (↑Y_infty : Type)","tag":[],"mvarId":["_uniq",952633],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]}]}],"start":11350},{"state":[{"type":"⟨x, hx⟩ ≤ ⟨x', hx'⟩ ∨ ⟨x', hx'⟩ ≤ ⟨x, hx⟩","tag":[],"mvarId":["_uniq",1031833],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",952673],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx✝"],"isProp":true,"id":["_uniq",952674],"binderInfo":"default"},{"type":"X","name":["x'"],"isProp":false,"id":["_uniq",952759],"binderInfo":"default"},{"type":"x' ∈ Y_infty","name":["hx'✝"],"isProp":true,"id":["_uniq",952760],"binderInfo":"default"},{"type":"∃ i, (∃ (x : i ∈ Ω₀), ⟨i, ⋯⟩ ∈ Ω) ∧ x ∈ i","name":["hx"],"isProp":true,"id":["_uniq",1031831],"binderInfo":"default"},{"type":"∃ i, (∃ (x : i ∈ Ω₀), ⟨i, ⋯⟩ ∈ Ω) ∧ x' ∈ i","name":["hx'"],"isProp":true,"id":["_uniq",1031832],"binderInfo":"default"}]}],"start":11415},{"state":[{"type":"⟨x, hx⟩ ≤ ⟨x', hx'⟩ ∨ ⟨x', hx'⟩ ≤ ⟨x, hx⟩","tag":["intro","intro","intro","intro","intro","intro"],"mvarId":["_uniq",1031954],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",952673],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",952674],"binderInfo":"default"},{"type":"X","name":["x'"],"isProp":false,"id":["_uniq",952759],"binderInfo":"default"},{"type":"x' ∈ Y_infty","name":["hx'"],"isProp":true,"id":["_uniq",952760],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1031856],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1031879],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1031896],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1031897],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1031916],"binderInfo":"default"},{"type":"x' ∈ Y'","name":["hxY'"],"isProp":true,"id":["_uniq",1031935],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1031952],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1031953],"binderInfo":"default"}]}],"start":11527},{"state":[{"type":"x ≤ x' ∨ x' ≤ x","tag":["intro","intro","intro","intro","intro","intro"],"mvarId":["_uniq",1047919],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",952673],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",952674],"binderInfo":"default"},{"type":"X","name":["x'"],"isProp":false,"id":["_uniq",952759],"binderInfo":"default"},{"type":"x' ∈ Y_infty","name":["hx'"],"isProp":true,"id":["_uniq",952760],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1031856],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1031879],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1031896],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1031897],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1031916],"binderInfo":"default"},{"type":"x' ∈ Y'","name":["hxY'"],"isProp":true,"id":["_uniq",1031935],"binderInfo":"default"},{"type":"IsTotal (↑Y' : Type) ∧ WellFoundedLT (↑Y' : Type) ∧ x₀ ∈ Y' ∧ ∀ x ∈ Y', x₀ ≤ x","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1031952],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1031953],"binderInfo":"default"},{"type":"Y ⊆ Y' ∨ Y' ⊆ Y","name":["this"],"isProp":true,"id":["_uniq",1047916],"binderInfo":"default"}]}],"start":11623},{"state":[{"type":"x ≤ x' ∨ x' ≤ x","tag":["intro","intro","intro","intro","intro","intro","inl"],"mvarId":["_uniq",1047943],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",952673],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",952674],"binderInfo":"default"},{"type":"X","name":["x'"],"isProp":false,"id":["_uniq",952759],"binderInfo":"default"},{"type":"x' ∈ Y_infty","name":["hx'"],"isProp":true,"id":["_uniq",952760],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1031856],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1031879],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1031896],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1031897],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1031916],"binderInfo":"default"},{"type":"x' ∈ Y'","name":["hxY'"],"isProp":true,"id":["_uniq",1031935],"binderInfo":"default"},{"type":"IsTotal (↑Y' : Type) ∧ WellFoundedLT (↑Y' : Type) ∧ x₀ ∈ Y' ∧ ∀ x ∈ Y', x₀ ≤ x","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1031952],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1031953],"binderInfo":"default"},{"type":"Y ⊆ Y'","name":["this"],"isProp":true,"id":["_uniq",1047942],"binderInfo":"default"}]},{"type":"x ≤ x' ∨ x' ≤ x","tag":["intro","intro","intro","intro","intro","intro","inr"],"mvarId":["_uniq",1047948],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",952673],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",952674],"binderInfo":"default"},{"type":"X","name":["x'"],"isProp":false,"id":["_uniq",952759],"binderInfo":"default"},{"type":"x' ∈ Y_infty","name":["hx'"],"isProp":true,"id":["_uniq",952760],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1031856],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1031879],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1031896],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1031897],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1031916],"binderInfo":"default"},{"type":"x' ∈ Y'","name":["hxY'"],"isProp":true,"id":["_uniq",1031935],"binderInfo":"default"},{"type":"IsTotal (↑Y' : Type) ∧ WellFoundedLT (↑Y' : Type) ∧ x₀ ∈ Y' ∧ ∀ x ∈ Y', x₀ ≤ x","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1031952],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1031953],"binderInfo":"default"},{"type":"Y' ⊆ Y","name":["this"],"isProp":true,"id":["_uniq",1047947],"binderInfo":"default"}]}],"start":11654},{"state":[{"type":"x ≤ x' ∨ x' ≤ x","tag":["intro","intro","intro","intro","intro","intro","inr"],"mvarId":["_uniq",1047948],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",952673],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",952674],"binderInfo":"default"},{"type":"X","name":["x'"],"isProp":false,"id":["_uniq",952759],"binderInfo":"default"},{"type":"x' ∈ Y_infty","name":["hx'"],"isProp":true,"id":["_uniq",952760],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1031856],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1031879],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1031896],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1031897],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1031916],"binderInfo":"default"},{"type":"x' ∈ Y'","name":["hxY'"],"isProp":true,"id":["_uniq",1031935],"binderInfo":"default"},{"type":"IsTotal (↑Y' : Type) ∧ WellFoundedLT (↑Y' : Type) ∧ x₀ ∈ Y' ∧ ∀ x ∈ Y', x₀ ≤ x","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1031952],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1031953],"binderInfo":"default"},{"type":"Y' ⊆ Y","name":["this"],"isProp":true,"id":["_uniq",1047947],"binderInfo":"default"}]}],"start":11749},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",952635],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]}]}],"start":11839},{"state":[{"type":"WellFoundedLT (↑Y_infty : Type)","tag":[],"mvarId":["_uniq",1053094],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]}]}],"start":11882},{"state":[{"type":"∃ x, IsMin x","tag":[],"mvarId":["_uniq",1053295],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"type":"Set (↑Y_infty : Type)","name":["A"],"isProp":false,"id":["_uniq",1053132],"binderInfo":"default"},{"type":"X","name":["a"],"isProp":false,"id":["_uniq",1053183],"binderInfo":"default"},{"type":"a ∈ Y_infty","name":["ha"],"isProp":true,"id":["_uniq",1053184],"binderInfo":"default"},{"type":"⟨a, ha⟩ ∈ A","name":["haA"],"isProp":true,"id":["_uniq",1053185],"binderInfo":"default"}]}],"start":11937},{"state":[{"type":"∃ x, IsMin x","tag":["intro","intro","intro"],"mvarId":["_uniq",1092877],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"type":"Set (↑Y_infty : Type)","name":["A"],"isProp":false,"id":["_uniq",1053132],"binderInfo":"default"},{"type":"X","name":["a"],"isProp":false,"id":["_uniq",1053183],"binderInfo":"default"},{"type":"a ∈ Y_infty","name":["ha"],"isProp":true,"id":["_uniq",1053184],"binderInfo":"default"},{"type":"⟨a, ha⟩ ∈ A","name":["haA"],"isProp":true,"id":["_uniq",1053185],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1092835],"binderInfo":"default"},{"type":"a ∈ Y","name":["haY"],"isProp":true,"id":["_uniq",1092858],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1092875],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1092876],"binderInfo":"default"}]}],"start":12012},{"state":[{"type":"∃ x, IsMin x","tag":["intro","intro","intro"],"mvarId":["_uniq",1124805],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"type":"Set (↑Y_infty : Type)","name":["A"],"isProp":false,"id":["_uniq",1053132],"binderInfo":"default"},{"type":"X","name":["a"],"isProp":false,"id":["_uniq",1053183],"binderInfo":"default"},{"type":"a ∈ Y_infty","name":["ha"],"isProp":true,"id":["_uniq",1053184],"binderInfo":"default"},{"type":"⟨a, ha⟩ ∈ A","name":["haA"],"isProp":true,"id":["_uniq",1053185],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1092835],"binderInfo":"default"},{"type":"a ∈ Y","name":["haY"],"isProp":true,"id":["_uniq",1092858],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀✝"],"isProp":true,"id":["_uniq",1092875],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1092876],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧\n  (∀ (A : Set (↑Y : Type)), A.Nonempty → ∃ a, ∃ (b : a ∈ Y) (b_1 : ⟨a, b⟩ ∈ A), IsMin ⟨⟨a, b⟩, b_1⟩) ∧\n    x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1124804],"binderInfo":"default"}]}],"start":12056},{"state":[{"type":"∃ x, IsMin x","tag":["intro","intro","intro"],"mvarId":["_uniq",1159531],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"type":"Set (↑Y_infty : Type)","name":["A"],"isProp":false,"id":["_uniq",1053132],"binderInfo":"default"},{"type":"X","name":["a"],"isProp":false,"id":["_uniq",1053183],"binderInfo":"default"},{"type":"a ∈ Y_infty","name":["ha"],"isProp":true,"id":["_uniq",1053184],"binderInfo":"default"},{"type":"⟨a, ha⟩ ∈ A","name":["haA"],"isProp":true,"id":["_uniq",1053185],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1092835],"binderInfo":"default"},{"type":"a ∈ Y","name":["haY"],"isProp":true,"id":["_uniq",1092858],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀✝"],"isProp":true,"id":["_uniq",1092875],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1092876],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧\n  (∀ (A : Set (↑Y : Type)), A.Nonempty → ∃ a, ∃ (b : a ∈ Y) (b_1 : ⟨a, b⟩ ∈ A), IsMin ⟨⟨a, b⟩, b_1⟩) ∧\n    x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1124804],"binderInfo":"default"},{"type":"X","name":["b"],"isProp":false,"id":["_uniq",1159511],"binderInfo":"default"},{"type":"b ∈ Y","name":["hb"],"isProp":true,"id":["_uniq",1159518],"binderInfo":"default"},{"type":"⟨b, hb⟩ ∈ {x | ∃ x', (↑x : X) = (↑(↑x' : (↑Y_infty : Type)) : X)}","name":["hbY"],"isProp":true,"id":["_uniq",1159526],"binderInfo":"default"},{"type":"IsMin ⟨⟨b, hb⟩, hbY⟩","name":["hbmin"],"isProp":true,"id":["_uniq",1159530],"binderInfo":"default"}]}],"start":12169},{"state":[{"type":"∃ x, IsMin x","tag":["intro","intro","intro"],"mvarId":["_uniq",1194474],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"type":"Set (↑Y_infty : Type)","name":["A"],"isProp":false,"id":["_uniq",1053132],"binderInfo":"default"},{"type":"X","name":["a"],"isProp":false,"id":["_uniq",1053183],"binderInfo":"default"},{"type":"a ∈ Y_infty","name":["ha"],"isProp":true,"id":["_uniq",1053184],"binderInfo":"default"},{"type":"⟨a, ha⟩ ∈ A","name":["haA"],"isProp":true,"id":["_uniq",1053185],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1092835],"binderInfo":"default"},{"type":"a ∈ Y","name":["haY"],"isProp":true,"id":["_uniq",1092858],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀✝"],"isProp":true,"id":["_uniq",1092875],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1092876],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧\n  (∀ (A : Set (↑Y : Type)), A.Nonempty → ∃ a, ∃ (b : a ∈ Y) (b_1 : ⟨a, b⟩ ∈ A), IsMin ⟨⟨a, b⟩, b_1⟩) ∧\n    x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1124804],"binderInfo":"default"},{"type":"X","name":["b"],"isProp":false,"id":["_uniq",1159511],"binderInfo":"default"},{"type":"b ∈ Y","name":["hb"],"isProp":true,"id":["_uniq",1159518],"binderInfo":"default"},{"type":"⟨b, hb⟩ ∈ {x | ∃ x', (↑x : X) = (↑(↑x' : (↑Y_infty : Type)) : X)}","name":["hbY"],"isProp":true,"id":["_uniq",1159526],"binderInfo":"default"},{"type":"IsMin ⟨⟨b, hb⟩, hbY⟩","name":["hbmin"],"isProp":true,"id":["_uniq",1159530],"binderInfo":"default"},{"type":"b ∈ Y_infty","name":["hbY_infty"],"isProp":true,"id":["_uniq",1194469],"binderInfo":"default"},{"type":"⟨b, ⋯⟩ ∈ A","name":["hbA"],"isProp":true,"id":["_uniq",1194473],"binderInfo":"default"}]}],"start":12217},{"state":[{"type":"∃ x₀ ∈ A, ∀ x ∈ A, x₀ ≤ x","tag":["intro","intro","intro"],"mvarId":["_uniq",1194640],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"type":"Set (↑Y_infty : Type)","name":["A"],"isProp":false,"id":["_uniq",1053132],"binderInfo":"default"},{"type":"X","name":["a"],"isProp":false,"id":["_uniq",1053183],"binderInfo":"default"},{"type":"a ∈ Y_infty","name":["ha"],"isProp":true,"id":["_uniq",1053184],"binderInfo":"default"},{"type":"⟨a, ha⟩ ∈ A","name":["haA"],"isProp":true,"id":["_uniq",1053185],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1092835],"binderInfo":"default"},{"type":"a ∈ Y","name":["haY"],"isProp":true,"id":["_uniq",1092858],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀✝"],"isProp":true,"id":["_uniq",1092875],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1092876],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧\n  (∀ (A : Set (↑Y : Type)), A.Nonempty → ∃ a, ∃ (b : a ∈ Y) (b_1 : ⟨a, b⟩ ∈ A), IsMin ⟨⟨a, b⟩, b_1⟩) ∧\n    x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1124804],"binderInfo":"default"},{"type":"X","name":["b"],"isProp":false,"id":["_uniq",1159511],"binderInfo":"default"},{"type":"b ∈ Y","name":["hb"],"isProp":true,"id":["_uniq",1159518],"binderInfo":"default"},{"type":"⟨b, hb⟩ ∈ {x | ∃ x', (↑x : X) = (↑(↑x' : (↑Y_infty : Type)) : X)}","name":["hbY"],"isProp":true,"id":["_uniq",1159526],"binderInfo":"default"},{"type":"IsMin ⟨⟨b, hb⟩, hbY⟩","name":["hbmin"],"isProp":true,"id":["_uniq",1159530],"binderInfo":"default"},{"type":"b ∈ Y_infty","name":["hbY_infty"],"isProp":true,"id":["_uniq",1194469],"binderInfo":"default"},{"type":"⟨b, ⋯⟩ ∈ A","name":["hbA"],"isProp":true,"id":["_uniq",1194473],"binderInfo":"default"}]}],"start":12273},{"state":[{"type":"⟨b, hbY_infty⟩ ≤ ⟨x, hx⟩","tag":["right"],"mvarId":["_uniq",1194841],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"type":"Set (↑Y_infty : Type)","name":["A"],"isProp":false,"id":["_uniq",1053132],"binderInfo":"default"},{"type":"X","name":["a"],"isProp":false,"id":["_uniq",1053183],"binderInfo":"default"},{"type":"a ∈ Y_infty","name":["ha"],"isProp":true,"id":["_uniq",1053184],"binderInfo":"default"},{"type":"⟨a, ha⟩ ∈ A","name":["haA"],"isProp":true,"id":["_uniq",1053185],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1092835],"binderInfo":"default"},{"type":"a ∈ Y","name":["haY"],"isProp":true,"id":["_uniq",1092858],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀✝"],"isProp":true,"id":["_uniq",1092875],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1092876],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧\n  (∀ (A : Set (↑Y : Type)), A.Nonempty → ∃ a, ∃ (b : a ∈ Y) (b_1 : ⟨a, b⟩ ∈ A), IsMin ⟨⟨a, b⟩, b_1⟩) ∧\n    x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1124804],"binderInfo":"default"},{"type":"X","name":["b"],"isProp":false,"id":["_uniq",1159511],"binderInfo":"default"},{"type":"b ∈ Y","name":["hb"],"isProp":true,"id":["_uniq",1159518],"binderInfo":"default"},{"type":"⟨b, hb⟩ ∈ {x | ∃ x', (↑x : X) = (↑(↑x' : (↑Y_infty : Type)) : X)}","name":["hbY"],"isProp":true,"id":["_uniq",1159526],"binderInfo":"default"},{"type":"IsMin ⟨⟨b, hb⟩, hbY⟩","name":["hbmin"],"isProp":true,"id":["_uniq",1159530],"binderInfo":"default"},{"type":"b ∈ Y_infty","name":["hbY_infty"],"isProp":true,"id":["_uniq",1194469],"binderInfo":"default"},{"type":"⟨b, ⋯⟩ ∈ A","name":["hbA"],"isProp":true,"id":["_uniq",1194473],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1194779],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1194780],"binderInfo":"default"},{"type":"⟨x, hx⟩ ∈ A","name":["hxA"],"isProp":true,"id":["_uniq",1194840],"binderInfo":"default"}]}],"start":12332},{"state":[{"type":"b ≤ x","tag":["right","intro","intro","intro"],"mvarId":["_uniq",1270508],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"type":"Set (↑Y_infty : Type)","name":["A"],"isProp":false,"id":["_uniq",1053132],"binderInfo":"default"},{"type":"X","name":["a"],"isProp":false,"id":["_uniq",1053183],"binderInfo":"default"},{"type":"a ∈ Y_infty","name":["ha"],"isProp":true,"id":["_uniq",1053184],"binderInfo":"default"},{"type":"⟨a, ha⟩ ∈ A","name":["haA"],"isProp":true,"id":["_uniq",1053185],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1092835],"binderInfo":"default"},{"type":"a ∈ Y","name":["haY"],"isProp":true,"id":["_uniq",1092858],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀✝"],"isProp":true,"id":["_uniq",1092875],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1092876],"binderInfo":"default"},{"type":"IsTotal (↑Y : Type) ∧\n  (∀ (A : Set (↑Y : Type)), A.Nonempty → ∃ a, ∃ (b : a ∈ Y) (b_1 : ⟨a, b⟩ ∈ A), IsMin ⟨⟨a, b⟩, b_1⟩) ∧\n    x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1124804],"binderInfo":"default"},{"type":"X","name":["b"],"isProp":false,"id":["_uniq",1159511],"binderInfo":"default"},{"type":"b ∈ Y","name":["hb"],"isProp":true,"id":["_uniq",1159518],"binderInfo":"default"},{"type":"⟨b, hb⟩ ∈ {x | ∃ x', (↑x : X) = (↑(↑x' : (↑Y_infty : Type)) : X)}","name":["hbY"],"isProp":true,"id":["_uniq",1159526],"binderInfo":"default"},{"type":"IsMin ⟨⟨b, hb⟩, hbY⟩","name":["hbmin"],"isProp":true,"id":["_uniq",1159530],"binderInfo":"default"},{"type":"b ∈ Y_infty","name":["hbY_infty"],"isProp":true,"id":["_uniq",1194469],"binderInfo":"default"},{"type":"⟨b, ⋯⟩ ∈ A","name":["hbA"],"isProp":true,"id":["_uniq",1194473],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1194779],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1194780],"binderInfo":"default"},{"type":"⟨x, hx⟩ ∈ A","name":["hxA"],"isProp":true,"id":["_uniq",1194840],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1270466],"binderInfo":"default"},{"type":"x ∈ Y'","name":["hxY'"],"isProp":true,"id":["_uniq",1270489],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1270506],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1270507],"binderInfo":"default"}]}],"start":12417},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1053096],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]}]}],"start":12427},{"state":[{"type":"Y_infty ∈ Ω₀","tag":[],"mvarId":["_uniq",1270591],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]}]}],"start":12474},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1270593],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]}]}],"start":12484},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1270610],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]}]}],"start":12533},{"state":[{"type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","tag":[],"mvarId":["_uniq",1271132],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]}]}],"start":12599},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1271134],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]}]}],"start":12609},{"state":[{"type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","tag":[],"mvarId":["_uniq",1271425],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]}]}],"start":12680},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1271427],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]}]}],"start":12690},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1271573],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]}]}],"start":12751},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1271744],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]}]}],"start":12825},{"state":[{"type":"Y_infty ∪ {sY_infty} ∈ Ω₀","tag":[],"mvarId":["_uniq",1271888],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]}]}],"start":12885},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1271890],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"fun Y => Exists.choose_spec (hs✝ (↑Y : Set X) Y.property)","type":"∀ (Y : (↑Ω₀ : Type)), IsStrictUpperBound (↑Y : Set X) (s Y)","name":["hs"],"isProp":true,"id":["_uniq",551527]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]}]}],"start":12955},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1277083],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"IsStrictUpperBound (↑⟨Y_infty, hY_inftyΩ₀⟩ : Set X) (s ⟨Y_infty, hY_inftyΩ₀⟩)","name":["hs"],"isProp":true,"id":["_uniq",1277080],"binderInfo":"default"}]}],"start":12996},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1279580],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"}]}],"start":13034},{"state":[{"type":"⟨Y_infty ∪ {sY_infty}, hYs_Ω₀⟩ ∈ Ω","tag":[],"mvarId":["_uniq",1279681],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"}]}],"start":13084},{"state":[{"type":"∀ (x : X), x ∈ insert sY_infty Y_infty ∧ ¬x = x₀ → x = s (F ⟨insert sY_infty Y_infty, ⋯⟩ x)","tag":[],"mvarId":["_uniq",1287178],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"}]}],"start":13129},{"state":[{"type":"sY_infty = s (F ⟨insert sY_infty Y_infty, ⋯⟩ sY_infty)","tag":["intro","inl"],"mvarId":["_uniq",1287247],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"}]},{"type":"x = s (F ⟨insert sY_infty Y_infty, ⋯⟩ x)","tag":["intro","inr"],"mvarId":["_uniq",1287234],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"}]}],"start":13169},{"state":[{"type":"⟨Y_infty, hY_inftyΩ₀⟩ = F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, ⋯⟩ (s ⟨Y_infty, hY_inftyΩ₀⟩)","tag":["intro","inl","e_a"],"mvarId":["_uniq",1287352],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"}]}],"start":13200},{"state":[{"type":"(↑⟨Y_infty, hY_inftyΩ₀⟩ : Set X) =\n  {y | y ∈ (↑⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, ⋯⟩ : Set X) ∧ y < s ⟨Y_infty, hY_inftyΩ₀⟩}","tag":["h","e'_3"],"mvarId":["_uniq",1287841],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"}]},{"type":"s ⟨Y_infty, hY_inftyΩ₀⟩ ∈ (↑⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, ⋯⟩ : Set X) \\ {x₀}","tag":["intro","inl","e_a","a","convert_3"],"mvarId":["_uniq",1287471],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"}]}],"start":13254},{"state":[{"type":"x✝ ∈ Y_infty → (x✝ = s ⟨Y_infty, hY_inftyΩ₀⟩ ∨ x✝ ∈ Y_infty) ∧ x✝ < s ⟨Y_infty, hY_inftyΩ₀⟩","tag":["h","e'_3","h","mp"],"mvarId":["_uniq",1289513],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"},{"type":"X","name":["x✝"],"isProp":false,"id":["_uniq",1288589],"binderInfo":"default"}]},{"type":"(x✝ = s ⟨Y_infty, hY_inftyΩ₀⟩ ∨ x✝ ∈ Y_infty) ∧ x✝ < s ⟨Y_infty, hY_inftyΩ₀⟩ → x✝ ∈ Y_infty","tag":["h","e'_3","h","mpr"],"mvarId":["_uniq",1289514],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"},{"type":"X","name":["x✝"],"isProp":false,"id":["_uniq",1288589],"binderInfo":"default"}]}],"start":13285},{"state":[{"type":"(x✝ = s ⟨Y_infty, hY_inftyΩ₀⟩ ∨ x✝ ∈ Y_infty) ∧ x✝ < s ⟨Y_infty, hY_inftyΩ₀⟩ → x✝ ∈ Y_infty","tag":["h","e'_3","h","mpr"],"mvarId":["_uniq",1289514],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"},{"type":"X","name":["x✝"],"isProp":false,"id":["_uniq",1288589],"binderInfo":"default"}]}],"start":13301},{"state":[{"type":"x✝ ∈ Y_infty","tag":["h","e'_3","h","mpr","intro","inl"],"mvarId":["_uniq",1295731],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"},{"type":"X","name":["x✝"],"isProp":false,"id":["_uniq",1288589],"binderInfo":"default"},{"type":"x✝ < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["right✝"],"isProp":true,"id":["_uniq",1295706],"binderInfo":"default"},{"type":"x✝ = s ⟨Y_infty, hY_inftyΩ₀⟩","name":["h✝"],"isProp":true,"id":["_uniq",1295730],"binderInfo":"default"}]},{"type":"x✝ ∈ Y_infty","tag":["h","e'_3","h","mpr","intro","inr"],"mvarId":["_uniq",1295736],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"},{"type":"X","name":["x✝"],"isProp":false,"id":["_uniq",1288589],"binderInfo":"default"},{"type":"x✝ < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["right✝"],"isProp":true,"id":["_uniq",1295706],"binderInfo":"default"},{"type":"x✝ ∈ Y_infty","name":["h✝"],"isProp":true,"id":["_uniq",1295735],"binderInfo":"default"}]}],"start":13333},{"state":[{"type":"x✝ ∈ Y_infty","tag":["h","e'_3","h","mpr","intro","inr"],"mvarId":["_uniq",1295736],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"},{"type":"X","name":["x✝"],"isProp":false,"id":["_uniq",1288589],"binderInfo":"default"},{"type":"x✝ < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["right✝"],"isProp":true,"id":["_uniq",1295706],"binderInfo":"default"},{"type":"x✝ ∈ Y_infty","name":["h✝"],"isProp":true,"id":["_uniq",1295735],"binderInfo":"default"}]}],"start":13349},{"state":[{"type":"s ⟨Y_infty, hY_inftyΩ₀⟩ ∈ (↑⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, ⋯⟩ : Set X) \\ {x₀}","tag":["intro","inl","e_a","a","convert_3"],"mvarId":["_uniq",1287471],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"¬sY_infty = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287246],"binderInfo":"default"}]}],"start":13368},{"state":[{"type":"x = s (F ⟨insert sY_infty Y_infty, ⋯⟩ x)","tag":["intro","inr"],"mvarId":["_uniq",1287234],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"}]}],"start":13430},{"state":[{"type":"x = s (F ⟨insert sY_infty Y_infty, ⋯⟩ x)","tag":["intro","inr","intro","intro","intro"],"mvarId":["_uniq",1345643],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ"],"isProp":true,"id":["_uniq",1345642],"binderInfo":"default"}]}],"start":13523},{"state":[{"type":"x = s (F ⟨insert sY_infty Y_infty, ⋯⟩ x)","tag":["intro","inr","intro","intro","intro"],"mvarId":["_uniq",1352224],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"}]}],"start":13565},{"state":[{"type":"F ⟨insert sY_infty Y_infty, ⋯⟩ x = F ⟨Y, ⋯⟩ x","tag":["h","e'_3","h","e'_1"],"mvarId":["_uniq",1352905],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"}]}],"start":13603},{"state":[{"type":"(↑(F ⟨insert sY_infty Y_infty, ⋯⟩ x) : Set X) = (↑(F ⟨Y, ⋯⟩ x) : Set X)","tag":["h","e'_3","h","e'_1","a"],"mvarId":["_uniq",1353014],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"}]}],"start":13635},{"state":[{"type":"{y | y ∈ (↑⟨insert sY_infty Y_infty, ⋯⟩ : Set X) ∧ y < x} = {y | y ∈ (↑⟨Y, ⋯⟩ : Set X) ∧ y < x}","tag":["h","e'_3","h","e'_1","a"],"mvarId":["_uniq",1353062],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"}]},{"type":"x ∈ (↑⟨Y, ⋯⟩ : Set X) \\ {x₀}","tag":["h","e'_3","h","e'_1","a"],"mvarId":["_uniq",1353053],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"}]},{"type":"x ∈ (↑⟨insert sY_infty Y_infty, ⋯⟩ : Set X) \\ {x₀}","tag":["h","e'_3","h","e'_1","a"],"mvarId":["_uniq",1353026],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"}]}],"start":13651},{"state":[{"type":"(y = sY_infty ∨ ∃ i, (∃ (x : i ∈ Ω₀), ⟨i, ⋯⟩ ∈ Ω) ∧ y ∈ i) → y ∈ Y","tag":["h","e'_3","h","e'_1","a","h","mp"],"mvarId":["_uniq",1402996],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",1353105],"binderInfo":"default"},{"type":"y < x","name":["hyx"],"isProp":true,"id":["_uniq",1402987],"binderInfo":"default"}]},{"type":"y ∈ Y → y = sY_infty ∨ ∃ i, (∃ (x : i ∈ Ω₀), ⟨i, ⋯⟩ ∈ Ω) ∧ y ∈ i","tag":["h","e'_3","h","e'_1","a","h","mpr"],"mvarId":["_uniq",1402997],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",1353105],"binderInfo":"default"},{"type":"y < x","name":["hyx"],"isProp":true,"id":["_uniq",1402987],"binderInfo":"default"}]}],"start":13703},{"state":[{"type":"sY_infty ∈ Y","tag":["h","e'_3","h","e'_1","a","h","mp","inl"],"mvarId":["_uniq",1403043],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"sY_infty < x","name":["hyx"],"isProp":true,"id":["_uniq",1403042],"binderInfo":"default"}]},{"type":"y ∈ Y","tag":["h","e'_3","h","e'_1","a","h","mp","inr","intro","intro","intro"],"mvarId":["_uniq",1403097],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",1353105],"binderInfo":"default"},{"type":"y < x","name":["hyx"],"isProp":true,"id":["_uniq",1402987],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1403059],"binderInfo":"default"},{"type":"y ∈ Y'","name":["hyY'"],"isProp":true,"id":["_uniq",1403078],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1403095],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1403096],"binderInfo":"default"}]}],"start":13766},{"state":[{"type":"y ∈ Y","tag":["h","e'_3","h","e'_1","a","h","mp","inr","intro","intro","intro"],"mvarId":["_uniq",1403097],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",1353105],"binderInfo":"default"},{"type":"y < x","name":["hyx"],"isProp":true,"id":["_uniq",1402987],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1403059],"binderInfo":"default"},{"type":"y ∈ Y'","name":["hyY'"],"isProp":true,"id":["_uniq",1403078],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1403095],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1403096],"binderInfo":"default"}]}],"start":13802},{"state":[{"type":"False","tag":["h","e'_3","h","e'_1","a","h","mp","inr","intro","intro","intro"],"mvarId":["_uniq",1409234],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this✝"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",1353105],"binderInfo":"default"},{"type":"y < x","name":["hyx"],"isProp":true,"id":["_uniq",1402987],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1403059],"binderInfo":"default"},{"type":"y ∈ Y'","name":["hyY'"],"isProp":true,"id":["_uniq",1403078],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1403095],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1403096],"binderInfo":"default"},{"type":"y ∉ Y","name":["this"],"isProp":true,"id":["_uniq",1409219],"binderInfo":"default"}]}],"start":13821},{"state":[{"type":"False","tag":["h","e'_3","h","e'_1","a","h","mp","inr","intro","intro","intro"],"mvarId":["_uniq",1416770],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        _fvar.685361 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              _fvar.685361 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              _fvar.685361 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this✝"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",1353105],"binderInfo":"default"},{"type":"y < x","name":["hyx"],"isProp":true,"id":["_uniq",1402987],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1403059],"binderInfo":"default"},{"type":"y ∈ Y'","name":["hyY'"],"isProp":true,"id":["_uniq",1403078],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1403095],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1403096],"binderInfo":"default"},{"type":"y ∉ Y","name":["this"],"isProp":true,"id":["_uniq",1409219],"binderInfo":"default"},{"type":"IsStrictUpperBound (↑(↑⟨⟨Y, ⋯⟩, hYΩ'⟩ : (↑Ω₀ : Type)) : Set X) y","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",1416767],"binderInfo":"default"}]}],"start":13908},{"state":[{"type":"False","tag":["h","e'_3","h","e'_1","a","h","mp","inr","intro","intro","intro"],"mvarId":["_uniq",1417036],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        _fvar.685361 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              _fvar.685361 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              _fvar.685361 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this✝"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",1353105],"binderInfo":"default"},{"type":"y < x","name":["hyx"],"isProp":true,"id":["_uniq",1402987],"binderInfo":"default"},{"type":"Set X","name":["Y'"],"isProp":false,"id":["_uniq",1403059],"binderInfo":"default"},{"type":"y ∈ Y'","name":["hyY'"],"isProp":true,"id":["_uniq",1403078],"binderInfo":"default"},{"type":"Y' ∈ Ω₀","name":["hY'Ω₀"],"isProp":true,"id":["_uniq",1403095],"binderInfo":"default"},{"type":"⟨Y', ⋯⟩ ∈ Ω","name":["hY'Ω"],"isProp":true,"id":["_uniq",1403096],"binderInfo":"default"},{"type":"y ∉ Y","name":["this"],"isProp":true,"id":["_uniq",1409219],"binderInfo":"default"},{"type":"∀ y_1 ∈ (↑(↑⟨⟨Y, ⋯⟩, hYΩ'⟩ : (↑Ω₀ : Type)) : Set X), y_1 < y","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",1417031],"binderInfo":"default"}]}],"start":13957},{"state":[{"type":"y ∈ Y → y = sY_infty ∨ ∃ i, (∃ (x : i ∈ Ω₀), ⟨i, ⋯⟩ ∈ Ω) ∧ y ∈ i","tag":["h","e'_3","h","e'_1","a","h","mpr"],"mvarId":["_uniq",1402997],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"},{"type":"X","name":["y"],"isProp":false,"id":["_uniq",1353105],"binderInfo":"default"},{"type":"y < x","name":["hyx"],"isProp":true,"id":["_uniq",1402987],"binderInfo":"default"}]}],"start":14011},{"state":[{"type":"x ∈ (↑⟨Y, ⋯⟩ : Set X) \\ {x₀}","tag":["h","e'_3","h","e'_1","a"],"mvarId":["_uniq",1353053],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"}]},{"type":"x ∈ (↑⟨insert sY_infty Y_infty, ⋯⟩ : Set X) \\ {x₀}","tag":["h","e'_3","h","e'_1","a"],"mvarId":["_uniq",1353026],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",1287179],"binderInfo":"default"},{"type":"¬x = x₀","name":["hxx₀"],"isProp":true,"id":["_uniq",1287204],"binderInfo":"default"},{"type":"x ∈ Y_infty","name":["hx"],"isProp":true,"id":["_uniq",1287233],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",1345601],"binderInfo":"default"},{"type":"x ∈ Y","name":["hxY"],"isProp":true,"id":["_uniq",1345624],"binderInfo":"default"},{"type":"Y ∈ Ω₀","name":["hYΩ₀"],"isProp":true,"id":["_uniq",1345641],"binderInfo":"default"},{"value":"_fvar.1345642","type":"⟨Y, ⋯⟩ ∈ Ω","name":["hYΩ'"],"isProp":true,"id":["_uniq",1345649]},{"type":"∀ x ∈ Y, ¬x = x₀ → x = s (F ⟨Y, ⋯⟩ x)","name":["hYΩ"],"isProp":true,"id":["_uniq",1352221],"binderInfo":"default"}]}],"start":14023},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1279683],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congr\n      (congrArg (fun x => Membership.mem (setOf x))\n        (funext fun Y =>\n          forall_congr fun x =>\n            implies_congr\n              (Eq.trans (Set.mem_diff._simp_1 x)\n                (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n              (Eq.refl (x = s (F Y x)))))\n      ((fun {α} {p} val val_1 e_val =>\n          Eq.rec (motive := fun val_2 e_val => ∀ (property : p val), ⟨val, property⟩ = ⟨val_2, e_val ▸ property⟩)\n            (fun property => Eq.refl ⟨val, property⟩) e_val)\n        (Y_infty ∪ {sY_infty}) (insert sY_infty Y_infty) Set.union_singleton hYs_Ω₀)))\n  fun x a =>\n  And.casesOn a fun left hxx₀ =>\n    Or.casesOn left\n      (fun h =>\n        Eq.ndrec (motive := fun x => ¬x = x₀ → x = s (F ⟨insert sY_infty Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩ x))\n          (fun hxx₀ =>\n            id\n              ((fun a a_1 e_a => e_a ▸ Eq.refl (s a)) ⟨Y_infty, hY_inftyΩ₀⟩\n                (F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩ (s ⟨Y_infty, hY_inftyΩ₀⟩))\n                (Eq.symm\n                  (Subtype.val_injective\n                    (Eq.mpr\n                      (eq_of_heq\n                        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                  (fun e_2 h =>\n                                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                      e'_3\n                                      (fun h =>\n                                        Eq.ndrec (motive := fun a' =>\n                                          ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                      (Eq.refl a'_1) (HEq.refl e'_3))\n                                  (Eq.symm h) e'_2)\n                              (Eq.refl a') (HEq.refl e'_2))\n                          (Set X)\n                          (↑(F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩\n                                (s ⟨Y_infty, hY_inftyΩ₀⟩)) :\n                            Set X)\n                          (↑(F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩\n                                (s ⟨Y_infty, hY_inftyΩ₀⟩)) :\n                            Set X)\n                          (Eq.refl\n                            (↑(F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩\n                                  (s ⟨Y_infty, hY_inftyΩ₀⟩)) :\n                              Set X))\n                          (↑⟨Y_infty, hY_inftyΩ₀⟩ : Set X)\n                          {y |\n                            y ∈ (↑⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩ : Set X) ∧\n                              y < s ⟨Y_infty, hY_inftyΩ₀⟩}\n                          (Set.ext fun x =>\n                            Eq.mpr (id (congrArg (fun x_1 => x ∈ Y_infty ↔ x ∈ setOf x_1) (funext ⋯))) ⋯)))\n                      ⋯)))))\n          ⋯ ⋯)\n      ⋯","type":"⟨Y_infty ∪ {sY_infty}, hYs_Ω₀⟩ ∈ Ω","name":["hYs_Ω"],"isProp":true,"id":["_uniq",1279682]}]}],"start":14060},{"state":[{"type":"False","tag":["this"],"mvarId":["_uniq",1433098],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",548710],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝"],"isProp":false,"id":["_uniq",548711],"binderInfo":"instImplicit"},{"type":"X","name":["x₀"],"isProp":false,"id":["_uniq",548712],"binderInfo":"default"},{"value":"{Y | IsTotal (↑Y : Type) ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x}","type":"Set (Set X)","name":["Ω₀"],"isProp":false,"id":["_uniq",549299]},{"type":"∀ Y ∈ Ω₀, ∃ x, IsStrictUpperBound Y x","name":["hs✝"],"isProp":true,"id":["_uniq",551104],"binderInfo":"default"},{"value":"fun Y => ⋯.choose","type":"(↑Ω₀ : Type) → X","name":["s"],"isProp":false,"id":["_uniq",551233]},{"value":"have htotal :=\n  of_eq_true\n    (Eq.trans\n      (forall_congr fun x =>\n        Eq.trans\n          (forall_congr fun y =>\n            Eq.trans (congr (congrArg Or le_of_subsingleton._simp_1) le_of_subsingleton._simp_1) (or_self True))\n          (implies_true (↑{x₀} : Type)))\n      (implies_true (↑{x₀} : Type)));\nlet _lin := LinearOrder.mk htotal;\nEq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true htotal))\n        (Eq.trans\n          (congrArg (And (WellFoundedLT (↑{x₀} : Type)))\n            (Eq.trans\n              (congr (congrArg And (Eq.trans Set.mem_singleton_iff._simp_1 (eq_self x₀)))\n                (Eq.trans\n                  (Eq.trans (forall_congr fun x => implies_congr Set.mem_singleton_iff._simp_1 (Eq.refl (x₀ ≤ x)))\n                    forall_eq._simp_1)\n                  (le_refl._simp_1 x₀)))\n              (and_self True)))\n          (and_true (WellFoundedLT (↑{x₀} : Type)))))\n      (true_and (WellFoundedLT (↑{x₀} : Type)))))\n  ofFinite","type":"{x₀} ∈ Ω₀","name":["hpt"],"isProp":true,"id":["_uniq",551760]},{"value":"⟨{x₀}, hpt⟩","type":"(↑Ω₀ : Type)","name":["pt"],"isProp":false,"id":["_uniq",557231]},{"value":"fun {Y} hY {x} hxy =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x_1 => {y | y ∈ Y ∧ y < x} ∈ setOf x_1)\n          (funext fun Y =>\n            congrArg (fun x => x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n              (Eq.trans (Eq.trans (forall_congr fun x => Subtype.forall._simp_1) Subtype.forall._simp_1)\n                (forall_congr fun a =>\n                  forall_congr fun b =>\n                    forall_congr fun a_1 =>\n                      forall_congr fun b_1 => congr (congrArg Or Subtype.mk_le_mk._simp_1) Subtype.mk_le_mk._simp_1))))\n        (congr\n          (congrArg And\n            (forall_congr fun a =>\n              Eq.trans (implies_congr (Eq.refl (a ∈ Y ∧ a < x)) (forall_congr fun a_1 => and_imp._simp_1))\n                and_imp._simp_1))\n          (congrArg (fun x_1 => WellFoundedLT { x_2 // x_2 ∈ Y ∧ x_2 < x } ∧ (x₀ ∈ Y ∧ x₀ < x) ∧ x_1)\n            (forall_congr fun x_1 => and_imp._simp_1)))))\n    (Eq.mpr\n      (id\n        (Eq.trans\n          (congr\n            (congrArg And\n              (Eq.trans\n                (forall_congr fun a =>\n                  Eq.trans\n                    (implies_congr_ctx (Eq.refl (a ∈ Y)) fun a_1 =>\n                      Eq.trans\n                        (implies_congr_ctx (Eq.refl (a < x)) fun a_2 =>\n                          Eq.trans\n                            (forall_congr fun a_3 =>\n                              Eq.trans\n                                (implies_congr_ctx (Eq.refl (a_3 ∈ Y)) fun a_4 =>\n                                  Eq.trans\n                                    (implies_congr_ctx (Eq.refl (a_3 < x)) fun a_5 =>\n                                      (fun a b a_6 b_1 =>\n                                          eq_true\n                                            ((id\n                                                  (Eq.mp\n                                                    (congrArg (And (∀ a ∈ Y, ∀ a_7 ∈ Y, a ≤ a_7 ∨ a_7 ≤ a))\n                                                      (Eq.trans\n                                                        (congrArg (And (WellFoundedLT (↑Y : Type)))\n                                                          (Eq.trans\n                                                            (congr\n                                                              (congrArg And\n                                                                (eq_true\n                                                                  (Eq.mp (congrArg (fun x => Y ∈ setOf x) (funext ⋯))\n                                                                          hY).right.right.left))\n                                                              (Eq.trans\n                                                                (forall_congr fun x =>\n                                                                  Eq.trans\n                                                                    (implies_congr_ctx (Eq.refl (x ∈ Y)) fun a =>\n                                                                      (fun x => ⋯) x a)\n                                                                    (implies_true (x ∈ Y)))\n                                                                (implies_true X)))\n                                                            (and_self True)))\n                                                        (and_true (WellFoundedLT (↑Y : Type)))))\n                                                    (Eq.mp\n                                                      (congrArg (fun x => Y ∈ setOf x)\n                                                        (funext fun Y =>\n                                                          congrArg\n                                                            (fun x =>\n                                                              x ∧ WellFoundedLT (↑Y : Type) ∧ x₀ ∈ Y ∧ ∀ x ∈ Y, x₀ ≤ x)\n                                                            (Eq.trans\n                                                              (Eq.trans (forall_congr fun x => Subtype.forall._simp_1)\n                                                                Subtype.forall._simp_1)\n                                                              (forall_congr fun a =>\n                                                                forall_congr fun b =>\n                                                                  forall_congr fun a_7 => forall_congr ⋯))))\n                                                      hY))).1\n                                              a b a_6 b_1))\n                                        a a_1 a_3 a_4)\n                                    (implies_true (a_3 < x)))\n                                (implies_true (a_3 ∈ Y)))\n                            (implies_true X))\n                        (implies_true (a < x)))\n                    (implies_true (a ∈ Y)))\n                (implies_true X)))\n            (congrArg ⋯ ⋯))\n          ⋯))\n      ⋯)","type":"∀ {Y : Set X}, Y ∈ Ω₀ → ∀ {x : X}, x ∈ Y \\ {x₀} → {y | y ∈ Y ∧ y < x} ∈ Ω₀","name":["hF✝"],"isProp":true,"id":["_uniq",557581]},{"value":"fun Y x => if hxy : x ∈ (↑Y : Set X) \\ {x₀} then ⟨{y | y ∈ (↑Y : Set X) ∧ y < x}, ⋯⟩ else pt","type":"(↑Ω₀ : Type) → X → (↑Ω₀ : Type)","name":["F"],"isProp":false,"id":["_uniq",654847]},{"value":"fun {Y} {x} hxy =>\n  of_eq_true\n    (Eq.trans\n      (congrArg (fun x_1 => (↑x_1 : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x})\n        (Eq.trans\n          (congrArg (fun x_1 => x_1 Y x)\n            (funext fun Y =>\n              funext fun x =>\n                dite_congr\n                  (Eq.trans (Set.mem_diff._simp_1 x)\n                    (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                  (fun h =>\n                    Eq.refl\n                      ⟨{y | y ∈ (↑Y : Set X) ∧ y < x},\n                        hF✝ Y.property\n                          (Eq.mpr_prop\n                            (Eq.trans (Set.mem_diff._simp_1 x)\n                              (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n                            h)⟩)\n                  fun h => Eq.refl pt))\n          (dite_cond_eq_true ⋯)))\n      ⋯)","type":"∀ {Y : (↑Ω₀ : Type)} {x : X}, x ∈ (↑Y : Set X) \\ {x₀} → (↑(F Y x) : Set X) = {y | y ∈ (↑Y : Set X) ∧ y < x}","name":["hF"],"isProp":true,"id":["_uniq",664494]},{"value":"{Y | ∀ x ∈ (↑Y : Set X) \\ {x₀}, x = s (F Y x)}","type":"Set (↑Ω₀ : Type)","name":["Ω"],"isProp":false,"id":["_uniq",684489]},{"value":"sorry","type":"pt ∈ Ω","name":["hΩ"],"isProp":true,"id":["_uniq",684711]},{"value":"fun {Y Y'} x h => sorry","type":"∀ {Y Y' : (↑Ω : Type)},\n  ∀ x ∈ (↑(↑Y' : (↑Ω₀ : Type)) : Set X) \\ (↑(↑Y : (↑Ω₀ : Type)) : Set X),\n    IsStrictUpperBound (↑(↑Y : (↑Ω₀ : Type)) : Set X) x","name":["ex_8_5_13"],"isProp":true,"id":["_uniq",685361]},{"value":"id\n  (Decidable.byContradiction fun this =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun x => ∀ (y : (↑Ω : Type)), x ≤ y ∨ y ≤ x)\n          (congrArg Exists\n            (funext fun x =>\n              Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun y => x ≤ y ∨ y ≤ x)\n                (congrArg Exists (funext fun y => Mathlib.Tactic.PushNeg.not_or_eq (x ≤ y) (y ≤ x))))))\n        this)\n      fun w h =>\n      Subtype.casesOn (motive := fun x => (∃ y, ¬x ≤ y ∧ ¬y ≤ x) → False) w\n        (fun val hY2 h =>\n          Subtype.casesOn (motive := fun x => ∀ (hY2 : x ∈ Ω), (∃ y, ¬⟨x, hY2⟩ ≤ y ∧ ¬y ≤ ⟨x, hY2⟩) → False) val\n            (fun Y hY1 hY2 h =>\n              Exists.casesOn h fun w h =>\n                Subtype.casesOn (motive := fun x => ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ x ∧ ¬x ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) w\n                  (fun val hY'2 h =>\n                    Subtype.casesOn (motive := fun x =>\n                      ∀ (hY'2 : x ∈ Ω), ¬⟨⟨Y, hY1⟩, hY2⟩ ≤ ⟨x, hY'2⟩ ∧ ¬⟨x, hY'2⟩ ≤ ⟨⟨Y, hY1⟩, hY2⟩ → False) val\n                      (fun Y' hY'1 hY'2 h =>\n                        And.casesOn h fun h1 h2 =>\n                          (fun x₁ x =>\n                              (fun x₂ x_1 =>\n                                  ne_of_lt\n                                    (Eq.mp (partialOrder._simp_3 Y x₂)\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (forall_congr fun {Y} =>\n                                              Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y'} =>\n                                                    forall_congr fun x => Eq.trans (implies_congr ⋯ ⋯) and_imp._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                            Subtype.forall._simp_1)\n                                          Subtype.forall._simp_1)\n                                        ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                      x₁ x.left)\n                                    (le_antisymm\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y x₂)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y hY1 hY2 Y' hY'1 hY'2 x₂ x_1.left x_1.right)\n                                            x₁ x.left))\n                                        (le_refl x₂))\n                                      (le_trans\n                                        (le_of_lt\n                                          (Eq.mp (partialOrder._simp_3 Y' x₁)\n                                            (Eq.mp\n                                              (Eq.trans\n                                                (Eq.trans\n                                                  (forall_congr fun {Y} =>\n                                                    Eq.trans\n                                                      (Eq.trans (forall_congr fun {Y'} => forall_congr ⋯)\n                                                        Subtype.forall._simp_1)\n                                                      Subtype.forall._simp_1)\n                                                  Subtype.forall._simp_1)\n                                                Subtype.forall._simp_1)\n                                              ex_8_5_13 Y' hY'1 hY'2 Y hY1 hY2 x₁ x.left x.right)\n                                            x₂ x_1.left))\n                                        (le_refl x₁))))\n                                (Classical.choose\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2))\n                                (Classical.choose_spec\n                                  (Eq.mp\n                                    (Eq.trans\n                                      (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                      partialOrder._simp_2)\n                                    h2)))\n                            (Classical.choose\n                              (Eq.mp\n                                (Eq.trans (congrArg Not (Eq.trans Subtype.mk_le_mk._simp_1 Subtype.mk_le_mk._simp_1))\n                                  partialOrder._simp_2)\n                                h1))\n                            (Classical.choose_spec ⋯))\n                      ⋯ ⋯)\n                  ⋯)\n            ⋯ ⋯)\n        ⋯)","type":"IsTotal (↑Ω : Type)","name":["this"],"isProp":true,"id":["_uniq",685636]},{"value":"⋃ Y, (↑(↑Y : (↑Ω₀ : Type)) : Set X)","type":"Set X","name":["Y_infty"],"isProp":false,"id":["_uniq",908527]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (Eq.trans\n        (congrArg (fun x => x₀ ∈ x)\n          (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n            (Eq.trans\n              (Eq.trans\n                (congrArg Set.iUnion\n                  (funext fun i => Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n              (congrArg Set.iUnion\n                (funext fun i =>\n                  Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                    Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω))) fun x =>\n                      Eq.refl i)))))\n        Set.mem_iUnion._simp_1)\n      (congrArg Exists\n        (funext fun i =>\n          Eq.trans Set.mem_iUnion._simp_1\n            (Eq.trans\n              (propext\n                (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                  (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n              exists_and_right._simp_1)))))\n  (Exists.intro (↑pt : Set X) (partialOrder._proof_7 ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))","type":"x₀ ∈ Y_infty","name":["hmem"],"isProp":true,"id":["_uniq",908794]},{"value":"fun {x} hx => sorry","type":"∀ {x : X}, x ∈ Y_infty → x₀ ≤ x","name":["hmin"],"isProp":true,"id":["_uniq",952397]},{"value":"fun h =>\n  match h with\n  | ⋯ => fun h =>\n    match h with\n    | ⋯ =>\n      Exists.casesOn\n        (Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x_1 => x ∈ x_1)\n                (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                  (Eq.trans\n                    (Eq.trans\n                      (congrArg Set.iUnion\n                        (funext fun i =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                      (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                          Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                            fun x => Eq.refl i)))))\n              Set.mem_iUnion._simp_1)\n            (congrArg Exists\n              (funext fun i =>\n                Eq.trans Set.mem_iUnion._simp_1\n                  (Eq.trans\n                    (propext\n                      (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                        (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                    exists_and_right._simp_1))))\n          hx)\n        fun Y h =>\n        And.casesOn h fun left hxY =>\n          Exists.casesOn left fun hYΩ₀ hYΩ =>\n            Exists.casesOn\n              (Eq.mp\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => x' ∈ x)\n                      (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                        (Eq.trans\n                          (Eq.trans\n                            (congrArg Set.iUnion\n                              (funext fun i =>\n                                Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                            (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                          (congrArg Set.iUnion (funext ⋯)))))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯","type":"IsTotal (↑Y_infty : Type)","name":["htotal"],"isProp":true,"id":["_uniq",952634]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (iff' htotal)))) fun A h =>\n  match h with\n  | ⋯ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans\n            (congrArg (fun x => a ∈ x)\n              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg Set.iUnion\n                      (funext fun i =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω))) fun x => Eq.refl (↑i : Set X)))\n                    (Set.iUnion_coe_set Ω₀ fun i => ⋃ (_ : i ∈ Ω), (↑i : Set X)))\n                  (congrArg Set.iUnion\n                    (funext fun i =>\n                      Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (i ∈ Ω₀))) fun x =>\n                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⟨i, (Iff.of_eq (Eq.refl (i ∈ Ω₀))).mpr x⟩ ∈ Ω)))\n                          fun x => Eq.refl i)))))\n            Set.mem_iUnion._simp_1)\n          (congrArg Exists\n            (funext fun i =>\n              Eq.trans Set.mem_iUnion._simp_1\n                (Eq.trans\n                  (propext\n                    (exists_prop_congr (fun h => Iff.of_eq (Eq.trans Set.mem_iUnion._simp_1 exists_prop._simp_1))\n                      (Iff.of_eq (Eq.refl (i ∈ Ω₀)))))\n                  exists_and_right._simp_1))))\n        ha)\n      fun Y h =>\n      And.casesOn h fun left haY =>\n        Exists.casesOn left fun hYΩ₀ hYΩ =>\n          (fun b x =>\n              (fun hb x =>\n                  (fun hbY hbmin =>\n                      (fun hbY_infty hbA =>\n                          Eq.mpr\n                            (id (congrArg (fun _a => _a) (propext (IsMin.iff_lowerbound' (IsTotal.subtype htotal)))))\n                            (Exists.intro ⟨b, hbY_infty⟩\n                              ⟨hbA, fun h =>\n                                match h with\n                                | ⋯ => fun hxA =>\n                                  Eq.mpr (id Subtype.mk_le_mk._simp_1)\n                                    (Exists.casesOn\n                                      (Eq.mp\n                                        (Eq.trans\n                                          (Eq.trans\n                                            (congrArg (fun x_1 => x ∈ x_1)\n                                              (Eq.trans (Set.iUnion_coe_set Ω fun i => (↑(↑i : (↑Ω₀ : Type)) : Set X))\n                                                (Eq.trans\n                                                  (Eq.trans\n                                                    (congrArg Set.iUnion\n                                                      (funext fun i =>\n                                                        Set.iUnion_congr_Prop (Iff.of_eq (Eq.refl (⋯ ∈ ⋯))) ⋯))\n                                                    ⋯)\n                                                  ⋯)))\n                                            ⋯)\n                                          ⋯)\n                                        ⋯)\n                                      ⋯)⟩))\n                        ⋯ ⋯)\n                    ⋯ ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯","type":"WellFoundedLT (↑Y_infty : Type)","name":["hwell"],"isProp":true,"id":["_uniq",1053095]},{"value":"sorry","type":"Y_infty ∈ Ω₀","name":["hY_inftyΩ₀"],"isProp":true,"id":["_uniq",1270592]},{"value":"s ⟨Y_infty, hY_inftyΩ₀⟩","type":"X","name":["sY_infty"],"isProp":false,"id":["_uniq",1270609]},{"value":"sorry","type":"IsTotal (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_total"],"isProp":true,"id":["_uniq",1271133]},{"value":"sorry","type":"WellFoundedLT (↑(Y_infty ∪ {sY_infty}) : Type)","name":["hYs_well"],"isProp":true,"id":["_uniq",1271426]},{"value":"sorry","type":"x₀ ∈ Y_infty ∪ {sY_infty}","name":["hYs_mem"],"isProp":true,"id":["_uniq",1271572]},{"value":"sorry","type":"∀ x ∈ Y_infty ∪ {sY_infty}, x₀ ≤ x","name":["hYs_min"],"isProp":true,"id":["_uniq",1271741]},{"value":"Eq.mpr\n  (id\n    (Eq.trans\n      (congr (congrArg And (eq_true hYs_total))\n        (Eq.trans\n          (congr (congrArg And (eq_true hYs_well))\n            (Eq.trans\n              (congr (congrArg And (eq_true hYs_mem))\n                (forall_congr fun x =>\n                  implies_congr\n                    (Eq.trans (Set.mem_union._simp_1 x Y_infty {sY_infty})\n                      (congrArg (Or (x ∈ Y_infty)) Set.mem_singleton_iff._simp_1))\n                    (Eq.refl (x₀ ≤ x))))\n              (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n          (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n      (true_and (∀ (x : X), x ∈ Y_infty ∨ x = sY_infty → x₀ ≤ x))))\n  hYs_min","type":"Y_infty ∪ {sY_infty} ∈ Ω₀","name":["hYs_Ω₀"],"isProp":true,"id":["_uniq",1271889]},{"type":"∀ y ∈ Y_infty, y < s ⟨Y_infty, hY_inftyΩ₀⟩","name":["hs"],"isProp":true,"id":["_uniq",1279575],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congr\n      (congrArg (fun x => Membership.mem (setOf x))\n        (funext fun Y =>\n          forall_congr fun x =>\n            implies_congr\n              (Eq.trans (Set.mem_diff._simp_1 x)\n                (congrArg (fun x_1 => x ∈ (↑Y : Set X) ∧ ¬x_1) Set.mem_singleton_iff._simp_1))\n              (Eq.refl (x = s (F Y x)))))\n      ((fun {α} {p} val val_1 e_val =>\n          Eq.rec (motive := fun val_2 e_val => ∀ (property : p val), ⟨val, property⟩ = ⟨val_2, e_val ▸ property⟩)\n            (fun property => Eq.refl ⟨val, property⟩) e_val)\n        (Y_infty ∪ {sY_infty}) (insert sY_infty Y_infty) Set.union_singleton hYs_Ω₀)))\n  fun x a =>\n  And.casesOn a fun left hxx₀ =>\n    Or.casesOn left\n      (fun h =>\n        Eq.ndrec (motive := fun x => ¬x = x₀ → x = s (F ⟨insert sY_infty Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩ x))\n          (fun hxx₀ =>\n            id\n              ((fun a a_1 e_a => e_a ▸ Eq.refl (s a)) ⟨Y_infty, hY_inftyΩ₀⟩\n                (F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩ (s ⟨Y_infty, hY_inftyΩ₀⟩))\n                (Eq.symm\n                  (Subtype.val_injective\n                    (Eq.mpr\n                      (eq_of_heq\n                        ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                  (fun e_2 h =>\n                                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                      e'_3\n                                      (fun h =>\n                                        Eq.ndrec (motive := fun a' =>\n                                          ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                          (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                      (Eq.refl a'_1) (HEq.refl e'_3))\n                                  (Eq.symm h) e'_2)\n                              (Eq.refl a') (HEq.refl e'_2))\n                          (Set X)\n                          (↑(F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩\n                                (s ⟨Y_infty, hY_inftyΩ₀⟩)) :\n                            Set X)\n                          (↑(F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩\n                                (s ⟨Y_infty, hY_inftyΩ₀⟩)) :\n                            Set X)\n                          (Eq.refl\n                            (↑(F ⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩\n                                  (s ⟨Y_infty, hY_inftyΩ₀⟩)) :\n                              Set X))\n                          (↑⟨Y_infty, hY_inftyΩ₀⟩ : Set X)\n                          {y |\n                            y ∈ (↑⟨insert (s ⟨Y_infty, hY_inftyΩ₀⟩) Y_infty, Set.union_singleton ▸ hYs_Ω₀⟩ : Set X) ∧\n                              y < s ⟨Y_infty, hY_inftyΩ₀⟩}\n                          (Set.ext fun x =>\n                            Eq.mpr (id (congrArg (fun x_1 => x ∈ Y_infty ↔ x ∈ setOf x_1) (funext ⋯))) ⋯)))\n                      ⋯)))))\n          ⋯ ⋯)\n      ⋯","type":"⟨Y_infty ∪ {sY_infty}, hYs_Ω₀⟩ ∈ Ω","name":["hYs_Ω"],"isProp":true,"id":["_uniq",1279682]},{"value":"Set.mem_iUnion_of_mem ⟨⟨Y_infty ∪ {sY_infty}, hYs_Ω₀⟩, hYs_Ω⟩\n  (of_eq_true\n    (Eq.trans (Eq.trans (congrArg (fun x => sY_infty ∈ x) Set.union_singleton) Set.mem_insert_iff._simp_1)\n      (Eq.trans (congrArg (fun x => x ∨ sY_infty ∈ Y_infty) (eq_self sY_infty)) (true_or (sY_infty ∈ Y_infty)))))","type":"sY_infty ∈ Y_infty","name":["hs_mem"],"isProp":true,"id":["_uniq",1433097]}]}],"start":14150},{"state":[],"start":14182},{"state":[],"start":14183},{"state":[],"start":14184},{"state":[],"start":14237},{"state":[],"start":14296},{"state":[{"type":"∃ x, IsMax x","tag":[],"mvarId":["_uniq",1437807],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1437803],"binderInfo":"implicit"},{"type":"PartialOrder X","name":["inst✝¹"],"isProp":false,"id":["_uniq",1437804],"binderInfo":"instImplicit"},{"type":"Nonempty X","name":["inst✝"],"isProp":true,"id":["_uniq",1437805],"binderInfo":"instImplicit"},{"type":"∀ (Y : Set X), IsTotal (↑Y : Type) ∧ Y.Nonempty → ∃ x, IsUpperBound Y x","name":["hchain"],"isProp":true,"id":["_uniq",1437806],"binderInfo":"default"}]}],"start":14399},{"state":[],"start":14407},{"state":[],"start":14408},{"state":[],"start":14430},{"state":[{"type":"Decidable (∃ h, LE.le = LE.le)","tag":[],"mvarId":["_uniq",1437843],"isProp":false,"context":[{"type":"LE Empty","name":["h₀"],"isProp":false,"id":["_uniq",1437842],"binderInfo":"instImplicit"}]}],"start":14538},{"state":[],"start":14546},{"state":[],"start":14547},{"state":[{"type":"Decidable (∃ h, LE.le = LE.le)","tag":[],"mvarId":["_uniq",1437990],"isProp":false,"context":[{"type":"LE Empty","name":["h₀"],"isProp":false,"id":["_uniq",1437989],"binderInfo":"instImplicit"}]}],"start":14653},{"state":[],"start":14661},{"state":[],"start":14662},{"state":[{"type":"Decidable (Nonempty (WellFoundedLT Empty))","tag":[],"mvarId":["_uniq",1438092],"isProp":false,"context":[{"type":"LT Empty","name":["h₀"],"isProp":false,"id":["_uniq",1438091],"binderInfo":"instImplicit"}]}],"start":14754},{"state":[],"start":14762},{"state":[],"start":14763},{"state":[],"start":14785},{"state":[],"start":14954},{"state":[],"start":14955},{"state":[],"start":15124},{"state":[],"start":15125},{"state":[],"start":15294},{"state":[],"start":15295},{"state":[],"start":15317},{"state":[],"start":15411},{"state":[],"start":15412},{"state":[],"start":15508},{"state":[],"start":15509},{"state":[],"start":15531},{"state":[],"start":15588},{"state":[],"start":15589},{"state":[],"start":15611},{"state":[],"start":15743},{"state":[],"start":15744},{"state":[{"type":"Decidable (∀ (X Y : Type) (h : LinearOrder Y) (f : X → Y), ∃ h₀, LE.le = fun x y => f x < f y ∨ x = y)","tag":[],"mvarId":["_uniq",1439309],"isProp":false,"context":[]}],"start":15895},{"state":[],"start":15903},{"state":[],"start":15904},{"state":[],"start":16020},{"state":[],"start":16021},{"state":[],"start":16043},{"state":[],"start":16130},{"state":[],"start":16131},{"state":[],"start":16206},{"state":[],"start":16243},{"state":[],"start":16264},{"state":[],"start":16287},{"state":[],"start":16311},{"state":[],"start":16338},{"state":[],"start":16342},{"state":[],"start":16343},{"state":[],"start":16365},{"state":[{"type":"x = y","tag":[],"mvarId":["_uniq",1442563],"isProp":true,"context":[{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",1442557],"binderInfo":"implicit"},{"type":"PartialOrder Y","name":["inst✝"],"isProp":false,"id":["_uniq",1442558],"binderInfo":"instImplicit"},{"type":"Y","name":["x"],"isProp":false,"id":["_uniq",1442559],"binderInfo":"implicit"},{"type":"Y","name":["y"],"isProp":false,"id":["_uniq",1442560],"binderInfo":"implicit"},{"type":"IsMin x","name":["hx"],"isProp":true,"id":["_uniq",1442561],"binderInfo":"default"},{"type":"IsMin y","name":["hy"],"isProp":true,"id":["_uniq",1442562],"binderInfo":"default"}]}],"start":16449},{"state":[],"start":16457},{"state":[],"start":16458},{"state":[{"type":"x = y","tag":[],"mvarId":["_uniq",1442738],"isProp":true,"context":[{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",1442732],"binderInfo":"implicit"},{"type":"PartialOrder Y","name":["inst✝"],"isProp":false,"id":["_uniq",1442733],"binderInfo":"instImplicit"},{"type":"Y","name":["x"],"isProp":false,"id":["_uniq",1442734],"binderInfo":"implicit"},{"type":"Y","name":["y"],"isProp":false,"id":["_uniq",1442735],"binderInfo":"implicit"},{"type":"IsMax x","name":["hx"],"isProp":true,"id":["_uniq",1442736],"binderInfo":"default"},{"type":"IsMax y","name":["hy"],"isProp":true,"id":["_uniq",1442737],"binderInfo":"default"}]}],"start":16542},{"state":[],"start":16549},{"state":[],"start":16550},{"state":[],"start":16572},{"state":[],"start":16736},{"state":[],"start":16737},{"state":[],"start":16738},{"state":[],"start":16862},{"state":[],"start":16975},{"state":[],"start":17003},{"state":[],"start":17030},{"state":[],"start":17031},{"state":[],"start":17140},{"state":[],"start":17219},{"state":[],"start":17241},{"state":[],"start":17267},{"state":[],"start":17290},{"state":[],"start":17292},{"state":[],"start":17293},{"state":[],"start":17404},{"state":[],"start":17405},{"state":[],"start":17513},{"state":[],"start":17557},{"state":[],"start":17558},{"state":[],"start":17559},{"state":[],"start":17572},{"state":[],"start":17572}]
