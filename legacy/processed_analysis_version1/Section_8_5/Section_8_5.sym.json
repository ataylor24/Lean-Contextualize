[{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lattice","toSemilatticeInf"],["Lean","Name"],["Set"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Subtype","partialOrder"],["OfNat","ofNat"],["Set","Elem"],["Set","instMembership"],["instDistribLatticeOfLinearOrder"],["Nat"],["DistribLattice","toLattice"],["instOfNatNat"],["Lean","Name","num"],["Chapter8","IsTotal"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["Set"],["Membership","mem"],["LinearOrder"],["Subtype","partialOrder"],["Chapter8","IsTotal"],["Set","Elem"],["Set","instMembership"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {X : Type} [inst : LinearOrder X] (A : Set X), Chapter8.IsTotal A.Elem","name":["Chapter8","LinearOrder","subtype","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[],"type":"Type → Type","name":["Chapter8","Lex'"],"kind":"definition","isProp":false},{"valueReferences":[["Preorder","le_trans"],["PartialOrder","toPreorder"]],"typeReferences":[["PartialOrder","toPreorder"],["PartialOrder"],["LE","le"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X] (a b c : X), inst.le a b → inst.le b c → inst.le a c","name":["Chapter8","LinearOrder","mk","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["instOfNatNat"],["Set"],["Singleton","singleton"],["Insert","insert"],["Set","instInsert"],["Set","instSingletonSet"],["OfNat","ofNat"]],"typeReferences":[["Nat"],["Set"]],"type":"Set (Set Nat)","name":["Chapter8","X_8_5_4"],"kind":"definition","isProp":false},{"valueReferences":[["PartialOrder","toPreorder"],["Preorder","le_refl"]],"typeReferences":[["PartialOrder","toPreorder"],["PartialOrder"],["LE","le"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X] (a : X), inst.le a a","name":["Chapter8","LinearOrder","mk","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","instHasSubset"],["Not"],["Exists"],["HasSubset","Subset"],["Set"],["Set","not_subset"],["Membership","mem"],["And"],["propext"],["Set","instMembership"]],"typeReferences":[["Set","instHasSubset"],["Not"],["Exists"],["HasSubset","Subset"],["Set"],["Membership","mem"],["And"],["Eq"],["Set","instMembership"]],"type":"∀ {α : Type u} {s t : Set α},\n  Eq (Not (Set.instHasSubset.Subset s t))\n    (Exists fun a => And (Set.instMembership.mem s a) (Not (Set.instMembership.mem t a)))","name":["Chapter8","WellFoundedLT","partialOrder","_simp_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["PartialOrder","toPreorder"],["Singleton","singleton"],["Membership","mem"],["Preorder","toLT"],["Classical","propDecidable"],["Subtype","partialOrder"],["Subtype","val"],["Subtype","property"],["Chapter8","IsTotal"],["Preorder","toLE"],["Eq"],["Set","decidableSingleton"],["Set","instSDiff"],["Set"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Set","instMembership"],["LT","lt"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["Std","instLTSubtype"],["dite"],["setOf"]],"typeReferences":[["Subtype"],["PartialOrder","toPreorder"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Preorder","toLT"],["Subtype","partialOrder"],["Subtype","val"],["PartialOrder"],["Eq"],["Chapter8","IsTotal"],["Preorder","toLE"],["Set","decidableSingleton"],["Set","instSDiff"],["Not"],["Exists"],["Set"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_9"],["Set","instMembership"],["LT","lt"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["Std","instLTSubtype"],["dite"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X),\n  (∀ (Y : Set X),\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        Exists fun x => And (∀ (y : X), Set.instMembership.mem Y y → inst.le y x) (Not (Set.instMembership.mem Y x))) →\n    ∀\n      (hpt :\n        Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          (Set.instSingletonSet.singleton x₀))\n      (hF :\n        ∀ {Y : Set X},\n          Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                  (And\n                    (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 =>\n                      Std.instLTSubtype.lt x1 x2)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              Y →\n            ∀ {x : X},\n              Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n                Set.instMembership.mem\n                  (setOf fun Y =>\n                    And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                      (And\n                        (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 =>\n                          Std.instLTSubtype.lt x1 x2)\n                        (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                  (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x)))\n      (Y :\n        Subtype fun x =>\n          Set.instMembership.mem\n            (setOf fun Y =>\n              And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                (And\n                  (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                  (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n            x)\n      (x : X),\n      Exists fun x_1 =>\n        And\n          (∀ (y : X),\n            Set.instMembership.mem\n                (if hxy : Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x then\n                    ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                  else ⟨Set.instSingletonSet.singleton x₀, hpt⟩).val\n                y →\n              inst.le y x_1)\n          (Not\n            (Set.instMembership.mem\n              (if hxy : Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x then\n                  ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                else ⟨Set.instSingletonSet.singleton x₀, hpt⟩).val\n              x_1))","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_10"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Set"],["Membership","mem"],["Exists","intro"],["Set","Elem"],["Set","instMembership"],["Exists","casesOn"],["Std","instLESubtype"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["LE","le"],["Subtype","casesOn"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["Exists"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Set"],["Membership","mem"],["LinearOrder"],["Exists","intro"],["Set","Elem"],["Set","instMembership"],["Std","instLESubtype"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["LE","le"],["Subtype","mk"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"type":"∀ (X : Type) [inst : LinearOrder X] (A : Set X)\n  (motive : (Exists fun x => ∀ ⦃b : A.Elem⦄, Std.instLESubtype.le b x → Std.instLESubtype.le x b) → Prop)\n  (h : Exists fun x => ∀ ⦃b : A.Elem⦄, Std.instLESubtype.le b x → Std.instLESubtype.le x b),\n  (∀ (x : X) (hx : Set.instMembership.mem A x)\n      (h : ∀ ⦃b : A.Elem⦄, Std.instLESubtype.le b ⟨x, hx⟩ → Std.instLESubtype.le ⟨x, hx⟩ b), motive ⋯) →\n    motive h","name":["Chapter8","WellFoundedLT","iff","match_1_5"],"kind":"definition","isProp":true},{"valueReferences":[["Chapter8","IsUpperBound","iff"],["Chapter8","IsUpperBound"],["PartialOrder","toPreorder"],["upperBounds"],["Set"],["Membership","mem"],["Preorder","toLE"],["propext"],["Set","instMembership"]],"typeReferences":[["Chapter8","IsUpperBound"],["PartialOrder","toPreorder"],["upperBounds"],["Set"],["PartialOrder"],["Membership","mem"],["Preorder","toLE"],["Eq"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] (A : Set X) (x : X),\n  Eq (Chapter8.IsUpperBound A x) (Set.instMembership.mem (upperBounds A) x)","name":["Chapter8","IsStrictUpperBound","iff'","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["LE","le"],["And"],["Iff","rfl"]],"typeReferences":[["Not"],["Iff"],["LE","le"],["And"],["LE"]],"type":"∀ {X : Type} [inst : LE X] (a b : X),\n  Iff (And (inst.le a b) (Not (inst.le b a))) (And (inst.le a b) (Not (inst.le b a)))","name":["Chapter8","PartialOrder","mk","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Preorder","toLT"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Set","iUnion"],["Union","union"],["Classical","choose"],["Subtype","val"],["Or"],["Lean","Grind","eq_false_of_imp_eq_true"],["forall_congr"],["Eq","symm"],["Lean","Grind","not_eq_of_eq_true"],["Chapter8","IsTotal"],["Set","instUnion"],["Set","instSDiff"],["Exists"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["True","intro"],["Lean","Grind","nestedProof"],["Set","instMembership"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_9"],["Lean","Grind","and_eq_of_eq_false_right"],["Set","instCompleteAtomicBooleanAlgebra"],["Eq","refl"],["Classical","byContradiction"],["setOf"],["CompleteLattice","instOmegaCompletePartialOrder"],["Lean","Grind","not_and"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["OmegaCompletePartialOrder","toPartialOrder"],["Lean","Grind","not_or"],["Subtype","partialOrder"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Subtype","property"],["Eq"],["Preorder","toLE"],["Lean","Grind","or_eq_of_eq_false_left"],["Set","decidableSingleton"],["Not"],["Lean","Grind","forall_and"],["True"],["Set"],["Set","instSingletonSet"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_15"],["LT","lt"],["LE","le"],["SDiff","sdiff"],["False"],["Lean","Grind","intro_with_eq"],["Subtype","mk"],["Std","instLTSubtype"],["dite"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_10"],["And","casesOn"]],"typeReferences":[["CompleteLattice","instOmegaCompletePartialOrder"],["PartialOrder","toPreorder"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Singleton","singleton"],["OmegaCompletePartialOrder","toPartialOrder"],["Membership","mem"],["Classical","propDecidable"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","iUnion"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["Set","Elem"],["Or"],["PartialOrder"],["Subtype","property"],["WellFoundedLT"],["Set","instUnion"],["Chapter8","IsTotal"],["Preorder","toLE"],["Eq"],["Set","decidableSingleton"],["Chapter8","IsStrictUpperBound"],["Set","instSDiff"],["Not"],["Exists"],["Set"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Exists","choose"],["Set","instMembership"],["LT","lt"],["Set","instCompleteAtomicBooleanAlgebra"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["dite"],["Std","instLTSubtype"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X)\n  (hs :\n    ∀ (Y : Set X),\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        Exists fun x => Chapter8.IsStrictUpperBound Y x)\n  (hpt :\n    Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal Y.Elem)\n          (And (WellFoundedLT Y.Elem)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      (Set.instSingletonSet.singleton x₀))\n  (hF :\n    ∀ {Y : Set X},\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        ∀ {x : X},\n          Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n            Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal Y.Elem)\n                  (And (WellFoundedLT Y.Elem)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x))),\n  (∀\n      {Y Y' :\n        (setOf fun Y =>\n            ∀ (x : X),\n              Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                Eq x\n                  ((fun Y => ⋯.choose)\n                    ((fun Y x =>\n                        if hxy :\n                            Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀))\n                              x then\n                          ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                        else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                      Y x))).Elem}\n      (x : X),\n      Set.instMembership.mem (Set.instSDiff.sdiff Y'.val.val Y.val.val) x → Chapter8.IsStrictUpperBound Y.val.val x) →\n    Chapter8.IsTotal\n        (setOf fun Y =>\n            ∀ (x : X),\n              Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                Eq x\n                  ((fun Y => ⋯.choose)\n                    ((fun Y x =>\n                        if hxy :\n                            Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀))\n                              x then\n                          ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                        else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                      Y x))).Elem →\n      Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x₀ →\n        (∀ {x : X}, Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x → inst.le x₀ x) →\n          Chapter8.IsTotal (Set.iUnion fun Y => Y.val.val).Elem →\n            WellFoundedLT (Set.iUnion fun Y => Y.val.val).Elem →\n              ∀\n                (hY_inftyΩ₀ :\n                  Set.instMembership.mem\n                    (setOf fun Y =>\n                      And (Chapter8.IsTotal Y.Elem)\n                        (And (WellFoundedLT Y.Elem)\n                          (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                    (Set.iUnion fun Y => Y.val.val)),\n                Chapter8.IsTotal\n                    (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                        (Set.instSingletonSet.singleton\n                          ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))).Elem →\n                  WellFoundedLT\n                      (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                          (Set.instSingletonSet.singleton\n                            ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))).Elem →\n                    Set.instMembership.mem\n                        (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                          (Set.instSingletonSet.singleton\n                            ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)))\n                        x₀ →\n                      (∀ (x : X),\n                          Set.instMembership.mem\n                              (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                                (Set.instSingletonSet.singleton\n                                  ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)))\n                              x →\n                            inst.le x₀ x) →\n                        Set.instMembership.mem\n                            (setOf fun Y =>\n                              And (Chapter8.IsTotal Y.Elem)\n                                (And (WellFoundedLT Y.Elem)\n                                  (And (Set.instMembership.mem Y x₀)\n                                    (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                            (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                              (Set.instSingletonSet.singleton\n                                ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))) →\n                          (∀ (y : X),\n                              Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) y →\n                                inst.lt y ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)) →\n                            Not (Eq ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩) x₀) →\n                              ∀ (x : X),\n                                Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x →\n                                  And\n                                    (Or (Eq x ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))\n                                      (Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x))\n                                    (inst.lt x ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_16"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["PartialOrder","toPreorder"],["Subtype"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["Exists","intro"],["Subtype","partialOrder"],["eq_true"],["Set","Elem"],["Iff","intro"],["congrArg"],["Subtype","mk_le_mk","_simp_1"],["Std","instLESubtype"],["IsMin"],["Or"],["congr"],["forall_congr"],["Preorder","toLE"],["Eq"],["forall_imp"],["And","left"],["Exists"],["True"],["Set"],["And"],["true_and"],["Set","instMembership"],["Exists","casesOn"],["Or","casesOn"],["of_eq_true"],["Subtype","forall","_simp_1"],["LE","le"],["id"],["Eq","mpr"],["Subtype","mk"]],"typeReferences":[["PartialOrder","toPreorder"],["Exists"],["Subtype"],["Set"],["Membership","mem"],["And"],["Subtype","partialOrder"],["Set","Elem"],["Set","instMembership"],["Std","instLESubtype"],["IsMin"],["PartialOrder"],["Iff"],["LE","le"],["Subtype","mk"],["Chapter8","IsTotal"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X] {Y : Set X},\n  Chapter8.IsTotal Y.Elem →\n    ∀ (x₀ : X),\n      Iff (Exists fun hx₀ => IsMin ⟨x₀, hx₀⟩)\n        (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))","name":["Chapter8","IsMin","iff_lowerbound"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","univ"],["Set","image"],["PartialOrder","toPreorder"],["Set"],["Set","Iic"]],"typeReferences":[["Set"],["PartialOrder"]],"type":"(X : Type) → [PartialOrder X] → Set (Set X)","name":["Chapter8","OrderIdeals"],"kind":"definition","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["PartialOrder","toPreorder"],["Decidable"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["PartialOrder"],["LE","le"],["Empty"],["Lean","Name","num"],["Eq"],["Preorder","toLE"]],"typeReferences":[["PartialOrder","toPreorder"],["Exists"],["Decidable"],["PartialOrder"],["LE","le"],["Empty"],["LE"],["Preorder","toLE"],["Eq"]],"type":"[h₀ : LE Empty] → Decidable (Exists fun h => Eq h.le h₀.le)","name":["Chapter8","empty_set_partial_order"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Set"],["Membership","mem"],["And"],["Preorder","toLT"],["Exists","intro"],["Set","instMembership"],["Exists","casesOn"],["LT","lt"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["And","casesOn"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["Not"],["Exists"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Set"],["Membership","mem"],["LinearOrder"],["And"],["Preorder","toLT"],["Exists","intro"],["Set","instMembership"],["LT","lt"],["And","intro"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["SemilatticeInf","toPartialOrder"]],"type":"∀ (X : Type) [inst : LinearOrder X] (A : Set X)\n  (motive :\n    (Exists fun m =>\n        And (Set.instMembership.mem A m)\n          (∀ (x : X), Set.instMembership.mem A x → Not (instDistribLatticeOfLinearOrder.toSemilatticeInf.lt x m))) →\n      Prop)\n  (h :\n    Exists fun m =>\n      And (Set.instMembership.mem A m)\n        (∀ (x : X), Set.instMembership.mem A x → Not (instDistribLatticeOfLinearOrder.toSemilatticeInf.lt x m))),\n  (∀ (x : X) (hxA : Set.instMembership.mem A x)\n      (h : ∀ (x_1 : X), Set.instMembership.mem A x_1 → Not (instDistribLatticeOfLinearOrder.toSemilatticeInf.lt x_1 x)),\n      motive ⋯) →\n    motive h","name":["Chapter8","WellFoundedLT","iff","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["Lattice","toSemilatticeInf"],["sorryAx"],["Exists"],["PartialOrder","toPreorder"],["Decidable"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["LinearOrder"],["Preorder","toLT"],["OfNat","ofNat"],["LT","lt"],["instDistribLatticeOfLinearOrder"],["LinearOrder","toPartialOrder"],["Nat"],["DistribLattice","toLattice"],["Or"],["instOfNatNat"],["LE","le"],["Lean","Name","num"],["Eq"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["Exists"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Decidable"],["LinearOrder"],["Preorder","toLT"],["LT","lt"],["instDistribLatticeOfLinearOrder"],["LinearOrder","toPartialOrder"],["DistribLattice","toLattice"],["Or"],["LE","le"],["Eq"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"type":"Decidable\n  (∀ (X Y : Type) (h : LinearOrder Y) (f : X → Y),\n    Exists fun h₀ => Eq h₀.le fun x y => Or (instDistribLatticeOfLinearOrder.toSemilatticeInf.lt (f x) (f y)) (Eq x y))","name":["Chapter8","Ex_8_5_5_b"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["Lean","Grind","not_true"],["PartialOrder","toPreorder"],["Exists"],["Eq","trans"],["True"],["Preorder","toLT"],["Lean","Grind","not_exists"],["congrArg"],["LT","lt"],["eq_self"],["Lean","Grind","iff_eq"],["False","casesOn"],["Iff"],["Classical","byContradiction"],["False"],["Lean","Grind","intro_with_eq"],["Eq"]],"typeReferences":[["LT","lt"],["Not"],["Exists"],["PartialOrder","toPreorder"],["Iff"],["PartialOrder"],["Preorder","toLT"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x : X), Iff (∀ (b : X), Not (inst.lt x b)) (Not (Exists fun y => inst.lt x y))","name":["Chapter8","IsMax","iff","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Preorder","toLT"],["OfNat","ofNat"],["instDistribLatticeOfLinearOrder"],["Nat"],["DistribLattice","toLattice"],["instOfNatNat"],["WellFoundedLT"],["Lean","Name","num"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["WellFoundedLT"],["Preorder","toLT"],["LinearOrder"],["Finite"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {X : Type} [inst : LinearOrder X] [Finite X], WellFoundedLT X","name":["Chapter8","WellFoundedLT","ofFinite"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Lean","Grind","not_true"],["PartialOrder","toPreorder"],["Exists"],["Eq","trans"],["True"],["Preorder","toLT"],["Lean","Grind","not_exists"],["congrArg"],["LT","lt"],["eq_self"],["Lean","Grind","iff_eq"],["False","casesOn"],["Iff"],["Classical","byContradiction"],["False"],["Lean","Grind","intro_with_eq"],["Eq"]],"typeReferences":[["LT","lt"],["Not"],["Exists"],["PartialOrder","toPreorder"],["Iff"],["PartialOrder"],["Preorder","toLT"],["GT","gt"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x : X), Iff (∀ (b : X), Not (inst.lt b x)) (Not (Exists fun y => GT.gt x y))","name":["Chapter8","IsMin","iff","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["PartialOrder","toPreorder"],["Set"],["LE","le"],["Membership","mem"],["And"],["Exists","intro"],["Preorder","toLE"],["And","casesOn"],["Set","instMembership"]],"typeReferences":[["And","intro"],["PartialOrder","toPreorder"],["Exists"],["Set"],["PartialOrder"],["LE","le"],["Membership","mem"],["And"],["Exists","intro"],["Preorder","toLE"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] {Y : Set X}\n  (motive :\n    (Exists fun x₀ => And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x)) → Prop)\n  (h : Exists fun x₀ => And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x)),\n  (∀ (x₀ : X) (hx₀ : Set.instMembership.mem Y x₀) (hmin : ∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x),\n      motive ⋯) →\n    motive h","name":["Chapter8","IsMin","iff_lowerbound'","match_1_3"],"kind":"definition","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["LT","lt"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["WellFoundedLT"],["Preorder","toLT"],["LinearOrder"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {X : Type} [inst : LinearOrder X] [WellFoundedLT X] {P : X → Prop},\n  (∀ (n : X), (∀ (m : X), instDistribLatticeOfLinearOrder.toSemilatticeInf.lt m n → P m) → P n) → ∀ (n : X), P n","name":["Chapter8","WellFoundedLT","strong_induction"],"kind":"theorem","isProp":true},{"valueReferences":[["Iff","of_eq"],["Set"],["Eq","refl"],["Iff","mpr"],["Membership","mem"],["Set","instMembership"]],"typeReferences":[["Set"],["Membership","mem"],["Set","instMembership"]],"type":"∀ {X : Type} {A : Set X} (a : X), Set.instMembership.mem A a → Set.instMembership.mem A a","name":["Chapter8","WellFoundedLT","subset","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","LinearOrder","mk"],["Eq","refl"],["LinearOrder"]],"typeReferences":[["Chapter8","LinearOrder","mk"],["PartialOrder"],["LinearOrder"],["Eq"],["Chapter8","IsTotal"]],"type":"∀ {X : Type} [inst : PartialOrder X] (htotal : Chapter8.IsTotal X),\n  Eq (Chapter8.LinearOrder.mk htotal) (Chapter8.LinearOrder.mk htotal)","name":["Chapter8","LinearOrder","mk","congr_simp"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Chapter8","Lex'","partialOrder"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Preorder","toLT"],["OfNat","ofNat"],["Prod"],["instDistribLatticeOfLinearOrder"],["Nat"],["DistribLattice","toLattice"],["instOfNatNat"],["WellFoundedLT"],["Chapter8","Lex'"],["Lean","Name","num"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["Prod"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["Chapter8","Lex'","partialOrder"],["WellFoundedLT"],["Chapter8","Lex'"],["Preorder","toLT"],["LinearOrder"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {X Y : Type} [inst : LinearOrder X] [WellFoundedLT X] [inst_2 : LinearOrder Y] [WellFoundedLT Y],\n  WellFoundedLT (Chapter8.Lex' (Prod X Y))","name":["Chapter8","Lex'","WellFoundedLT"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["le_refl"],["not_lt","_simp_1"],["PartialOrder","toPreorder"],["Eq","trans"],["Membership","mem"],["Preorder","toLT"],["eq_true"],["Exists","intro"],["Chapter8","WellFoundedLT","iff","match_1_1"],["Set","Elem"],["Std","instLESubtype"],["And","intro"],["WellFoundedLT"],["Chapter8","WellFoundedLT","iff","match_1_5"],["SemilatticeInf","toPartialOrder"],["WellFounded"],["Exists"],["IsWellFounded"],["And"],["isWellFounded_iff"],["Set","instMembership"],["Decidable","byContradiction"],["Iff"],["id"],["Mathlib","Tactic","PushNeg","not_le_eq"],["Eq","mpr"],["Mathlib","Tactic","PushNeg","not_implies_eq"],["Subtype"],["Eq","mp"],["le_trans"],["and_true"],["congrArg"],["Iff","intro"],["instDistribLatticeOfLinearOrder"],["Subtype","mk_le_mk","_simp_1"],["IsMin"],["Chapter8","WellFoundedLT","iff","match_1_3"],["WellFounded","wellFounded_iff_has_min"],["Eq"],["Preorder","toLE"],["le_antisymm"],["propext"],["Not"],["Mathlib","Tactic","PushNeg","not_not_eq"],["ne_of_not_le"],["Set","Nonempty"],["Lattice","toSemilatticeInf"],["True"],["Set"],["Mathlib","Tactic","Contrapose","mtr"],["le_of_not_ge"],["LT","lt"],["LinearOrder","toPartialOrder"],["DistribLattice","toLattice"],["ne_of_lt"],["le_of_lt"],["LinearOrder","toDecidableLE"],["LE","le"],["forall_congr'"],["Subtype","mk"]],"typeReferences":[["Set","Nonempty"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Exists"],["Set"],["Membership","mem"],["LinearOrder"],["Preorder","toLT"],["Set","Elem"],["Set","instMembership"],["Std","instLESubtype"],["instDistribLatticeOfLinearOrder"],["IsMin"],["DistribLattice","toLattice"],["Iff"],["WellFoundedLT"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"type":"∀ (X : Type) [inst : LinearOrder X], Iff (WellFoundedLT X) (∀ (A : Set X), A.Nonempty → Exists fun x => IsMin x)","name":["Chapter8","WellFoundedLT","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Prod"],["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter8","Lex'"],["LinearOrder"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Prod"],["Chapter8","Lex'"],["LinearOrder"]],"type":"{X Y : Type} → [LinearOrder X] → [LinearOrder Y] → LinearOrder (Chapter8.Lex' (Prod X Y))","name":["Chapter8","Lex'","linearOrder"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter8","LinearOrder","subtype","_proof_1"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["Set"],["Chapter8","LinearOrder","mk"],["Membership","mem"],["Subtype","partialOrder"],["Set","Elem"],["Set","instMembership"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["Set"],["LinearOrder"],["Set","Elem"]],"type":"{X : Type} → [LinearOrder X] → (A : Set X) → LinearOrder A.Elem","name":["Chapter8","LinearOrder","subtype"],"kind":"definition","isProp":false},{"valueReferences":[["PartialOrder","toPreorder"],["Subtype"],["Set"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","instMembership"],["LT","lt"],["Iff","of_eq"],["Eq","refl"],["Iff","mpr"],["LE","le"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["setOf"]],"typeReferences":[["PartialOrder","toPreorder"],["Subtype"],["Set"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","instMembership"],["LT","lt"],["PartialOrder"],["LE","le"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X) (Y : Set X),\n  Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n          (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      Y →\n    Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n          (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      Y","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_17"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["PartialOrder","toPreorder"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Preorder","toLT"],["And"],["Chapter8","Lex'","partialOrder","match_1"],["OfNat","ofNat"],["Prod"],["LT","lt"],["Nat"],["Or"],["instOfNatNat"],["LE","le"],["Chapter8","Lex'"],["Lean","Name","num"],["Eq"],["Preorder","toLE"]],"typeReferences":[["LT","lt"],["Prod"],["PartialOrder","toPreorder"],["Or"],["PartialOrder"],["LE","le"],["And"],["Preorder","toLT"],["Chapter8","Lex'"],["Chapter8","Lex'","partialOrder","match_1"],["Preorder","toLE"],["Eq"]],"type":"∀ {X Y : Type} [inst : PartialOrder X] [inst_1 : PartialOrder Y] (a b : Chapter8.Lex' (Prod X Y)),\n  (Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x y =>\n      Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) b fun x' y' =>\n        Or (inst.lt x x') (And (Eq x x') (inst_1.le y y'))) →\n    (Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) b fun x y =>\n        Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x' y' =>\n          Or (inst.lt x x') (And (Eq x x') (inst_1.le y y'))) →\n      Eq a b","name":["Chapter8","Lex'","partialOrder","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Subtype","casesOn"],["Set","instMembership"]],"typeReferences":[["Set"],["Membership","mem"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"∀ {X : Type} {A : Set X} (motive : A.Elem → Prop) (h : A.Elem),\n  (∀ (x : X) (hx : Set.instMembership.mem A x), motive ⟨x, hx⟩) → motive h","name":["Chapter8","IsTotal","subtype","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["sorryAx"],["Exists"],["PartialOrder","toPreorder"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["IsMax"],["Lean","Name","num"],["Preorder","toLE"]],"typeReferences":[["Set","Nonempty"],["PartialOrder","toPreorder"],["Exists"],["Set"],["Membership","mem"],["And"],["Subtype","partialOrder"],["Nonempty"],["Set","Elem"],["Set","instMembership"],["Chapter8","IsUpperBound"],["PartialOrder"],["IsMax"],["Preorder","toLE"],["Chapter8","IsTotal"]],"type":"∀ {X : Type} [inst : PartialOrder X] [Nonempty X],\n  (∀ (Y : Set X), And (Chapter8.IsTotal Y.Elem) Y.Nonempty → Exists fun x => Chapter8.IsUpperBound Y x) →\n    Exists fun x => IsMax x","name":["Chapter8","Zorns_lemma"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Set"],["Membership","mem"],["Exists","intro"],["Subtype","casesOn"],["Set","Elem"],["Set","instMembership"]],"typeReferences":[["Set","Nonempty"],["Set"],["Membership","mem"],["Exists","intro"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"∀ {X : Type} (Y_infty : Set X) (A : Set Y_infty.Elem) (motive : A.Nonempty → Prop) (h : A.Nonempty),\n  (∀ (a : X) (ha : Set.instMembership.mem Y_infty a) (haA : Set.instMembership.mem A ⟨a, ha⟩), motive ⋯) → motive h","name":["Chapter8","WellFoundedLT","partialOrder","match_1_13"],"kind":"definition","isProp":true},{"valueReferences":[["Preorder","le_trans"],["PartialOrder","toPreorder"],["Preorder","lt_iff_le_not_ge"],["Preorder","toLT"],["decidableEqOfDecidableLE"],["Ordering"],["compareOfLessAndEq"],["PartialOrder","le_antisymm"],["LT","lt"],["PartialOrder","mk"],["decidableLTOfDecidableLE"],["Eq","refl"],["Preorder","le_refl"],["LE","mk"],["LE","le"],["Classical","decRel"],["LT","mk"],["Preorder","mk"],["Preorder","toLE"]],"typeReferences":[["PartialOrder","toPreorder"],["Preorder","toLT"],["decidableEqOfDecidableLE"],["Ordering"],["compareOfLessAndEq"],["PartialOrder","le_antisymm"],["LT","lt"],["PartialOrder","mk"],["Chapter8","LinearOrder","mk","_proof_4"],["Chapter8","LinearOrder","mk","_proof_3"],["decidableLTOfDecidableLE"],["PartialOrder"],["LE","mk"],["LE","le"],["Classical","decRel"],["Chapter8","LinearOrder","mk","_proof_5"],["LT","mk"],["Preorder","mk"],["Eq"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X] (a b : X), Eq (compareOfLessAndEq a b) (compareOfLessAndEq a b)","name":["Chapter8","LinearOrder","mk","_proof_6"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Preorder","lt_iff_le_not_ge"]],"typeReferences":[["Not"],["LT","lt"],["PartialOrder","toPreorder"],["Iff"],["PartialOrder"],["LE","le"],["And"],["Preorder","toLT"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X] (a b : X), Iff (inst.lt a b) (And (inst.le a b) (Not (inst.le b a)))","name":["Chapter8","LinearOrder","mk","_proof_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["LT","lt"],["PartialOrder","toPreorder"],["Or"],["LE","le"],["Preorder","toLT"],["And"],["Chapter8","Lex'","partialOrder","match_1"],["Iff","rfl"],["Preorder","toLE"],["Eq"]],"typeReferences":[["Not"],["PartialOrder","toPreorder"],["And"],["Preorder","toLT"],["Chapter8","Lex'","partialOrder","match_1"],["Prod"],["LT","lt"],["Or"],["PartialOrder"],["Iff"],["LE","le"],["Chapter8","Lex'"],["Eq"],["Preorder","toLE"]],"type":"∀ {X Y : Type} [inst : PartialOrder X] [inst_1 : PartialOrder Y] (a b : Chapter8.Lex' (Prod X Y)),\n  Iff\n    (And\n      (Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x y =>\n        Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) b fun x' y' =>\n          Or (inst.lt x x') (And (Eq x x') (inst_1.le y y')))\n      (Not\n        (Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) b fun x y =>\n          Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x' y' =>\n            Or (inst.lt x x') (And (Eq x x') (inst_1.le y y')))))\n    (And\n      (Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x y =>\n        Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) b fun x' y' =>\n          Or (inst.lt x x') (And (Eq x x') (inst_1.le y y')))\n      (Not\n        (Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) b fun x y =>\n          Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x' y' =>\n            Or (inst.lt x x') (And (Eq x x') (inst_1.le y y')))))","name":["Chapter8","Lex'","partialOrder","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Exists"],["Eq","trans"],["True"],["Set"],["Set","mem_range","_simp_1"],["Membership","mem"],["Set","Iic"],["Set","range"],["congrArg"],["Set","instMembership"],["Set","univ"],["Set","image_univ"],["Set","image"],["of_eq_true"],["exists_apply_eq_apply","_simp_1"],["Eq"]],"typeReferences":[["Set","univ"],["Set","image"],["PartialOrder","toPreorder"],["Set"],["PartialOrder"],["Membership","mem"],["Set","Iic"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x : X), Set.instMembership.mem (Set.image Set.Iic Set.univ) (Set.Iic x)","name":["Chapter8","OrderIdeals","iso","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Chapter8","Lex'","partialOrder","_proof_3"],["Chapter8","Lex'","partialOrder","_proof_1"],["PartialOrder","toPreorder"],["Preorder","toLT"],["And"],["Chapter8","Lex'","partialOrder","_proof_2"],["Chapter8","Lex'","partialOrder","match_1"],["Prod"],["LT","lt"],["PartialOrder","mk"],["Or"],["LE","mk"],["LE","le"],["Chapter8","Lex'"],["Chapter8","Lex'","partialOrder","_proof_4"],["LT","mk"],["Preorder","mk"],["Preorder","toLE"],["Eq"]],"typeReferences":[["Prod"],["PartialOrder"],["Chapter8","Lex'"]],"type":"{X Y : Type} → [PartialOrder X] → [PartialOrder Y] → PartialOrder (Chapter8.Lex' (Prod X Y))","name":["Chapter8","Lex'","partialOrder"],"kind":"definition","isProp":false},{"valueReferences":[["implies_congr"],["Subtype"],["PartialOrder","toPreorder"],["Singleton","singleton"],["Membership","mem"],["Preorder","toLT"],["Classical","propDecidable"],["Subtype","partialOrder"],["Subtype","val"],["dite_congr"],["congrArg"],["congr"],["forall_congr"],["funext"],["Subtype","property"],["Eq"],["Chapter8","IsTotal"],["Eq","ndrec"],["Preorder","toLE"],["Set","decidableSingleton"],["Set","instSDiff"],["Not"],["Exists"],["Set"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Eq","mpr_prop"],["Set","instMembership"],["LT","lt"],["Iff","of_eq"],["Eq","refl"],["Iff","mpr"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["Std","instLTSubtype"],["dite"],["setOf"]],"typeReferences":[["Subtype"],["PartialOrder","toPreorder"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Preorder","toLT"],["Subtype","partialOrder"],["Subtype","val"],["PartialOrder"],["Eq"],["Chapter8","IsTotal"],["Preorder","toLE"],["Set","decidableSingleton"],["Set","instSDiff"],["Not"],["Exists"],["Set"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Set","instMembership"],["LT","lt"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["Std","instLTSubtype"],["dite"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_18"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X),\n  (∀ (Y : Set X),\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        Exists fun x => And (∀ (y : X), Set.instMembership.mem Y y → inst.le y x) (Not (Set.instMembership.mem Y x))) →\n    ∀\n      (hpt :\n        Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          (Set.instSingletonSet.singleton x₀))\n      (hF :\n        ∀ {Y : Set X},\n          Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                  (And\n                    (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 =>\n                      Std.instLTSubtype.lt x1 x2)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              Y →\n            ∀ {x : X},\n              Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n                Set.instMembership.mem\n                  (setOf fun Y =>\n                    And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                      (And\n                        (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 =>\n                          Std.instLTSubtype.lt x1 x2)\n                        (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                  (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x)))\n      (Y : Set X)\n      (hYΩ₀ :\n        Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y)\n      (x : X),\n      Exists fun x_1 =>\n        And\n          (∀ (y : X),\n            Set.instMembership.mem\n                (if h : Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x then\n                    ⟨setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x), ⋯⟩\n                  else ⟨Set.instSingletonSet.singleton x₀, hpt⟩).val\n                y →\n              inst.le y x_1)\n          (Not\n            (Set.instMembership.mem\n              (if h : Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x then\n                  ⟨setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x), ⋯⟩\n                else ⟨Set.instSingletonSet.singleton x₀, hpt⟩).val\n              x_1))","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_19"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Subtype"],["Set"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Subtype","val"],["Set","instMembership"],["LT","lt"],["Subtype","property"],["LE","le"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["setOf"]],"typeReferences":[["Not"],["Exists"],["PartialOrder","toPreorder"],["Subtype"],["Set"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Subtype","val"],["Set","instMembership"],["LT","lt"],["PartialOrder"],["LE","le"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X),\n  (∀ (Y : Set X),\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        Exists fun x => And (∀ (y : X), Set.instMembership.mem Y y → inst.le y x) (Not (Set.instMembership.mem Y x))) →\n    ∀\n      (Y :\n        Subtype fun x =>\n          Set.instMembership.mem\n            (setOf fun Y =>\n              And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                (And\n                  (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                  (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n            x),\n      Exists fun x =>\n        And (∀ (y : X), Set.instMembership.mem Y.val y → inst.le y x) (Not (Set.instMembership.mem Y.val x))","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_8"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["PartialOrder","toPreorder"],["Decidable"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["LinearOrder"],["OfNat","ofNat"],["LinearOrder","toPartialOrder"],["Nat"],["instOfNatNat"],["LE","le"],["Empty"],["Lean","Name","num"],["Eq"],["Preorder","toLE"]],"typeReferences":[["LinearOrder","toPartialOrder"],["PartialOrder","toPreorder"],["Exists"],["Decidable"],["LE","le"],["LinearOrder"],["Empty"],["LE"],["Preorder","toLE"],["Eq"]],"type":"[h₀ : LE Empty] → Decidable (Exists fun h => Eq h.le h₀.le)","name":["Chapter8","empty_set_linear_order"],"kind":"definition","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Equiv","instEquivLike"],["PartialOrder","toPreorder"],["Chapter8","OrderIdeals"],["Equiv","mk"],["Eq","trans"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["DFunLike","coe"],["Set","range"],["Equiv"],["Set","Elem"],["congrArg"],["Std","instLESubtype"],["instOfNatNat"],["EquivLike","toFunLike"],["Preorder","toLE"],["Eq"],["Set","instLE"],["Exists"],["True"],["Set"],["Set","mem_range","_simp_1"],["Set","Iic"],["OfNat","ofNat"],["Set","instMembership"],["Set","univ"],["Function","RightInverse"],["Set","image_univ"],["Nat"],["Set","image"],["of_eq_true"],["Iff"],["LE","le"],["Function","LeftInverse"],["Lean","Name","num"],["exists_apply_eq_apply","_simp_1"],["Subtype","mk"]],"typeReferences":[["Equiv","instEquivLike"],["PartialOrder","toPreorder"],["sorryAx"],["Lean","Name","anonymous"],["Chapter8","OrderIdeals"],["Equiv","mk"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["DFunLike","coe"],["Equiv"],["Set","Elem"],["Std","instLESubtype"],["instOfNatNat"],["PartialOrder"],["EquivLike","toFunLike"],["Chapter8","OrderIdeals","iso","_proof_2"],["Preorder","toLE"],["Set","instLE"],["Set"],["Chapter8","OrderIdeals","iso","_proof_3"],["Chapter8","OrderIdeals","iso","_proof_1"],["Set","Iic"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["Iff"],["LE","le"],["Subtype","mk"],["Lean","Name","num"]],"type":"∀ {X : Type} [inst : PartialOrder X] {a b : X},\n  Iff\n    (Std.instLESubtype.le\n      (EquivLike.toFunLike.coe { toFun := fun x => ⟨Set.Iic x, ⋯⟩, invFun := sorry, left_inv := ⋯, right_inv := ⋯ } a)\n      (EquivLike.toFunLike.coe { toFun := fun x => ⟨Set.Iic x, ⋯⟩, invFun := sorry, left_inv := ⋯, right_inv := ⋯ } b))\n    (inst.le a b)","name":["Chapter8","OrderIdeals","iso","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Subtype"],["True"],["Eq","trans"],["Set"],["Membership","mem"],["eq_true"],["Subtype","partialOrder"],["Set","Elem"],["congrArg"],["Set","instMembership"],["Subtype","mk_le_mk","_simp_1"],["Std","instLESubtype"],["Or"],["of_eq_true"],["congr"],["LE","le"],["Subtype","mk"],["Chapter8","IsTotal","subtype","match_1_1"],["Preorder","toLE"]],"typeReferences":[["Set"],["PartialOrder"],["Membership","mem"],["Subtype","partialOrder"],["Chapter8","IsTotal"],["Set","Elem"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] {A : Set X}, Chapter8.IsTotal X → Chapter8.IsTotal A.Elem","name":["Chapter8","IsTotal","subtype"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["isMax_iff_forall_not_lt"],["PartialOrder","toPreorder"],["Exists"],["Chapter8","IsMax","iff","_proof_1_1"],["Preorder","toLT"],["congrArg"],["LT","lt"],["Iff"],["IsMax"],["id"],["Eq","mpr"],["Preorder","toLE"],["Eq"],["propext"]],"typeReferences":[["LT","lt"],["Not"],["Exists"],["PartialOrder","toPreorder"],["Iff"],["PartialOrder"],["Preorder","toLT"],["IsMax"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x : X), Iff (IsMax x) (Not (Exists fun y => inst.lt x y))","name":["Chapter8","IsMax","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["ite"],["Eq","refl"],["LE","le"],["Classical","decRel"],["Preorder","toLE"]],"typeReferences":[["PartialOrder","toPreorder"],["ite"],["PartialOrder"],["LE","le"],["Classical","decRel"],["Preorder","toLE"],["Eq"]],"type":"∀ {X : Type} [inst : PartialOrder X] (a b : X), Eq (ite (inst.le a b) b a) (ite (inst.le a b) b a)","name":["Chapter8","LinearOrder","mk","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["PartialOrder","toPreorder"],["Singleton","singleton"],["Membership","mem"],["Preorder","toLT"],["Subtype","partialOrder"],["Subtype","val"],["Subtype","property"],["Chapter8","IsTotal"],["Preorder","toLE"],["Set","instSDiff"],["Set"],["IsWellFounded"],["And"],["Set","instSingletonSet"],["Set","instMembership"],["Eq","mpr_prop"],["LT","lt"],["Iff","of_eq"],["Iff","mpr"],["Eq","refl"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["Std","instLTSubtype"],["setOf"]],"typeReferences":[["PartialOrder","toPreorder"],["Subtype"],["Set"],["Singleton","singleton"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","instSingletonSet"],["Subtype","val"],["Set","instMembership"],["LT","lt"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_17"],["PartialOrder"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["Set","instSDiff"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X),\n  (∀ {Y : Set X},\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        ∀ {x : X},\n          Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n            Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                  (And\n                    (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 =>\n                      Std.instLTSubtype.lt x1 x2)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x))) →\n    ∀ (Y : Set X)\n      (hYΩ₀ :\n        Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y)\n      (x : X),\n      Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n        Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          (setOf fun y => And (Set.instMembership.mem ⟨Y, ⋯⟩.val y) (inst.lt y x))","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_18"],"kind":"theorem","isProp":true},{"valueReferences":[["Prod","casesOn"]],"typeReferences":[["Prod"],["Prod","mk"],["Chapter8","Lex'"]],"type":"{X Y : Type} →\n  (motive : Chapter8.Lex' (Prod X Y) → Sort u_1) →\n    (x : Chapter8.Lex' (Prod X Y)) → ((x' : X) → (y' : Y) → motive { fst := x', snd := y' }) → motive x","name":["Chapter8","Lex'","partialOrder","match_1"],"kind":"definition","isProp":false},{"valueReferences":[["implies_congr"],["PartialOrder","toPreorder"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Preorder","toLT"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Set","iUnion"],["Set","mem_diff"],["Union","union"],["Classical","choose"],["Subtype","val"],["funext"],["forall_congr"],["Eq","symm"],["Eq","ndrec"],["Chapter8","IsTotal"],["Set","instUnion"],["Set","instSDiff"],["Exists"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["True","intro"],["Set","instMembership"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_9"],["Iff","of_eq"],["Set","instCompleteAtomicBooleanAlgebra"],["eq_false"],["Iff"],["Iff","mpr"],["Eq","refl"],["Classical","byContradiction"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_18"],["setOf"],["CompleteLattice","instOmegaCompletePartialOrder"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["OmegaCompletePartialOrder","toPartialOrder"],["Classical","choose","congr_simp"],["Subtype","partialOrder"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_19"],["dite_congr"],["congrArg"],["congr"],["Subtype","property"],["Eq"],["Preorder","toLE"],["Set","decidableSingleton"],["Not"],["Lean","Grind","forall_and"],["True"],["Set"],["Lean","Grind","eq_true_of_not_eq_false"],["Set","instSingletonSet"],["Eq","mpr_prop"],["LT","lt"],["Lean","Grind","iff_eq"],["Lean","Grind","and_eq_of_eq_true_left"],["LE","le"],["SDiff","sdiff"],["False"],["Lean","Grind","intro_with_eq"],["Subtype","mk"],["Std","instLTSubtype"],["dite"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_10"],["And","casesOn"]],"typeReferences":[["CompleteLattice","instOmegaCompletePartialOrder"],["PartialOrder","toPreorder"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Singleton","singleton"],["OmegaCompletePartialOrder","toPartialOrder"],["Membership","mem"],["Classical","propDecidable"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","iUnion"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["Set","Elem"],["PartialOrder"],["Subtype","property"],["WellFoundedLT"],["Set","instUnion"],["Chapter8","IsTotal"],["Preorder","toLE"],["Eq"],["Set","decidableSingleton"],["Chapter8","IsStrictUpperBound"],["Set","instSDiff"],["Not"],["Exists"],["Set"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Exists","choose"],["Set","instMembership"],["LT","lt"],["Iff","of_eq"],["Set","instCompleteAtomicBooleanAlgebra"],["Eq","refl"],["Iff","mpr"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["dite"],["Std","instLTSubtype"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X)\n  (hs :\n    ∀ (Y : Set X),\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        Exists fun x => Chapter8.IsStrictUpperBound Y x)\n  (hpt :\n    Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal Y.Elem)\n          (And (WellFoundedLT Y.Elem)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      (Set.instSingletonSet.singleton x₀))\n  (hF :\n    ∀ {Y : Set X},\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        ∀ {x : X},\n          Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n            Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal Y.Elem)\n                  (And (WellFoundedLT Y.Elem)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x))),\n  (∀\n      {Y Y' :\n        (setOf fun Y =>\n            ∀ (x : X),\n              Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                Eq x\n                  ((fun Y => ⋯.choose)\n                    ((fun Y x =>\n                        if hxy :\n                            Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀))\n                              x then\n                          ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                        else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                      Y x))).Elem}\n      (x : X),\n      Set.instMembership.mem (Set.instSDiff.sdiff Y'.val.val Y.val.val) x → Chapter8.IsStrictUpperBound Y.val.val x) →\n    Chapter8.IsTotal\n        (setOf fun Y =>\n            ∀ (x : X),\n              Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                Eq x\n                  ((fun Y => ⋯.choose)\n                    ((fun Y x =>\n                        if hxy :\n                            Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀))\n                              x then\n                          ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                        else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                      Y x))).Elem →\n      Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x₀ →\n        (∀ {x : X}, Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x → inst.le x₀ x) →\n          Chapter8.IsTotal (Set.iUnion fun Y => Y.val.val).Elem →\n            WellFoundedLT (Set.iUnion fun Y => Y.val.val).Elem →\n              ∀\n                (hY_inftyΩ₀ :\n                  Set.instMembership.mem\n                    (setOf fun Y =>\n                      And (Chapter8.IsTotal Y.Elem)\n                        (And (WellFoundedLT Y.Elem)\n                          (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                    (Set.iUnion fun Y => Y.val.val)),\n                Chapter8.IsTotal\n                    (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                        (Set.instSingletonSet.singleton\n                          ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))).Elem →\n                  WellFoundedLT\n                      (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                          (Set.instSingletonSet.singleton\n                            ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))).Elem →\n                    Set.instMembership.mem\n                        (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                          (Set.instSingletonSet.singleton\n                            ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)))\n                        x₀ →\n                      (∀ (x : X),\n                          Set.instMembership.mem\n                              (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                                (Set.instSingletonSet.singleton\n                                  ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)))\n                              x →\n                            inst.le x₀ x) →\n                        Set.instMembership.mem\n                            (setOf fun Y =>\n                              And (Chapter8.IsTotal Y.Elem)\n                                (And (WellFoundedLT Y.Elem)\n                                  (And (Set.instMembership.mem Y x₀)\n                                    (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                            (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                              (Set.instSingletonSet.singleton\n                                ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))) →\n                          (∀ (y : X),\n                              Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) y →\n                                inst.lt y ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)) →\n                            ∀ (x : X),\n                              Not (Eq x x₀) →\n                                Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x →\n                                  ∀ (Y : Set X),\n                                    Set.instMembership.mem Y x →\n                                      ∀\n                                        (hYΩ₀ :\n                                          Set.instMembership.mem\n                                            (setOf fun Y =>\n                                              And (Chapter8.IsTotal Y.Elem)\n                                                (And (WellFoundedLT Y.Elem)\n                                                  (And (Set.instMembership.mem Y x₀)\n                                                    (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                                            Y)\n                                        (hYΩ' :\n                                          Set.instMembership.mem\n                                            (setOf fun Y =>\n                                              ∀ (x : X),\n                                                Set.instMembership.mem\n                                                    (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                                                  Eq x\n                                                    ((fun Y => ⋯.choose)\n                                                      ((fun Y x =>\n                                                          if hxy :\n                                                              Set.instMembership.mem\n                                                                (Set.instSDiff.sdiff Y.val\n                                                                  (Set.instSingletonSet.singleton x₀))\n                                                                x then\n                                                            ⟨setOf fun y =>\n                                                                And (Set.instMembership.mem Y.val y) (inst.lt y x),\n                                                              ⋯⟩\n                                                          else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                                                        Y x)))\n                                            ⟨Y, ⋯⟩),\n                                        (∀ (x : X),\n                                            Set.instMembership.mem Y x →\n                                              Not (Eq x x₀) →\n                                                Eq x\n                                                  ((fun Y => ⋯.choose)\n                                                    ((fun Y x =>\n                                                        if hxy :\n                                                            Set.instMembership.mem\n                                                              (Set.instSDiff.sdiff Y.val\n                                                                (Set.instSingletonSet.singleton x₀))\n                                                              x then\n                                                          ⟨setOf fun y =>\n                                                              And (Set.instMembership.mem Y.val y) (inst.lt y x),\n                                                            ⋯⟩\n                                                        else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                                                      ⟨Y, ⋯⟩ x))) →\n                                          ∀ (y : X),\n                                            inst.lt y x →\n                                              ∀ (Y' : Set X),\n                                                Set.instMembership.mem Y' y →\n                                                  ∀\n                                                    (hY'Ω₀ :\n                                                      Set.instMembership.mem\n                                                        (setOf fun Y =>\n                                                          And (Chapter8.IsTotal Y.Elem)\n                                                            (And (WellFoundedLT Y.Elem)\n                                                              (And (Set.instMembership.mem Y x₀)\n                                                                (∀ (x : X),\n                                                                  Set.instMembership.mem Y x → inst.le x₀ x))))\n                                                        Y')\n                                                    (hY'Ω :\n                                                      Set.instMembership.mem\n                                                        (setOf fun Y =>\n                                                          ∀ (x : X),\n                                                            Set.instMembership.mem\n                                                                (Set.instSDiff.sdiff Y.val\n                                                                  (Set.instSingletonSet.singleton x₀))\n                                                                x →\n                                                              Eq x\n                                                                ((fun Y => ⋯.choose)\n                                                                  ((fun Y x =>\n                                                                      if hxy :\n                                                                          Set.instMembership.mem\n                                                                            (Set.instSDiff.sdiff Y.val\n                                                                              (Set.instSingletonSet.singleton x₀))\n                                                                            x then\n                                                                        ⟨setOf fun y =>\n                                                                            And (Set.instMembership.mem Y.val y)\n                                                                              (inst.lt y x),\n                                                                          ⋯⟩\n                                                                      else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                                                                    Y x)))\n                                                        ⟨Y', ⋯⟩),\n                                                    Not (Set.instMembership.mem Y y) →\n                                                      Set.instMembership.mem\n                                                        (Set.instSDiff.sdiff ⟨⟨Y', ⋯⟩, hY'Ω⟩.val.val\n                                                          ⟨⟨Y, ⋯⟩, hYΩ'⟩.val.val)\n                                                        y","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_20"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","refl"],["Chapter8","IsTotal"]],"typeReferences":[["PartialOrder","toPreorder"],["Or"],["PartialOrder"],["LE","le"],["Preorder","toLE"],["Chapter8","IsTotal"],["Eq"]],"type":"∀ (X : Type) [inst : PartialOrder X], Eq (Chapter8.IsTotal X) (∀ (x y : X), Or (inst.le x y) (inst.le y x))","name":["Chapter8","IsTotal","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["PartialOrder","toPreorder"],["Exists"],["Preorder","toLT"],["isMin_iff_forall_not_lt"],["GT","gt"],["congrArg"],["LT","lt"],["IsMin"],["Iff"],["id"],["Eq","mpr"],["Preorder","toLE"],["Eq"],["propext"],["Chapter8","IsMin","iff","_proof_1_1"]],"typeReferences":[["Not"],["Exists"],["PartialOrder","toPreorder"],["IsMin"],["Iff"],["PartialOrder"],["Preorder","toLT"],["GT","gt"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x : X), Iff (IsMin x) (Not (Exists fun y => GT.gt x y))","name":["Chapter8","IsMin","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","embeddingOfSubset"],["Eq","refl"],["Function","Embedding"],["Set","Elem"]],"typeReferences":[["Function","Embedding","mk"],["Set"],["Set","embeddingOfSubset","_proof_2"],["Set","embeddingOfSubset"],["Function","Embedding"],["Membership","mem"],["Subtype","val"],["Set","Elem"],["Set","instMembership"],["Set","instHasSubset"],["HasSubset","Subset"],["Set","embeddingOfSubset","_proof_1"],["Subtype","mk"],["Eq"]],"type":"∀ {α : Type u_1} (s t : Set α) (h : Set.instHasSubset.Subset s t),\n  Eq (s.embeddingOfSubset t h) { toFun := fun x => ⟨x.val, ⋯⟩, inj' := ⋯ }","name":["Set","embeddingOfSubset","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["iff_self"],["of_eq_true"],["Set"],["Iff"],["LE","le"],["Membership","mem"],["Preorder","toLE"],["Set","instMembership"]],"typeReferences":[["Chapter8","IsUpperBound"],["PartialOrder","toPreorder"],["upperBounds"],["Set"],["Iff"],["PartialOrder"],["Membership","mem"],["Preorder","toLE"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] (A : Set X) (x : X),\n  Iff (Chapter8.IsUpperBound A x) (Set.instMembership.mem (upperBounds A) x)","name":["Chapter8","IsUpperBound","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["PartialOrder","toPreorder"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["eq_true"],["Lean","Grind","of_forall_eq_false"],["Lean","Grind","imp_eq_of_eq_true_left"],["Lean","Grind","eq_false_of_imp_eq_true"],["Eq","symm"],["Chapter8","WellFoundedLT","subset","_proof_1_7"],["Eq"],["Preorder","toLE"],["Lean","Grind","forall_propagator"],["Not"],["True"],["Set"],["True","intro"],["Set","subset_def"],["Lean","Grind","nestedProof"],["Set","instMembership"],["Set","instHasSubset"],["Exists","casesOn"],["HasSubset","Subset"],["of_eq_true"],["Eq","refl"],["eq_false"],["LE","le"],["Classical","byContradiction"],["False"],["Subtype","mk"]],"typeReferences":[["PartialOrder","toPreorder"],["Set"],["Membership","mem"],["Set","Elem"],["Set","instMembership"],["Set","instHasSubset"],["HasSubset","Subset"],["Iff","of_eq"],["PartialOrder"],["Iff","mpr"],["Eq","refl"],["LE","le"],["Subtype","mk"],["Preorder","toLE"],["Eq"]],"type":"∀ {X : Type} [inst : PartialOrder X] {A B : Set X},\n  Set.instHasSubset.Subset B A →\n    ∀ (C : Set B.Elem) (x : X),\n      (∀ (a : X),\n          Set.instMembership.mem A a →\n            ∀ (x_1 : X) (x_2 : Set.instMembership.mem B x_1),\n              Set.instMembership.mem C ⟨x_1, ⋯⟩ → Eq x_1 a → inst.le a x → inst.le x a) →\n        ∀ (a : X) (b : Set.instMembership.mem B a), Set.instMembership.mem C ⟨a, b⟩ → inst.le a x → inst.le x a","name":["Chapter8","WellFoundedLT","subset","_proof_1_8"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["instDistribLatticeOfLinearOrder"],["Nat"],["DistribLattice","toLattice"],["instOfNatNat"],["IsMax"],["Lean","Name","num"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["Exists"],["IsMax"],["LinearOrder"],["Nonempty"],["Preorder","toLE"],["Finite"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {X : Type} [inst : LinearOrder X] [Finite X] [Nonempty X], Exists fun x => IsMax x","name":["Chapter8","IsMax","ofFinite"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["PartialOrder","toPreorder"],["True"],["Eq","trans"],["Set"],["Chapter8","IsStrictUpperBound","iff'","_simp_1_1"],["Membership","mem"],["And"],["Set","mem_diff","_simp_1"],["congrArg"],["Set","instMembership"],["Chapter8","IsUpperBound"],["iff_self"],["of_eq_true"],["upperBounds"],["congr"],["Iff"],["SDiff","sdiff"],["Preorder","toLE"],["Set","instSDiff"]],"typeReferences":[["PartialOrder","toPreorder"],["upperBounds"],["Set"],["Iff"],["PartialOrder"],["Membership","mem"],["SDiff","sdiff"],["Preorder","toLE"],["Chapter8","IsStrictUpperBound"],["Set","instSDiff"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] (A : Set X) (x : X),\n  Iff (Chapter8.IsStrictUpperBound A x) (Set.instMembership.mem (Set.instSDiff.sdiff (upperBounds A) A) x)","name":["Chapter8","IsStrictUpperBound","iff'"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Set"],["Set","embeddingOfSubset"],["Membership","mem"],["Function","Embedding"],["Exists","intro"],["DFunLike","coe"],["Set","Elem"],["Set","instMembership"],["Exists","casesOn"],["instDistribLatticeOfLinearOrder"],["Std","instLESubtype"],["Set","image"],["DistribLattice","toLattice"],["IsMin"],["Subtype","mk"],["Subtype","casesOn"],["Function","instFunLikeEmbedding"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["Exists"],["Set"],["Set","embeddingOfSubset"],["Membership","mem"],["Function","Embedding"],["LinearOrder"],["Exists","intro"],["DFunLike","coe"],["Set","Elem"],["Set","instMembership"],["Set","instHasSubset"],["instDistribLatticeOfLinearOrder"],["Std","instLESubtype"],["Set","image"],["DistribLattice","toLattice"],["IsMin"],["HasSubset","Subset"],["Subtype","mk"],["Preorder","toLE"],["Function","instFunLikeEmbedding"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {X : Type} {A B : Set X} (hAB : Set.instHasSubset.Subset B A) (hAlin : LinearOrder A.Elem) (C : Set B.Elem)\n  (motive : (Exists fun x => IsMin x) → Prop) (x : Exists fun x => IsMin x),\n  (∀ (x : X) (hx : Set.instMembership.mem A x)\n      (hx' :\n        Set.instMembership.mem (Set.image (Function.instFunLikeEmbedding.coe (B.embeddingOfSubset A hAB)) C) ⟨x, hx⟩)\n      (hmin : IsMin ⟨⟨x, hx⟩, hx'⟩), motive ⋯) →\n    motive x","name":["Chapter8","WellFoundedLT","subset","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Subtype","casesOn"],["Set","instMembership"]],"typeReferences":[["Set"],["Membership","mem"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"∀ {X : Type} {B : Set X} (motive : B.Elem → Prop) (h : B.Elem),\n  (∀ (x : X) (hx : Set.instMembership.mem B x), motive ⟨x, hx⟩) → motive h","name":["Chapter8","IsTotal","subset","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["ite"],["Chapter8","LinearOrder","mk","_proof_6"],["Preorder","toLT"],["Chapter8","LinearOrder","mk","_proof_2"],["LinearOrder","mk"],["decidableEqOfDecidableLE"],["compareOfLessAndEq"],["Min","mk"],["Max","mk"],["decidableLTOfDecidableLE"],["Ord","mk"],["LE","le"],["Classical","decRel"],["Preorder","toLE"],["Chapter8","LinearOrder","mk","_proof_1"]],"typeReferences":[["PartialOrder"],["LinearOrder"],["Chapter8","IsTotal"]],"type":"{X : Type} → [inst : PartialOrder X] → Chapter8.IsTotal X → LinearOrder X","name":["Chapter8","LinearOrder","mk"],"kind":"definition","isProp":false},{"valueReferences":[["Set"],["Membership","mem"],["Subtype","casesOn"],["Set","instMembership"]],"typeReferences":[["Set"],["Membership","mem"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"∀ (X : Type) (A : Set X) (motive : A.Elem → Prop) (h : A.Elem),\n  (∀ (y : X) (hy : Set.instMembership.mem A y), motive ⟨y, hy⟩) → motive h","name":["Chapter8","WellFoundedLT","iff","match_1_3"],"kind":"definition","isProp":true},{"valueReferences":[["Subtype"],["PartialOrder","toPreorder"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","iUnion"],["Subtype","val"],["Classical","choose"],["Subtype","property"],["Chapter8","IsTotal"],["Preorder","toLE"],["Eq"],["Set","decidableSingleton"],["Set","instSDiff"],["Not"],["Set"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Set","instMembership"],["LT","lt"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["Std","instLTSubtype"],["dite"],["setOf"]],"typeReferences":[["Subtype"],["PartialOrder","toPreorder"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","iUnion"],["Classical","choose"],["Subtype","val"],["PartialOrder"],["Chapter8","IsTotal"],["Preorder","toLE"],["Eq"],["Set","decidableSingleton"],["Set","instSDiff"],["Not"],["Exists"],["Set"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_9"],["Set","instMembership"],["LT","lt"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["dite"],["Std","instLTSubtype"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_10"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X)\n  (hs :\n    ∀ (Y : Set X),\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        Exists fun x => And (∀ (y : X), Set.instMembership.mem Y y → inst.le y x) (Not (Set.instMembership.mem Y x)))\n  (hpt :\n    Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n          (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      (Set.instSingletonSet.singleton x₀))\n  (hF :\n    ∀ {Y : Set X},\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        ∀ {x : X},\n          Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n            Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                  (And\n                    (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 =>\n                      Std.instLTSubtype.lt x1 x2)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x)))\n  (hY_inftyΩ₀ :\n    Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n          (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      (Set.iUnion fun Y => Y.val.val)),\n  Exists fun x =>\n    And (∀ (y : X), Set.instMembership.mem ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩.val y → inst.le y x)\n      (Not (Set.instMembership.mem ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩.val x))","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_15"],"kind":"theorem","isProp":true},{"valueReferences":[["Classical","choose_spec"],["implies_congr"],["sorryAx"],["Eq","trans"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Classical","propDecidable"],["Exists","intro"],["eq_true"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_20"],["or_true"],["Set","instInsert"],["heq_of_eq"],["Union","union"],["Classical","choose"],["Subtype","val"],["Set","Elem"],["Finite","of_fintype"],["Std","instLESubtype"],["Eq","symm"],["Subtype","exists","_simp_1"],["Set","instUnion"],["Chapter8","IsTotal"],["Eq","ndrec"],["Chapter8","IsStrictUpperBound"],["HEq","casesOn"],["Set","instSDiff"],["Exists"],["Exists","choose_spec"],["Set","union_singleton"],["Chapter8","IsStrictUpperBound","iff"],["true_and"],["Set","instMembership"],["implies_true"],["or_self"],["instNonemptyOfInhabited"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["HEq"],["Set","ext"],["Eq","mpr"],["Set","fintypeSingleton"],["setOf"],["forall_eq","_simp_1"],["Set","mem_iUnion_of_mem"],["OmegaCompletePartialOrder","toPartialOrder"],["and_true"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_16"],["IsMin"],["instOfNatNat"],["congr"],["Subtype","property"],["Preorder","toLE"],["Eq"],["propext"],["Subtype","val_injective"],["Mathlib","Tactic","PushNeg","not_exists_eq"],["Chapter8","IsTotal","subtype"],["Set"],["Chapter8","WellFoundedLT","partialOrder","_simp_1_6"],["Chapter8","WellFoundedLT","subset"],["exists_prop","_simp_1"],["Set","mem_iUnion","_simp_1"],["OfNat","ofNat"],["eq_self"],["and_self"],["dite_cond_eq_true"],["Set","mem_insert_iff","_simp_1"],["Subtype","forall","_simp_1"],["Set","iUnion_coe_set"],["SDiff","sdiff"],["Subtype","casesOn"],["Lean","Name","num"],["dite"],["And","casesOn"],["le_refl"],["PartialOrder","toPreorder"],["Mathlib","Tactic","Order","le_of_not_lt_le"],["Lean","Name"],["Chapter8","LinearOrder","mk"],["exists_const","_simp_1"],["Membership","mem"],["Chapter8","WellFoundedLT","partialOrder","match_1_13"],["Subtype","preorder"],["Preorder","toLT"],["Set","iUnion"],["CompleteBooleanAlgebra","toCompleteLattice"],["And","intro"],["Chapter8","WellFoundedLT","ofFinite"],["not_false_eq_true"],["Or"],["forall_congr"],["WellFoundedLT"],["funext"],["eq_of_heq"],["le_of_subsingleton","_simp_1"],["Unique","instSubsingleton"],["Eq","rec"],["And","left"],["exists_and_right","_simp_1"],["Chapter8","WellFoundedLT","partialOrder","_simp_1_7"],["And","right"],["Insert","insert"],["And"],["Set","decidableSdiff"],["exists_eq_right'","_simp_1"],["Exists","casesOn"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_12"],["Decidable","byContradiction"],["Nat"],["HasSubset","Subset"],["Iff","of_eq"],["Chapter8","IsMin","iff_lowerbound"],["ge_of_eq"],["Iff","mpr"],["id"],["Set","uniqueSingleton"],["implies_congr_ctx"],["and_congr_left_iff","_simp_1"],["CompleteLattice","instOmegaCompletePartialOrder"],["Chapter8","IsMin","iff_lowerbound'"],["Lean","Name","anonymous"],["instDecidableAnd"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["and_imp","_simp_1"],["le_trans"],["Subtype","partialOrder"],["Iff","intro"],["dite_congr"],["congrArg"],["Subtype","mk_le_mk","_simp_1"],["Chapter8","WellFoundedLT","partialOrder","match_1_4"],["le_of_eq"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_21"],["Set","iUnion_congr_Prop"],["le_antisymm"],["Set","decidableSingleton"],["le_refl","_simp_1"],["Not"],["Mathlib","Tactic","PushNeg","not_not_eq"],["Set","Nonempty"],["true_or"],["True"],["HEq","refl"],["Mathlib","Tactic","PushNeg","not_and_eq"],["Mathlib","Tactic","PushNeg","not_forall_eq"],["Set","instSingletonSet"],["Exists","choose"],["Mathlib","Tactic","PushNeg","not_or_eq"],["Eq","casesOn"],["Set","mem_union","_simp_1"],["Mathlib","Tactic","Contrapose","mtr"],["exists_prop_congr"],["Set","mem_diff","_simp_1"],["Eq","mpr_prop"],["Chapter8","WellFoundedLT","iff'"],["Set","instHasSubset"],["Or","casesOn"],["LT","lt"],["ne_of_lt"],["of_eq_true"],["le_of_lt"],["LE","le"],["False"],["Subtype","mk"],["Set","mem_singleton_iff","_simp_1"],["Std","instLTSubtype"],["Chapter8","WellFoundedLT","partialOrder","match_1_1"],["LT"],["instInhabitedTrue"],["instDecidableNot"]],"typeReferences":[["Not"],["Subtype"],["Exists"],["PartialOrder","toPreorder"],["Set"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","Elem"],["Set","instMembership"],["Std","instLESubtype"],["IsMin"],["PartialOrder"],["WellFoundedLT"],["Subtype","mk"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["Chapter8","IsStrictUpperBound"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X),\n  Exists fun Y =>\n    And (Chapter8.IsTotal Y.Elem)\n      (And (WellFoundedLT Y.Elem)\n        (And (Exists fun hx₀ => IsMin ⟨x₀, hx₀⟩) (Not (Exists fun x => Chapter8.IsStrictUpperBound Y x))))","name":["Chapter8","WellFoundedLT","partialOrder"],"kind":"theorem","isProp":true},{"valueReferences":[["Classical","choose_spec"],["Subtype","mk","injEq"],["PartialOrder","toPreorder"],["Eq","trans"],["Chapter8","LinearOrder","mk"],["Set","embeddingOfSubset"],["Membership","mem"],["Preorder","toLT"],["eq_true"],["Exists","intro"],["Classical","choose"],["Subtype","val"],["Set","Elem"],["Std","instLESubtype"],["funext"],["forall_congr"],["WellFoundedLT"],["Subtype","exists","_simp_1"],["Function","instFunLikeEmbedding"],["Eq","ndrec"],["Eq","rec"],["forall_prop_domain_congr"],["SemilatticeInf","toPartialOrder"],["And","left"],["Exists"],["Function","Embedding"],["And","right"],["And"],["Set","instMembership"],["Chapter8","WellFoundedLT","subset","match_1_1"],["Set","image"],["Iff","of_eq"],["Iff","mpr"],["Eq","refl"],["Chapter8","WellFoundedLT","subset","_proof_1_8"],["id"],["Eq","mpr"],["implies_congr_ctx"],["Set","mem_image","_simp_1"],["Eq","substr"],["Subtype"],["Eq","mp"],["and_imp","_simp_1"],["Subtype","partialOrder"],["DFunLike","coe"],["congrArg"],["Subtype","mk_le_mk","_simp_1"],["instDistribLatticeOfLinearOrder"],["IsMin"],["Chapter8","IsTotal","subset"],["Eq"],["Preorder","toLE"],["propext"],["Set","Nonempty"],["Lattice","toSemilatticeInf"],["True"],["Set"],["Chapter8","WellFoundedLT","iff"],["exists_prop_congr"],["DistribLattice","toLattice"],["of_eq_true"],["Subtype","forall","_simp_1"],["LE","le"],["Set","embeddingOfSubset","_proof_1"],["forall_exists_index","_simp_1"],["Set","image_nonempty","_simp_1"],["Subtype","mk"],["Std","instLTSubtype"]],"typeReferences":[["PartialOrder","toPreorder"],["Set"],["Membership","mem"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","Elem"],["Set","instMembership"],["Set","instHasSubset"],["HasSubset","Subset"],["PartialOrder"],["WellFoundedLT"],["Chapter8","IsTotal"],["Std","instLTSubtype"]],"type":"∀ {X : Type} [inst : PartialOrder X] {A B : Set X},\n  Chapter8.IsTotal A.Elem → ∀ [hwell : WellFoundedLT A.Elem], Set.instHasSubset.Subset B A → WellFoundedLT B.Elem","name":["Chapter8","WellFoundedLT","subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Subtype","casesOn"],["Set","instMembership"]],"typeReferences":[["Set"],["Membership","mem"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"∀ {X : Type} {Y : Set X} (motive : Y.Elem → Prop) (h : Y.Elem),\n  (∀ (val : X) (property : Set.instMembership.mem Y val), motive ⟨val, property⟩) → motive h","name":["Chapter8","WellFoundedLT","partialOrder","match_1_4"],"kind":"definition","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["PartialOrder","toPreorder"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Preorder","toLT"],["And"],["Chapter8","Lex'","partialOrder","match_1"],["OfNat","ofNat"],["Prod"],["LT","lt"],["Nat"],["Or"],["instOfNatNat"],["LE","le"],["Chapter8","Lex'"],["Lean","Name","num"],["Eq"],["Preorder","toLE"]],"typeReferences":[["LT","lt"],["Prod"],["PartialOrder","toPreorder"],["Or"],["PartialOrder"],["LE","le"],["And"],["Preorder","toLT"],["Chapter8","Lex'"],["Chapter8","Lex'","partialOrder","match_1"],["Preorder","toLE"],["Eq"]],"type":"∀ {X Y : Type} [inst : PartialOrder X] [inst_1 : PartialOrder Y] (a b c : Chapter8.Lex' (Prod X Y)),\n  (Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x y =>\n      Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) b fun x' y' =>\n        Or (inst.lt x x') (And (Eq x x') (inst_1.le y y'))) →\n    (Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) b fun x y =>\n        Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) c fun x' y' =>\n          Or (inst.lt x x') (And (Eq x x') (inst_1.le y y'))) →\n      Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x y =>\n        Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) c fun x' y' =>\n          Or (inst.lt x x') (And (Eq x x') (inst_1.le y y'))","name":["Chapter8","Lex'","partialOrder","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["PartialOrder","toPreorder"],["Chapter8","OrderIdeals"],["Eq","trans"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["Set","range"],["Set","Elem"],["congrArg"],["instOfNatNat"],["Eq"],["Exists"],["True"],["Set"],["Set","mem_range","_simp_1"],["Set","Iic"],["OfNat","ofNat"],["Set","instMembership"],["Set","univ"],["Set","image_univ"],["Function","RightInverse"],["Nat"],["Set","image"],["of_eq_true"],["exists_apply_eq_apply","_simp_1"],["Lean","Name","num"],["Subtype","mk"]],"typeReferences":[["PartialOrder","toPreorder"],["sorryAx"],["Lean","Name","anonymous"],["Chapter8","OrderIdeals"],["Set"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter8","OrderIdeals","iso","_proof_1"],["Set","Iic"],["Set","Elem"],["OfNat","ofNat"],["Set","instMembership"],["Function","RightInverse"],["Nat"],["instOfNatNat"],["PartialOrder"],["Subtype","mk"],["Lean","Name","num"]],"type":"∀ {X : Type} [inst : PartialOrder X], Function.RightInverse sorry fun x => ⟨Set.Iic x, ⋯⟩","name":["Chapter8","OrderIdeals","iso","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Exists"],["PartialOrder","toPreorder"],["Set"],["Membership","mem"],["And"],["Preorder","toLT"],["Exists","intro"],["Subtype","partialOrder"],["Set","Elem"],["Set","instMembership"],["Exists","casesOn"],["And","intro"],["WellFoundedLT"],["LE","le"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["Chapter8","IsStrictUpperBound"],["And","casesOn"],["setOf"]],"typeReferences":[["Not"],["Exists"],["PartialOrder","toPreorder"],["Set"],["Membership","mem"],["And"],["Preorder","toLT"],["Exists","intro"],["Subtype","partialOrder"],["Set","Elem"],["Set","instMembership"],["And","intro"],["PartialOrder"],["LE","le"],["WellFoundedLT"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["Chapter8","IsStrictUpperBound"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X),\n  let Ω₀ :=\n    setOf fun Y =>\n      And (Chapter8.IsTotal Y.Elem)\n        (And (WellFoundedLT Y.Elem)\n          (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x)));\n  ∀\n    (motive :\n      (Exists fun Y => And (Set.instMembership.mem Ω₀ Y) (Not (Exists fun x => Chapter8.IsStrictUpperBound Y x))) →\n        Prop)\n    (this : Exists fun Y => And (Set.instMembership.mem Ω₀ Y) (Not (Exists fun x => Chapter8.IsStrictUpperBound Y x))),\n    (∀ (Y : Set X) (hY : Chapter8.IsTotal Y.Elem)\n        (hY' :\n          And (WellFoundedLT Y.Elem)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x)))\n        (hstrict : Not (Exists fun x => Chapter8.IsStrictUpperBound Y x)), motive ⋯) →\n      motive this","name":["Chapter8","WellFoundedLT","partialOrder","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["PartialOrder","toPreorder"],["Chapter8","OrderIdeals"],["Eq","trans"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["Set","range"],["Set","Elem"],["congrArg"],["instOfNatNat"],["Eq"],["Exists"],["True"],["Set"],["Set","mem_range","_simp_1"],["Set","Iic"],["OfNat","ofNat"],["Set","instMembership"],["Set","univ"],["Set","image_univ"],["Nat"],["Set","image"],["of_eq_true"],["Function","LeftInverse"],["exists_apply_eq_apply","_simp_1"],["Lean","Name","num"],["Subtype","mk"]],"typeReferences":[["PartialOrder","toPreorder"],["sorryAx"],["Lean","Name","anonymous"],["Chapter8","OrderIdeals"],["Set"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter8","OrderIdeals","iso","_proof_1"],["Set","Iic"],["Set","Elem"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["instOfNatNat"],["PartialOrder"],["Function","LeftInverse"],["Subtype","mk"],["Lean","Name","num"]],"type":"∀ {X : Type} [inst : PartialOrder X], Function.LeftInverse sorry fun x => ⟨Set.Iic x, ⋯⟩","name":["Chapter8","OrderIdeals","iso","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["ite"],["Eq","refl"],["LE","le"],["Classical","decRel"],["Preorder","toLE"]],"typeReferences":[["PartialOrder","toPreorder"],["ite"],["PartialOrder"],["LE","le"],["Classical","decRel"],["Preorder","toLE"],["Eq"]],"type":"∀ {X : Type} [inst : PartialOrder X] (a b : X), Eq (ite (inst.le a b) a b) (ite (inst.le a b) a b)","name":["Chapter8","LinearOrder","mk","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Classical","choose_spec"],["PartialOrder","toPreorder"],["Subtype"],["Eq","mp"],["Membership","mem"],["Exists","intro"],["Chapter8","IsMin","iff_lowerbound'","match_1_1"],["Classical","choose"],["Set","Elem"],["Iff","intro"],["congrArg"],["Chapter8","IsMin","iff_lowerbound'","match_1_3"],["Std","instLESubtype"],["And","intro"],["IsMin"],["Preorder","toLE"],["propext"],["Exists"],["Set"],["And"],["Set","instMembership"],["Chapter8","IsMin","iff_lowerbound"],["Iff","mpr"],["LE","le"],["Subtype","mk"]],"typeReferences":[["Exists"],["PartialOrder","toPreorder"],["Set"],["Membership","mem"],["And"],["Subtype","partialOrder"],["Set","Elem"],["Set","instMembership"],["Std","instLESubtype"],["IsMin"],["PartialOrder"],["Iff"],["LE","le"],["Chapter8","IsTotal"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X] {Y : Set X},\n  Chapter8.IsTotal Y.Elem →\n    Iff (Exists fun x₀ => IsMin x₀)\n      (Exists fun x₀ => And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))","name":["Chapter8","IsMin","iff_lowerbound'"],"kind":"theorem","isProp":true},{"valueReferences":[["RelIso","mk"],["PartialOrder","toPreorder"],["sorryAx"],["Lean","Name","anonymous"],["Equiv","mk"],["Chapter8","OrderIdeals"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Set","Elem"],["Std","instLESubtype"],["instOfNatNat"],["Chapter8","OrderIdeals","iso","_proof_2"],["Preorder","toLE"],["Set","instLE"],["Chapter8","OrderIdeals","iso","_proof_4"],["Set"],["Chapter8","OrderIdeals","iso","_proof_3"],["Chapter8","OrderIdeals","iso","_proof_1"],["Set","Iic"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["LE","le"],["Subtype","mk"],["Lean","Name","num"]],"typeReferences":[["Std","instLESubtype"],["PartialOrder","toPreorder"],["Chapter8","OrderIdeals"],["Set"],["PartialOrder"],["Membership","mem"],["OrderIso"],["Preorder","toLE"],["Set","Elem"],["Set","instMembership"],["Set","instLE"]],"type":"{X : Type} → [inst : PartialOrder X] → OrderIso X (Chapter8.OrderIdeals X).Elem","name":["Chapter8","OrderIdeals","iso"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter8","LinearOrder","mk"],["Chapter8","WellFoundedLT","iff"]],"typeReferences":[["Set","Nonempty"],["PartialOrder","toPreorder"],["Exists"],["Set"],["Membership","mem"],["Preorder","toLT"],["Set","Elem"],["Set","instMembership"],["Std","instLESubtype"],["IsMin"],["PartialOrder"],["Iff"],["WellFoundedLT"],["Chapter8","IsTotal"],["Preorder","toLE"]],"type":"∀ {X : Type} [inst : PartialOrder X],\n  Chapter8.IsTotal X → Iff (WellFoundedLT X) (∀ (A : Set X), A.Nonempty → Exists fun x => IsMin x)","name":["Chapter8","WellFoundedLT","iff'"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Chapter8","IsUpperBound"],["Set"],["Membership","mem"],["And"],["Set","instMembership"]],"typeReferences":[["Set"],["PartialOrder"]],"type":"{X : Type} → [PartialOrder X] → Set X → X → Prop","name":["Chapter8","IsStrictUpperBound"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Decidable"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Nonempty"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["WellFoundedLT"],["Empty"],["Lean","Name","num"]],"typeReferences":[["Decidable"],["WellFoundedLT"],["Empty"],["Nonempty"],["LT"]],"type":"[h₀ : LT Empty] → Decidable (Nonempty (WellFoundedLT Empty))","name":["Chapter8","empty_set_well_order"],"kind":"definition","isProp":false},{"valueReferences":[["PartialOrder","toPreorder"],["Set"],["LE","le"],["Membership","mem"],["Preorder","toLE"],["Set","instMembership"]],"typeReferences":[["Set"],["PartialOrder"]],"type":"{X : Type} → [PartialOrder X] → Set X → X → Prop","name":["Chapter8","IsUpperBound"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["PartialOrder","mk"],["Chapter8","PartialOrder","mk","_proof_1"],["LE","le"],["LE","mk"],["And"],["LT","mk"],["Preorder","mk"]],"typeReferences":[["PartialOrder"],["LE","le"],["LE"],["Eq"]],"type":"{X : Type} →\n  [inst : LE X] →\n    (∀ (x : X), inst.le x x) →\n      (∀ (x y : X), inst.le x y → inst.le y x → Eq x y) →\n        (∀ (x y z : X), inst.le x y → inst.le y z → inst.le x z) → PartialOrder X","name":["Chapter8","PartialOrder","mk"],"kind":"definition","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["PartialOrder","toPreorder"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Preorder","toLT"],["And"],["Chapter8","Lex'","partialOrder","match_1"],["OfNat","ofNat"],["Prod"],["LT","lt"],["Nat"],["Or"],["instOfNatNat"],["LE","le"],["Chapter8","Lex'"],["Lean","Name","num"],["Eq"],["Preorder","toLE"]],"typeReferences":[["LT","lt"],["Prod"],["PartialOrder","toPreorder"],["Or"],["PartialOrder"],["LE","le"],["And"],["Preorder","toLT"],["Chapter8","Lex'"],["Chapter8","Lex'","partialOrder","match_1"],["Preorder","toLE"],["Eq"]],"type":"∀ {X Y : Type} [inst : PartialOrder X] [inst_1 : PartialOrder Y] (a : Chapter8.Lex' (Prod X Y)),\n  Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x y =>\n    Chapter8.Lex'.partialOrder.match_1 (fun x => Prop) a fun x' y' => Or (inst.lt x x') (And (Eq x x') (inst_1.le y y'))","name":["Chapter8","Lex'","partialOrder","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Preorder","toLT"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Set","iUnion"],["Classical","choose"],["Subtype","val"],["Or"],["forall_congr"],["Eq","symm"],["Lean","Grind","not_eq_of_eq_true"],["Chapter8","IsTotal"],["Lean","Grind","forall_propagator"],["Set","instSDiff"],["Exists"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_11"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["Lean","Grind","not_not"],["True","intro"],["Lean","Grind","nestedProof"],["Set","instMembership"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_9"],["Exists","casesOn"],["Iff","of_eq"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["Iff","mpr"],["Eq","refl"],["Classical","byContradiction"],["setOf"],["CompleteLattice","instOmegaCompletePartialOrder"],["Lean","Grind","not_and"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["OmegaCompletePartialOrder","toPartialOrder"],["Subtype","partialOrder"],["Lean","Grind","not_exists"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Lean","Grind","of_forall_eq_false"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_8"],["Subtype","property"],["Preorder","toLE"],["Eq"],["Lean","Grind","or_eq_of_eq_false_left"],["propext"],["Set","decidableSingleton"],["Not"],["Lean","Grind","forall_and"],["Set","mem_singleton_iff"],["True"],["Set"],["Set","instSingletonSet"],["exists_prop_congr"],["LT","lt"],["eq_self"],["Lean","Grind","iff_eq"],["LE","le"],["SDiff","sdiff"],["False"],["Subtype","mk"],["Lean","Grind","intro_with_eq"],["Std","instLTSubtype"],["dite"],["Lean","Grind","eq_true_eq"],["And","casesOn"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_10"]],"typeReferences":[["CompleteLattice","instOmegaCompletePartialOrder"],["PartialOrder","toPreorder"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Singleton","singleton"],["OmegaCompletePartialOrder","toPartialOrder"],["Membership","mem"],["Classical","propDecidable"],["Preorder","toLT"],["Subtype","partialOrder"],["CompleteBooleanAlgebra","toCompleteLattice"],["Subtype","val"],["Set","Elem"],["PartialOrder"],["WellFoundedLT"],["Subtype","property"],["Eq"],["Chapter8","IsTotal"],["Preorder","toLE"],["Set","decidableSingleton"],["Chapter8","IsStrictUpperBound"],["Set","instSDiff"],["Exists"],["Set"],["And"],["Set","decidableSdiff"],["Exists","choose"],["Set","instSingletonSet"],["Set","instMembership"],["LT","lt"],["Iff","of_eq"],["Set","instCompleteAtomicBooleanAlgebra"],["Eq","refl"],["Iff","mpr"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["dite"],["Std","instLTSubtype"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X)\n  (hs :\n    ∀ (Y : Set X),\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        Exists fun x => Chapter8.IsStrictUpperBound Y x),\n  (∀\n      (Y :\n        (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x)))).Elem),\n      Chapter8.IsStrictUpperBound Y.val ((fun Y => ⋯.choose) Y)) →\n    ∀\n      (hpt :\n        Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          (Set.instSingletonSet.singleton x₀))\n      (hF :\n        ∀ {Y : Set X},\n          Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal Y.Elem)\n                  (And (WellFoundedLT Y.Elem)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              Y →\n            ∀ {x : X},\n              Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n                Set.instMembership.mem\n                  (setOf fun Y =>\n                    And (Chapter8.IsTotal Y.Elem)\n                      (And (WellFoundedLT Y.Elem)\n                        (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                  (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x))),\n      (∀\n          {Y :\n            (setOf fun Y =>\n                And (Chapter8.IsTotal Y.Elem)\n                  (And (WellFoundedLT Y.Elem)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x)))).Elem}\n          {x : X},\n          Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n            Eq\n              ((fun Y x =>\n                    if hxy :\n                        Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x then\n                      ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                    else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                  Y x).val\n              (setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x))) →\n        Set.instMembership.mem\n            (setOf fun Y =>\n              ∀ (x : X),\n                Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                  Eq x\n                    ((fun Y => ⋯.choose)\n                      ((fun Y x =>\n                          if hxy :\n                              Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀))\n                                x then\n                            ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                          else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                        Y x)))\n            ⟨Set.instSingletonSet.singleton x₀, hpt⟩ →\n          (∀\n              {Y Y' :\n                (setOf fun Y =>\n                    ∀ (x : X),\n                      Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                        Eq x\n                          ((fun Y => ⋯.choose)\n                            ((fun Y x =>\n                                if hxy :\n                                    Set.instMembership.mem\n                                      (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x then\n                                  ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                                else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                              Y x))).Elem}\n              (x : X),\n              Set.instMembership.mem (Set.instSDiff.sdiff Y'.val.val Y.val.val) x →\n                Chapter8.IsStrictUpperBound Y.val.val x) →\n            Chapter8.IsTotal\n                (setOf fun Y =>\n                    ∀ (x : X),\n                      Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                        Eq x\n                          ((fun Y => ⋯.choose)\n                            ((fun Y x =>\n                                if hxy :\n                                    Set.instMembership.mem\n                                      (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x then\n                                  ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                                else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                              Y x))).Elem →\n              And\n                (Exists fun x =>\n                  Set.instMembership.mem\n                    (setOf fun Y =>\n                      ∀ (x : X),\n                        Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                          Eq x\n                            ((fun Y => ⋯.choose)\n                              ((fun Y x =>\n                                  if hxy :\n                                      Set.instMembership.mem\n                                        (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x then\n                                    ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                                  else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                                Y x)))\n                    ⟨⟨Set.instSingletonSet.singleton x₀, hpt⟩.val, ⋯⟩)\n                (Set.instMembership.mem ⟨Set.instSingletonSet.singleton x₀, hpt⟩.val x₀)","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_12"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["PartialOrder","toPreorder"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Preorder","toLT"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Set","iUnion"],["Union","union"],["Classical","choose"],["Subtype","val"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_17"],["Or"],["funext"],["forall_congr"],["Eq","symm"],["Lean","Grind","forall_forall_or"],["Eq","ndrec"],["Chapter8","IsTotal"],["Set","instUnion"],["Lean","Grind","forall_propagator"],["Set","instSDiff"],["Exists"],["IsWellFounded"],["And"],["Set","decidableSdiff"],["True","intro"],["Lean","Grind","nestedProof"],["Set","instMembership"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_9"],["false_or"],["Iff","of_eq"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff","mpr"],["Eq","refl"],["Classical","byContradiction"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_18"],["setOf"],["CompleteLattice","instOmegaCompletePartialOrder"],["Lean","Grind","not_and"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["OmegaCompletePartialOrder","toPartialOrder"],["Classical","choose","congr_simp"],["Lean","Grind","not_or"],["Subtype","partialOrder"],["Lean","Grind","not_exists"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_19"],["Lean","Grind","eq_false_of_not_eq_true"],["dite_congr"],["congrArg"],["Lean","Grind","imp_eq_of_eq_true_left"],["congr"],["Subtype","property"],["Eq"],["Preorder","toLE"],["propext"],["Set","decidableSingleton"],["Not"],["Lean","Grind","forall_and"],["True"],["Set"],["Set","instSingletonSet"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_15"],["exists_prop_congr"],["Eq","mpr_prop"],["LT","lt"],["LE","le"],["SDiff","sdiff"],["False"],["Lean","Grind","intro_with_eq"],["Subtype","mk"],["Std","instLTSubtype"],["dite"],["Chapter8","WellFoundedLT","partialOrder","_proof_1_10"],["And","casesOn"]],"typeReferences":[["CompleteLattice","instOmegaCompletePartialOrder"],["PartialOrder","toPreorder"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Singleton","singleton"],["OmegaCompletePartialOrder","toPartialOrder"],["Membership","mem"],["Classical","propDecidable"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","iUnion"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["Set","Elem"],["Or"],["PartialOrder"],["Subtype","property"],["WellFoundedLT"],["Set","instUnion"],["Chapter8","IsTotal"],["Preorder","toLE"],["Eq"],["Set","decidableSingleton"],["Chapter8","IsStrictUpperBound"],["Set","instSDiff"],["Not"],["Exists"],["Set"],["And"],["Set","decidableSdiff"],["Set","instSingletonSet"],["Exists","choose"],["Set","instMembership"],["LT","lt"],["Iff","of_eq"],["Set","instCompleteAtomicBooleanAlgebra"],["Eq","refl"],["Iff","mpr"],["LE","le"],["SDiff","sdiff"],["Subtype","mk"],["dite"],["Std","instLTSubtype"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X)\n  (hs :\n    ∀ (Y : Set X),\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        Exists fun x => Chapter8.IsStrictUpperBound Y x)\n  (hpt :\n    Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal Y.Elem)\n          (And (WellFoundedLT Y.Elem)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      (Set.instSingletonSet.singleton x₀))\n  (hF :\n    ∀ {Y : Set X},\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal Y.Elem)\n              (And (WellFoundedLT Y.Elem)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        ∀ {x : X},\n          Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n            Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal Y.Elem)\n                  (And (WellFoundedLT Y.Elem)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x))),\n  (∀\n      {Y Y' :\n        (setOf fun Y =>\n            ∀ (x : X),\n              Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                Eq x\n                  ((fun Y => ⋯.choose)\n                    ((fun Y x =>\n                        if hxy :\n                            Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀))\n                              x then\n                          ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                        else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                      Y x))).Elem}\n      (x : X),\n      Set.instMembership.mem (Set.instSDiff.sdiff Y'.val.val Y.val.val) x → Chapter8.IsStrictUpperBound Y.val.val x) →\n    Chapter8.IsTotal\n        (setOf fun Y =>\n            ∀ (x : X),\n              Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                Eq x\n                  ((fun Y => ⋯.choose)\n                    ((fun Y x =>\n                        if hxy :\n                            Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀))\n                              x then\n                          ⟨setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x), ⋯⟩\n                        else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                      Y x))).Elem →\n      Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x₀ →\n        (∀ {x : X}, Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x → inst.le x₀ x) →\n          Chapter8.IsTotal (Set.iUnion fun Y => Y.val.val).Elem →\n            WellFoundedLT (Set.iUnion fun Y => Y.val.val).Elem →\n              ∀\n                (hY_inftyΩ₀ :\n                  Set.instMembership.mem\n                    (setOf fun Y =>\n                      And (Chapter8.IsTotal Y.Elem)\n                        (And (WellFoundedLT Y.Elem)\n                          (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                    (Set.iUnion fun Y => Y.val.val)),\n                Chapter8.IsTotal\n                    (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                        (Set.instSingletonSet.singleton\n                          ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))).Elem →\n                  WellFoundedLT\n                      (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                          (Set.instSingletonSet.singleton\n                            ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))).Elem →\n                    Set.instMembership.mem\n                        (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                          (Set.instSingletonSet.singleton\n                            ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)))\n                        x₀ →\n                      (∀ (x : X),\n                          Set.instMembership.mem\n                              (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                                (Set.instSingletonSet.singleton\n                                  ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)))\n                              x →\n                            inst.le x₀ x) →\n                        Set.instMembership.mem\n                            (setOf fun Y =>\n                              And (Chapter8.IsTotal Y.Elem)\n                                (And (WellFoundedLT Y.Elem)\n                                  (And (Set.instMembership.mem Y x₀)\n                                    (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                            (Set.instUnion.union (Set.iUnion fun Y => Y.val.val)\n                              (Set.instSingletonSet.singleton\n                                ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))) →\n                          (∀ (y : X),\n                              Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) y →\n                                inst.lt y ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩)) →\n                            ∀ (x : X),\n                              Not (Eq x x₀) →\n                                Set.instMembership.mem (Set.iUnion fun Y => Y.val.val) x →\n                                  ∀ (Y : Set X),\n                                    Set.instMembership.mem Y x →\n                                      ∀\n                                        (hYΩ₀ :\n                                          Set.instMembership.mem\n                                            (setOf fun Y =>\n                                              And (Chapter8.IsTotal Y.Elem)\n                                                (And (WellFoundedLT Y.Elem)\n                                                  (And (Set.instMembership.mem Y x₀)\n                                                    (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n                                            Y),\n                                        Set.instMembership.mem\n                                            (setOf fun Y =>\n                                              ∀ (x : X),\n                                                Set.instMembership.mem\n                                                    (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n                                                  Eq x\n                                                    ((fun Y => ⋯.choose)\n                                                      ((fun Y x =>\n                                                          if hxy :\n                                                              Set.instMembership.mem\n                                                                (Set.instSDiff.sdiff Y.val\n                                                                  (Set.instSingletonSet.singleton x₀))\n                                                                x then\n                                                            ⟨setOf fun y =>\n                                                                And (Set.instMembership.mem Y.val y) (inst.lt y x),\n                                                              ⋯⟩\n                                                          else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                                                        Y x)))\n                                            ⟨Y, ⋯⟩ →\n                                          (∀ (x : X),\n                                              Set.instMembership.mem Y x →\n                                                Not (Eq x x₀) →\n                                                  Eq x\n                                                    ((fun Y => ⋯.choose)\n                                                      ((fun Y x =>\n                                                          if hxy :\n                                                              Set.instMembership.mem\n                                                                (Set.instSDiff.sdiff Y.val\n                                                                  (Set.instSingletonSet.singleton x₀))\n                                                                x then\n                                                            ⟨setOf fun y =>\n                                                                And (Set.instMembership.mem Y.val y) (inst.lt y x),\n                                                              ⋯⟩\n                                                          else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                                                        ⟨Y, ⋯⟩ x))) →\n                                            ∀ (y : X),\n                                              inst.lt y x →\n                                                Set.instMembership.mem Y y →\n                                                  Or\n                                                    (Eq y\n                                                      ((fun Y => ⋯.choose) ⟨Set.iUnion fun Y => Y.val.val, hY_inftyΩ₀⟩))\n                                                    (Exists fun i =>\n                                                      And\n                                                        (Exists fun x =>\n                                                          Set.instMembership.mem\n                                                            (setOf fun Y =>\n                                                              ∀ (x : X),\n                                                                Set.instMembership.mem\n                                                                    (Set.instSDiff.sdiff Y.val\n                                                                      (Set.instSingletonSet.singleton x₀))\n                                                                    x →\n                                                                  Eq x\n                                                                    ((fun Y => ⋯.choose)\n                                                                      ((fun Y x =>\n                                                                          if hxy :\n                                                                              Set.instMembership.mem\n                                                                                (Set.instSDiff.sdiff Y.val\n                                                                                  (Set.instSingletonSet.singleton x₀))\n                                                                                x then\n                                                                            ⟨setOf fun y => And ⋯ (inst.lt y x), ⋯⟩\n                                                                          else ⟨Set.instSingletonSet.singleton x₀, hpt⟩)\n                                                                        Y x)))\n                                                            ⟨i, ⋯⟩)\n                                                        (Set.instMembership.mem i y))","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_21"],"kind":"theorem","isProp":true},{"valueReferences":[["LT","lt"],["PartialOrder","toPreorder"],["Set"],["Membership","mem"],["Preorder","toLT"],["Chapter8","IsStrictUpperBound","iff"],["Chapter8","IsStrictUpperBound"],["propext"],["Set","instMembership"]],"typeReferences":[["LT","lt"],["PartialOrder","toPreorder"],["Set"],["PartialOrder"],["Membership","mem"],["Preorder","toLT"],["Eq"],["Chapter8","IsStrictUpperBound"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] (A : Set X) (x : X),\n  Eq (Chapter8.IsStrictUpperBound A x) (∀ (y : X), Set.instMembership.mem A y → inst.lt y x)","name":["Chapter8","WellFoundedLT","partialOrder","_simp_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Or"],["LE","le"],["Preorder","toLE"]],"typeReferences":[["PartialOrder"]],"type":"(X : Type) → [PartialOrder X] → Prop","name":["Chapter8","IsTotal"],"kind":"definition","isProp":false},{"valueReferences":[["PartialOrder","toPreorder"],["Subtype"],["True"],["Eq","trans"],["Eq","mp"],["Set"],["Membership","mem"],["eq_true"],["Subtype","partialOrder"],["Set","Elem"],["congrArg"],["Set","instMembership"],["Subtype","mk_le_mk","_simp_1"],["Std","instLESubtype"],["Or"],["of_eq_true"],["congr"],["LE","le"],["id"],["Chapter8","IsTotal","subset","match_1_1"],["Subtype","mk"],["Preorder","toLE"]],"typeReferences":[["Set","instHasSubset"],["HasSubset","Subset"],["Set"],["PartialOrder"],["Membership","mem"],["Subtype","partialOrder"],["Chapter8","IsTotal"],["Set","Elem"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] {A B : Set X},\n  Chapter8.IsTotal A.Elem → Set.instHasSubset.Subset B A → Chapter8.IsTotal B.Elem","name":["Chapter8","IsTotal","subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["instDistribLatticeOfLinearOrder"],["Nat"],["IsMin"],["DistribLattice","toLattice"],["instOfNatNat"],["Lean","Name","num"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["IsMin"],["Exists"],["LinearOrder"],["Nonempty"],["Preorder","toLE"],["Finite"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {X : Type} [inst : LinearOrder X] [Finite X] [Nonempty X], Exists fun x => IsMin x","name":["Chapter8","IsMin","ofFinite"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","embeddingOfSubset"],["Eq","refl"],["Function","Embedding"],["Set","Elem"]],"typeReferences":[["Set","instHasSubset"],["HasSubset","Subset"],["Set"],["Set","embeddingOfSubset"],["Function","Embedding"],["Eq"],["Set","Elem"]],"type":"∀ {α : Type u_1} (s t : Set α) (h : Set.instHasSubset.Subset s t),\n  Eq (s.embeddingOfSubset t h) (s.embeddingOfSubset t h)","name":["Set","embeddingOfSubset","congr_simp"],"kind":"theorem","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Subtype"],["Set"],["Singleton","singleton"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","instSingletonSet"],["Subtype","val"],["Set","instMembership"],["LT","lt"],["Iff","of_eq"],["Eq","refl"],["Iff","mpr"],["LE","le"],["Subtype","mk"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["setOf"]],"typeReferences":[["PartialOrder","toPreorder"],["Subtype"],["Set"],["Singleton","singleton"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","instSingletonSet"],["Subtype","val"],["Set","instMembership"],["LT","lt"],["PartialOrder"],["LE","le"],["Subtype","mk"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X)\n  (hpt :\n    Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n          (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      (Set.instSingletonSet.singleton x₀)),\n  Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n          (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      (Set.instSingletonSet.singleton x₀) →\n    Set.instMembership.mem\n      (setOf fun Y =>\n        And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n          (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n            (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n      ⟨Set.instSingletonSet.singleton x₀, hpt⟩.val","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_11"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Std","instLESubtype"],["PartialOrder","toPreorder"],["IsMin"],["Set"],["Membership","mem"],["Exists","intro"],["Subtype","casesOn"],["Preorder","toLE"],["Set","Elem"],["Set","instMembership"]],"typeReferences":[["Std","instLESubtype"],["PartialOrder","toPreorder"],["IsMin"],["Exists"],["Set"],["PartialOrder"],["Membership","mem"],["Exists","intro"],["Subtype","mk"],["Preorder","toLE"],["Set","Elem"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] {Y : Set X} (motive : (Exists fun x₀ => IsMin x₀) → Prop)\n  (h : Exists fun x₀ => IsMin x₀),\n  (∀ (x₀ : X) (hx₀ : Set.instMembership.mem Y x₀) (hmin : IsMin ⟨x₀, hx₀⟩), motive ⋯) → motive h","name":["Chapter8","IsMin","iff_lowerbound'","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["PartialOrder","toPreorder"],["Subtype"],["Set"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Subtype","val"],["Set","instMembership"],["LT","lt"],["Subtype","property"],["LE","le"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["setOf"]],"typeReferences":[["PartialOrder","toPreorder"],["Subtype"],["Set"],["Singleton","singleton"],["IsWellFounded"],["Membership","mem"],["And"],["Preorder","toLT"],["Subtype","partialOrder"],["Set","instSingletonSet"],["Subtype","val"],["Set","instMembership"],["LT","lt"],["PartialOrder"],["LE","le"],["SDiff","sdiff"],["Preorder","toLE"],["Chapter8","IsTotal"],["Std","instLTSubtype"],["Set","instSDiff"],["setOf"]],"type":"∀ {X : Type} [inst : PartialOrder X] (x₀ : X),\n  (∀ {Y : Set X},\n      Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          Y →\n        ∀ {x : X},\n          Set.instMembership.mem (Set.instSDiff.sdiff Y (Set.instSingletonSet.singleton x₀)) x →\n            Set.instMembership.mem\n              (setOf fun Y =>\n                And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                  (And\n                    (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 =>\n                      Std.instLTSubtype.lt x1 x2)\n                    (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n              (setOf fun y => And (Set.instMembership.mem Y y) (inst.lt y x))) →\n    ∀\n      {Y :\n        Subtype fun x =>\n          Set.instMembership.mem\n            (setOf fun Y =>\n              And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n                (And\n                  (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                  (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n            x}\n      {x : X},\n      Set.instMembership.mem (Set.instSDiff.sdiff Y.val (Set.instSingletonSet.singleton x₀)) x →\n        Set.instMembership.mem\n          (setOf fun Y =>\n            And (Chapter8.IsTotal (Subtype fun x => Set.instMembership.mem Y x))\n              (And (IsWellFounded (Subtype fun x => Set.instMembership.mem Y x) fun x1 x2 => Std.instLTSubtype.lt x1 x2)\n                (And (Set.instMembership.mem Y x₀) (∀ (x : X), Set.instMembership.mem Y x → inst.le x₀ x))))\n          (setOf fun y => And (Set.instMembership.mem Y.val y) (inst.lt y x))","name":["Chapter8","WellFoundedLT","partialOrder","_proof_1_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["PartialOrder","toPreorder"],["Lean","Name"],["Set"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Preorder","toLT"],["OfNat","ofNat"],["Set","instMembership"],["LT","lt"],["Nat"],["instOfNatNat"],["Iff"],["Lean","Name","num"],["Chapter8","IsStrictUpperBound"]],"typeReferences":[["LT","lt"],["PartialOrder","toPreorder"],["Set"],["Iff"],["PartialOrder"],["Membership","mem"],["Preorder","toLT"],["Chapter8","IsStrictUpperBound"],["Set","instMembership"]],"type":"∀ {X : Type} [inst : PartialOrder X] (A : Set X) (x : X),\n  Iff (Chapter8.IsStrictUpperBound A x) (∀ (y : X), Set.instMembership.mem A y → inst.lt y x)","name":["Chapter8","IsStrictUpperBound","iff"],"kind":"theorem","isProp":true}]
