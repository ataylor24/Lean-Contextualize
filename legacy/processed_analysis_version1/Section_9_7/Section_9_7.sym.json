[{"valueReferences":[["implies_congr"],["Real","instPreorder"],["Eq","trans"],["Lean","Grind","Field","toDiv"],["Lean","Grind","Semiring","toMul"],["eq_true"],["eagerReduce"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Linarith","Expr","add"],["NatCast","natCast"],["SupSet","sSup"],["Eq","symm"],["Bool","true"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["instPreorder_mathlib"],["instLinearOrder_mathlib"],["Lean","Grind","Linarith","lt_lt_combine"],["Set","instMembership"],["instOfNat"],["Iff"],["Eq","refl"],["Lean","Grind","CommRing","Poly","num"],["Lean","Grind","Field","div_eq_mul_inv"],["Classical","byContradiction"],["covariant_swap_add_of_covariant_add"],["setOf"],["Bool"],["Real","instIsStrictOrderedRing"],["Lean","Grind","CommRing","Expr","mul"],["Set","Icc"],["Lean","Grind","and_eq_of_eq_true_right"],["Real","field"],["Real","instNatCast"],["instHDiv"],["Lean","Grind","Ring","toSemiring"],["instOfNatNat"],["contravariant_lt_of_covariant_le"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Set"],["Real","instSupSet"],["Real","instAdd"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["Real","instInv"],["Lean","Grind","iff_eq"],["Real","instDivInvMonoid"],["And","casesOn"],["contravariant_swap_add_of_contravariant_add"],["Lean","Grind","CommRing","lt_norm"],["PartialOrder","toPreorder"],["Membership","mem"],["One","one"],["Preorder","toLT"],["HMul","hMul"],["Lean","Grind","Field","toCommRing"],["HDiv","hDiv"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["Lean","Grind","Linarith","le_norm"],["forall_congr"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","Poly","add"],["Lean","Grind","CommRing","Power","mk"],["Lean","Grind","Ring","toIntModule"],["Real","instAddCommMonoid"],["Set","mem_Icc"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["Lean","Grind","eq_true_of_and_eq_true_right"],["And"],["IsOrderedAddMonoid","toAddLeftMono"],["BddAbove"],["Int","instNegInt"],["Real","instLE"],["Lean","Grind","CommRing","le_norm"],["Nat"],["HasSubset","Subset"],["Real","instAddRightCancelSemigroup"],["instHMul"],["Lean","Grind","CommRing","Expr","var"],["Real","linearOrder"],["Real","instOne"],["Lean","Grind","Linarith","le_lt_combine"],["Lean","Grind","CommRing","Expr","add"],["Eq","mp"],["congrArg"],["Lean","RArray","leaf"],["Lean","Grind","Linarith","Expr","var"],["Real","instLT"],["Lean","RArray","branch"],["AddCommSemigroup","toAddCommMagma"],["Real","partialOrder"],["Real","instMul"],["Not"],["Lean","Grind","Field","toInv"],["Inv","inv"],["Set","Nonempty"],["True"],["instHAdd"],["Lean","Grind","Linarith","lt_norm"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","CommRing","Mon","unit"],["Real","semiring"],["DivInvMonoid","toDiv"],["LT","lt"],["Set","instHasSubset"],["Lean","Grind","CommRing","Expr","num"],["of_eq_true"],["One","toOfNat1"],["Field","toGrindField"],["LE","le"],["Lean","Grind","CommRing","not_le_norm"],["False"],["Lean","Grind","intro_with_eq"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"],["instLENat"]],"typeReferences":[["Real","instPreorder"],["Nat","cast"],["Set","Icc"],["Membership","mem"],["Real","instNatCast"],["GT","gt"],["instHDiv"],["GE","ge"],["HDiv","hDiv"],["SupSet","sSup"],["Real","instLT"],["Preorder","toLE"],["Set","Nonempty"],["Real"],["Set"],["instHAdd"],["And"],["Real","instSupSet"],["Real","instAdd"],["OfNat","ofNat"],["DivInvMonoid","toDiv"],["BddAbove"],["Set","instMembership"],["Real","instLE"],["Set","instHasSubset"],["LT","lt"],["HAdd","hAdd"],["Nat"],["One","toOfNat1"],["HasSubset","Subset"],["LE","le"],["Real","instOne"],["instLENat"],["Real","instDivInvMonoid"],["setOf"]],"type":"∀ {a b : Real} {f : Real → Real} {y : Real},\n  And (Real.instPreorder.le (f a) y) (Real.instPreorder.le y (f b)) →\n    Real.instLT.lt (f a) y →\n      Real.instLT.lt y (f b) →\n        Set.instHasSubset.Subset (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))\n            (Set.Icc a b) →\n          BddAbove (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) →\n            Set.instMembership.mem\n                (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) a →\n              (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)).Nonempty →\n                Set.instMembership.mem (Set.Icc a b)\n                    (Real.instSupSet.sSup\n                      (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))) →\n                  Real.instLE.le\n                      (f\n                        (Real.instSupSet.sSup\n                          (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))))\n                      y →\n                    Real.instLT.lt\n                        (Real.instSupSet.sSup\n                          (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n                        b →\n                      ∀ (N : Nat),\n                        (∀ (n : Nat),\n                            GE.ge n N →\n                              Real.instLT.lt\n                                (instHAdd.hAdd\n                                  (Real.instSupSet.sSup\n                                    (setOf fun x =>\n                                      And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n                                  (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n                                b) →\n                          ∀ (n : Nat),\n                            GE.ge n N →\n                              GT.gt\n                                  (instHAdd.hAdd\n                                    (Real.instSupSet.sSup\n                                      (setOf fun x =>\n                                        And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n                                    (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n                                  (Real.instSupSet.sSup\n                                    (setOf fun x =>\n                                      And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))) →\n                                Real.instPreorder.le a\n                                  (instHAdd.hAdd\n                                    (Real.instSupSet.sSup\n                                      (setOf fun x =>\n                                        And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n                                    (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))","name":["Chapter9","intermediate_value","_proof_1_11"],"kind":"theorem","isProp":true},{"valueReferences":[["contravariant_swap_add_of_contravariant_add"],["Real","instPreorder"],["PartialOrder","toPreorder"],["Preorder","toLT"],["One","one"],["eagerReduce"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Field","toCommRing"],["Lean","Grind","Linarith","Expr","add"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","diseq_split_resolve"],["Lean","Grind","Linarith","Expr","intMul"],["Lean","Grind","Linarith","le_norm"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","Poly","add"],["HSub","hSub"],["Real","instAddCommMonoid"],["Lean","Grind","CommRing","Power","mk"],["Lean","Grind","Ring","toIntModule"],["Bool","true"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["Real"],["instPreorder_mathlib"],["Neg","neg"],["instLinearOrder_mathlib"],["Real","instIsOrderedAddMonoid"],["IsOrderedAddMonoid","toAddLeftMono"],["Real","instSub"],["Int","instNegInt"],["Real","instLE"],["Lean","Grind","CommRing","le_norm"],["Nat"],["instOfNat"],["Eq","refl"],["Real","instAddRightCancelSemigroup"],["Lean","Grind","CommRing","Poly","num"],["Classical","byContradiction"],["Lean","Grind","CommRing","Expr","var"],["Real","linearOrder"],["Real","instOne"],["covariant_swap_add_of_covariant_add"],["Lean","Grind","Linarith","le_lt_combine"],["Bool"],["Real","instIsStrictOrderedRing"],["Lean","Grind","Linarith","diseq_norm"],["Real","field"],["Lean","Grind","CommRing","not_lt_norm"],["Lean","RArray","leaf"],["Lean","Grind","Linarith","Expr","var"],["contravariant_lt_of_covariant_le"],["instOfNatNat"],["Real","instLT"],["Lean","RArray","branch"],["Lean","Grind","CommRing","diseq_norm"],["AddCommSemigroup","toAddCommMagma"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["Real","partialOrder"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Inv","inv"],["instHAdd"],["Real","instAdd"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","CommRing","Mon","unit"],["Real","semiring"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LT","lt"],["Real","instInv"],["Lean","Grind","Linarith","diseq_neg"],["Field","toGrindField"],["LE","le"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"],["instHSub"],["And","casesOn"]],"typeReferences":[["LT","lt"],["Not"],["Real","instPreorder"],["Real"],["Real","instLT"],["LE","le"],["And"],["Preorder","toLE"],["Eq"]],"type":"∀ {a b : Real} {f : Real → Real} {y : Real},\n  Not (Eq y (f a)) → And (Real.instPreorder.le (f a) y) (Real.instPreorder.le y (f b)) → Real.instLT.lt (f a) y","name":["Chapter9","intermediate_value","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["instHPow"],["Nat"],["Monoid","toNatPow"],["Real"],["instOfNatNat"],["Real","instMonoid"],["HSub","hSub"],["Real","instSub"],["HPow","hPow"],["instHSub"],["OfNat","ofNat"]],"typeReferences":[["Real"]],"type":"Real → Real","name":["Chapter9","f_9_7_2"],"kind":"definition","isProp":false},{"valueReferences":[["Real","instPreorder"],["Eq","trans"],["eq_true"],["eagerReduce"],["Lean","Grind","Linarith","le_le_combine"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Linarith","Expr","add"],["Lean","Grind","Linarith","diseq_split_resolve"],["SupSet","sSup"],["Eq","symm"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Bool","true"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["instPreorder_mathlib"],["instLinearOrder_mathlib"],["Set","instMembership"],["instOfNat"],["Iff"],["Lean","Grind","CommRing","Poly","num"],["Eq","refl"],["Classical","byContradiction"],["covariant_swap_add_of_covariant_add"],["setOf"],["Bool"],["Real","instIsStrictOrderedRing"],["Set","Icc"],["Real","field"],["Lean","Grind","Linarith","le_of_eq"],["instOfNatNat"],["contravariant_lt_of_covariant_le"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Set"],["Real","instSupSet"],["Real","instAdd"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["Real","instInv"],["Lean","Grind","iff_eq"],["instHSub"],["And","casesOn"],["contravariant_swap_add_of_contravariant_add"],["Lean","Grind","CommRing","lt_norm"],["PartialOrder","toPreorder"],["Membership","mem"],["One","one"],["Preorder","toLT"],["Lean","Grind","Field","toCommRing"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["Lean","Grind","Linarith","Poly","add"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","le_norm"],["HSub","hSub"],["Lean","Grind","CommRing","Power","mk"],["Lean","Grind","Ring","toIntModule"],["Real","instAddCommMonoid"],["Set","mem_Icc"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["Lean","Grind","CommRing","eq_norm"],["Lean","Grind","eq_true_of_and_eq_true_right"],["And"],["Real","instSub"],["IsOrderedAddMonoid","toAddLeftMono"],["Int","instNegInt"],["BddAbove"],["Real","instLE"],["Nat"],["Lean","Grind","CommRing","le_norm"],["HasSubset","Subset"],["Real","instAddRightCancelSemigroup"],["Lean","Grind","CommRing","Expr","var"],["Real","instOne"],["Real","linearOrder"],["Lean","Grind","Linarith","le_lt_combine"],["Lean","Grind","Linarith","diseq_norm"],["Eq","mp"],["congrArg"],["Lean","Grind","CommRing","not_lt_norm"],["Lean","Grind","Linarith","Expr","var"],["Lean","RArray","leaf"],["Real","instLT"],["Lean","RArray","branch"],["Lean","Grind","CommRing","diseq_norm"],["AddCommSemigroup","toAddCommMagma"],["Real","partialOrder"],["Not"],["Set","Nonempty"],["Inv","inv"],["Lean","Grind","em"],["True"],["Lean","Grind","alreadyNorm"],["instHAdd"],["Lean","Grind","CommRing","Mon","unit"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","Linarith","lt_norm"],["Real","semiring"],["LT","lt"],["Set","instHasSubset"],["Or","casesOn"],["Lean","Grind","Linarith","diseq_neg"],["of_eq_true"],["Field","toGrindField"],["LE","le"],["False"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"]],"typeReferences":[["Set","Nonempty"],["Real","instPreorder"],["Real"],["Set","Icc"],["Set"],["Membership","mem"],["Real","instSupSet"],["And"],["BddAbove"],["Real","instLE"],["Set","instMembership"],["LT","lt"],["Set","instHasSubset"],["HasSubset","Subset"],["SupSet","sSup"],["Real","instLT"],["LE","le"],["Preorder","toLE"],["setOf"]],"type":"∀ {a b : Real} {f : Real → Real} {y : Real},\n  And (Real.instPreorder.le (f a) y) (Real.instPreorder.le y (f b)) →\n    Real.instLT.lt (f a) y →\n      Real.instLT.lt y (f b) →\n        Set.instHasSubset.Subset (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))\n            (Set.Icc a b) →\n          BddAbove (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) →\n            Set.instMembership.mem\n                (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) a →\n              (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)).Nonempty →\n                Set.instMembership.mem (Set.Icc a b)\n                    (Real.instSupSet.sSup\n                      (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))) →\n                  Real.instLE.le\n                      (f\n                        (Real.instSupSet.sSup\n                          (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))))\n                      y →\n                    Real.instLT.lt\n                      (Real.instSupSet.sSup\n                        (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n                      b","name":["Chapter9","intermediate_value","_proof_1_10"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Ring","toNonAssocRing"],["Real","instAddGroup"],["Bool","false"],["Real","normedCommRing"],["MulZeroClass","toMul"],["Mathlib","Tactic","Ring","div_pf"],["AddGroupWithOne","toAddMonoidWithOne"],["eq_true"],["sub_zero"],["Chapter9","intermediate_value","_proof_1_3"],["Int","instCommSemiring"],["BddAbove","mono"],["Eq","symm"],["Real","lattice"],["NonAssocSemiring","toAddCommMonoidWithOne"],["Nat","ble"],["instLatticeInt"],["bddAbove_Icc"],["Real","normedAddCommGroup"],["instLTNat"],["Exists"],["Real","instCommSemiring"],["DivisionSemiring","toSemiring"],["Real","instArchimedean"],["Ring","toSemiring"],["Filter","atTop"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Int","negOfNat"],["Eq","mpr"],["Filter","Tendsto","squeeze"],["covariant_swap_add_of_covariant_add"],["CancelDenoms","add_subst"],["Real","instIsStrictOrderedRing"],["Set","Icc"],["Mathlib","Tactic","Ring","add_mul"],["Not","intro"],["tendsto_one_div_add_atTop_nhds_zero_nat"],["Real","instNatCast"],["Real","instConditionallyCompleteLinearOrder"],["MulZeroOneClass","toMulOneClass"],["Mathlib","Tactic","Ring","atom_pf'"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Nat","instSemiring"],["le_of_tendsto'"],["Int","instIsStrictOrderedRing"],["Mathlib","Tactic","Ring","neg_one_mul"],["Eq"],["instNatCastInt"],["Mathlib","Tactic","Ring","neg_zero"],["Set"],["Int","instIsOrderedAddMonoid"],["DivisionRing","toRing"],["Filter","atTop_neBot"],["Field","toDivisionRing"],["Real","instAdd"],["HPow","hPow"],["Mathlib","Tactic","PushNeg","not_ge_eq"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["eq_self"],["and_self"],["AddZeroClass","toAdd"],["Real","instZero"],["Monoid","toNatPow"],["Chapter9","intermediate_value","_proof_1_9"],["Mathlib","Meta","Positivity","pos_of_isNat"],["instHSub"],["Real","instDivInvMonoid"],["Filter","Eventually"],["LT","lt","trans"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Mathlib","Tactic","Linarith","eq_of_not_lt_of_not_gt"],["Membership","mem"],["Right","add_pos_of_nonneg_of_pos"],["Preorder","toLT"],["Real","instNontrivial"],["GE","ge"],["ContinuousWithinAt","tendsto"],["IsTopologicalRing","toIsTopologicalSemiring"],["Semiring","toNonAssocSemiring"],["forall_congr"],["eq_of_heq"],["Int","instLEInt"],["Chapter9","intermediate_value","_proof_1_1"],["Mathlib","Tactic","Ring","div_congr"],["Semifield","toDivisionSemiring"],["AddGroup","toSubNegMonoid"],["Int","ofNat"],["Filter","Tendsto"],["NonAssocSemiring","toMulZeroOneClass"],["And","left"],["SemilatticeInf","toPartialOrder"],["IsStrictOrderedRing","toPosMulStrictMono"],["AddZeroClass","toZero"],["Real"],["Nat","instPartialOrder"],["Real","instIsOrderedAddMonoid"],["And","right"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["IsTopologicalSemiring","toContinuousAdd"],["ConditionallyCompleteLattice","le_csSup"],["Mathlib","Tactic","Ring","mul_zero"],["Filter","principal"],["Nat"],["AddMonoidWithOne","toNatCast"],["Mathlib","Tactic","Ring","atom_pf"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Real","instOne"],["Set","mem_Icc","_simp_1"],["instArchimedeanNat"],["PosMulStrictMono","toPosMulReflectLE"],["DivisionMonoid","toDivInvOneMonoid"],["GroupWithZero","toDivisionMonoid"],["ge_of_tendsto"],["Nat","cast"],["Eq","mp"],["UniformSpace","toTopologicalSpace"],["ContinuousOn","continuousWithinAt"],["CommRing","toNonUnitalCommRing"],["PosMulReflectLE","toPosMulReflectLT"],["instDistribLatticeOfLinearOrder"],["Nat","cast_nonneg'"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["Monoid","toMulOneClass"],["Filter","Tendsto","comp_of_continuous"],["Real","instDivisionRing"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Real","partialOrder"],["le_refl","_simp_1"],["Not"],["Inv","inv"],["Field","toCommRing"],["instClosedIicTopology"],["instHAdd"],["Distrib","toMul"],["Real","instZeroLEOneClass"],["Mathlib","Tactic","Ring","cast_pos"],["Function","comp"],["Mathlib","Tactic","Ring","add_congr"],["Real","semiring"],["LT","lt"],["One","toOfNat1"],["of_eq_true"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","neg_congr"],["le_of_lt"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Real","instAddCommGroup"],["Field","toSemifield"],["NormedCommRing","toNonUnitalNormedCommRing"],["DivInvMonoid","toInv"],["Classical","choose_spec"],["instAddNat"],["SubtractionMonoid","toSubNegZeroMonoid"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["Real","instPreorder"],["sorryAx"],["PseudoMetricSpace","toUniformSpace"],["Eq","trans"],["Lean","Name","str"],["instClosedIciTopology"],["Exists","intro"],["Classical","choose"],["tendsto_const_nhds"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Mathlib","Tactic","Linarith","sub_neg_of_lt"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Linarith","add_lt_of_le_of_neg"],["ConditionallyCompleteLinearOrder","toConditionallyCompleteLattice"],["SupSet","sSup"],["Mathlib","Tactic","Ring","one_mul"],["SubNegMonoid","toSub"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Eq","ndrec"],["Mathlib","Tactic","Ring","sub_pf"],["nhds"],["rfl"],["Chapter9","intermediate_value","_proof_1_4"],["Real","instAddCommSemigroup"],["Exists","choose_spec"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["DivisionSemiring","toGroupWithZero"],["Filter","tendsto_principal","_simp_1"],["Filter"],["Set","instMembership"],["Filter","eventually_atTop","_simp_1"],["DivInvMonoid","toMonoid"],["instIsTopologicalAddGroupReal"],["Chapter9","intermediate_value","match_1_5"],["instNonemptyOfInhabited"],["Eq","refl"],["AddMonoidWithOne","toOne"],["HEq"],["instInhabitedNat"],["Nat","rawCast"],["setOf"],["AddMonoid","toAddZeroClass"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Bool"],["one_div"],["Real","field"],["SubtractionCommMonoid","toSubtractionMonoid"],["and_true"],["div_pos"],["Chapter9","intermediate_value","_proof_1_7"],["Int","instRing"],["instHDiv"],["Nat","instPreorder"],["HasSolidNorm","orderClosedTopology"],["IsTopologicalAddGroup","to_continuousSub"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["DivisionRing","toDivisionSemiring"],["congr"],["Preorder","toLE"],["Mathlib","Tactic","Ring","mul_add"],["AddMonoidWithOne"],["ge_iff_le","_simp_1"],["propext"],["lt_of_not_ge"],["Distrib","toAdd"],["IsStrictOrderedRing","toIsOrderedRing"],["Filter","Tendsto","const_sub"],["Mul"],["Real","instSupSet"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LinearOrder","toPartialOrder"],["CommRing","toRing"],["AddGroupWithOne","toAddGroup"],["Filter","Tendsto","comp"],["AddCommGroup","toDivisionAddCommMonoid"],["Filter","Tendsto","const_add"],["MulZeroClass","toZero"],["nhdsWithin","eq_1"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["inferInstance"],["Nat","instIsStrictOrderedRing"],["Lean","Name","num"],["neg_neg_of_pos"],["dite"],["Real","instAddMonoid"],["Nat","cast_lt","_simp_1"],["Nat","cast_one"],["Mathlib","Tactic","Ring","zero_mul"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["Lean","Name"],["GroupWithZero","toDivInvMonoid"],["Chapter9","intermediate_value","_proof_1_2"],["instIsDirectedLe"],["HMul","hMul"],["Int","rawCast"],["AddMonoidWithOne","toAddMonoid"],["csSup_le_csSup"],["one_div_lt"],["HDiv","hDiv"],["And","intro"],["Real","instRCLike"],["Ring","toAddGroupWithOne"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocRing"],["funext"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Real","instAddCommMonoid"],["Nat","instLinearOrder"],["RCLike","charZero_rclike"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["instHPow"],["InvOneClass","toInv"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["And"],["exists_lt_of_lt_csSup"],["IsOrderedAddMonoid","toAddLeftMono"],["Real","instSub"],["instIsTopologicalRingReal"],["add_zero"],["Mathlib","Tactic","Linarith","without_one_mul"],["Real","instLE"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Chapter9","intermediate_value","_proof_1_11"],["CancelDenoms","sub_subst"],["Real","decidableEq"],["nhdsWithin"],["Filter","tendsto_inf"],["Real","pseudoMetricSpace"],["Iff","mpr"],["Mathlib","Meta","NormNum","instAddMonoidWithOne"],["Nat","cast_zero"],["Mathlib","Tactic","Ring","mul_pf_right"],["NegZeroClass","toZero"],["id"],["instHMul"],["Real","linearOrder"],["implies_congr_ctx"],["ConditionallyCompleteLattice","toLattice"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Lean","Name","anonymous"],["Nat","cast_add","_simp_1"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["SubNegZeroMonoid","toSubNegMonoid"],["Real","instRing"],["SubNegZeroMonoid","toNegZeroClass"],["Filter","instInf"],["Real","instIsOrderedRing"],["congrArg"],["instOrderTopologyReal"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["MulOneClass","toOne"],["Real","instLT"],["MonoidWithZero","toMonoid"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Mathlib","Tactic","PushNeg","not_not_eq"],["Lattice","toSemilatticeInf"],["HEq","refl"],["True"],["CommSemiring","toSemiring"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["Semiring","toMonoidWithZero"],["Exists","choose"],["notMem_of_csSup_lt"],["Eq","casesOn"],["Mathlib","Tactic","Contrapose","mtr"],["DivInvMonoid","toDiv"],["instHasSolidNormReal"],["Or","casesOn"],["NegZeroClass","toNeg"],["DistribLattice","toLattice"],["DivInvOneMonoid","toInvOneClass"],["Min","min"],["Int","instSemiring"],["LE","le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Chapter9","intermediate_value","_proof_1_10"],["ConditionallyCompleteLattice","toSupSet"],["Int","instAddMonoid"],["instLENat"],["exists_nat_gt"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["Set"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["And"],["ContinuousOn"],["Set","instMembership"],["LT","lt"],["Or"],["Real","pseudoMetricSpace"],["Real","instLT"],["Eq"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ {f : Real → Real},\n      ContinuousOn f (Set.Icc a b) →\n        ∀ {y : Real},\n          Or (Set.instMembership.mem (Set.Icc (f a) (f b)) y) (Set.instMembership.mem (Set.Icc (f a) (f b)) y) →\n            Exists fun c => And (Set.instMembership.mem (Set.Icc a b) c) (Eq (f c) y)","name":["Chapter9","intermediate_value"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Eq","trans"],["eagerReduce"],["eq_true"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Linarith","Expr","add"],["ConditionallyCompleteLinearOrder","toConditionallyCompleteLattice"],["SupSet","sSup"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Bool","true"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["instPreorder_mathlib"],["instLinearOrder_mathlib"],["Lean","Grind","Linarith","lt_lt_combine"],["Set","instMembership"],["instOfNat"],["eq_false"],["Lean","Grind","CommRing","Poly","num"],["Eq","refl"],["Classical","byContradiction"],["covariant_swap_add_of_covariant_add"],["setOf"],["Bool"],["Real","instIsStrictOrderedRing"],["Set","Icc"],["Real","field"],["Real","instConditionallyCompleteLinearOrder"],["instOfNatNat"],["contravariant_lt_of_covariant_le"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Set"],["Real","instSupSet"],["Real","instAdd"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["Lean","Grind","eq_congr'"],["And","casesOn"],["contravariant_swap_add_of_contravariant_add"],["Lean","Grind","CommRing","lt_norm"],["PartialOrder","toPreorder"],["Membership","mem"],["One","one"],["Preorder","toLT"],["Lean","Grind","Field","toCommRing"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","Poly","add"],["Lean","Grind","eq_false_of_imp_eq_true"],["csSup_Icc"],["Lean","Grind","CommRing","Power","mk"],["Lean","Grind","Ring","toIntModule"],["Real","instAddCommMonoid"],["SemilatticeInf","toPartialOrder"],["of_eq_false"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["And"],["IsOrderedAddMonoid","toAddLeftMono"],["Int","instNegInt"],["BddAbove"],["Real","instLE"],["Nat"],["HasSubset","Subset"],["Real","instAddRightCancelSemigroup"],["Lean","Grind","CommRing","Expr","var"],["Real","instOne"],["Real","linearOrder"],["ConditionallyCompleteLattice","toLattice"],["Eq","mp"],["Lean","Grind","Linarith","Expr","var"],["Lean","RArray","leaf"],["Real","instLT"],["Lean","RArray","branch"],["AddCommSemigroup","toAddCommMagma"],["Real","partialOrder"],["Set","Nonempty"],["Lattice","toSemilatticeInf"],["instHAdd"],["Lean","Grind","CommRing","Mon","unit"],["Lean","Grind","Linarith","lt_norm"],["instOrderedRingOfIsStrictOrderedRing"],["Real","semiring"],["LT","lt"],["Set","instHasSubset"],["Field","toGrindField"],["LE","le"],["Lean","Grind","CommRing","not_le_norm"],["False"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"],["ConditionallyCompleteLattice","toSupSet"]],"typeReferences":[["Real","instPreorder"],["PartialOrder","toPreorder"],["Set","Icc"],["Membership","mem"],["Real","instConditionallyCompleteLinearOrder"],["ConditionallyCompleteLinearOrder","toConditionallyCompleteLattice"],["SupSet","sSup"],["Real","instLT"],["Preorder","toLE"],["Eq"],["SemilatticeInf","toPartialOrder"],["Set","Nonempty"],["Lattice","toSemilatticeInf"],["Real"],["Set"],["And"],["BddAbove"],["Set","instMembership"],["Real","instLE"],["Set","instHasSubset"],["LT","lt"],["HasSubset","Subset"],["LE","le"],["ConditionallyCompleteLattice","toLattice"],["ConditionallyCompleteLattice","toSupSet"],["setOf"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ {f : Real → Real} {y : Real},\n      And (Real.instPreorder.le (f a) y) (Real.instPreorder.le y (f b)) →\n        Real.instLT.lt (f a) y →\n          Real.instLT.lt y (f b) →\n            Set.instHasSubset.Subset\n                (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) (Set.Icc a b) →\n              BddAbove (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) →\n                Set.instMembership.mem\n                    (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) a →\n                  (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)).Nonempty →\n                    Eq b (Real.instConditionallyCompleteLinearOrder.sSup (Set.Icc a b))","name":["Chapter9","intermediate_value","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["PseudoMetricSpace","toUniformSpace"],["Lean","Grind","Field","toDiv"],["Eq","trans"],["Lean","Grind","Semiring","toMul"],["eagerReduce"],["Lean","Grind","intro_with_eq'"],["Lean","Grind","CommRing","Mon","mult"],["Classical","choose"],["Lean","Grind","Linarith","Expr","add"],["NatCast","natCast"],["SupSet","sSup"],["Eq","ndrec"],["Bool","true"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["nhds"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["Exists"],["instPreorder_mathlib"],["instLinearOrder_mathlib"],["Lean","Grind","Linarith","lt_lt_combine"],["Set","instMembership"],["Filter","atTop"],["instOfNat"],["Eq","refl"],["Lean","Grind","CommRing","Poly","num"],["Lean","Grind","Field","div_eq_mul_inv"],["Classical","byContradiction"],["covariant_swap_add_of_covariant_add"],["setOf"],["Bool"],["Real","instIsStrictOrderedRing"],["Set","Icc"],["Real","field"],["Real","instNatCast"],["instHDiv"],["Nat","instPreorder"],["Lean","Grind","Ring","toSemiring"],["contravariant_lt_of_covariant_le"],["instOfNatNat"],["congr"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Set"],["Real","instSupSet"],["Real","instAdd"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["Real","instInv"],["instHSub"],["Real","instDivInvMonoid"],["And","casesOn"],["contravariant_swap_add_of_contravariant_add"],["Lean","Grind","CommRing","lt_norm"],["PartialOrder","toPreorder"],["Membership","mem"],["Preorder","toLT"],["One","one"],["HMul","hMul"],["Lean","Grind","Field","toCommRing"],["HDiv","hDiv"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["forall_congr"],["funext"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","Poly","add"],["HSub","hSub"],["Real","instAddCommMonoid"],["Lean","Grind","CommRing","Power","mk"],["Lean","Grind","Ring","toIntModule"],["Filter","Tendsto"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["And"],["IsOrderedAddMonoid","toAddLeftMono"],["Real","instSub"],["BddAbove"],["Lean","Grind","nestedProof"],["Int","instNegInt"],["Real","instLE"],["Nat"],["HasSubset","Subset"],["Chapter9","intermediate_value","_proof_1_8"],["Real","pseudoMetricSpace"],["Real","instAddRightCancelSemigroup"],["instHMul"],["Lean","Grind","CommRing","Expr","var"],["Real","linearOrder"],["Real","instOne"],["UniformSpace","toTopologicalSpace"],["Classical","choose","congr_simp"],["congrArg"],["Lean","RArray","leaf"],["Lean","Grind","Linarith","Expr","var"],["Real","instLT"],["Lean","RArray","branch"],["AddCommSemigroup","toAddCommMagma"],["Real","partialOrder"],["Real","instMul"],["Not"],["Lean","Grind","Field","toInv"],["Set","Nonempty"],["Inv","inv"],["instHAdd"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","Linarith","lt_norm"],["Lean","Grind","CommRing","Mon","unit"],["Real","semiring"],["DivInvMonoid","toDiv"],["Eq","mpr_prop"],["LT","lt"],["Set","instHasSubset"],["One","toOfNat1"],["Field","toGrindField"],["LE","le"],["Lean","Grind","CommRing","not_le_norm"],["False"],["Lean","Grind","intro_with_eq"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"],["Lean","Grind","_simp_1"]],"typeReferences":[["Real","instPreorder"],["Nat","cast"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["Real","instNatCast"],["instHDiv"],["Nat","instPreorder"],["HDiv","hDiv"],["SupSet","sSup"],["Real","instLT"],["HSub","hSub"],["Preorder","toLE"],["nhds"],["Filter","Tendsto"],["Set","Nonempty"],["Exists"],["Real"],["instHAdd"],["Set"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["Exists","choose"],["OfNat","ofNat"],["DivInvMonoid","toDiv"],["BddAbove"],["Set","instMembership"],["Real","instLE"],["HAdd","hAdd"],["Set","instHasSubset"],["LT","lt"],["Filter","atTop"],["Nat"],["One","toOfNat1"],["HasSubset","Subset"],["Real","pseudoMetricSpace"],["LE","le"],["Real","instOne"],["instHSub"],["Real","instDivInvMonoid"],["setOf"]],"type":"∀ {a b : Real} {f : Real → Real} {y : Real},\n  And (Real.instPreorder.le (f a) y) (Real.instPreorder.le y (f b)) →\n    Real.instLT.lt (f a) y →\n      Real.instLT.lt y (f b) →\n        Set.instHasSubset.Subset (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))\n            (Set.Icc a b) →\n          BddAbove (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) →\n            Set.instMembership.mem\n                (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) a →\n              (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)).Nonempty →\n                Set.instMembership.mem (Set.Icc a b)\n                    (Real.instSupSet.sSup\n                      (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))) →\n                  ∀\n                    (hxe :\n                      ∀ (n : Nat),\n                        Exists fun x =>\n                          And\n                            (Set.instMembership.mem\n                              (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)) x)\n                            (Real.instLT.lt\n                              (instHSub.hSub\n                                (Real.instSupSet.sSup\n                                  (setOf fun x =>\n                                    And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n                                (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n                              x)),\n                    (∀ (n : Nat),\n                        Real.instLT.lt\n                          (instHSub.hSub\n                            (Real.instSupSet.sSup\n                              (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n                            (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n                          ((fun n => ⋯.choose) n)) →\n                      Filter.Tendsto (fun n => f ((fun n => ⋯.choose) n)) Filter.atTop\n                          (nhds\n                            (f\n                              (Real.instSupSet.sSup\n                                (setOf fun x =>\n                                  And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))))) →\n                        ∀ (n : Nat),\n                          And\n                              (And (Real.instPreorder.le a ((fun n => ⋯.choose) n))\n                                (Real.instPreorder.le ((fun n => ⋯.choose) n) b))\n                              (Real.instLT.lt (f ((fun n => ⋯.choose) n)) y) →\n                            Real.instLE.le (f ((fun n => ⋯.choose) n)) y","name":["Chapter9","intermediate_value","_proof_1_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Real"],["Lean","Name"],["Set"],["Set","Icc"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["And"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["One","toOfNat1"],["Real","instZero"],["instOfNatNat"],["Real","instOne"],["Zero","toOfNat0"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["PseudoMetricSpace","toUniformSpace"],["Set"],["Set","Icc"],["Membership","mem"],["UniformSpace","toTopologicalSpace"],["And"],["ContinuousOn"],["OfNat","ofNat"],["Set","instMembership"],["Set","instHasSubset"],["Set","image"],["Real","instZero"],["One","toOfNat1"],["HasSubset","Subset"],["Real","pseudoMetricSpace"],["Zero","toOfNat0"],["Real","instOne"],["Eq"]],"type":"∀ {f : Real → Real},\n  ContinuousOn f (Set.Icc 0 1) →\n    Set.instHasSubset.Subset (Set.image f (Set.Icc 0 1)) (Set.Icc 0 1) →\n      Exists fun x => And (Set.instMembership.mem (Set.Icc 0 1) x) (Eq (f x) x)","name":["Chapter9","exists_fixed_pt"],"kind":"theorem","isProp":true},{"valueReferences":[["contravariant_swap_add_of_contravariant_add"],["Real","instPreorder"],["PartialOrder","toPreorder"],["Preorder","toLT"],["One","one"],["eagerReduce"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Field","toCommRing"],["Lean","Grind","Linarith","Expr","add"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","diseq_split_resolve"],["Lean","Grind","Linarith","Expr","intMul"],["Lean","Grind","Linarith","le_norm"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","Poly","add"],["HSub","hSub"],["Real","instAddCommMonoid"],["Lean","Grind","CommRing","Power","mk"],["Lean","Grind","Ring","toIntModule"],["Bool","true"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["Real"],["instPreorder_mathlib"],["Neg","neg"],["instLinearOrder_mathlib"],["Real","instIsOrderedAddMonoid"],["IsOrderedAddMonoid","toAddLeftMono"],["Real","instSub"],["Int","instNegInt"],["Real","instLE"],["Lean","Grind","CommRing","le_norm"],["Nat"],["instOfNat"],["Eq","refl"],["Real","instAddRightCancelSemigroup"],["Lean","Grind","CommRing","Poly","num"],["Classical","byContradiction"],["Lean","Grind","CommRing","Expr","var"],["Real","linearOrder"],["Real","instOne"],["covariant_swap_add_of_covariant_add"],["Lean","Grind","Linarith","le_lt_combine"],["Bool"],["Real","instIsStrictOrderedRing"],["Lean","Grind","Linarith","diseq_norm"],["Real","field"],["Lean","Grind","CommRing","not_lt_norm"],["Lean","RArray","leaf"],["Lean","Grind","Linarith","Expr","var"],["contravariant_lt_of_covariant_le"],["instOfNatNat"],["Real","instLT"],["Lean","RArray","branch"],["Lean","Grind","CommRing","diseq_norm"],["AddCommSemigroup","toAddCommMagma"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["Real","partialOrder"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Inv","inv"],["instHAdd"],["Real","instAdd"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","CommRing","Mon","unit"],["Real","semiring"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LT","lt"],["Real","instInv"],["Lean","Grind","Linarith","diseq_neg"],["Field","toGrindField"],["LE","le"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"],["instHSub"],["And","casesOn"]],"typeReferences":[["LT","lt"],["Not"],["Real","instPreorder"],["Real"],["Real","instLT"],["LE","le"],["And"],["Preorder","toLE"],["Eq"]],"type":"∀ {a b : Real} {f : Real → Real} {y : Real},\n  Not (Eq y (f b)) →\n    And (Real.instPreorder.le (f a) y) (Real.instPreorder.le y (f b)) → Real.instLT.lt (f a) y → Real.instLT.lt y (f b)","name":["Chapter9","intermediate_value","_proof_1_4"],"kind":"theorem","isProp":true},{"valueReferences":[["LT","lt"],["Real","instPreorder"],["Real"],["Set","Icc"],["Set"],["Real","instLT"],["Membership","mem"],["And"],["And","casesOn"],["Set","instMembership"],["setOf"]],"typeReferences":[["LT","lt"],["And","intro"],["Real","instPreorder"],["Real"],["Set","Icc"],["Set"],["Real","instLT"],["Membership","mem"],["And"],["Set","instMembership"],["setOf"]],"type":"∀ {a b : Real} {f : Real → Real} {y : Real} (x : Real),\n  let E := setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y);\n  ∀ (motive : Set.instMembership.mem E x → Prop) (x_1 : Set.instMembership.mem E x),\n    (∀ (hx₁ : Set.instMembership.mem (Set.Icc a b) x) (hx₂ : Real.instLT.lt (f x) y), motive ⋯) → motive x_1","name":["Chapter9","intermediate_value","match_1_5"],"kind":"definition","isProp":true},{"valueReferences":[["contravariant_swap_add_of_contravariant_add"],["Lean","Grind","CommRing","lt_norm"],["Real","instPreorder"],["PartialOrder","toPreorder"],["Eq","trans"],["Membership","mem"],["Preorder","toLT"],["One","one"],["eagerReduce"],["eq_true"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Field","toCommRing"],["Lean","Grind","Linarith","Expr","add"],["Lean","Grind","or_of_and_eq_false"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["Or"],["Lean","Grind","Linarith","Poly","add"],["Lean","Grind","Linarith","Poly","nil"],["Eq","symm"],["Lean","Grind","not_eq_of_eq_true"],["Lean","Grind","CommRing","Power","mk"],["Real","instAddCommMonoid"],["Lean","Grind","Ring","toIntModule"],["Bool","true"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["Set","mem_Icc"],["instPreorder_mathlib"],["Real"],["Neg","neg"],["instLinearOrder_mathlib"],["Real","instIsOrderedAddMonoid"],["And"],["Lean","Grind","Linarith","lt_lt_combine"],["IsOrderedAddMonoid","toAddLeftMono"],["Int","instNegInt"],["Real","instLE"],["Set","instMembership"],["Nat"],["instOfNat"],["Eq","refl"],["Real","instAddRightCancelSemigroup"],["Iff"],["Lean","Grind","CommRing","Poly","num"],["Classical","byContradiction"],["Lean","Grind","CommRing","Expr","var"],["Real","linearOrder"],["Real","instOne"],["covariant_swap_add_of_covariant_add"],["Bool"],["Lean","Grind","not_and"],["Real","instIsStrictOrderedRing"],["Eq","mp"],["Set","Icc"],["Real","field"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","RArray","leaf"],["Lean","Grind","Linarith","Expr","var"],["contravariant_lt_of_covariant_le"],["instOfNatNat"],["Real","instLT"],["Lean","RArray","branch"],["AddCommSemigroup","toAddCommMagma"],["AddCommMagma","toAdd"],["Preorder","toLE"],["Eq"],["Real","partialOrder"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Not"],["True"],["instHAdd"],["Set"],["Real","instAdd"],["Lean","Grind","CommRing","Mon","unit"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","Linarith","lt_norm"],["Real","semiring"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LT","lt"],["Or","casesOn"],["Lean","Grind","iff_eq"],["Field","toGrindField"],["Lean","Grind","or_eq_of_eq_false_right"],["LE","le"],["Lean","Grind","CommRing","not_le_norm"],["False"],["Lean","Grind","intro_with_eq"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"]],"typeReferences":[["LT","lt"],["Real","instPreorder"],["Real"],["Set","Icc"],["Set"],["Real","instLT"],["Membership","mem"],["And"],["Eq"],["Set","instMembership"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ {f : Real → Real} {y : Real}, Eq y (f a) → And (Set.instMembership.mem (Set.Icc a b) a) (Eq (f a) y)","name":["Chapter9","intermediate_value","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Lean","Grind","Field","toDiv"],["Lean","Grind","Semiring","toMul"],["Set","Icc"],["Membership","mem"],["Real","field"],["HMul","hMul"],["Real","instNatCast"],["Lean","Grind","Field","toCommRing"],["instHDiv"],["congrArg"],["HDiv","hDiv"],["Lean","Grind","Ring","toSemiring"],["NatCast","natCast"],["SupSet","sSup"],["Real","instLT"],["funext"],["forall_congr"],["HSub","hSub"],["Eq","ndrec"],["Lean","Grind","CommRing","toRing"],["Real","instMul"],["Lean","Grind","Field","toInv"],["Inv","inv"],["Exists"],["Real"],["Set"],["instHAdd"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["DivInvMonoid","toDiv"],["OfNat","ofNat"],["Eq","mpr_prop"],["Set","instMembership"],["LT","lt"],["HAdd","hAdd"],["Real","instInv"],["Nat"],["One","toOfNat1"],["Field","toGrindField"],["Lean","Grind","Field","div_eq_mul_inv"],["instHMul"],["Real","instOne"],["instHSub"],["Real","instDivInvMonoid"],["setOf"]],"typeReferences":[["Real","instPreorder"],["Set","Icc"],["Membership","mem"],["Real","instNatCast"],["HMul","hMul"],["NatCast","natCast"],["SupSet","sSup"],["Real","instLT"],["HSub","hSub"],["Real","instMul"],["Inv","inv"],["Exists"],["Real"],["instHAdd"],["Set"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["OfNat","ofNat"],["Set","instMembership"],["HAdd","hAdd"],["LT","lt"],["Real","instInv"],["Nat"],["One","toOfNat1"],["instHMul"],["Real","instOne"],["instHSub"],["setOf"]],"type":"∀ {a b : Real} {f : Real → Real} {y : Real},\n  (∀ (n : Nat),\n      Exists fun x =>\n        And\n          (Set.instMembership.mem (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))\n            x)\n          (Real.instLT.lt\n            (instHSub.hSub\n              (Real.instSupSet.sSup\n                (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n              (instHMul.hMul 1 (Real.instInv.inv (instHAdd.hAdd (Real.instNatCast.natCast n) 1))))\n            x)) →\n    ∀ (n : Nat),\n      Exists fun x =>\n        And\n          (Set.instMembership.mem (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y))\n            x)\n          (Real.instLT.lt\n            (instHSub.hSub\n              (Real.instSupSet.sSup\n                (setOf fun x => And (Set.instMembership.mem (Set.Icc a b) x) (Real.instLT.lt (f x) y)))\n              (instHMul.hMul 1 (Real.instInv.inv (instHAdd.hAdd (Real.instNatCast.natCast n) 1))))\n            x)","name":["Chapter9","intermediate_value","_proof_1_8"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Eq","trans"],["eq_true"],["eagerReduce"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Linarith","Expr","add"],["Eq","symm"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Bool","true"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["instPreorder_mathlib"],["instLinearOrder_mathlib"],["Lean","Grind","Linarith","lt_lt_combine"],["Set","instMembership"],["instOfNat"],["Iff"],["Lean","Grind","CommRing","Poly","num"],["Eq","refl"],["Classical","byContradiction"],["covariant_swap_add_of_covariant_add"],["Bool"],["Real","instIsStrictOrderedRing"],["Set","Icc"],["Real","field"],["Lean","Grind","eq_false_of_not_eq_true"],["instOfNatNat"],["contravariant_lt_of_covariant_le"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Set"],["Real","instAdd"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["Real","instInv"],["Lean","Grind","iff_eq"],["Lean","Grind","or_eq_of_eq_false_right"],["instHSub"],["contravariant_swap_add_of_contravariant_add"],["Lean","Grind","CommRing","lt_norm"],["PartialOrder","toPreorder"],["Membership","mem"],["One","one"],["Preorder","toLT"],["Lean","Grind","Field","toCommRing"],["Lean","Grind","or_of_and_eq_false"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["Or"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","Poly","add"],["HSub","hSub"],["Lean","Grind","not_eq_of_eq_true"],["Lean","Grind","CommRing","Power","mk"],["Lean","Grind","Ring","toIntModule"],["Real","instAddCommMonoid"],["Set","mem_Icc"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["And"],["Real","instSub"],["IsOrderedAddMonoid","toAddLeftMono"],["Int","instNegInt"],["Real","instLE"],["Nat"],["Real","instAddRightCancelSemigroup"],["Lean","Grind","CommRing","Expr","var"],["Real","instOne"],["Real","linearOrder"],["Lean","Grind","not_and"],["Eq","mp"],["Lean","RArray","leaf"],["Lean","Grind","Linarith","Expr","var"],["Real","instLT"],["Lean","RArray","branch"],["AddCommSemigroup","toAddCommMagma"],["Real","partialOrder"],["Not"],["Inv","inv"],["True"],["instHAdd"],["Lean","Grind","CommRing","Mon","unit"],["Lean","Grind","Linarith","lt_norm"],["instOrderedRingOfIsStrictOrderedRing"],["Real","semiring"],["Or","casesOn"],["LT","lt"],["Field","toGrindField"],["LE","le"],["Lean","Grind","CommRing","not_le_norm"],["False"],["Lean","Grind","intro_with_eq"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"]],"typeReferences":[["LT","lt"],["Real","instPreorder"],["Real"],["Set","Icc"],["Set"],["Real","instLT"],["Membership","mem"],["And"],["Eq"],["Set","instMembership"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ {f : Real → Real} {y : Real}, Eq y (f b) → And (Set.instMembership.mem (Set.Icc a b) b) (Eq (f b) y)","name":["Chapter9","intermediate_value","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["One","toOfNat1"],["Real","decidableLE"],["Real","instZero"],["Real"],["Neg","neg"],["ite"],["Real","instNeg"],["LE","le"],["Real","instOne"],["Zero","toOfNat0"],["OfNat","ofNat"],["Real","instLE"]],"typeReferences":[["Real"]],"type":"Real → Real","name":["Chapter9","f_9_7_1"],"kind":"definition","isProp":false},{"valueReferences":[["Real","instPreorder"],["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Real"],["Lean","Name"],["Set"],["Set","Icc"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["And"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["PseudoMetricSpace","toUniformSpace"],["Set"],["Set","Icc"],["Membership","mem"],["UniformSpace","toTopologicalSpace"],["Real","instSupSet"],["And"],["ContinuousOn"],["Set","instMembership"],["Real","instLE"],["LT","lt"],["Set","image"],["SupSet","sSup"],["Real","pseudoMetricSpace"],["Real","instLT"],["LE","le"],["InfSet","sInf"],["Eq"],["Real","instInfSet"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ {f : Real → Real},\n      ContinuousOn f (Set.Icc a b) →\n        ∀ {y : Real},\n          And (Real.instLE.le (Real.instInfSet.sInf (Set.image f (Set.Icc a b))) y)\n              (Real.instLE.le y (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))) →\n            Exists fun c => And (Set.instMembership.mem (Set.Icc a b) c) (Eq (f c) y)","name":["Chapter9","continuous_image_Icc"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Lean","Name","anonymous"],["sorryAx"],["Real"],["Lean","Name"],["Set"],["Set","Icc"],["Lean","Name","str"],["Bool","false"],["Real","instSupSet"],["OfNat","ofNat"],["Nat"],["Set","image"],["instOfNatNat"],["SupSet","sSup"],["InfSet","sInf"],["Lean","Name","num"],["Eq"],["Real","instInfSet"]],"typeReferences":[["Real","instPreorder"],["Real"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["Set"],["UniformSpace","toTopologicalSpace"],["Real","instSupSet"],["ContinuousOn"],["LT","lt"],["Set","image"],["SupSet","sSup"],["Real","pseudoMetricSpace"],["Real","instLT"],["InfSet","sInf"],["Real","instInfSet"],["Eq"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ {f : Real → Real},\n      ContinuousOn f (Set.Icc a b) →\n        Eq (Set.image f (Set.Icc a b))\n          (Set.Icc (Real.instInfSet.sInf (Set.image f (Set.Icc a b)))\n            (Real.instSupSet.sSup (Set.image f (Set.Icc a b))))","name":["Chapter9","continuous_image_Icc'"],"kind":"theorem","isProp":true}]
