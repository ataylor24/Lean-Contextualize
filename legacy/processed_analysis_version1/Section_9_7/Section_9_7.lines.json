[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":78},{"state":[],"start":79},{"state":[],"start":80},{"state":[],"start":84},{"state":[],"start":142},{"state":[],"start":143},{"state":[],"start":239},{"state":[],"start":328},{"state":[],"start":420},{"state":[],"start":517},{"state":[],"start":527},{"state":[],"start":528},{"state":[],"start":576},{"state":[],"start":610},{"state":[],"start":613},{"state":[],"start":614},{"state":[],"start":633},{"state":[],"start":634},{"state":[],"start":684},{"state":[],"start":854},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":[],"mvarId":["_uniq",482],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"y ∈ Set.Icc (f a) (f b) ∨ y ∈ Set.Icc (f a) (f b)","name":["hy"],"isProp":true,"id":["_uniq",481],"binderInfo":"default"}]}],"start":893},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":[],"mvarId":["_uniq",482],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"y ∈ Set.Icc (f a) (f b) ∨ y ∈ Set.Icc (f a) (f b)","name":["hy"],"isProp":true,"id":["_uniq",481],"binderInfo":"default"}]}],"start":966},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["inl"],"mvarId":["_uniq",508],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"y ∈ Set.Icc (f a) (f b)","name":["hy_left"],"isProp":true,"id":["_uniq",507],"binderInfo":"default"}]},{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["inr"],"mvarId":["_uniq",513],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"y ∈ Set.Icc (f a) (f b)","name":["hy_right"],"isProp":true,"id":["_uniq",512],"binderInfo":"default"}]}],"start":1000},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",101],"mvarId":["_uniq",542],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"y ∈ Set.Icc (f a) (f b)","name":["hy_left"],"isProp":true,"id":["_uniq",507],"binderInfo":"default"},{"type":"¬y = f a","name":["hya"],"isProp":true,"id":["_uniq",541],"binderInfo":"default"}]}],"start":1041},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",2615],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"y ∈ Set.Icc (f a) (f b)","name":["hy_left"],"isProp":true,"id":["_uniq",507],"binderInfo":"default"},{"type":"¬y = f a","name":["hya"],"isProp":true,"id":["_uniq",541],"binderInfo":"default"},{"type":"¬y = f b","name":["hyb"],"isProp":true,"id":["_uniq",2614],"binderInfo":"default"}]}],"start":1082},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",6723],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"¬y = f a","name":["hya"],"isProp":true,"id":["_uniq",541],"binderInfo":"default"},{"type":"¬y = f b","name":["hyb"],"isProp":true,"id":["_uniq",2614],"binderInfo":"default"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"}]}],"start":1102},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",8615],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"¬y = f b","name":["hyb"],"isProp":true,"id":["_uniq",2614],"binderInfo":"default"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]}]}],"start":1140},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",10551],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]}]}],"start":1178},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",10648],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]}]}],"start":1227},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",10943],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]}]}],"start":1294},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",11169],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]}]}],"start":1347},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",11253],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]}]}],"start":1404},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",14666],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]}]}],"start":1450},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",14697],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]}]}],"start":1470},{"state":[{"type":"c ∈ Set.Icc a b","tag":[],"mvarId":["_uniq",14968],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]}]}],"start":1508},{"state":[{"type":"a ≤ c","tag":["refine_1"],"mvarId":["_uniq",17008],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]}]},{"type":"c ≤ b","tag":["refine_2"],"mvarId":["_uniq",17009],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]}]}],"start":1531},{"state":[{"type":"c ≤ b","tag":["refine_2"],"mvarId":["_uniq",17009],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]}]}],"start":1593},{"state":[{"type":"b = sSup (Set.Icc a b)","tag":["h","e'_4"],"mvarId":["_uniq",17818],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]}]}],"start":1650},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["neg","_@","_hyg",203],"mvarId":["_uniq",14970],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]}]}],"start":1674},{"state":[{"type":"f c = y","tag":["right"],"mvarId":["_uniq",20419],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]}]}],"start":1688},{"state":[{"type":"f c ≤ y","tag":[],"mvarId":["_uniq",20457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]}]}],"start":1725},{"state":[{"type":"∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","tag":[],"mvarId":["_uniq",20804],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",20463],"binderInfo":"default"}]}],"start":1789},{"state":[{"type":"∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","tag":[],"mvarId":["_uniq",21014],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",20463],"binderInfo":"default"},{"value":"div_pos (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"1 / ((↑n : ℝ) + 1) > 0","name":["this"],"isProp":true,"id":["_uniq",21013]}]}],"start":1837},{"state":[{"type":"∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","tag":[],"mvarId":["_uniq",28555],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",20463],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                      (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          Nat.rawCast 1 +\n                        0)))\n                  (Mathlib.Tactic.Ring.zero_mul\n                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                        Nat.rawCast 1 +\n                      0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                        Nat.rawCast 1 +\n                      0))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                    (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                      (Int.negOfNat 1).rawCast +\n                    0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf c)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"c - 1 / ((↑n : ℝ) + 1) < sSup E","name":["this"],"isProp":true,"id":["_uniq",27263]}]}],"start":1895},{"state":[{"type":"f c ≤ y","tag":[],"mvarId":["_uniq",20807],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]}]}],"start":1941},{"state":[{"type":"f c ≤ y","tag":[],"mvarId":["_uniq",28812],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]}]}],"start":1981},{"state":[{"type":"f c ≤ y","tag":[],"mvarId":["_uniq",29110],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]}]}],"start":2041},{"state":[{"type":"f c ≤ y","tag":[],"mvarId":["_uniq",29439],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]}],"start":2113},{"state":[{"type":"Filter.Tendsto x Filter.atTop (nhds c)","tag":[],"mvarId":["_uniq",29615],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]}],"start":2164},{"state":[{"type":"Filter.Tendsto (fun j => c - 1 / ((↑j : ℝ) + 1)) Filter.atTop (nhds c)","tag":["hg"],"mvarId":["_uniq",29867],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]},{"type":"Filter.Tendsto (fun j => c) Filter.atTop (nhds c)","tag":["hh"],"mvarId":["_uniq",29868],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]},{"type":"(fun j => c - 1 / ((↑j : ℝ) + 1)) ≤ x","tag":["hgf"],"mvarId":["_uniq",29869],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]},{"type":"x ≤ fun j => c","tag":["hfh"],"mvarId":["_uniq",29870],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]}],"start":2262},{"state":[{"type":"Filter.Tendsto (fun j => c) Filter.atTop (nhds c)","tag":["hh"],"mvarId":["_uniq",29868],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]},{"type":"(fun j => c - 1 / ((↑j : ℝ) + 1)) ≤ x","tag":["hgf"],"mvarId":["_uniq",29869],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]},{"type":"x ≤ fun j => c","tag":["hfh"],"mvarId":["_uniq",29870],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]}],"start":2337},{"state":[{"type":"(fun j => c - 1 / ((↑j : ℝ) + 1)) ≤ x","tag":["hgf"],"mvarId":["_uniq",29869],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]},{"type":"x ≤ fun j => c","tag":["hfh"],"mvarId":["_uniq",29870],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]}],"start":2372},{"state":[{"type":"x ≤ fun j => c","tag":["hfh"],"mvarId":["_uniq",29870],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]}]}],"start":2415},{"state":[{"type":"f c ≤ y","tag":[],"mvarId":["_uniq",29617],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]},{"value":"Filter.Tendsto.squeeze\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α β f l₁ l₂ l₂' e'_5 =>\n          Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n            (fun h =>\n              Eq.ndrec (motive := fun l₂' =>\n                ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n                (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n            (Eq.refl l₂') (HEq.refl e'_5))\n        ℕ ℝ (fun j => c - 1 / ((↑j : ℝ) + 1)) Filter.atTop (nhds c) (nhds (c - 0))\n        (eq_of_heq\n          ((fun X inst x x' e'_3 =>\n              Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n                (fun h =>\n                  Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                    (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n                (Eq.refl x') (HEq.refl e'_3))\n            ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace c (c - 0)\n            (of_eq_true (Eq.trans (congrArg (Eq c) (sub_zero c)) (eq_self c)))))))\n    (Filter.Tendsto.const_sub c tendsto_one_div_add_atTop_nhds_zero_nat))\n  tendsto_const_nhds (fun n => le_of_lt (hx2 n)) fun n => ConditionallyCompleteLattice.le_csSup E (x n) hE_bdd (hx1 n)","type":"Filter.Tendsto x Filter.atTop (nhds c)","name":["this"],"isProp":true,"id":["_uniq",29616]}]}],"start":2496},{"state":[{"type":"f c ≤ y","tag":[],"mvarId":["_uniq",31348],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]},{"value":"Filter.Tendsto.comp_of_continuous hc (ContinuousOn.continuousWithinAt hf hc) (fun n => hE (hx1 n)) _fvar.29616","type":"Filter.Tendsto (fun n => f (x n)) Filter.atTop (nhds (f c))","name":["this"],"isProp":true,"id":["_uniq",31344]}]}],"start":2590},{"state":[{"type":"f c ≤ y","tag":[],"mvarId":["_uniq",31362],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ (n : ℕ), ∃ x ∈ E, c - 1 / ((↑n : ℝ) + 1) < x","name":["hxe"],"isProp":true,"id":["_uniq",20806]},{"value":"fun n => ⋯.choose","type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",28811]},{"value":"fun n => (Exists.choose_spec (hxe n)).left","type":"∀ (n : ℕ), x n ∈ E","name":["hx1"],"isProp":true,"id":["_uniq",29108]},{"value":"fun n => (Exists.choose_spec (hxe n)).right","type":"∀ (n : ℕ), c - 1 / ((↑n : ℝ) + 1) < x n","name":["hx2"],"isProp":true,"id":["_uniq",29437]},{"value":"Filter.Tendsto.comp_of_continuous hc (ContinuousOn.continuousWithinAt hf hc) (fun n => hE (hx1 n)) _fvar.29616","type":"Filter.Tendsto (fun n => f (x n)) Filter.atTop (nhds (f c))","name":["this"],"isProp":true,"id":["_uniq",31344]},{"value":"fun n =>\n  intermediate_value._proof_7 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hxe hx2 this n\n    (Eq.mp\n      (congrArg (fun x_1 => x n ∈ setOf x_1) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n      (hx1 n))","type":"∀ (n : ℕ), f (x n) ≤ y","name":["hfxny"],"isProp":true,"id":["_uniq",31360]}]}],"start":2678},{"state":[{"type":"f c = y","tag":["right"],"mvarId":["_uniq",20459],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]}]}],"start":2716},{"state":[{"type":"f c = y","tag":["right"],"mvarId":["_uniq",39329],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]}]}],"start":2749},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",41548],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]}]}],"start":2786},{"state":[{"type":"∃ N, ∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","tag":[],"mvarId":["_uniq",41870],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]}]}],"start":2849},{"state":[{"type":"∃ N, ∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","tag":[],"mvarId":["_uniq",42033],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",42029],"binderInfo":"default"},{"type":"1 / (b - c) < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",42032],"binderInfo":"default"}]}],"start":2899},{"state":[{"type":"c + 1 / ((↑n : ℝ) + 1) < b","tag":["h"],"mvarId":["_uniq",42096],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",42029],"binderInfo":"default"},{"type":"1 / (b - c) < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",42032],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",42092],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",42095],"binderInfo":"default"}]}],"start":2925},{"state":[{"type":"c + 1 / ((↑n : ℝ) + 1) < b","tag":["h"],"mvarId":["_uniq",42174],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",42029],"binderInfo":"default"},{"type":"1 / (b - c) < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",42032],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",42092],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",42095],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf c) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (c ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf c)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul c (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (c ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (c ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero c (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hne)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"0 < b - c","name":["hpos"],"isProp":true,"id":["_uniq",42173]}]}],"start":2968},{"state":[{"type":"c + 1 / ((↑n : ℝ) + 1) < b","tag":["h"],"mvarId":["_uniq",44277],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",42029],"binderInfo":"default"},{"type":"1 / (b - c) < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",42032],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",42092],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",42095],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf c) (Mathlib.Tactic.Ring.atom_pf b)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (c ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf c)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul c (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (c ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (c ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero c (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hne)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"0 < b - c","name":["hpos"],"isProp":true,"id":["_uniq",42173]},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a)\n      (propext\n        (one_div_lt\n          (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n              (Eq.refl (Nat.ble 1 1))))\n          hpos))))\n  (LT.lt.trans hN\n    (Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => (↑N : ℝ) < (↑n : ℝ) + x) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (LT.lt (↑N : ℝ)) (Nat.cast_add._simp_1 n 1)) Nat.cast_lt._simp_1)))\n      (lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℤ))\n                      (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ((↑N : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((↑N : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑N : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt ((↑N : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le (id (Eq.mp (Mathlib.Tactic.Zify.natCast_le._simp_1 N n) hn))))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (id\n                  (Eq.mp\n                    (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (n + 1) N)\n                      (congrArg (fun x => x ≤ (↑N : ℤ))\n                        (Eq.trans (Nat.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℤ)) Nat.cast_one))))\n                    a))))))))","type":"1 / ((↑n : ℝ) + 1) < b - c","name":["this"],"isProp":true,"id":["_uniq",44276]}]}],"start":3081},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",41872],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"value":"(fun N hN =>\n    Exists.intro N fun n hn =>\n      have hpos :=\n        lt_of_not_ge fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf c) (Mathlib.Tactic.Ring.atom_pf b)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (c ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (c ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          (c ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero c (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hne)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)));\n      have this :=\n        Eq.mpr\n          (id\n            (congrArg (fun _a => _a)\n              (propext\n                (one_div_lt\n                  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                      (Eq.refl (Nat.ble 1 1))))\n                  hpos))))\n          (LT.lt.trans hN\n            (Eq.mpr\n              (id\n                (Eq.trans (congrArg (fun x => (↑N : ℝ) < (↑n : ℝ) + x) (Eq.symm Nat.cast_one))\n                  (Eq.trans (congrArg (LT.lt (↑N : ℝ)) (Nat.cast_add._simp_1 n 1)) Nat.cast_lt._simp_1)))\n              (lt_of_not_ge fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℤ))\n                              (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt ((↑N : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((↑N : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.atom_pf (↑N : ℤ))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑N : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ((↑N : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat ⋯).rawCast)\n                                  ⋯))))\n                          ⋯)\n                        ⋯))\n                    ⋯))));\n      ⋯)\n  ⋯ ⋯","type":"∃ N, ∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["this"],"isProp":true,"id":["_uniq",41871]}]}],"start":3098},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",60829],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"}]}],"start":3127},{"state":[{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","tag":[],"mvarId":["_uniq",61260],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"}]}],"start":3198},{"state":[{"type":"c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","tag":[],"mvarId":["_uniq",61273],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",61269],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",61272],"binderInfo":"default"}]}],"start":3217},{"state":[{"type":"a ≤ c + 1 / ((↑n : ℝ) + 1)","tag":[],"mvarId":["_uniq",64303],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",61269],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",61272],"binderInfo":"default"}]}],"start":3261},{"state":[{"type":"a ≤ c + 1 / ((↑n : ℝ) + 1)","tag":[],"mvarId":["_uniq",64611],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",61269],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",61272],"binderInfo":"default"},{"value":"div_pos (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"1 / ((↑n : ℝ) + 1) > 0","name":["this"],"isProp":true,"id":["_uniq",64610]}]}],"start":3309},{"state":[{"type":"a ≤ c + 1 / ((↑n : ℝ) + 1)","tag":[],"mvarId":["_uniq",73702],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",61269],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",61272],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                      (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          Nat.rawCast 1 +\n                        0)))\n                  (Mathlib.Tactic.Ring.zero_mul\n                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                        Nat.rawCast 1 +\n                      0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                        Nat.rawCast 1 +\n                      0))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                    (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                      (Int.negOfNat 1).rawCast +\n                    0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf c)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.atom_pf'\n                        (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_pf_right ⋯ ⋯ ⋯) ⋯ ⋯) ⋯ ⋯)))\n                  ⋯)\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"c + 1 / ((↑n : ℝ) + 1) > c","name":["this"],"isProp":true,"id":["_uniq",71544]}]}],"start":3362},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",61264],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]}]}],"start":3376},{"state":[{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∉ E","tag":[],"mvarId":["_uniq",76679],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]}]}],"start":3430},{"state":[{"type":"c + 1 / ((↑n : ℝ) + 1) ∉ E","tag":[],"mvarId":["_uniq",76692],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",76688],"binderInfo":"default"},{"type":"n ≥ N","name":["a✝"],"isProp":true,"id":["_uniq",76691],"binderInfo":"default"}]}],"start":3448},{"state":[{"type":"c + 1 / ((↑n : ℝ) + 1) ∉ E","tag":[],"mvarId":["_uniq",76927],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",76688],"binderInfo":"default"},{"type":"n ≥ N","name":["a✝"],"isProp":true,"id":["_uniq",76691],"binderInfo":"default"},{"value":"div_pos (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1))))","type":"1 / ((↑n : ℝ) + 1) > 0","name":["this"],"isProp":true,"id":["_uniq",76926]}]}],"start":3496},{"state":[{"type":"c + 1 / ((↑n : ℝ) + 1) ∉ E","tag":[],"mvarId":["_uniq",86250],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",76688],"binderInfo":"default"},{"type":"n ≥ N","name":["a✝"],"isProp":true,"id":["_uniq",76691],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_right (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                      (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          Nat.rawCast 1 +\n                        0)))\n                  (Mathlib.Tactic.Ring.zero_mul\n                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                        Nat.rawCast 1 +\n                      0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                        Nat.rawCast 1 +\n                      0))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                    (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                      (Int.negOfNat 1).rawCast +\n                    0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.atom_pf c)\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.atom_pf'\n                        (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_pf_right ⋯ ⋯ ⋯) ⋯ ⋯) ⋯ ⋯)))\n                  ⋯)\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"c + 1 / ((↑n : ℝ) + 1) > c","name":["this"],"isProp":true,"id":["_uniq",84087]}]}],"start":3549},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",76683],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"value":"fun n a =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_add ⋯ ⋯ ⋯) ⋯ ⋯)))\n                      ⋯)\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∉ E","name":["this"],"isProp":true,"id":["_uniq",76680]}]}],"start":3592},{"state":[{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","tag":[],"mvarId":["_uniq",86945],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"value":"fun n a =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_add ⋯ ⋯ ⋯) ⋯ ⋯)))\n                      ⋯)\n                    ⋯)\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∉ E","name":["this"],"isProp":true,"id":["_uniq",76680]}]}],"start":3653},{"state":[{"type":"c + 1 / ((↑n : ℝ) + 1) ∈ E","tag":[],"mvarId":["_uniq",87044],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",86954],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",86957],"binderInfo":"default"},{"type":"f (c + 1 / ((↑n : ℝ) + 1)) < y","name":["this"],"isProp":true,"id":["_uniq",87043],"binderInfo":"default"}]}],"start":3712},{"state":[{"type":"(a ≤ c + ((↑n : ℝ) + 1)⁻¹ ∧ c + ((↑n : ℝ) + 1)⁻¹ ≤ b) ∧ f (c + ((↑n : ℝ) + 1)⁻¹) < y","tag":[],"mvarId":["_uniq",92596],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",86954],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",86957],"binderInfo":"default"},{"type":"f (c + 1 / ((↑n : ℝ) + 1)) < y","name":["this"],"isProp":true,"id":["_uniq",87043],"binderInfo":"default"}]}],"start":3729},{"state":[{"type":"(a ≤ c + ((↑n : ℝ) + 1)⁻¹ ∧ c + ((↑n : ℝ) + 1)⁻¹ ≤ b) ∧ f (c + ((↑n : ℝ) + 1)⁻¹) < y","tag":[],"mvarId":["_uniq",92604],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",86954],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",86957],"binderInfo":"default"},{"type":"f (c + 1 / ((↑n : ℝ) + 1)) < y","name":["this✝"],"isProp":true,"id":["_uniq",87043],"binderInfo":"default"},{"value":"hmem n hn","type":"c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",92603]}]}],"start":3755},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",120008],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]}]}],"start":3772},{"state":[{"type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c)","tag":[],"mvarId":["_uniq",120615],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]}]}],"start":3859},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",120617],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β f l₁ l₂ l₂' e'_5 =>\n        Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun l₂' =>\n              ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n              (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n          (Eq.refl l₂') (HEq.refl e'_5))\n      ℕ ℝ (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c) (nhds (c + 0))\n      (eq_of_heq\n        ((fun X inst x x' e'_3 =>\n            Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                  (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n              (Eq.refl x') (HEq.refl e'_3))\n          ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace c (c + 0)\n          (of_eq_true (Eq.trans (congrArg (Eq c) (add_zero c)) (eq_self c)))))))\n  (Filter.Tendsto.const_add c tendsto_one_div_add_atTop_nhds_zero_nat)","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c)","name":["hconv"],"isProp":true,"id":["_uniq",120616]}]}],"start":3933},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",122093],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β f l₁ l₂ l₂' e'_5 =>\n        Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun l₂' =>\n              ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n              (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n          (Eq.refl l₂') (HEq.refl e'_5))\n      ℕ ℝ (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c) (nhds (c + 0))\n      (eq_of_heq\n        ((fun X inst x x' e'_3 =>\n            Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                  (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n              (Eq.refl x') (HEq.refl e'_3))\n          ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace c (c + 0)\n          (of_eq_true (Eq.trans (congrArg (Eq c) (add_zero c)) (eq_self c)))))))\n  (Filter.Tendsto.const_add c tendsto_one_div_add_atTop_nhds_zero_nat)","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c)","name":["hconv"],"isProp":true,"id":["_uniq",120616]},{"value":"ContinuousWithinAt.tendsto (ContinuousOn.continuousWithinAt _fvar.479 hc)","type":"Filter.Tendsto f (nhdsWithin c (Set.Icc a b)) (nhds (f c))","name":["hf"],"isProp":true,"id":["_uniq",122089]}]}],"start":3988},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",122256],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β f l₁ l₂ l₂' e'_5 =>\n        Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun l₂' =>\n              ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n              (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n          (Eq.refl l₂') (HEq.refl e'_5))\n      ℕ ℝ (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c) (nhds (c + 0))\n      (eq_of_heq\n        ((fun X inst x x' e'_3 =>\n            Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                  (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n              (Eq.refl x') (HEq.refl e'_3))\n          ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace c (c + 0)\n          (of_eq_true (Eq.trans (congrArg (Eq c) (add_zero c)) (eq_self c)))))))\n  (Filter.Tendsto.const_add c tendsto_one_div_add_atTop_nhds_zero_nat)","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c)","name":["hconv"],"isProp":true,"id":["_uniq",120616]},{"type":"Filter.Tendsto f (nhds c ⊓ Filter.principal (Set.Icc a b)) (nhds (f c))","name":["hf"],"isProp":true,"id":["_uniq",122253],"binderInfo":"default"}]}],"start":4021},{"state":[{"type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (Filter.principal (Set.Icc a b))","tag":[],"mvarId":["_uniq",122747],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β f l₁ l₂ l₂' e'_5 =>\n        Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun l₂' =>\n              ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n              (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n          (Eq.refl l₂') (HEq.refl e'_5))\n      ℕ ℝ (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c) (nhds (c + 0))\n      (eq_of_heq\n        ((fun X inst x x' e'_3 =>\n            Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                  (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n              (Eq.refl x') (HEq.refl e'_3))\n          ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace c (c + 0)\n          (of_eq_true (Eq.trans (congrArg (Eq c) (add_zero c)) (eq_self c)))))))\n  (Filter.Tendsto.const_add c tendsto_one_div_add_atTop_nhds_zero_nat)","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c)","name":["hconv"],"isProp":true,"id":["_uniq",120616]},{"type":"Filter.Tendsto f (nhds c ⊓ Filter.principal (Set.Icc a b)) (nhds (f c))","name":["hf"],"isProp":true,"id":["_uniq",122253],"binderInfo":"default"}]}],"start":4124},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",122749],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β f l₁ l₂ l₂' e'_5 =>\n        Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun l₂' =>\n              ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n              (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n          (Eq.refl l₂') (HEq.refl e'_5))\n      ℕ ℝ (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c) (nhds (c + 0))\n      (eq_of_heq\n        ((fun X inst x x' e'_3 =>\n            Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                  (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n              (Eq.refl x') (HEq.refl e'_3))\n          ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace c (c + 0)\n          (of_eq_true (Eq.trans (congrArg (Eq c) (add_zero c)) (eq_self c)))))))\n  (Filter.Tendsto.const_add c tendsto_one_div_add_atTop_nhds_zero_nat)","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c)","name":["hconv"],"isProp":true,"id":["_uniq",120616]},{"type":"Filter.Tendsto f (nhds c ⊓ Filter.principal (Set.Icc a b)) (nhds (f c))","name":["hf"],"isProp":true,"id":["_uniq",122253],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans Filter.tendsto_principal._simp_1\n      (Eq.trans Filter.eventually_atTop._simp_1\n        (congrArg Exists\n          (funext fun a_1 =>\n            forall_congr fun b_1 =>\n              implies_congr ge_iff_le._simp_1 (Eq.refl (c + 1 / ((↑b_1 : ℝ) + 1) ∈ Set.Icc a b)))))))\n  (Exists.intro N hmem)","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (Filter.principal (Set.Icc a b))","name":["hconv'"],"isProp":true,"id":["_uniq",122748]}]}],"start":4169},{"state":[{"type":"y ≤ f c","tag":[],"mvarId":["_uniq",128839],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β f l₁ l₂ l₂' e'_5 =>\n        Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun l₂' =>\n              ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n              (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n          (Eq.refl l₂') (HEq.refl e'_5))\n      ℕ ℝ (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c) (nhds (c + 0))\n      (eq_of_heq\n        ((fun X inst x x' e'_3 =>\n            Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                  (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n              (Eq.refl x') (HEq.refl e'_3))\n          ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace c (c + 0)\n          (of_eq_true (Eq.trans (congrArg (Eq c) (add_zero c)) (eq_self c)))))))\n  (Filter.Tendsto.const_add c tendsto_one_div_add_atTop_nhds_zero_nat)","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c)","name":["hconv"],"isProp":true,"id":["_uniq",120616]},{"type":"Filter.Tendsto f (nhds c ⊓ Filter.principal (Set.Icc a b)) (nhds (f c))","name":["hf"],"isProp":true,"id":["_uniq",122253],"binderInfo":"default"},{"value":"Filter.tendsto_inf.mpr ⟨hconv, _fvar.122748⟩","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c ⊓ Filter.principal (Set.Icc a b))","name":["hconv'"],"isProp":true,"id":["_uniq",128835]}]}],"start":4238},{"state":[{"type":"∀ᶠ (c_1 : ℕ) in Filter.atTop, y ≤ (f ∘ fun n => c + 1 / ((↑n : ℝ) + 1)) c_1","tag":[],"mvarId":["_uniq",128891],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",60822],"binderInfo":"default"},{"type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) < b","name":["hN"],"isProp":true,"id":["_uniq",60826],"binderInfo":"default"},{"value":"fun n hn =>\n  Eq.mpr\n    (id\n      (Eq.trans Set.mem_Icc._simp_1\n        (Eq.trans (congrArg (And (a ≤ c + 1 / ((↑n : ℝ) + 1))) (eq_true (le_of_lt (hN n hn))))\n          (and_true (a ≤ c + 1 / ((↑n : ℝ) + 1))))))\n    (have this :=\n      div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n        (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n          (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n            (Eq.refl (Nat.ble 1 1))));\n    have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.div_pf\n                          (Mathlib.Tactic.Ring.atom_pf'\n                            (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right\n                                (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                    Nat.rawCast 1 +\n                                  0)))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right\n                            (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))\n                        (Mathlib.Tactic.Ring.zero_mul\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                          (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            (Int.negOfNat 1).rawCast +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf c)\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right c (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.mul_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.div_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1) (Mathlib.Tactic.Ring.add_pf_add_zero ⋯)))\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯)\n                ⋯))\n            ⋯);\n    ⋯)","type":"∀ n ≥ N, c + 1 / ((↑n : ℝ) + 1) ∈ Set.Icc a b","name":["hmem"],"isProp":true,"id":["_uniq",61261]},{"type":"∀ n ≥ N, f (c + 1 / ((↑n : ℝ) + 1)) ≥ y","name":["this"],"isProp":true,"id":["_uniq",86946]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α β f l₁ l₂ l₂' e'_5 =>\n        Eq.casesOn (motive := fun a x => l₂' = a → e'_5 ≍ x → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂') e'_5\n          (fun h =>\n            Eq.ndrec (motive := fun l₂' =>\n              ∀ (e_5 : l₂ = l₂'), e_5 ≍ Eq.refl l₂ → Filter.Tendsto f l₁ l₂ ≍ Filter.Tendsto f l₁ l₂')\n              (fun e_5 h => HEq.refl (Filter.Tendsto f l₁ l₂)) (Eq.symm h) e'_5)\n          (Eq.refl l₂') (HEq.refl e'_5))\n      ℕ ℝ (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c) (nhds (c + 0))\n      (eq_of_heq\n        ((fun X inst x x' e'_3 =>\n            Eq.casesOn (motive := fun a x_1 => x' = a → e'_3 ≍ x_1 → nhds x ≍ nhds x') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun x' => ∀ (e_3 : x = x'), e_3 ≍ Eq.refl x → nhds x ≍ nhds x')\n                  (fun e_3 h => HEq.refl (nhds x)) (Eq.symm h) e'_3)\n              (Eq.refl x') (HEq.refl e'_3))\n          ℝ PseudoMetricSpace.toUniformSpace.toTopologicalSpace c (c + 0)\n          (of_eq_true (Eq.trans (congrArg (Eq c) (add_zero c)) (eq_self c)))))))\n  (Filter.Tendsto.const_add c tendsto_one_div_add_atTop_nhds_zero_nat)","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c)","name":["hconv"],"isProp":true,"id":["_uniq",120616]},{"type":"Filter.Tendsto f (nhds c ⊓ Filter.principal (Set.Icc a b)) (nhds (f c))","name":["hf"],"isProp":true,"id":["_uniq",122253],"binderInfo":"default"},{"value":"Filter.tendsto_inf.mpr ⟨hconv, _fvar.122748⟩","type":"Filter.Tendsto (fun n => c + 1 / ((↑n : ℝ) + 1)) Filter.atTop (nhds c ⊓ Filter.principal (Set.Icc a b))","name":["hconv'"],"isProp":true,"id":["_uniq",128835]}]}],"start":4283},{"state":[{"type":"f c = y","tag":["right"],"mvarId":["_uniq",41550],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"f a ≤ y ∧ y ≤ f b","name":["hy_left"],"isProp":true,"id":["_uniq",6720],"binderInfo":"default"},{"value":"intermediate_value._proof_3 _fvar.541 hy_left","type":"f a < y","name":["hya"],"isProp":true,"id":["_uniq",6731]},{"value":"intermediate_value._proof_4 _fvar.2614 hy_left hya","type":"y < f b","name":["hyb"],"isProp":true,"id":["_uniq",8624]},{"value":"{x | x ∈ Set.Icc a b ∧ f x < y}","type":"Set ℝ","name":["E"],"isProp":false,"id":["_uniq",10647]},{"value":"fun x x_1 =>\n  match x_1 with\n  | ⟨hx₁, hx₂⟩ => hx₁","type":"E ⊆ Set.Icc a b","name":["hE"],"isProp":true,"id":["_uniq",10942]},{"value":"BddAbove.mono hE bddAbove_Icc","type":"BddAbove E","name":["hE_bdd"],"isProp":true,"id":["_uniq",11168]},{"value":"of_eq_true\n  (Eq.trans (congrArg (fun x => a ∈ setOf x) (funext fun x => congrArg (fun x_1 => x_1 ∧ f x < y) Set.mem_Icc._simp_1))\n    (Eq.trans\n      (congr\n        (congrArg And (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true (le_of_lt hab))) (and_self True)))\n        (eq_true hya))\n      (and_self True)))","type":"a ∈ E","name":["hEa"],"isProp":true,"id":["_uniq",11252]},{"value":"Exists.intro a hEa","type":"E.Nonempty","name":["hE_nonempty"],"isProp":true,"id":["_uniq",14665]},{"value":"sSup E","type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",14696]},{"value":"Eq.mpr (id Set.mem_Icc._simp_1)\n  ⟨ConditionallyCompleteLattice.le_csSup E a hE_bdd hEa,\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a_1 a' e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a')) e'_4\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n              (Eq.refl a') (HEq.refl e'_4))\n          ℝ Real.instPreorder.toLE c b (sSup (Set.Icc a b))\n          (intermediate_value._proof_5 hab hy_left hya hyb hE hE_bdd hEa hE_nonempty)))\n      (csSup_le_csSup bddAbove_Icc hE_nonempty hE)⟩","type":"c ∈ Set.Icc a b","name":["hc"],"isProp":true,"id":["_uniq",14969]},{"value":"have hxe := fun n =>\n  have this :=\n    div_pos\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n          (Eq.refl (Nat.ble 1 1))));\n  have this :=\n    lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.atom_pf'\n                          (Eq.refl (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right\n                              (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                  Nat.rawCast 1 +\n                                0)))\n                          (Mathlib.Tactic.Ring.zero_mul\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                                Nat.rawCast 1 +\n                              0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right\n                          (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                              Nat.rawCast 1 +\n                            0)))\n                      (Mathlib.Tactic.Ring.zero_mul\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                        ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                            Nat.rawCast 1 +\n                          0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹\n                        (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((Nat.rawCast 1 + ((↑n : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))⁻¹ ^ Nat.rawCast 1 *\n                          (Int.negOfNat 1).rawCast +\n                        0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (sSup E))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf c)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (sSup E) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (sSup E ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.div_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℝ))\n                          (Mathlib.Tactic.Ring.cast_pos ⋯) ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯;\n⋯","type":"f c ≤ y","name":["hfc_upper"],"isProp":true,"id":["_uniq",20458]},{"value":"intermediate_value._proof_8 hy_left hya hyb hE hE_bdd hEa hE_nonempty hc hfc_upper","type":"c < b","name":["hne"],"isProp":true,"id":["_uniq",39328]},{"value":"have this :=\n  (fun N hN =>\n      Exists.intro N fun n hn =>\n        have hpos :=\n          lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf c) (Mathlib.Tactic.Ring.atom_pf b)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (c ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf c)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul c (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_gt (c ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (c ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero c (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.ofNat 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hne)\n                  (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)));\n        have this :=\n          Eq.mpr\n            (id\n              (congrArg (fun _a => _a)\n                (propext\n                  (one_div_lt\n                    (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' n)\n                      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Eq.refl (Nat.ble 1 1))))\n                    hpos))))\n            (LT.lt.trans hN\n              (Eq.mpr\n                (id\n                  (Eq.trans (congrArg (fun x => (↑N : ℝ) < (↑n : ℝ) + x) (Eq.symm Nat.cast_one))\n                    (Eq.trans (congrArg (LT.lt (↑N : ℝ)) (Nat.cast_add._simp_1 n 1)) Nat.cast_lt._simp_1)))\n                (lt_of_not_ge fun a =>\n                  Mathlib.Tactic.Linarith.lt_irrefl\n                    (Eq.mp\n                      (congrArg (fun _a => _a < 0)\n                        (Mathlib.Tactic.Ring.of_eq\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℤ))\n                                (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.sub_pf\n                                  (Mathlib.Tactic.Ring.neg_add\n                                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.neg_one_mul\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                            (Eq.refl (Int.negOfNat 1))))))\n                                    Mathlib.Tactic.Ring.neg_zero)\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑N : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  ((↑N : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                    ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.atom_pf (↑N : ℤ))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (↑N : ℤ) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_gt ((↑N : ℤ) ^ Nat.rawCast 1 * ⋯.rawCast) ⋯))))\n                            ⋯)\n                          ⋯))\n                      ⋯))));\n        ⋯)\n    ⋯ ⋯;\n⋯","type":"y ≤ f c","name":["hfc_lower"],"isProp":true,"id":["_uniq",41549]}]}],"start":4312},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":["inr"],"mvarId":["_uniq",513],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",475],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",476],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",477],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",478],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",479],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",480],"binderInfo":"implicit"},{"type":"y ∈ Set.Icc (f a) (f b)","name":["hy_right"],"isProp":true,"id":["_uniq",512],"binderInfo":"default"}]}],"start":4325},{"state":[],"start":4333},{"state":[],"start":4334},{"state":[],"start":4352},{"state":[],"start":4434},{"state":[],"start":4435},{"state":[{"type":"0 ∈ Set.Icc (f_9_7_1 (-1)) (f_9_7_1 1) ∧ ¬∃ x ∈ Set.Icc (-1) 1, f_9_7_1 x = 0","tag":[],"mvarId":["_uniq",137530],"isProp":true,"context":[]}],"start":4539},{"state":[],"start":4547},{"state":[],"start":4548},{"state":[],"start":4568},{"state":[],"start":4618},{"state":[],"start":4619},{"state":[],"start":4659},{"state":[],"start":4695},{"state":[],"start":4734},{"state":[],"start":4770},{"state":[],"start":4806},{"state":[],"start":4807},{"state":[],"start":4827},{"state":[],"start":4892},{"state":[],"start":4893},{"state":[],"start":4966},{"state":[{"type":"∃ c ∈ Set.Icc a b, f c = y","tag":[],"mvarId":["_uniq",139191],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",139184],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",139185],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",139186],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",139187],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",139188],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",139189],"binderInfo":"implicit"},{"type":"sInf (f '' Set.Icc a b) ≤ y ∧ y ≤ sSup (f '' Set.Icc a b)","name":["hy"],"isProp":true,"id":["_uniq",139190],"binderInfo":"default"}]}],"start":5177},{"state":[],"start":5185},{"state":[],"start":5186},{"state":[{"type":"f '' Set.Icc a b = Set.Icc (sInf (f '' Set.Icc a b)) (sSup (f '' Set.Icc a b))","tag":[],"mvarId":["_uniq",139795],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",139790],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",139791],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",139792],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",139793],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",139794],"binderInfo":"default"}]}],"start":5362},{"state":[],"start":5370},{"state":[],"start":5371},{"state":[],"start":5393},{"state":[{"type":"∃ x ∈ Set.Icc 0 1, f x = x","tag":[],"mvarId":["_uniq",140451],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",140448],"binderInfo":"implicit"},{"type":"ContinuousOn f (Set.Icc 0 1)","name":["hf"],"isProp":true,"id":["_uniq",140449],"binderInfo":"default"},{"type":"f '' Set.Icc 0 1 ⊆ Set.Icc 0 1","name":["hmap"],"isProp":true,"id":["_uniq",140450],"binderInfo":"default"}]}],"start":5539},{"state":[],"start":5547},{"state":[],"start":5548},{"state":[],"start":5561},{"state":[],"start":5561}]
