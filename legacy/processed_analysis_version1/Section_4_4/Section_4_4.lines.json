[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":23},{"state":[],"start":27},{"state":[],"start":83},{"state":[],"start":84},{"state":[],"start":180},{"state":[],"start":268},{"state":[],"start":364},{"state":[],"start":457},{"state":[],"start":467},{"state":[],"start":468},{"state":[],"start":516},{"state":[],"start":517},{"state":[],"start":587},{"state":[],"start":588},{"state":[],"start":684},{"state":[],"start":735},{"state":[],"start":736},{"state":[],"start":760},{"state":[],"start":761},{"state":[],"start":905},{"state":[],"start":906},{"state":[],"start":923},{"state":[],"start":924},{"state":[],"start":927},{"state":[],"start":928},{"state":[],"start":1011},{"state":[{"type":"∃! n, (↑n : ℚ) ≤ x ∧ x < (↑n : ℚ) + 1","tag":[],"mvarId":["_uniq",832],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",831],"binderInfo":"default"}]}],"start":1083},{"state":[],"start":1091},{"state":[],"start":1092},{"state":[{"type":"∃ n, (↑n : ℚ) > x","tag":[],"mvarId":["_uniq",1865],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1864],"binderInfo":"default"}]}],"start":1147},{"state":[],"start":1155},{"state":[],"start":1156},{"state":[],"start":1210},{"state":[{"type":"∃ z, x < z ∧ z < y","tag":[],"mvarId":["_uniq",1896],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"}]}],"start":1297},{"state":[{"type":"∃ z, x < z ∧ z < y","tag":[],"mvarId":["_uniq",1896],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"}]}],"start":1370},{"state":[{"type":"∃ z, x < z ∧ z < y","tag":[],"mvarId":["_uniq",1896],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"}]}],"start":1437},{"state":[{"type":"∃ z, x < z ∧ z < y","tag":[],"mvarId":["_uniq",1896],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"}]}],"start":1477},{"state":[{"type":"x < (x + y) / 2 ∧ (x + y) / 2 < y","tag":["h"],"mvarId":["_uniq",1901],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"}]}],"start":1491},{"state":[{"type":"x / 2 < y / 2","tag":[],"mvarId":["_uniq",2194],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"}]}],"start":1519},{"state":[{"type":"x * (1 / 2) < y * (1 / 2)","tag":[],"mvarId":["_uniq",2738],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"}]}],"start":1583},{"state":[{"type":"x < (x + y) / 2 ∧ (x + y) / 2 < y","tag":["h"],"mvarId":["_uniq",2196],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a < y / 2)\n      (have this :=\n        Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.div_congr (Mathlib.Tactic.Ring.atom_pf x)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.div_pf\n              (Mathlib.Tactic.Ring.inv_single\n                (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                  (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf x)\n            (Mathlib.Tactic.Ring.div_congr\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                      (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0))));\n      this)))\n  (Eq.mpr\n    (id\n      (congrArg (fun _a => x * (1 / 2) < _a)\n        (have this :=\n          Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.div_congr (Mathlib.Tactic.Ring.atom_pf y)\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                      (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                    (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n            (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y)\n              (Mathlib.Tactic.Ring.div_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.div_pf\n                  (Mathlib.Tactic.Ring.inv_single\n                    (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0))));\n        this)))\n    (mul_lt_mul_of_pos_right h\n      (div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2))))))","type":"x / 2 < y / 2","name":["h'"],"isProp":true,"id":["_uniq",2195]}]}],"start":1631},{"state":[{"type":"x < (x + y) / 2","tag":["h","left"],"mvarId":["_uniq",3538],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a < y / 2)\n      (have this :=\n        Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.div_congr (Mathlib.Tactic.Ring.atom_pf x)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.div_pf\n              (Mathlib.Tactic.Ring.inv_single\n                (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                  (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf x)\n            (Mathlib.Tactic.Ring.div_congr\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                      (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0))));\n      this)))\n  (Eq.mpr\n    (id\n      (congrArg (fun _a => x * (1 / 2) < _a)\n        (have this :=\n          Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.div_congr (Mathlib.Tactic.Ring.atom_pf y)\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                      (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                    (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n            (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y)\n              (Mathlib.Tactic.Ring.div_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.div_pf\n                  (Mathlib.Tactic.Ring.inv_single\n                    (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0))));\n        this)))\n    (mul_lt_mul_of_pos_right h\n      (div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2))))))","type":"x / 2 < y / 2","name":["h'"],"isProp":true,"id":["_uniq",2195]}]},{"type":"(x + y) / 2 < y","tag":["h","right"],"mvarId":["_uniq",3539],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a < y / 2)\n      (have this :=\n        Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.div_congr (Mathlib.Tactic.Ring.atom_pf x)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.div_pf\n              (Mathlib.Tactic.Ring.inv_single\n                (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                  (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf x)\n            (Mathlib.Tactic.Ring.div_congr\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                      (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0))));\n      this)))\n  (Eq.mpr\n    (id\n      (congrArg (fun _a => x * (1 / 2) < _a)\n        (have this :=\n          Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.div_congr (Mathlib.Tactic.Ring.atom_pf y)\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                      (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                    (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n            (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y)\n              (Mathlib.Tactic.Ring.div_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.div_pf\n                  (Mathlib.Tactic.Ring.inv_single\n                    (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0))));\n        this)))\n    (mul_lt_mul_of_pos_right h\n      (div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2))))))","type":"x / 2 < y / 2","name":["h'"],"isProp":true,"id":["_uniq",2195]}]}],"start":1645},{"state":[{"type":"(x + y) / 2 < y","tag":["h","right"],"mvarId":["_uniq",3539],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",1893],"binderInfo":"implicit"},{"type":"ℚ","name":["y"],"isProp":false,"id":["_uniq",1894],"binderInfo":"implicit"},{"type":"x < y","name":["h"],"isProp":true,"id":["_uniq",1895],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (congrArg (fun _a => _a < y / 2)\n      (have this :=\n        Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.div_congr (Mathlib.Tactic.Ring.atom_pf x)\n            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n            (Mathlib.Tactic.Ring.div_pf\n              (Mathlib.Tactic.Ring.inv_single\n                (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                  (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf x)\n            (Mathlib.Tactic.Ring.div_congr\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                      (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left x (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                (Mathlib.Tactic.Ring.mul_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0))));\n      this)))\n  (Eq.mpr\n    (id\n      (congrArg (fun _a => x * (1 / 2) < _a)\n        (have this :=\n          Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.div_congr (Mathlib.Tactic.Ring.atom_pf y)\n              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n              (Mathlib.Tactic.Ring.div_pf\n                (Mathlib.Tactic.Ring.inv_single\n                  (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                      (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                    (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n            (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf y)\n              (Mathlib.Tactic.Ring.div_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.div_pf\n                  (Mathlib.Tactic.Ring.inv_single\n                    (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 2)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_mul\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left y (Nat.rawCast 1) (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2)))\n                  (Mathlib.Tactic.Ring.mul_zero (y ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))\n                (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                (Mathlib.Tactic.Ring.add_pf_add_zero (y ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0))));\n        this)))\n    (mul_lt_mul_of_pos_right h\n      (div_pos\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2))))))","type":"x / 2 < y / 2","name":["h'"],"isProp":true,"id":["_uniq",2195]}]}],"start":1700},{"state":[],"start":1753},{"state":[],"start":1754},{"state":[],"start":1776},{"state":[{"type":"¬∃ a, ∀ (n : ℕ), a (n + 1) < a n","tag":[],"mvarId":["_uniq",8357],"isProp":true,"context":[]}],"start":1859},{"state":[],"start":1867},{"state":[],"start":1868},{"state":[{"type":"Decidable (∃ a, ∀ (n : ℕ), a (n + 1) < a n)","tag":[],"mvarId":["_uniq",8464],"isProp":false,"context":[]}],"start":1953},{"state":[{"type":"Decidable (∃ a, ∀ (n : ℕ), a (n + 1) < a n)","tag":[],"mvarId":["_uniq",8464],"isProp":false,"context":[]}],"start":2046},{"state":[],"start":2054},{"state":[],"start":2055},{"state":[],"start":2086},{"state":[],"start":2113},{"state":[],"start":2114},{"state":[{"type":"Even n ∨ Odd n","tag":[],"mvarId":["_uniq",8590],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",8589],"binderInfo":"default"}]}],"start":2173},{"state":[],"start":2181},{"state":[],"start":2182},{"state":[{"type":"¬(Even n ∧ Odd n)","tag":[],"mvarId":["_uniq",8618],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",8617],"binderInfo":"default"}]}],"start":2249},{"state":[],"start":2257},{"state":[],"start":2258},{"state":[],"start":2273},{"state":[],"start":2274},{"state":[],"start":2317},{"state":[{"type":"¬∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",8891],"isProp":true,"context":[]}],"start":2378},{"state":[{"type":"¬∃ x, x ^ 2 = 2","tag":[],"mvarId":["_uniq",8891],"isProp":true,"context":[]}],"start":2451},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",8903],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",8898],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",8902],"binderInfo":"default"}]}],"start":2486},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",8943],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",8898],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",8902],"binderInfo":"default"},{"value":"id\n  (Aesop.BuiltinRules.not_intro fun a =>\n    Eq.ndrec (motive := fun x => x ^ 2 = 2 → False)\n      (fun hx =>\n        False.elim\n          (Eq.mp\n            (Eq.trans\n              (congrArg (fun x => x = 2)\n                (zero_pow (of_eq_true (Eq.trans (congrArg Not (OfNat.ofNat_ne_zero._simp_1 2)) not_false_eq_true))))\n              (OfNat.zero_ne_ofNat._simp_1 2))\n            hx))\n      (Eq.symm a) hx)","type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",8942]}]}],"start":2520},{"state":[{"type":"False","tag":["inr"],"mvarId":["_uniq",9638],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",8898],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",8902],"binderInfo":"default"},{"value":"id\n  (Aesop.BuiltinRules.not_intro fun a =>\n    Eq.ndrec (motive := fun x => x ^ 2 = 2 → False)\n      (fun hx =>\n        False.elim\n          (Eq.mp\n            (Eq.trans\n              (congrArg (fun x => x = 2)\n                (zero_pow (of_eq_true (Eq.trans (congrArg Not (OfNat.ofNat_ne_zero._simp_1 2)) not_false_eq_true))))\n              (OfNat.zero_ne_ofNat._simp_1 2))\n            hx))\n      (Eq.symm a) hx)","type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",8942]},{"type":"∀ (x : ℚ), x ^ 2 = 2 → x ≠ 0 → x > 0 → False","name":["this"],"isProp":true,"id":["_uniq",9599],"binderInfo":"default"},{"type":"¬x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9637],"binderInfo":"default"}]},{"type":"False","tag":[],"mvarId":["_uniq",9611],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"}]}],"start":2540},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",9611],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"}]}],"start":2598},{"state":[{"type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","tag":[],"mvarId":["_uniq",19391],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"}]}],"start":2663},{"state":[{"type":"x.num.toNat > 0 ∧ x.den > 0 ∧ x.num.toNat ^ 2 = 2 * x.den ^ 2","tag":["h"],"mvarId":["_uniq",19413],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"}]}],"start":2690},{"state":[{"type":"x.num.toNat > 0 ∧ x.den > 0 ∧ x.num.toNat ^ 2 = 2 * x.den ^ 2","tag":["h"],"mvarId":["_uniq",70469],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"type":"0 < x.num","name":["hnum_pos"],"isProp":true,"id":["_uniq",70468],"binderInfo":"default"}]}],"start":2723},{"state":[{"type":"x.num.toNat > 0 ∧ x.den > 0 ∧ x.num.toNat ^ 2 = 2 * x.den ^ 2","tag":["h"],"mvarId":["_uniq",71328],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"type":"0 < x.num","name":["hnum_pos"],"isProp":true,"id":["_uniq",70468],"binderInfo":"default"},{"type":"0 < x.den","name":["hden_pos"],"isProp":true,"id":["_uniq",71327],"binderInfo":"default"}]}],"start":2756},{"state":[{"type":"x.num.toNat ^ 2 = 2 * x.den ^ 2","tag":["h"],"mvarId":["_uniq",71345],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"type":"0 < x.num","name":["hnum_pos"],"isProp":true,"id":["_uniq",70468],"binderInfo":"default"},{"type":"0 < x.den","name":["hden_pos"],"isProp":true,"id":["_uniq",71327],"binderInfo":"default"}]}],"start":2804},{"state":[{"type":"x.num.toNat ^ 2 = 2 * x.den ^ 2","tag":["h"],"mvarId":["_uniq",74137],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",72396],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",72397],"binderInfo":"default"},{"type":"0 < x.num","name":["hnum_pos"],"isProp":true,"id":["_uniq",72398],"binderInfo":"default"},{"type":"0 < x.den","name":["hden_pos"],"isProp":true,"id":["_uniq",72399],"binderInfo":"default"},{"type":"(↑x.num : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2","name":["hx"],"isProp":true,"id":["_uniq",74134],"binderInfo":"default"}]}],"start":2854},{"state":[{"type":"x.num.toNat ^ 2 = 2 * x.den ^ 2","tag":["h"],"mvarId":["_uniq",74217],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",72396],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",72397],"binderInfo":"default"},{"type":"0 < x.num","name":["hnum_pos"],"isProp":true,"id":["_uniq",72398],"binderInfo":"default"},{"type":"0 < x.den","name":["hden_pos"],"isProp":true,"id":["_uniq",72399],"binderInfo":"default"},{"type":"(↑x.num : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2","name":["hx"],"isProp":true,"id":["_uniq",74134],"binderInfo":"default"},{"value":"Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos))","type":"x.num = (↑x.num.toNat : ℤ)","name":["hnum_cast"],"isProp":true,"id":["_uniq",74216]}]}],"start":2939},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",19393],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]}]}],"start":2981},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",79810],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]}]}],"start":3050},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",79896],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]}]}],"start":3085},{"state":[{"type":"∃ q < p, P q","tag":[],"mvarId":["_uniq",95658],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"}]}],"start":3146},{"state":[{"type":"∃ q < p, P q","tag":["inl"],"mvarId":["_uniq",95694],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Even p","name":["hp"],"isProp":true,"id":["_uniq",95693],"binderInfo":"default"}]},{"type":"∃ q < p, P q","tag":["inr"],"mvarId":["_uniq",95699],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"}]}],"start":3184},{"state":[{"type":"∃ q < p, P q","tag":["inl"],"mvarId":["_uniq",95889],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"∃ b, p = 2 * b","name":["hp"],"isProp":true,"id":["_uniq",95886],"binderInfo":"default"}]}],"start":3225},{"state":[{"type":"∃ q < 2 * k, P q","tag":["inl","intro"],"mvarId":["_uniq",95937],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",95915],"binderInfo":"default"},{"type":"P (2 * k)","name":["hPp"],"isProp":true,"id":["_uniq",95936],"binderInfo":"default"}]}],"start":3259},{"state":[{"type":"∃ q < 2 * k, P q","tag":["inl","intro"],"mvarId":["_uniq",95955],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos✝"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos✝)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos✝));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",95915],"binderInfo":"default"},{"type":"P (2 * k)","name":["hPp"],"isProp":true,"id":["_uniq",95936],"binderInfo":"default"},{"type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",95942],"binderInfo":"default"},{"type":"q > 0","name":["hpos"],"isProp":true,"id":["_uniq",95950],"binderInfo":"default"},{"type":"(2 * k) ^ 2 = 2 * q ^ 2","name":["hq"],"isProp":true,"id":["_uniq",95954],"binderInfo":"default"}]}],"start":3294},{"state":[{"type":"∃ q < 2 * k, P q","tag":["inl","intro"],"mvarId":["_uniq",96644],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos✝"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos✝)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos✝));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",95915],"binderInfo":"default"},{"type":"P (2 * k)","name":["hPp"],"isProp":true,"id":["_uniq",95936],"binderInfo":"default"},{"type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",95942],"binderInfo":"default"},{"type":"q > 0","name":["hpos"],"isProp":true,"id":["_uniq",95950],"binderInfo":"default"},{"type":"(2 * k) ^ 2 = 2 * q ^ 2","name":["hq"],"isProp":true,"id":["_uniq",95954],"binderInfo":"default"},{"value":"Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n  (Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.pow_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_add\n                      (Mathlib.Tactic.Ring.single_pow\n                        (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                              (Mathlib.Meta.NormNum.IsNatPowT.run Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                      (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                          (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                        (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Eq.refl (Int.negOfNat 2))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                      ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                        (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯)\n              ⋯)\n            ⋯))\n        ⋯))\n  ⋯","type":"q ^ 2 = 2 * k ^ 2","name":["this"],"isProp":true,"id":["_uniq",96643]}]}],"start":3336},{"state":[{"type":"q < 2 * k","tag":["h","left"],"mvarId":["_uniq",104370],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos✝"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos✝)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos✝));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",95915],"binderInfo":"default"},{"type":"P (2 * k)","name":["hPp"],"isProp":true,"id":["_uniq",95936],"binderInfo":"default"},{"type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",95942],"binderInfo":"default"},{"type":"q > 0","name":["hpos"],"isProp":true,"id":["_uniq",95950],"binderInfo":"default"},{"type":"(2 * k) ^ 2 = 2 * q ^ 2","name":["hq"],"isProp":true,"id":["_uniq",95954],"binderInfo":"default"},{"value":"Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n  (Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.pow_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_add\n                      (Mathlib.Tactic.Ring.single_pow\n                        (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                              (Mathlib.Meta.NormNum.IsNatPowT.run Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                      (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                          (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                        (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Eq.refl (Int.negOfNat 2))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                      ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                        (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯)\n              ⋯)\n            ⋯))\n        ⋯))\n  ⋯","type":"q ^ 2 = 2 * k ^ 2","name":["this"],"isProp":true,"id":["_uniq",96643]}]},{"type":"P q","tag":["h","right"],"mvarId":["_uniq",104371],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos✝"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos✝)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos✝));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",95915],"binderInfo":"default"},{"type":"P (2 * k)","name":["hPp"],"isProp":true,"id":["_uniq",95936],"binderInfo":"default"},{"type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",95942],"binderInfo":"default"},{"type":"q > 0","name":["hpos"],"isProp":true,"id":["_uniq",95950],"binderInfo":"default"},{"type":"(2 * k) ^ 2 = 2 * q ^ 2","name":["hq"],"isProp":true,"id":["_uniq",95954],"binderInfo":"default"},{"value":"Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n  (Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.pow_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_add\n                      (Mathlib.Tactic.Ring.single_pow\n                        (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                              (Mathlib.Meta.NormNum.IsNatPowT.run Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                      (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                          (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                        (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Eq.refl (Int.negOfNat 2))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                      ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                        (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯)\n              ⋯)\n            ⋯))\n        ⋯))\n  ⋯","type":"q ^ 2 = 2 * k ^ 2","name":["this"],"isProp":true,"id":["_uniq",96643]}]}],"start":3361},{"state":[{"type":"P q","tag":["h","right"],"mvarId":["_uniq",104371],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos✝"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos✝)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos✝));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",95915],"binderInfo":"default"},{"type":"P (2 * k)","name":["hPp"],"isProp":true,"id":["_uniq",95936],"binderInfo":"default"},{"type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",95942],"binderInfo":"default"},{"type":"q > 0","name":["hpos"],"isProp":true,"id":["_uniq",95950],"binderInfo":"default"},{"type":"(2 * k) ^ 2 = 2 * q ^ 2","name":["hq"],"isProp":true,"id":["_uniq",95954],"binderInfo":"default"},{"value":"Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n  (Not.intro fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.pow_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_add\n                      (Mathlib.Tactic.Ring.single_pow\n                        (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                              (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                              (Mathlib.Meta.NormNum.IsNatPowT.run Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                      (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                          (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                        (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Eq.refl (Int.negOfNat 2))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                      ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.pow_add\n                        (Mathlib.Tactic.Ring.single_pow\n                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                            (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                        (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯)\n              ⋯)\n            ⋯))\n        ⋯))\n  ⋯","type":"q ^ 2 = 2 * k ^ 2","name":["this"],"isProp":true,"id":["_uniq",96643]}]}],"start":3375},{"state":[{"type":"∃ q < p, P q","tag":["inr"],"mvarId":["_uniq",95699],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"}]}],"start":3430},{"state":[{"type":"Odd (p ^ 2)","tag":[],"mvarId":["_uniq",109446],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"}]}],"start":3460},{"state":[{"type":"∃ q < p, P q","tag":["inr"],"mvarId":["_uniq",109448],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"},{"value":"sorry","type":"Odd (p ^ 2)","name":["h1"],"isProp":true,"id":["_uniq",109447]}]}],"start":3472},{"state":[{"type":"Even (p ^ 2)","tag":[],"mvarId":["_uniq",109769],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"},{"value":"sorry","type":"Odd (p ^ 2)","name":["h1"],"isProp":true,"id":["_uniq",109447]}]}],"start":3503},{"state":[{"type":"Even (p ^ 2)","tag":[],"mvarId":["_uniq",109792],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos✝"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos✝)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos✝));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"},{"value":"sorry","type":"Odd (p ^ 2)","name":["h1"],"isProp":true,"id":["_uniq",109447]},{"type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",109779],"binderInfo":"default"},{"type":"q > 0","name":["hpos"],"isProp":true,"id":["_uniq",109787],"binderInfo":"default"},{"type":"p ^ 2 = 2 * q ^ 2","name":["hq"],"isProp":true,"id":["_uniq",109791],"binderInfo":"default"}]}],"start":3538},{"state":[{"type":"∃ b, p ^ 2 = 2 * b","tag":[],"mvarId":["_uniq",109969],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos✝"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos✝)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos✝));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"},{"value":"sorry","type":"Odd (p ^ 2)","name":["h1"],"isProp":true,"id":["_uniq",109447]},{"type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",109779],"binderInfo":"default"},{"type":"q > 0","name":["hpos"],"isProp":true,"id":["_uniq",109787],"binderInfo":"default"},{"type":"p ^ 2 = 2 * q ^ 2","name":["hq"],"isProp":true,"id":["_uniq",109791],"binderInfo":"default"}]}],"start":3573},{"state":[{"type":"∃ q < p, P q","tag":["inr"],"mvarId":["_uniq",109771],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"},{"value":"sorry","type":"Odd (p ^ 2)","name":["h1"],"isProp":true,"id":["_uniq",109447]},{"value":"(fun q x => Eq.mpr (id (congrArg (fun _a => _a) (propext even_iff_exists_two_mul))) (Exists.intro (q ^ 2) x.right))\n  (Classical.choose hPp.right) (Classical.choose_spec hPp.right)","type":"Even (p ^ 2)","name":["h2"],"isProp":true,"id":["_uniq",109770]}]}],"start":3587},{"state":[{"type":"∃ q < p, P q","tag":["inr"],"mvarId":["_uniq",113026],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",95642],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",95644],"binderInfo":"default"},{"type":"Odd p","name":["hp"],"isProp":true,"id":["_uniq",95698],"binderInfo":"default"},{"value":"sorry","type":"Odd (p ^ 2)","name":["h1"],"isProp":true,"id":["_uniq",109447]},{"value":"(fun q x => Eq.mpr (id (congrArg (fun _a => _a) (propext even_iff_exists_two_mul))) (Exists.intro (q ^ 2) x.right))\n  (Classical.choose hPp.right) (Classical.choose_spec hPp.right)","type":"Even (p ^ 2)","name":["h2"],"isProp":true,"id":["_uniq",109770]},{"type":"¬(Even (p ^ 2) ∧ Odd (p ^ 2))","name":["this"],"isProp":true,"id":["_uniq",113025],"binderInfo":"default"}]}],"start":3634},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",95661],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]}]}],"start":3644},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",95661],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]}]}],"start":3656},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",118101],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]}]}],"start":3736},{"state":[{"type":"f p < p ∧ P (f p)","tag":[],"mvarId":["_uniq",118222],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118212],"binderInfo":"default"},{"type":"P p","name":["hPp"],"isProp":true,"id":["_uniq",118214],"binderInfo":"default"}]}],"start":3795},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",118225],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg Exists\n      (funext fun p =>\n        congrFun\n          (funext fun p =>\n            congr (congrArg And gt_iff_lt._simp_1)\n              (congrArg Exists (funext fun q => congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n          p))\n    (eq_true\n      (id\n        (Eq.mp\n          (congrArg Exists\n            (funext fun p =>\n              Eq.trans\n                (congrArg Exists\n                  (funext fun q =>\n                    congr (congrArg And gt_iff_lt._simp_1)\n                      (congrArg (fun x => x ∧ p ^ 2 = 2 * q ^ 2) gt_iff_lt._simp_1)))\n                exists_and_left._simp_1))\n          hrep))))","type":"∃ p, P p","name":["hP"],"isProp":true,"id":["_uniq",79895]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]}]}],"start":3846},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",118985],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118980],"binderInfo":"default"},{"type":"P p","name":["hP"],"isProp":true,"id":["_uniq",118984],"binderInfo":"default"}]}],"start":3869},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",119019],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118980],"binderInfo":"default"},{"type":"P p","name":["hP"],"isProp":true,"id":["_uniq",118984],"binderInfo":"default"},{"value":"fun t => Nat.rec p (fun n p => f p) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",119018]}]}],"start":3922},{"state":[{"type":"P (a n)","tag":[],"mvarId":["_uniq",119158],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118980],"binderInfo":"default"},{"type":"P p","name":["hP"],"isProp":true,"id":["_uniq",118984],"binderInfo":"default"},{"value":"fun t => Nat.rec p (fun n p => f p) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",119018]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",119156],"binderInfo":"default"}]}],"start":3956},{"state":[{"type":"P (a n)","tag":[],"mvarId":["_uniq",119158],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118980],"binderInfo":"default"},{"type":"P p","name":["hP"],"isProp":true,"id":["_uniq",118984],"binderInfo":"default"},{"value":"fun t => Nat.rec p (fun n p => f p) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",119018]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",119156],"binderInfo":"default"}]}],"start":3977},{"state":[],"start":4000},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",119161],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118980],"binderInfo":"default"},{"type":"P p","name":["hP"],"isProp":true,"id":["_uniq",118984],"binderInfo":"default"},{"value":"fun t => Nat.rec p (fun n p => f p) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",119018]},{"value":"fun n => Nat.recAux hP (fun n ih => (hf (a n) ih).right) n","type":"∀ (n : ℕ), P (a n)","name":["ha"],"isProp":true,"id":["_uniq",119160]}]}],"start":4037},{"state":[{"type":"a (n + 1) < a n","tag":[],"mvarId":["_uniq",119332],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118980],"binderInfo":"default"},{"type":"P p","name":["hP"],"isProp":true,"id":["_uniq",118984],"binderInfo":"default"},{"value":"fun t => Nat.rec p (fun n p => f p) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",119018]},{"value":"fun n => Nat.recAux hP (fun n ih => (hf (a n) ih).right) n","type":"∀ (n : ℕ), P (a n)","name":["ha"],"isProp":true,"id":["_uniq",119160]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",119249],"binderInfo":"default"}]}],"start":4078},{"state":[{"type":"a (n + 1) < a n","tag":[],"mvarId":["_uniq",119813],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118980],"binderInfo":"default"},{"type":"P p","name":["hP"],"isProp":true,"id":["_uniq",118984],"binderInfo":"default"},{"value":"fun t => Nat.rec p (fun n p => f p) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",119018]},{"value":"fun n => Nat.recAux hP (fun n ih => (hf (a n) ih).right) n","type":"∀ (n : ℕ), P (a n)","name":["ha"],"isProp":true,"id":["_uniq",119160]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",119249],"binderInfo":"default"},{"value":"Nat.rec_add_one p (fun n p => f p) n","type":"a (n + 1) = f (a n)","name":["this"],"isProp":true,"id":["_uniq",119812]}]}],"start":4144},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",119336],"isProp":true,"context":[{"type":"ℚ","name":["x"],"isProp":false,"id":["_uniq",9605],"binderInfo":"default"},{"type":"x ^ 2 = 2","name":["hx"],"isProp":true,"id":["_uniq",9606],"binderInfo":"default"},{"type":"x ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",9607],"binderInfo":"default"},{"type":"x > 0","name":["hpos"],"isProp":true,"id":["_uniq",9610],"binderInfo":"default"},{"value":"Exists.intro x.num.toNat\n  (Exists.intro x.den\n    ⟨of_eq_true\n        (Eq.trans gt_iff_lt._simp_1\n          (Eq.trans Int.lt_toNat._simp_1\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => x_1 < x.num) (CharP.cast_eq_zero ℤ 0)) num_pos._simp_1)\n              (eq_true hpos)))),\n      ⟨den_pos x,\n        have hnum_cast := Int.eq_natCast_toNat.mpr (le_of_lt (Mathlib.Meta.Positivity.num_pos_of_pos✝ hpos));\n        Eq.mp\n          (Eq.trans\n            (Eq.trans\n              (congr\n                (congrArg Eq\n                  (Eq.trans (Int.cast_pow._simp_1 (↑x.num.toNat : ℤ) 2)\n                    (congrArg Int.cast (Nat.cast_pow._simp_1 x.num.toNat 2))))\n                (Eq.trans (congrArg (HMul.hMul (↑2 : ℚ)) (Nat.cast_pow._simp_1 x.den 2))\n                  (Nat.cast_mul._simp_1 2 (x.den ^ 2))))\n              (congrArg (Eq (↑(↑(x.num.toNat ^ 2) : ℤ) : ℚ))\n                (Eq.trans (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2)))\n                  (Eq.symm\n                    (Eq.trans\n                      (Eq.trans\n                        (congrArg Int.cast\n                          (Eq.trans (Nat.cast_mul 2 (x.den ^ 2)) (congrArg (HMul.hMul 2) (Nat.cast_pow x.den 2))))\n                        (Int.cast_mul 2 ((↑x.den : ℤ) ^ 2)))\n                      (congr (congrArg HMul.hMul (Int.cast_ofNat 2))\n                        (Eq.trans (Int.cast_pow (↑x.den : ℤ) 2)\n                          (congrArg (fun x => x ^ 2) (Int.cast_natCast x.den)))))))))\n            (Eq.trans\n              (Eq.trans Int.cast_inj._simp_1\n                (congrArg (fun x_1 => x_1 = (↑(2 * x.den ^ 2) : ℤ))\n                  (Eq.trans (Nat.cast_pow x.num.toNat 2) (Eq.symm (Nat.cast_pow x.num.toNat 2)))))\n              Nat.cast_inj._simp_1))\n          (Eq.mp (congrArg (fun _a => (↑_a : ℚ) ^ 2 = 2 * (↑x.den : ℚ) ^ 2) hnum_cast)\n            (Eq.mp\n              (Eq.trans (congrArg (fun x => x = 2) (div_pow (↑x.num : ℚ) (↑x.den : ℚ) 2))\n                (div_eq_iff._simp_1 (ne_of_gt (pow_pos (Nat.cast_pos'.mpr (den_pos x)) 2))))\n              (Eq.mp (congrArg (fun _a => _a ^ 2 = 2) (Eq.symm (num_div_den x))) hx)))⟩⟩)","type":"∃ p q, p > 0 ∧ q > 0 ∧ p ^ 2 = 2 * q ^ 2","name":["hrep"],"isProp":true,"id":["_uniq",19392]},{"value":"fun p => p > 0 ∧ ∃ q > 0, p ^ 2 = 2 * q ^ 2","type":"ℕ → Prop","name":["P"],"isProp":false,"id":["_uniq",79809]},{"value":"fun p hPp =>\n  Or.casesOn (Nat.even_or_odd'' p)\n    (fun hp =>\n      Exists.casesOn (Eq.mp (congrArg (fun _a => _a) (propext even_iff_exists_two_mul)) hp) fun k h =>\n        Eq.ndrec (motive := fun p => P p → ∃ q < p, P q)\n          (fun hPp =>\n            (fun q x =>\n                have this :=\n                  Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt (q ^ 2) (2 * k ^ 2)\n                    (Not.intro fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.mul_congr\n                                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                    (Mathlib.Tactic.Ring.neg_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.negOfNat 1)))))\n                                        Mathlib.Tactic.Ring.neg_zero))\n                                    (Mathlib.Tactic.Ring.add_mul\n                                      (Mathlib.Tactic.Ring.mul_add\n                                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                            (Eq.refl (Int.negOfNat 2))))\n                                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.pow_congr\n                                      (Mathlib.Tactic.Ring.mul_congr\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.atom_pf (↑k : ℤ))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_right (↑k : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_add\n                                        (Mathlib.Tactic.Ring.single_pow\n                                          (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isNat_pow (Eq.refl HPow.hPow)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2)\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℕ 2)\n                                                (Mathlib.Meta.NormNum.IsNatPowT.run\n                                                  Mathlib.Meta.NormNum.IsNatPowT.bit0)))))\n                                        (Mathlib.Tactic.Ring.pow_zero ((↑k : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))\n                                        (Mathlib.Tactic.Ring.add_mul\n                                          (Mathlib.Tactic.Ring.mul_add\n                                            (Mathlib.Tactic.Ring.mul_pf_left (↑k : ℤ) (Nat.rawCast 2)\n                                              (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 4)))\n                                            (Mathlib.Tactic.Ring.mul_zero ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))\n                                          (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 + 0)))))\n                                    (Mathlib.Tactic.Ring.mul_congr\n                                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add\n                                          (Mathlib.Tactic.Ring.single_pow\n                                            (Mathlib.Tactic.Ring.mul_pow (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 2))\n                                              (Mathlib.Tactic.Ring.one_pow (Nat.rawCast 2))))\n                                          (Mathlib.Tactic.Ring.pow_zero ((↑q : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                          (Mathlib.Tactic.Ring.add_mul\n                                            (Mathlib.Tactic.Ring.mul_add\n                                              (Mathlib.Tactic.Ring.mul_pf_left (↑q : ℤ) (Nat.rawCast 2)\n                                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                              (Mathlib.Tactic.Ring.mul_zero ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1))\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))\n                                            (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                                              ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0)))))\n                                      (Mathlib.Tactic.Ring.add_mul\n                                        (Mathlib.Tactic.Ring.mul_add\n                                          (Mathlib.Tactic.Ring.mul_pf_right (↑q : ℤ) (Nat.rawCast 2)\n                                            (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                                            ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0)))\n                                        (Mathlib.Tactic.Ring.zero_mul ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 1 + 0))\n                                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 2 + 0))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (↑q : ℤ) (Nat.rawCast 2)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                                (Eq.refl (Int.negOfNat 2))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                      ((↑k : ℤ) ^ Nat.rawCast 2 * Nat.rawCast 4 +\n                                        ((↑q : ℤ) ^ Nat.rawCast 2 * (Int.negOfNat 2).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.mul_congr\n                                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.pow_congr (Mathlib.Tactic.Ring.atom_pf (↑q : ℤ))\n                                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℕ (Eq.refl 2)))\n                                        (Mathlib.Tactic.Ring.pow_add (Mathlib.Tactic.Ring.single_pow ⋯) ⋯ ⋯))\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯)\n                                ⋯)\n                              ⋯))\n                          ⋯))\n                    ⋯;\n                ⋯)\n              ⋯ ⋯)\n          ⋯ ⋯)\n    ⋯","type":"∀ (p : ℕ), P p → ∃ q < p, P q","name":["hiter"],"isProp":true,"id":["_uniq",95660]},{"value":"fun p => if hPp : P p then ⋯.choose else 0","type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",118100]},{"value":"fun p hPp =>\n  Eq.mpr\n    (id\n      (congr (congrArg (fun x => And (x < p)) (dite_cond_eq_true (eq_true hPp)))\n        (congrArg P (dite_cond_eq_true (eq_true hPp)))))\n    (Exists.choose_spec (hiter p hPp))","type":"∀ (p : ℕ), P p → f p < p ∧ P (f p)","name":["hf"],"isProp":true,"id":["_uniq",118224]},{"type":"ℕ","name":["p"],"isProp":false,"id":["_uniq",118980],"binderInfo":"default"},{"type":"P p","name":["hP"],"isProp":true,"id":["_uniq",118984],"binderInfo":"default"},{"value":"fun t => Nat.rec p (fun n p => f p) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",119018]},{"value":"fun n => Nat.recAux hP (fun n ih => (hf (a n) ih).right) n","type":"∀ (n : ℕ), P (a n)","name":["ha"],"isProp":true,"id":["_uniq",119160]},{"value":"fun n =>\n  have this := Nat.rec_add_one p (fun n p => f p) n;\n  not_exist_sqrt_two._proof_7 hrep hiter hf p hP ha n this","type":"∀ (n : ℕ), a (n + 1) < a n","name":["hlt"],"isProp":true,"id":["_uniq",119334]}]}],"start":4154},{"state":[],"start":4201},{"state":[],"start":4202},{"state":[],"start":4203},{"state":[],"start":4228},{"state":[{"type":"∃ x ≥ 0, x ^ 2 < 2 ∧ 2 < (x + ε) ^ 2","tag":[],"mvarId":["_uniq",137172],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"}]}],"start":4334},{"state":[{"type":"∃ x ≥ 0, x ^ 2 < 2 ∧ 2 < (x + ε) ^ 2","tag":[],"mvarId":["_uniq",137172],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"}]}],"start":4407},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",138105],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"}]}],"start":4422},{"state":[{"type":"((↑n : ℚ) * ε) ^ 2 < 2","tag":[],"mvarId":["_uniq",139417],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",138108],"binderInfo":"default"}]}],"start":4457},{"state":[{"type":"((↑(n + 1) : ℚ) * ε) ^ 2 < 2","tag":["succ"],"mvarId":["_uniq",139444],"isProp":false,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",139440],"binderInfo":"default"},{"type":"((↑n : ℚ) * ε) ^ 2 < 2","name":["hn"],"isProp":true,"id":["_uniq",139441],"binderInfo":"default"}]}],"start":4490},{"state":[{"type":"((↑n : ℚ) * ε + ε) ^ 2 < 2","tag":["succ"],"mvarId":["_uniq",140880],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",139440],"binderInfo":"default"},{"type":"((↑n : ℚ) * ε) ^ 2 < 2","name":["hn"],"isProp":true,"id":["_uniq",139441],"binderInfo":"default"}]}],"start":4509},{"state":[{"type":"((↑n : ℚ) * ε + ε) ^ 2 ≠ 2","tag":["succ"],"mvarId":["_uniq",141022],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",139440],"binderInfo":"default"},{"type":"((↑n : ℚ) * ε) ^ 2 < 2","name":["hn"],"isProp":true,"id":["_uniq",139441],"binderInfo":"default"}]}],"start":4564},{"state":[{"type":"((↑n : ℚ) * ε + ε) ^ 2 ≠ 2","tag":["succ"],"mvarId":["_uniq",143440],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",139440],"binderInfo":"default"},{"type":"((↑n : ℚ) * ε) ^ 2 < 2","name":["hn"],"isProp":true,"id":["_uniq",139441],"binderInfo":"default"},{"value":"not_exist_sqrt_two","type":"¬∃ x, x ^ 2 = 2","name":["this"],"isProp":true,"id":["_uniq",143439]}]}],"start":4595},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",139421],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"},{"value":"fun n =>\n  Nat.recAux\n    (of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x < 2)\n          (Eq.trans\n            (congrArg (fun x => x ^ 2) (Eq.trans (congrArg (fun x => x * ε) (CharP.cast_eq_zero ℚ 0)) (zero_mul ε)))\n            (zero_pow (of_eq_true (Eq.trans (congrArg Not (OfNat.ofNat_ne_zero._simp_1 2)) not_false_eq_true)))))\n        Nat.ofNat_pos._simp_1))\n    (fun n hn =>\n      Eq.mpr\n        (id\n          (congrArg (fun x => x ^ 2 < 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (fun x => x * ε) (Eq.trans (Nat.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℚ)) Nat.cast_one)))\n                (add_mul (↑n : ℚ) 1 ε))\n              (congrArg (HAdd.hAdd ((↑n : ℚ) * ε)) (one_mul ε)))))\n        (lt_of_le_of_ne (h ((↑n : ℚ) * ε) (mul_nonneg (Nat.cast_nonneg' n) (le_of_lt hε)) hn)\n          (have this := not_exist_sqrt_two;\n          of_eq_true\n            (Eq.trans (congrArg Not ((fun x => eq_false (id (Eq.mp not_exists._simp_1 this) x)) ((↑n : ℚ) * ε + ε)))\n              not_false_eq_true))))\n    n","type":"∀ (n : ℕ), ((↑n : ℚ) * ε) ^ 2 < 2","name":["this"],"isProp":true,"id":["_uniq",139419]}]}],"start":4605},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",152809],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"},{"value":"fun n =>\n  Nat.recAux\n    (of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x < 2)\n          (Eq.trans\n            (congrArg (fun x => x ^ 2) (Eq.trans (congrArg (fun x => x * ε) (CharP.cast_eq_zero ℚ 0)) (zero_mul ε)))\n            (zero_pow (of_eq_true (Eq.trans (congrArg Not (OfNat.ofNat_ne_zero._simp_1 2)) not_false_eq_true)))))\n        Nat.ofNat_pos._simp_1))\n    (fun n hn =>\n      Eq.mpr\n        (id\n          (congrArg (fun x => x ^ 2 < 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (fun x => x * ε) (Eq.trans (Nat.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℚ)) Nat.cast_one)))\n                (add_mul (↑n : ℚ) 1 ε))\n              (congrArg (HAdd.hAdd ((↑n : ℚ) * ε)) (one_mul ε)))))\n        (lt_of_le_of_ne (h ((↑n : ℚ) * ε) (mul_nonneg (Nat.cast_nonneg' n) (le_of_lt hε)) hn)\n          (have this := not_exist_sqrt_two;\n          of_eq_true\n            (Eq.trans (congrArg Not ((fun x => eq_false (id (Eq.mp not_exists._simp_1 this) x)) ((↑n : ℚ) * ε + ε)))\n              not_false_eq_true))))\n    n","type":"∀ (n : ℕ), ((↑n : ℚ) * ε) ^ 2 < 2","name":["this"],"isProp":true,"id":["_uniq",139419]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",152805],"binderInfo":"default"},{"type":"(↑n : ℚ) > 2 / ε","name":["hn"],"isProp":true,"id":["_uniq",152808],"binderInfo":"default"}]}],"start":4646},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",154172],"isProp":true,"context":[{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",137170],"binderInfo":"implicit"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",137171],"binderInfo":"default"},{"type":"∀ x ≥ 0, x ^ 2 < 2 → (x + ε) ^ 2 ≤ 2","name":["h"],"isProp":true,"id":["_uniq",138101],"binderInfo":"default"},{"value":"fun n =>\n  Nat.recAux\n    (of_eq_true\n      (Eq.trans\n        (congrArg (fun x => x < 2)\n          (Eq.trans\n            (congrArg (fun x => x ^ 2) (Eq.trans (congrArg (fun x => x * ε) (CharP.cast_eq_zero ℚ 0)) (zero_mul ε)))\n            (zero_pow (of_eq_true (Eq.trans (congrArg Not (OfNat.ofNat_ne_zero._simp_1 2)) not_false_eq_true)))))\n        Nat.ofNat_pos._simp_1))\n    (fun n hn =>\n      Eq.mpr\n        (id\n          (congrArg (fun x => x ^ 2 < 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (fun x => x * ε) (Eq.trans (Nat.cast_add n 1) (congrArg (HAdd.hAdd (↑n : ℚ)) Nat.cast_one)))\n                (add_mul (↑n : ℚ) 1 ε))\n              (congrArg (HAdd.hAdd ((↑n : ℚ) * ε)) (one_mul ε)))))\n        (lt_of_le_of_ne (h ((↑n : ℚ) * ε) (mul_nonneg (Nat.cast_nonneg' n) (le_of_lt hε)) hn)\n          (have this := not_exist_sqrt_two;\n          of_eq_true\n            (Eq.trans (congrArg Not ((fun x => eq_false (id (Eq.mp not_exists._simp_1 this) x)) ((↑n : ℚ) * ε + ε)))\n              not_false_eq_true))))\n    n","type":"∀ (n : ℕ), ((↑n : ℚ) * ε) ^ 2 < 2","name":["this"],"isProp":true,"id":["_uniq",139419]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",152805],"binderInfo":"default"},{"type":"2 ^ 2 < ((↑n : ℚ) * ε) ^ 2","name":["hn"],"isProp":true,"id":["_uniq",154169],"binderInfo":"default"}]}],"start":4730},{"state":[],"start":4738},{"state":[],"start":4739},{"state":[],"start":4760},{"state":[],"start":4770},{"state":[],"start":4793},{"state":[],"start":4818},{"state":[],"start":4860},{"state":[],"start":4860}]
