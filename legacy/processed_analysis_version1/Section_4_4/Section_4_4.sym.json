[
    {
        "valueReferences": [
            [
                "instAddNat"
            ],
            [
                "implies_congr"
            ],
            [
                "Eq",
                "trans"
            ],
            [
                "Bool",
                "false"
            ],
            [
                "Classical",
                "propDecidable"
            ],
            [
                "eq_true"
            ],
            [
                "eagerReduce"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_5"
            ],
            [
                "Lean",
                "Grind",
                "intro_with_eq'"
            ],
            [
                "Classical",
                "choose"
            ],
            [
                "Lean",
                "Grind",
                "eq_false_of_imp_eq_true"
            ],
            [
                "funext"
            ],
            [
                "forall_congr"
            ],
            [
                "Eq",
                "symm"
            ],
            [
                "Eq",
                "rec"
            ],
            [
                "Eq",
                "ndrec"
            ],
            [
                "Bool",
                "true"
            ],
            [
                "instHPow"
            ],
            [
                "Nat",
                "le_trans"
            ],
            [
                "instLTNat"
            ],
            [
                "Exists"
            ],
            [
                "Nat",
                "Linear",
                "ExprCnstr",
                "eq_true_of_isValid"
            ],
            [
                "Lean",
                "Grind",
                "rfl_true"
            ],
            [
                "And"
            ],
            [
                "Nat",
                "Linear",
                "Expr",
                "var"
            ],
            [
                "True",
                "intro"
            ],
            [
                "instNatPowNat"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_6"
            ],
            [
                "Nat",
                "decLt"
            ],
            [
                "Exists",
                "casesOn"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "instMonoid"
            ],
            [
                "Nat",
                "Linear",
                "Expr",
                "num"
            ],
            [
                "Nat",
                "rec"
            ],
            [
                "Eq",
                "refl"
            ],
            [
                "Classical",
                "byContradiction"
            ],
            [
                "id"
            ],
            [
                "instHMul"
            ],
            [
                "Bool"
            ],
            [
                "instDecidableAnd"
            ],
            [
                "Eq",
                "mp"
            ],
            [
                "Nat",
                "Linear",
                "ExprCnstr",
                "mk"
            ],
            [
                "instPowNat"
            ],
            [
                "Classical",
                "choose",
                "congr_simp"
            ],
            [
                "Nat",
                "Linear",
                "ExprCnstr",
                "eq_of_toNormPoly_eq"
            ],
            [
                "Lean",
                "Grind",
                "dite_cond_eq_false'"
            ],
            [
                "congrArg"
            ],
            [
                "dite_congr"
            ],
            [
                "Lean",
                "RArray",
                "leaf"
            ],
            [
                "Lean",
                "Grind",
                "Nat",
                "lt_eq"
            ],
            [
                "Nat",
                "not_le_eq"
            ],
            [
                "Lean",
                "Grind",
                "nestedDecidable"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Lean",
                "Grind",
                "Nat",
                "le_of_eq_1"
            ],
            [
                "congr"
            ],
            [
                "instMulNat"
            ],
            [
                "Lean",
                "RArray",
                "branch"
            ],
            [
                "Eq"
            ],
            [
                "Lean",
                "Grind",
                "Nat",
                "lo_eq_false_of_le"
            ],
            [
                "Not"
            ],
            [
                "Lean",
                "Grind",
                "forall_and"
            ],
            [
                "True"
            ],
            [
                "instHAdd"
            ],
            [
                "Nat",
                "decLe"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Eq",
                "mpr_prop"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Lean",
                "Grind",
                "exists_and_left"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "True",
                "casesOn"
            ],
            [
                "LE",
                "le"
            ],
            [
                "Nat",
                "Linear",
                "Expr",
                "add"
            ],
            [
                "False"
            ],
            [
                "Lean",
                "Grind",
                "intro_with_eq"
            ],
            [
                "dite"
            ],
            [
                "instLENat"
            ],
            [
                "And",
                "casesOn"
            ]
        ],
        "typeReferences": [
            [
                "instAddNat"
            ],
            [
                "instDecidableAnd"
            ],
            [
                "Classical",
                "propDecidable"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "GT",
                "gt"
            ],
            [
                "instOfNatNat"
            ],
            [
                "instMulNat"
            ],
            [
                "Eq"
            ],
            [
                "instHPow"
            ],
            [
                "instLTNat"
            ],
            [
                "Exists"
            ],
            [
                "instHAdd"
            ],
            [
                "And"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "Exists",
                "choose"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Nat",
                "decLt"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "instMonoid"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "Nat",
                "rec"
            ],
            [
                "instHMul"
            ],
            [
                "dite"
            ]
        ],
        "type": "(Exists fun p =>\n    Exists fun q => And (GT.gt p 0) (And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2))))) →\n  ∀\n    (hiter :\n      ∀ (p : Nat),\n        (fun p =>\n              And (GT.gt p 0)\n                (Exists fun q => And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n            p →\n          Exists fun q =>\n            And (instLTNat.lt q p)\n              ((fun p =>\n                  And (GT.gt p 0)\n                    (Exists fun q => And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                q)),\n    (∀ (p : Nat),\n        (fun p =>\n              And (GT.gt p 0)\n                (Exists fun q => And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n            p →\n          And\n            (instLTNat.lt\n              ((fun p =>\n                  if hPp :\n                      (fun p =>\n                          And (GT.gt p 0)\n                            (Exists fun q =>\n                              And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                        p then\n                    ⋯.choose\n                  else 0)\n                p)\n              p)\n            ((fun p =>\n                And (GT.gt p 0)\n                  (Exists fun q => And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n              ((fun p =>\n                  if hPp :\n                      (fun p =>\n                          And (GT.gt p 0)\n                            (Exists fun q =>\n                              And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                        p then\n                    ⋯.choose\n                  else 0)\n                p))) →\n      ∀ (p : Nat),\n        (fun p =>\n              And (GT.gt p 0)\n                (Exists fun q => And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n            p →\n          (∀ (n : Nat),\n              (fun p =>\n                  And (GT.gt p 0)\n                    (Exists fun q => And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                ((fun t =>\n                    Nat.rec p\n                      (fun n p =>\n                        (fun p =>\n                            if hPp :\n                                (fun p =>\n                                    And (GT.gt p 0)\n                                      (Exists fun q =>\n                                        And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                                  p then\n                              ⋯.choose\n                            else 0)\n                          p)\n                      t)\n                  n)) →\n            ∀ (n : Nat),\n              Eq\n                  ((fun t =>\n                      Nat.rec p\n                        (fun n p =>\n                          (fun p =>\n                              if hPp :\n                                  (fun p =>\n                                      And (GT.gt p 0)\n                                        (Exists fun q =>\n                                          And (GT.gt q 0)\n                                            (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                                    p then\n                                ⋯.choose\n                              else 0)\n                            p)\n                        t)\n                    (instHAdd.hAdd n 1))\n                  ((fun p =>\n                      if hPp :\n                          (fun p =>\n                              And (GT.gt p 0)\n                                (Exists fun q =>\n                                  And (GT.gt q 0) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                            p then\n                        ⋯.choose\n                      else 0)\n                    ((fun t =>\n                        Nat.rec p\n                          (fun n p =>\n                            (fun p =>\n                                if hPp :\n                                    (fun p =>\n                                        And (GT.gt p 0)\n                                          (Exists fun q =>\n                                            And (GT.gt q 0)\n                                              (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                                      p then\n                                  ⋯.choose\n                                else 0)\n                              p)\n                          t)\n                      n)) →\n                instLTNat.lt\n                  ((fun t =>\n                      Nat.rec p\n                        (fun n p =>\n                          (fun p =>\n                              if hPp :\n                                  (fun p =>\n                                      And (GT.gt p 0)\n                                        (Exists fun q =>\n                                          And (GT.gt q 0)\n                                            (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                                    p then\n                                ⋯.choose\n                              else 0)\n                            p)\n                        t)\n                    (instHAdd.hAdd n 1))\n                  ((fun t =>\n                      Nat.rec p\n                        (fun n p =>\n                          (fun p =>\n                              if hPp :\n                                  (fun p =>\n                                      And (GT.gt p 0)\n                                        (Exists fun q =>\n                                          And (GT.gt q 0)\n                                            (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))\n                                    p then\n                                ⋯.choose\n                              else 0)\n                            p)\n                        t)\n                    n)",
        "name": [
            "Rat",
            "not_exist_sqrt_two",
            "_proof_1_8"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "sorryAx"
            ],
            [
                "Exists"
            ],
            [
                "Nat",
                "cast"
            ],
            [
                "Lean",
                "Name",
                "anonymous"
            ],
            [
                "Lean",
                "Name"
            ],
            [
                "Bool",
                "false"
            ],
            [
                "Lean",
                "Name",
                "str"
            ],
            [
                "GT",
                "gt"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Nat"
            ],
            [
                "Rat",
                "instNatCast"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Rat"
            ],
            [
                "Lean",
                "Name",
                "num"
            ],
            [
                "Rat",
                "instLT"
            ]
        ],
        "typeReferences": [
            [
                "Nat"
            ],
            [
                "Rat",
                "instNatCast"
            ],
            [
                "Nat",
                "cast"
            ],
            [
                "Exists"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instLT"
            ],
            [
                "GT",
                "gt"
            ]
        ],
        "type": "∀ (x : Rat), Exists fun n => GT.gt n.cast x",
        "name": [
            "Nat",
            "exists_gt"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "Not"
            ],
            [
                "instAddNat"
            ],
            [
                "instLTNat"
            ],
            [
                "Lean",
                "Name",
                "anonymous"
            ],
            [
                "sorryAx"
            ],
            [
                "Exists"
            ],
            [
                "Lean",
                "Name"
            ],
            [
                "instHAdd"
            ],
            [
                "Lean",
                "Name",
                "str"
            ],
            [
                "Bool",
                "false"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Lean",
                "Name",
                "num"
            ]
        ],
        "typeReferences": [
            [
                "instAddNat"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "Not"
            ],
            [
                "instLTNat"
            ],
            [
                "Nat"
            ],
            [
                "Exists"
            ],
            [
                "instOfNatNat"
            ],
            [
                "instHAdd"
            ],
            [
                "OfNat",
                "ofNat"
            ]
        ],
        "type": "Not (Exists fun a => ∀ (n : Nat), instLTNat.lt (a (instHAdd.hAdd n 1)) (a n))",
        "name": [
            "Nat",
            "no_infinite_descent"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "implies_congr"
            ],
            [
                "instAddNat"
            ],
            [
                "instPowNat"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "congrArg"
            ],
            [
                "Lean",
                "Grind",
                "Nat",
                "lt_eq"
            ],
            [
                "instOfNatNat"
            ],
            [
                "congr"
            ],
            [
                "funext"
            ],
            [
                "forall_congr"
            ],
            [
                "instMulNat"
            ],
            [
                "Eq"
            ],
            [
                "Eq",
                "ndrec"
            ],
            [
                "instHPow"
            ],
            [
                "instLTNat"
            ],
            [
                "Exists"
            ],
            [
                "instHAdd"
            ],
            [
                "And"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "instNatPowNat"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Eq",
                "mpr_prop"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "instMonoid"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "LE",
                "le"
            ],
            [
                "instHMul"
            ],
            [
                "instLENat"
            ]
        ],
        "typeReferences": [
            [
                "instAddNat"
            ],
            [
                "instHPow"
            ],
            [
                "Exists"
            ],
            [
                "instHAdd"
            ],
            [
                "And"
            ],
            [
                "instPowNat"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "instNatPowNat"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "instOfNatNat"
            ],
            [
                "LE",
                "le"
            ],
            [
                "instMulNat"
            ],
            [
                "instHMul"
            ],
            [
                "Eq"
            ],
            [
                "instLENat"
            ]
        ],
        "type": "(∀ (p : Nat),\n    And (instLENat.le 1 p)\n        (Exists fun q => And (instLENat.le 1 q) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) →\n      Exists fun q =>\n        And (instLENat.le (instHAdd.hAdd q 1) p)\n          (And (instLENat.le 1 q)\n            (Exists fun q_1 =>\n              And (instLENat.le 1 q_1) (Eq (instHPow.hPow q 2) (instHMul.hMul 2 (instHPow.hPow q_1 2)))))) →\n  ∀ (p : Nat),\n    And (instLENat.le 1 p)\n        (Exists fun q => And (instLENat.le 1 q) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) →\n      Exists fun x =>\n        And (instLENat.le (instHAdd.hAdd x 1) p)\n          (And (instLENat.le 1 x)\n            (Exists fun q => And (instLENat.le 1 q) (Eq (instHPow.hPow x 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))",
        "name": [
            "Rat",
            "not_exist_sqrt_two",
            "_proof_1_5"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "implies_congr"
            ],
            [
                "instAddNat"
            ],
            [
                "instDecidableAnd"
            ],
            [
                "Eq",
                "trans"
            ],
            [
                "Classical",
                "choose",
                "congr_simp"
            ],
            [
                "instPowNat"
            ],
            [
                "Classical",
                "propDecidable"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "Classical",
                "choose"
            ],
            [
                "dite_congr"
            ],
            [
                "congrArg"
            ],
            [
                "Lean",
                "Grind",
                "Nat",
                "lt_eq"
            ],
            [
                "instOfNatNat"
            ],
            [
                "congr"
            ],
            [
                "funext"
            ],
            [
                "forall_congr"
            ],
            [
                "instMulNat"
            ],
            [
                "Eq"
            ],
            [
                "Eq",
                "ndrec"
            ],
            [
                "instHPow"
            ],
            [
                "instLTNat"
            ],
            [
                "Exists"
            ],
            [
                "instHAdd"
            ],
            [
                "Nat",
                "decLe"
            ],
            [
                "And"
            ],
            [
                "instNatPowNat"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Nat",
                "decLt"
            ],
            [
                "Eq",
                "mpr_prop"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "instMonoid"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "Eq",
                "refl"
            ],
            [
                "Nat",
                "rec"
            ],
            [
                "LE",
                "le"
            ],
            [
                "instHMul"
            ],
            [
                "dite"
            ],
            [
                "instLENat"
            ]
        ],
        "typeReferences": [
            [
                "instAddNat"
            ],
            [
                "instDecidableAnd"
            ],
            [
                "instPowNat"
            ],
            [
                "Classical",
                "propDecidable"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_5"
            ],
            [
                "Classical",
                "choose"
            ],
            [
                "instOfNatNat"
            ],
            [
                "instMulNat"
            ],
            [
                "Eq"
            ],
            [
                "instHPow"
            ],
            [
                "Exists"
            ],
            [
                "instHAdd"
            ],
            [
                "And"
            ],
            [
                "Nat",
                "decLe"
            ],
            [
                "instNatPowNat"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "rec"
            ],
            [
                "LE",
                "le"
            ],
            [
                "instHMul"
            ],
            [
                "dite"
            ],
            [
                "instLENat"
            ]
        ],
        "type": "∀\n  (hiter :\n    ∀ (p : Nat),\n      And (instLENat.le 1 p)\n          (Exists fun q => And (instLENat.le 1 q) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) →\n        Exists fun q =>\n          And (instLENat.le (instHAdd.hAdd q 1) p)\n            (And (instLENat.le 1 q)\n              (Exists fun q_1 =>\n                And (instLENat.le 1 q_1) (Eq (instHPow.hPow q 2) (instHMul.hMul 2 (instHPow.hPow q_1 2))))))\n  (p n : Nat),\n  And\n      (instLENat.le 1\n        (Nat.rec p\n          (fun n p =>\n            if h :\n                And (instLENat.le 1 p)\n                  (Exists fun q =>\n                    And (instLENat.le 1 q) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n              Classical.choose ⋯\n            else 0)\n          n))\n      (Exists fun q =>\n        And (instLENat.le 1 q)\n          (Eq\n            (instHPow.hPow\n              (Nat.rec p\n                (fun n p =>\n                  if h :\n                      And (instLENat.le 1 p)\n                        (Exists fun q =>\n                          And (instLENat.le 1 q) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                    Classical.choose ⋯\n                  else 0)\n                n)\n              2)\n            (instHMul.hMul 2 (instHPow.hPow q 2)))) →\n    Exists fun x =>\n      And\n        (instLENat.le (instHAdd.hAdd x 1)\n          (Nat.rec p\n            (fun n p =>\n              if h :\n                  And (instLENat.le 1 p)\n                    (Exists fun q =>\n                      And (instLENat.le 1 q) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                Classical.choose ⋯\n              else 0)\n            n))\n        (And (instLENat.le 1 x)\n          (Exists fun q => And (instLENat.le 1 q) (Eq (instHPow.hPow x 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))",
        "name": [
            "Rat",
            "not_exist_sqrt_two",
            "_proof_1_6"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "Lean",
                "Name",
                "anonymous"
            ],
            [
                "sorryAx"
            ],
            [
                "instHAdd"
            ],
            [
                "Lean",
                "Name"
            ],
            [
                "Lean",
                "Name",
                "str"
            ],
            [
                "Bool",
                "false"
            ],
            [
                "And"
            ],
            [
                "Int",
                "cast"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Int"
            ],
            [
                "Rat",
                "instLE"
            ],
            [
                "Rat",
                "instIntCast"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "instOfNatNat"
            ],
            [
                "LE",
                "le"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instAdd"
            ],
            [
                "ExistsUnique"
            ],
            [
                "Lean",
                "Name",
                "num"
            ],
            [
                "Rat",
                "instLT"
            ]
        ],
        "typeReferences": [
            [
                "instHAdd"
            ],
            [
                "And"
            ],
            [
                "Int",
                "cast"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Int"
            ],
            [
                "Rat",
                "instLE"
            ],
            [
                "Rat",
                "instIntCast"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "LE",
                "le"
            ],
            [
                "Rat"
            ],
            [
                "ExistsUnique"
            ],
            [
                "Rat",
                "instAdd"
            ],
            [
                "Rat",
                "instLT"
            ]
        ],
        "type": "∀ (x : Rat), ExistsUnique fun n => And (Rat.instLE.le n.cast x) (Rat.instLT.lt x (instHAdd.hAdd n.cast 1))",
        "name": [
            "Rat",
            "between_int"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "MulZeroClass",
                "toMul"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "div_pf"
            ],
            [
                "AddGroupWithOne",
                "toAddMonoidWithOne"
            ],
            [
                "Exists",
                "intro"
            ],
            [
                "Rat",
                "instMul"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "one_mul"
            ],
            [
                "NonUnitalNonAssocCommRing",
                "toNonUnitalNonAssocCommSemiring"
            ],
            [
                "Eq",
                "symm"
            ],
            [
                "Eq",
                "ndrec"
            ],
            [
                "NonAssocSemiring",
                "toAddCommMonoidWithOne"
            ],
            [
                "NormedField",
                "toNormedCommRing"
            ],
            [
                "Nat",
                "ble"
            ],
            [
                "Rat",
                "addCommSemigroup"
            ],
            [
                "Rat",
                "instPreorder"
            ],
            [
                "Rat",
                "instNormedField"
            ],
            [
                "NonUnitalCommRing",
                "toNonUnitalNonAssocCommRing"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNNRat",
                "to_isNat"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNNRat",
                "den_nz"
            ],
            [
                "DivisionSemiring",
                "toGroupWithZero"
            ],
            [
                "DivisionSemiring",
                "toSemiring"
            ],
            [
                "Eq",
                "refl"
            ],
            [
                "HEq"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instAdd"
            ],
            [
                "Rat",
                "instAddLeftMono"
            ],
            [
                "Eq",
                "mpr"
            ],
            [
                "Nat",
                "rawCast"
            ],
            [
                "covariant_swap_add_of_covariant_add"
            ],
            [
                "Rat",
                "semiring"
            ],
            [
                "Bool"
            ],
            [
                "Rat",
                "instPartialOrder"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_mul"
            ],
            [
                "Rat",
                "instCharZero"
            ],
            [
                "div_pos"
            ],
            [
                "instHDiv"
            ],
            [
                "Rat",
                "instIsStrictOrderedRing"
            ],
            [
                "instOfNatNat"
            ],
            [
                "DivisionRing",
                "toDivisionSemiring"
            ],
            [
                "mul_lt_mul_of_pos_right"
            ],
            [
                "Preorder",
                "toLE"
            ],
            [
                "Rat",
                "instLT"
            ],
            [
                "Eq"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_add"
            ],
            [
                "Rat",
                "instDiv"
            ],
            [
                "AddRightCancelSemigroup",
                "toIsRightCancelAdd"
            ],
            [
                "Rat",
                "instField"
            ],
            [
                "Distrib",
                "toAdd"
            ],
            [
                "IsStrictOrderedRing",
                "toIsOrderedRing"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNNRat",
                "of_raw"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_congr"
            ],
            [
                "add_lt_add_right"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "MulZeroClass",
                "toZero"
            ],
            [
                "NonUnitalNonAssocSemiring",
                "toMulZeroClass"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isNNRat_add"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "instAddMonoidWithOne'"
            ],
            [
                "Mathlib",
                "Meta",
                "Positivity",
                "pos_of_isNat"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNat",
                "to_isNNRat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "zero_mul"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNat",
                "to_raw_eq"
            ],
            [
                "PartialOrder",
                "toPreorder"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNat",
                "of_raw"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_zero_add"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "inv_single"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "IsRightCancelAdd",
                "addRightStrictMono_of_addRightMono"
            ],
            [
                "NormedRing",
                "toRing"
            ],
            [
                "HDiv",
                "hDiv"
            ],
            [
                "And",
                "intro"
            ],
            [
                "Semiring",
                "toNonAssocSemiring"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_add_overlap"
            ],
            [
                "Ring",
                "toAddGroupWithOne"
            ],
            [
                "eq_of_heq"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "div_congr"
            ],
            [
                "Semifield",
                "toDivisionSemiring"
            ],
            [
                "Rat",
                "linearOrder"
            ],
            [
                "instHPow"
            ],
            [
                "IsStrictOrderedRing",
                "toPosMulStrictMono"
            ],
            [
                "InvOneClass",
                "toInv"
            ],
            [
                "NonUnitalNonAssocSemiring",
                "toDistrib"
            ],
            [
                "Rat",
                "addRightCancelSemigroup"
            ],
            [
                "NonAssocSemiring",
                "toNonUnitalNonAssocSemiring"
            ],
            [
                "And"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_zero"
            ],
            [
                "NonUnitalNonAssocCommSemiring",
                "toNonUnitalNonAssocSemiring"
            ],
            [
                "Nat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "atom_pf"
            ],
            [
                "id"
            ],
            [
                "instHMul"
            ],
            [
                "NonUnitalNormedCommRing",
                "toNonUnitalCommRing"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isNat_ofNat"
            ],
            [
                "PosMulStrictMono",
                "toPosMulReflectLE"
            ],
            [
                "DivisionMonoid",
                "toDivInvOneMonoid"
            ],
            [
                "Rat",
                "instDivisionRing"
            ],
            [
                "GroupWithZero",
                "toDivisionMonoid"
            ],
            [
                "Rat",
                "nontrivial"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNNRat",
                "to_raw_eq"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "PosMulReflectLE",
                "toPosMulReflectLT"
            ],
            [
                "congrArg"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "instCommSemiringNat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_add_lt"
            ],
            [
                "MonoidWithZero",
                "toMonoid"
            ],
            [
                "NormedCommRing",
                "toNormedRing"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isNNRat_inv_pos"
            ],
            [
                "Zero",
                "toOfNat0"
            ],
            [
                "NNRat",
                "rawCast"
            ],
            [
                "AddCommMonoidWithOne",
                "toAddMonoidWithOne"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_overlap_pf"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "of_eq"
            ],
            [
                "Inv",
                "inv"
            ],
            [
                "HEq",
                "refl"
            ],
            [
                "instHAdd"
            ],
            [
                "Distrib",
                "toMul"
            ],
            [
                "CommSemiring",
                "toSemiring"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "cast_pos"
            ],
            [
                "Semiring",
                "toMonoidWithZero"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_congr"
            ],
            [
                "Eq",
                "casesOn"
            ],
            [
                "Rat",
                "commSemiring"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "DivInvOneMonoid",
                "toInvOneClass"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_add_zero"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_pf_left"
            ],
            [
                "LE",
                "le"
            ],
            [
                "Field",
                "toSemifield"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_add_gt"
            ],
            [
                "IsStrictOrderedRing",
                "toMulPosStrictMono"
            ],
            [
                "NormedCommRing",
                "toNonUnitalNormedCommRing"
            ]
        ],
        "typeReferences": [
            [
                "LT",
                "lt"
            ],
            [
                "Exists"
            ],
            [
                "And"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instLT"
            ]
        ],
        "type": "∀ {x y : Rat}, Rat.instLT.lt x y → Exists fun z => And (Rat.instLT.lt x z) (Rat.instLT.lt z y)",
        "name": [
            "Rat",
            "exists_between_rat"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "Not"
            ],
            [
                "instAddNat"
            ],
            [
                "sorryAx"
            ],
            [
                "Lean",
                "Name",
                "anonymous"
            ],
            [
                "Lean",
                "Name"
            ],
            [
                "Bool",
                "false"
            ],
            [
                "Lean",
                "Name",
                "str"
            ],
            [
                "And"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "instSemiring"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Even"
            ],
            [
                "Lean",
                "Name",
                "num"
            ],
            [
                "Odd"
            ]
        ],
        "typeReferences": [
            [
                "instAddNat"
            ],
            [
                "Not"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "instSemiring"
            ],
            [
                "Even"
            ],
            [
                "And"
            ],
            [
                "Odd"
            ]
        ],
        "type": "∀ (n : Nat), Not (And (Even n) (Odd n))",
        "name": [
            "Nat",
            "not_even_and_odd"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "implies_congr"
            ],
            [
                "Rat",
                "instInv_mathlib"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "simp"
            ],
            [
                "eagerReduce"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Mon",
                "mult"
            ],
            [
                "Lean",
                "Grind",
                "Field",
                "toCommRing"
            ],
            [
                "Rat",
                "instLE"
            ],
            [
                "forall_congr"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Power",
                "mk"
            ],
            [
                "Bool",
                "true"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "toRing"
            ],
            [
                "instHPow"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "mul"
            ],
            [
                "Rat",
                "instPreorder"
            ],
            [
                "instPreorder_mathlib"
            ],
            [
                "Neg",
                "neg"
            ],
            [
                "Lean",
                "Grind",
                "not_not"
            ],
            [
                "Int",
                "instNegInt"
            ],
            [
                "Nat"
            ],
            [
                "instOfNat"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "core"
            ],
            [
                "Eq",
                "refl"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Poly",
                "num"
            ],
            [
                "Classical",
                "byContradiction"
            ],
            [
                "Rat"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "var"
            ],
            [
                "Lean",
                "Grind",
                "imp_false_eq"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "neg"
            ],
            [
                "Rat",
                "semiring"
            ],
            [
                "Bool"
            ],
            [
                "Rat",
                "instPartialOrder"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "Lean",
                "Grind",
                "OrderedRing",
                "instIsCharPOfNatNat"
            ],
            [
                "Lean",
                "RArray",
                "leaf"
            ],
            [
                "Rat",
                "instIsStrictOrderedRing"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Lean",
                "RArray",
                "branch"
            ],
            [
                "Rat",
                "instNeg"
            ],
            [
                "Rat",
                "instLT"
            ],
            [
                "Eq"
            ],
            [
                "Not"
            ],
            [
                "Rat",
                "instField"
            ],
            [
                "Inv",
                "inv"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "pow"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Mon",
                "unit"
            ],
            [
                "instOrderedRingOfIsStrictOrderedRing"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Int"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "num"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "unsat_eq"
            ],
            [
                "Field",
                "toGrindField"
            ],
            [
                "False"
            ],
            [
                "Lean",
                "Grind",
                "intro_with_eq"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Poly",
                "add"
            ]
        ],
        "typeReferences": [
            [
                "Not"
            ],
            [
                "instHPow"
            ],
            [
                "Neg",
                "neg"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "GT",
                "gt"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "Nat"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instNeg"
            ],
            [
                "False"
            ],
            [
                "Ne"
            ],
            [
                "Eq"
            ],
            [
                "Rat",
                "instLT"
            ]
        ],
        "type": "∀ (x : Rat),\n  Eq (instHPow.hPow x 2) 2 →\n    (∀ (x : Rat), Eq (instHPow.hPow x 2) 2 → Ne x 0 → GT.gt x 0 → False) → Not (GT.gt x 0) → Ne (Rat.instNeg.neg x) 0",
        "name": [
            "Rat",
            "not_exist_sqrt_two",
            "_proof_1_3"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "instAddNat"
            ],
            [
                "Lean",
                "Name",
                "anonymous"
            ],
            [
                "sorryAx"
            ],
            [
                "Exists"
            ],
            [
                "Decidable"
            ],
            [
                "Lean",
                "Name"
            ],
            [
                "instHAdd"
            ],
            [
                "Lean",
                "Name",
                "str"
            ],
            [
                "Bool",
                "false"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Int"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Int",
                "instLTInt"
            ],
            [
                "Lean",
                "Name",
                "num"
            ]
        ],
        "typeReferences": [
            [
                "instAddNat"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "Nat"
            ],
            [
                "Exists"
            ],
            [
                "Decidable"
            ],
            [
                "instOfNatNat"
            ],
            [
                "instHAdd"
            ],
            [
                "Int",
                "instLTInt"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Int"
            ]
        ],
        "type": "Decidable (Exists fun a => ∀ (n : Nat), Int.instLTInt.lt (a (instHAdd.hAdd n 1)) (a n))",
        "name": [
            "Int",
            "infinite_descent"
        ],
        "kind": "definition",
        "isProp": false
    },
    {
        "valueReferences": [
            [
                "instAddNat"
            ],
            [
                "instDecidableAnd"
            ],
            [
                "instPowNat"
            ],
            [
                "Classical",
                "propDecidable"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_5"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "Classical",
                "choose"
            ],
            [
                "Lean",
                "Grind",
                "nestedDecidable"
            ],
            [
                "instOfNatNat"
            ],
            [
                "instMulNat"
            ],
            [
                "Eq"
            ],
            [
                "instHPow"
            ],
            [
                "Exists"
            ],
            [
                "instHAdd"
            ],
            [
                "And"
            ],
            [
                "Nat",
                "decLe"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "instNatPowNat"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_6"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "rec"
            ],
            [
                "LE",
                "le"
            ],
            [
                "instHMul"
            ],
            [
                "dite"
            ],
            [
                "instLENat"
            ]
        ],
        "typeReferences": [
            [
                "instAddNat"
            ],
            [
                "instDecidableAnd"
            ],
            [
                "instPowNat"
            ],
            [
                "Classical",
                "propDecidable"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_5"
            ],
            [
                "Classical",
                "choose"
            ],
            [
                "Lean",
                "Grind",
                "nestedDecidable"
            ],
            [
                "instOfNatNat"
            ],
            [
                "instMulNat"
            ],
            [
                "Eq"
            ],
            [
                "instHPow"
            ],
            [
                "Exists"
            ],
            [
                "instHAdd"
            ],
            [
                "And"
            ],
            [
                "Nat",
                "decLe"
            ],
            [
                "instNatPowNat"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_6"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "rec"
            ],
            [
                "LE",
                "le"
            ],
            [
                "instHMul"
            ],
            [
                "dite"
            ],
            [
                "instLENat"
            ]
        ],
        "type": "∀\n  (hiter :\n    ∀ (p : Nat),\n      And (instLENat.le 1 p)\n          (Exists fun q => And (instLENat.le 1 q) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) →\n        Exists fun q =>\n          And (instLENat.le (instHAdd.hAdd q 1) p)\n            (And (instLENat.le 1 q)\n              (Exists fun q_1 =>\n                And (instLENat.le 1 q_1) (Eq (instHPow.hPow q 2) (instHMul.hMul 2 (instHPow.hPow q_1 2))))))\n  (p n : Nat),\n  And\n      (instLENat.le 1\n        (if h :\n            And\n              (instLENat.le 1\n                (Nat.rec p\n                  (fun n p =>\n                    if h :\n                        And (instLENat.le 1 p)\n                          (Exists fun q =>\n                            And (instLENat.le 1 q) (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                      Classical.choose ⋯\n                    else 0)\n                  n))\n              (Exists fun q =>\n                And (instLENat.le 1 q)\n                  (Eq\n                    (instHPow.hPow\n                      (Nat.rec p\n                        (fun n p =>\n                          if h :\n                              And (instLENat.le 1 p)\n                                (Exists fun q =>\n                                  And (instLENat.le 1 q)\n                                    (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                            Classical.choose ⋯\n                          else 0)\n                        n)\n                      2)\n                    (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n          Classical.choose ⋯\n        else 0))\n      (Exists fun q =>\n        And (instLENat.le 1 q)\n          (Eq\n            (instHPow.hPow\n              (if h :\n                  And\n                    (instLENat.le 1\n                      (Nat.rec p\n                        (fun n p =>\n                          if h :\n                              And (instLENat.le 1 p)\n                                (Exists fun q =>\n                                  And (instLENat.le 1 q)\n                                    (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                            Classical.choose ⋯\n                          else 0)\n                        n))\n                    (Exists fun q =>\n                      And (instLENat.le 1 q)\n                        (Eq\n                          (instHPow.hPow\n                            (Nat.rec p\n                              (fun n p =>\n                                if h :\n                                    And (instLENat.le 1 p)\n                                      (Exists fun q =>\n                                        And (instLENat.le 1 q)\n                                          (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                                  Classical.choose ⋯\n                                else 0)\n                              n)\n                            2)\n                          (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                Classical.choose ⋯\n              else 0)\n              2)\n            (instHMul.hMul 2 (instHPow.hPow q 2)))) →\n    Exists fun x =>\n      And\n        (instLENat.le (instHAdd.hAdd x 1)\n          (if h :\n              And\n                (instLENat.le 1\n                  (Nat.rec p\n                    (fun n p =>\n                      if h :\n                          And (instLENat.le 1 p)\n                            (Exists fun q =>\n                              And (instLENat.le 1 q)\n                                (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                        Classical.choose ⋯\n                      else 0)\n                    n))\n                (Exists fun q =>\n                  And (instLENat.le 1 q)\n                    (Eq\n                      (instHPow.hPow\n                        (Nat.rec p\n                          (fun n p =>\n                            if h :\n                                And (instLENat.le 1 p)\n                                  (Exists fun q =>\n                                    And (instLENat.le 1 q)\n                                      (Eq (instHPow.hPow p 2) (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n                              Classical.choose ⋯\n                            else 0)\n                          n)\n                        2)\n                      (instHMul.hMul 2 (instHPow.hPow q 2)))) then\n            Classical.choose ⋯\n          else 0))\n        (And (instLENat.le 1 x)\n          (Exists fun q => And (instLENat.le 1 q) (Eq (instHPow.hPow x 2) (instHMul.hMul 2 (instHPow.hPow q 2)))))",
        "name": [
            "Rat",
            "not_exist_sqrt_two",
            "_proof_1_7"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "Int",
                "instMonoid"
            ],
            [
                "Ring",
                "toNonAssocRing"
            ],
            [
                "Bool",
                "false"
            ],
            [
                "MulZeroClass",
                "toMul"
            ],
            [
                "Rat",
                "addGroup"
            ],
            [
                "Classical",
                "propDecidable"
            ],
            [
                "eq_true"
            ],
            [
                "AddGroupWithOne",
                "toAddMonoidWithOne"
            ],
            [
                "MonoidWithZero",
                "toMulZeroOneClass"
            ],
            [
                "zero_pow"
            ],
            [
                "div_pow"
            ],
            [
                "AddGroup",
                "toSubtractionMonoid"
            ],
            [
                "Int",
                "instCommSemiring"
            ],
            [
                "congrFun"
            ],
            [
                "le_of_not_gt"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isNat_pow"
            ],
            [
                "Even"
            ],
            [
                "Int",
                "instLTInt"
            ],
            [
                "Eq",
                "symm"
            ],
            [
                "_private",
                "Mathlib",
                "Tactic",
                "Positivity",
                "Basic",
                0,
                "Mathlib",
                "Meta",
                "Positivity",
                "num_pos_of_pos"
            ],
            [
                "NormedField",
                "toNormedCommRing"
            ],
            [
                "NonAssocSemiring",
                "toAddCommMonoidWithOne"
            ],
            [
                "instLatticeInt"
            ],
            [
                "Int",
                "cast_pow"
            ],
            [
                "instLTNat"
            ],
            [
                "Rat",
                "instPreorder"
            ],
            [
                "Exists"
            ],
            [
                "ne_of_gt"
            ],
            [
                "Classical",
                "em"
            ],
            [
                "Ring",
                "toSemiring"
            ],
            [
                "Nat",
                "cast_mul",
                "_simp_1"
            ],
            [
                "instOfNat"
            ],
            [
                "MulZeroOneClass",
                "toMulZeroClass"
            ],
            [
                "AddMonoid",
                "toAddSemigroup"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isNat_lt_true"
            ],
            [
                "gt_iff_lt",
                "_simp_1"
            ],
            [
                "Int",
                "negOfNat"
            ],
            [
                "Rat"
            ],
            [
                "Int",
                "instCharZero"
            ],
            [
                "Eq",
                "mpr"
            ],
            [
                "Rat",
                "instAddLeftMono"
            ],
            [
                "Rat",
                "semiring"
            ],
            [
                "Nat",
                "cast_inj",
                "_simp_1"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_mul"
            ],
            [
                "Not",
                "intro"
            ],
            [
                "Rat",
                "instDecidableLt"
            ],
            [
                "Rat",
                "instCharZero"
            ],
            [
                "Mathlib",
                "Tactic",
                "Linarith",
                "lt_irrefl"
            ],
            [
                "Int",
                "cast"
            ],
            [
                "Rat",
                "instIntCast"
            ],
            [
                "Nat",
                "instSemiring"
            ],
            [
                "Int",
                "instIsStrictOrderedRing"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "neg_one_mul"
            ],
            [
                "Int",
                "lt_toNat",
                "_simp_1"
            ],
            [
                "Rat",
                "instLT"
            ],
            [
                "Eq"
            ],
            [
                "Odd"
            ],
            [
                "instNatCastInt"
            ],
            [
                "Rat",
                "instField"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "neg_zero"
            ],
            [
                "Int",
                "instIsOrderedAddMonoid"
            ],
            [
                "instOfNatAtLeastTwo"
            ],
            [
                "Nat",
                "cast_pow"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_congr"
            ],
            [
                "AddZeroClass",
                "toAdd"
            ],
            [
                "dite_cond_eq_true"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNatPowT",
                "bit0"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "OfNat",
                "ofNat_ne_zero",
                "_simp_1"
            ],
            [
                "Ne"
            ],
            [
                "IsLeftCancelAdd",
                "addLeftStrictMono_of_addLeftMono"
            ],
            [
                "instHSub"
            ],
            [
                "IsStrictOrderedRing",
                "toZeroLEOneClass"
            ],
            [
                "PartialOrder",
                "toPreorder"
            ],
            [
                "AddLeftCancelSemigroup",
                "toIsLeftCancelAdd"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNat",
                "of_raw"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_zero_add"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsInt",
                "of_raw"
            ],
            [
                "Mathlib",
                "Tactic",
                "Linarith",
                "eq_of_not_lt_of_not_gt"
            ],
            [
                "Preorder",
                "toLT"
            ],
            [
                "CommGroupWithZero",
                "toDivisionCommMonoid"
            ],
            [
                "GT",
                "gt"
            ],
            [
                "NormedRing",
                "toRing"
            ],
            [
                "Nat",
                "cast_pos'"
            ],
            [
                "not_false_eq_true"
            ],
            [
                "Semiring",
                "toNonAssocSemiring"
            ],
            [
                "Or"
            ],
            [
                "Int",
                "instLEInt"
            ],
            [
                "Nat",
                "cast_mul"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "single_pow"
            ],
            [
                "Semifield",
                "toDivisionSemiring"
            ],
            [
                "AddGroup",
                "toSubNegMonoid"
            ],
            [
                "Int",
                "ofNat"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_3"
            ],
            [
                "And",
                "left"
            ],
            [
                "SemilatticeInf",
                "toPartialOrder"
            ],
            [
                "IsStrictOrderedRing",
                "toPosMulStrictMono"
            ],
            [
                "AddZeroClass",
                "toZero"
            ],
            [
                "And",
                "right"
            ],
            [
                "NonAssocSemiring",
                "toNonUnitalNonAssocSemiring"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_zero"
            ],
            [
                "Mathlib",
                "Tactic",
                "Linarith",
                "mul_neg"
            ],
            [
                "Exists",
                "casesOn"
            ],
            [
                "Nat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "atom_pf"
            ],
            [
                "AddMonoidWithOne",
                "toNatCast"
            ],
            [
                "NonUnitalNormedCommRing",
                "toNonUnitalCommRing"
            ],
            [
                "Mathlib",
                "Tactic",
                "Linarith",
                "mul_nonpos"
            ],
            [
                "Int",
                "cast_natCast"
            ],
            [
                "Int",
                "toNat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_one"
            ],
            [
                "Rat",
                "num_pos",
                "_simp_1"
            ],
            [
                "instDecidableAnd"
            ],
            [
                "Nat",
                "cast"
            ],
            [
                "Eq",
                "mp"
            ],
            [
                "le_trans"
            ],
            [
                "Aesop",
                "BuiltinRules",
                "not_intro"
            ],
            [
                "neg_eq_zero"
            ],
            [
                "Nat",
                "cast_pow",
                "_simp_1"
            ],
            [
                "instDistribLatticeOfLinearOrder"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_add_lt"
            ],
            [
                "GroupWithZero",
                "toMonoidWithZero"
            ],
            [
                "NormedCommRing",
                "toNormedRing"
            ],
            [
                "AddCommMonoidWithOne",
                "toAddMonoidWithOne"
            ],
            [
                "Nat",
                "instDecidablePredOdd"
            ],
            [
                "Not"
            ],
            [
                "Int",
                "cast_pow",
                "_simp_1"
            ],
            [
                "instHAdd"
            ],
            [
                "Distrib",
                "toMul"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "cast_pos"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_congr"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "Rat",
                "addLeftCancelSemigroup"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_add_zero"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "neg_add"
            ],
            [
                "of_eq_true"
            ],
            [
                "One",
                "toOfNat1"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "neg_congr"
            ],
            [
                "le_of_lt"
            ],
            [
                "Mathlib",
                "Tactic",
                "Linarith",
                "sub_nonpos_of_le"
            ],
            [
                "Rat",
                "num_div_den"
            ],
            [
                "Field",
                "toSemifield"
            ],
            [
                "False"
            ],
            [
                "NormedCommRing",
                "toNonUnitalNormedCommRing"
            ],
            [
                "Classical",
                "choose_spec"
            ],
            [
                "instAddNat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Linarith",
                "add_lt_of_neg_of_le"
            ],
            [
                "SubtractionMonoid",
                "toSubNegZeroMonoid"
            ],
            [
                "sorryAx"
            ],
            [
                "Eq",
                "trans"
            ],
            [
                "Lean",
                "Name",
                "str"
            ],
            [
                "Exists",
                "intro"
            ],
            [
                "Classical",
                "choose"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsInt",
                "to_raw_eq"
            ],
            [
                "DivisionMonoid",
                "toDivInvMonoid"
            ],
            [
                "NonUnitalNonAssocRing",
                "toNonUnitalNonAssocSemiring"
            ],
            [
                "False",
                "elim"
            ],
            [
                "sub_eq_zero_of_eq"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "one_mul"
            ],
            [
                "Nat",
                "instCharZero"
            ],
            [
                "NonUnitalNonAssocCommRing",
                "toNonUnitalNonAssocCommSemiring"
            ],
            [
                "SubNegMonoid",
                "toSub"
            ],
            [
                "OfNat",
                "zero_ne_ofNat",
                "_simp_1"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_overlap_pf_zero"
            ],
            [
                "Int",
                "eq_natCast_toNat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "sub_pf"
            ],
            [
                "Eq",
                "ndrec"
            ],
            [
                "Int",
                "instAddGroup"
            ],
            [
                "Left",
                "one_lt_inv_iff",
                "_simp_4"
            ],
            [
                "Rat",
                "instNormedField"
            ],
            [
                "Exists",
                "choose_spec"
            ],
            [
                "NonUnitalCommRing",
                "toNonUnitalNonAssocCommRing"
            ],
            [
                "Nat",
                "recAux"
            ],
            [
                "DivisionSemiring",
                "toGroupWithZero"
            ],
            [
                "DivInvMonoid",
                "toMonoid"
            ],
            [
                "Nat",
                "rec"
            ],
            [
                "Eq",
                "refl"
            ],
            [
                "AddMonoidWithOne",
                "toOne"
            ],
            [
                "Nat",
                "no_infinite_descent"
            ],
            [
                "Nat",
                "rawCast"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNat",
                "to_isInt"
            ],
            [
                "Rat",
                "den_pos"
            ],
            [
                "AddMonoid",
                "toAddZeroClass"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isNat_mul"
            ],
            [
                "Bool"
            ],
            [
                "Rat",
                "instPartialOrder"
            ],
            [
                "pow_pos"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNatPowT",
                "run"
            ],
            [
                "Rat",
                "instZeroLEOneClass"
            ],
            [
                "SubtractionCommMonoid",
                "toSubtractionMonoid"
            ],
            [
                "Int",
                "cast_inj",
                "_simp_1"
            ],
            [
                "Int",
                "add_one_le_iff"
            ],
            [
                "Int",
                "instRing"
            ],
            [
                "instHDiv"
            ],
            [
                "Nat",
                "instAddMonoidWithOne"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_add_overlap_zero"
            ],
            [
                "Rat",
                "instIsStrictOrderedRing"
            ],
            [
                "Int",
                "instAddCommGroup"
            ],
            [
                "instOfNatNat"
            ],
            [
                "exists_and_left",
                "_simp_1"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "pow_congr"
            ],
            [
                "congr"
            ],
            [
                "Int",
                "instAdd"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_pow"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_add"
            ],
            [
                "propext"
            ],
            [
                "lt_of_not_ge"
            ],
            [
                "Rat",
                "den"
            ],
            [
                "Rat",
                "instDiv"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "pow_zero"
            ],
            [
                "Distrib",
                "toAdd"
            ],
            [
                "IsStrictOrderedRing",
                "toIsOrderedRing"
            ],
            [
                "div_eq_iff",
                "_simp_1"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_8"
            ],
            [
                "CharP",
                "ofCharZero"
            ],
            [
                "Mathlib",
                "Tactic",
                "Zify",
                "natCast_lt",
                "_simp_1"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Int"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "AddGroupWithOne",
                "toAddGroup"
            ],
            [
                "AddCommGroup",
                "toDivisionAddCommMonoid"
            ],
            [
                "MulZeroClass",
                "toZero"
            ],
            [
                "NonUnitalNonAssocSemiring",
                "toMulZeroClass"
            ],
            [
                "AddGroupWithOne",
                "toIntCast"
            ],
            [
                "Int",
                "instNormedCommRing"
            ],
            [
                "Lean",
                "Name",
                "num"
            ],
            [
                "dite"
            ],
            [
                "neg_neg_of_pos"
            ],
            [
                "And",
                "casesOn"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "zero_mul"
            ],
            [
                "even_iff_exists_two_mul"
            ],
            [
                "le_refl"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsNat",
                "to_raw_eq"
            ],
            [
                "Mathlib",
                "Tactic",
                "Linarith",
                "lt_of_lt_of_eq"
            ],
            [
                "Lean",
                "Name"
            ],
            [
                "Rat",
                "not_exist_sqrt_two",
                "_proof_1_2"
            ],
            [
                "Iff",
                "mp"
            ],
            [
                "Int",
                "rawCast"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "AddMonoidWithOne",
                "toAddMonoid"
            ],
            [
                "HDiv",
                "hDiv"
            ],
            [
                "Nat",
                "even_or_odd''"
            ],
            [
                "And",
                "intro"
            ],
            [
                "Rat",
                "instNatCast"
            ],
            [
                "Ring",
                "toAddGroupWithOne"
            ],
            [
                "Rat",
                "commGroupWithZero"
            ],
            [
                "funext"
            ],
            [
                "HSub",
                "hSub"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "IsInt",
                "to_isNat"
            ],
            [
                "Mathlib",
                "Tactic",
                "Linarith",
                "zero_lt_one"
            ],
            [
                "Rat",
                "linearOrder"
            ],
            [
                "Int",
                "cast_ofNat"
            ],
            [
                "Nat",
                "instLinearOrder"
            ],
            [
                "NonAssocRing",
                "toNonUnitalNonAssocRing"
            ],
            [
                "AddSemigroup",
                "toAdd"
            ],
            [
                "instHPow"
            ],
            [
                "NonUnitalNonAssocSemiring",
                "toDistrib"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "one_pow"
            ],
            [
                "Neg",
                "neg"
            ],
            [
                "And"
            ],
            [
                "Decidable",
                "not_and_iff_not_or_not'"
            ],
            [
                "Nat",
                "decLt"
            ],
            [
                "NonUnitalNonAssocCommSemiring",
                "toNonUnitalNonAssocSemiring"
            ],
            [
                "Decidable",
                "byContradiction"
            ],
            [
                "Nat",
                "instMonoid"
            ],
            [
                "Nat",
                "cast_zero"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "instAddMonoidWithOne"
            ],
            [
                "Iff",
                "mpr"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_pf_right"
            ],
            [
                "NegZeroClass",
                "toZero"
            ],
            [
                "id"
            ],
            [
                "instHMul"
            ],
            [
                "instNatAtLeastTwo"
            ],
            [
                "NeZero",
                "charZero_one"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isNat_ofNat"
            ],
            [
                "Nat",
                "rec_add_one"
            ],
            [
                "Lean",
                "Name",
                "anonymous"
            ],
            [
                "Mathlib",
                "Tactic",
                "Zify",
                "natCast_eq",
                "_simp_1"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isInt_add"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "neg_mul"
            ],
            [
                "SubNegZeroMonoid",
                "toNegZeroClass"
            ],
            [
                "Rat",
                "num"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "congrArg"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "instCommSemiringNat"
            ],
            [
                "NonAssocRing",
                "toAddCommGroupWithOne"
            ],
            [
                "MonoidWithZero",
                "toMonoid"
            ],
            [
                "Nat",
                "not_even_and_odd"
            ],
            [
                "instMulNat"
            ],
            [
                "Rat",
                "instNeg"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "sub_congr"
            ],
            [
                "Zero",
                "toOfNat0"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "cast_zero"
            ],
            [
                "le_antisymm"
            ],
            [
                "DivisionCommMonoid",
                "toDivisionMonoid"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isInt_mul"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "of_eq"
            ],
            [
                "Lattice",
                "toSemilatticeInf"
            ],
            [
                "True"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "pow_add"
            ],
            [
                "CommSemiring",
                "toSemiring"
            ],
            [
                "Mathlib",
                "Tactic",
                "Zify",
                "natCast_le",
                "_simp_1"
            ],
            [
                "Semiring",
                "toMonoidWithZero"
            ],
            [
                "Exists",
                "choose"
            ],
            [
                "DivInvMonoid",
                "toDiv"
            ],
            [
                "Or",
                "casesOn"
            ],
            [
                "AddCommGroupWithOne",
                "toAddGroupWithOne"
            ],
            [
                "DistribLattice",
                "toLattice"
            ],
            [
                "NegZeroClass",
                "toNeg"
            ],
            [
                "SubNegMonoid",
                "toAddMonoid"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "mul_pf_left"
            ],
            [
                "Int",
                "instSemiring"
            ],
            [
                "Int",
                "cast_mul"
            ],
            [
                "CharP",
                "cast_eq_zero"
            ],
            [
                "LE",
                "le"
            ],
            [
                "Mathlib",
                "Tactic",
                "Ring",
                "add_pf_add_gt"
            ],
            [
                "instLENat"
            ],
            [
                "Int",
                "instAddMonoid"
            ]
        ],
        "typeReferences": [
            [
                "instHPow"
            ],
            [
                "Not"
            ],
            [
                "Nat"
            ],
            [
                "Exists"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "Rat"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "Eq"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "OfNat",
                "ofNat"
            ]
        ],
        "type": "Not (Exists fun x => Eq (instHPow.hPow x 2) 2)",
        "name": [
            "Rat",
            "not_exist_sqrt_two"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "instAddNat"
            ],
            [
                "sorryAx"
            ],
            [
                "Lean",
                "Name",
                "anonymous"
            ],
            [
                "Lean",
                "Name"
            ],
            [
                "Bool",
                "false"
            ],
            [
                "Lean",
                "Name",
                "str"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Nat"
            ],
            [
                "Or"
            ],
            [
                "Nat",
                "instSemiring"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Even"
            ],
            [
                "Lean",
                "Name",
                "num"
            ],
            [
                "Odd"
            ]
        ],
        "typeReferences": [
            [
                "instAddNat"
            ],
            [
                "Nat"
            ],
            [
                "Nat",
                "instSemiring"
            ],
            [
                "Or"
            ],
            [
                "Even"
            ],
            [
                "Odd"
            ]
        ],
        "type": "∀ (n : Nat), Or (Even n) (Odd n)",
        "name": [
            "Nat",
            "even_or_odd''"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "contravariant_swap_add_of_contravariant_add"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "lt_norm"
            ],
            [
                "PartialOrder",
                "toPreorder"
            ],
            [
                "Preorder",
                "toLT"
            ],
            [
                "One",
                "one"
            ],
            [
                "eagerReduce"
            ],
            [
                "AddGroupWithOne",
                "toAddMonoidWithOne"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "Rat",
                "instMul"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Mon",
                "mult"
            ],
            [
                "Lean",
                "Grind",
                "Field",
                "toCommRing"
            ],
            [
                "NormedRing",
                "toRing"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "Expr",
                "add"
            ],
            [
                "Rat",
                "instLE"
            ],
            [
                "IsRightCancelAdd",
                "addRightReflectLE_of_addRightReflectLT"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "Expr",
                "intMul"
            ],
            [
                "Rat",
                "instNatCast"
            ],
            [
                "Ring",
                "toAddGroupWithOne"
            ],
            [
                "NatCast",
                "natCast"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "Poly",
                "nil"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "Poly",
                "add"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Power",
                "mk"
            ],
            [
                "Lean",
                "Grind",
                "Ring",
                "toIntModule"
            ],
            [
                "Bool",
                "true"
            ],
            [
                "Rat",
                "linearOrder"
            ],
            [
                "instOrderedAddOfAddRightMonoOfAddRightReflectLE"
            ],
            [
                "NormedField",
                "toNormedCommRing"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "toRing"
            ],
            [
                "Rat",
                "addCommSemigroup"
            ],
            [
                "instHPow"
            ],
            [
                "Rat",
                "instPreorder"
            ],
            [
                "Rat",
                "instNormedField"
            ],
            [
                "instPreorder_mathlib"
            ],
            [
                "Neg",
                "neg"
            ],
            [
                "Rat",
                "addRightCancelSemigroup"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "lt_lt_combine"
            ],
            [
                "Int",
                "instNegInt"
            ],
            [
                "Nat"
            ],
            [
                "instOfNat"
            ],
            [
                "Eq",
                "refl"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Poly",
                "num"
            ],
            [
                "AddMonoidWithOne",
                "toOne"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instAdd"
            ],
            [
                "instHMul"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "var"
            ],
            [
                "Rat",
                "instAddLeftMono"
            ],
            [
                "covariant_swap_add_of_covariant_add"
            ],
            [
                "Rat",
                "semiring"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "zero_lt_one"
            ],
            [
                "Bool"
            ],
            [
                "Rat",
                "instPartialOrder"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "mul"
            ],
            [
                "Eq",
                "mp"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "Lean",
                "RArray",
                "leaf"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "Expr",
                "var"
            ],
            [
                "Rat",
                "instIsStrictOrderedRing"
            ],
            [
                "contravariant_lt_of_covariant_le"
            ],
            [
                "instOfNatNat"
            ],
            [
                "MonoidWithZero",
                "toMonoid"
            ],
            [
                "NormedCommRing",
                "toNormedRing"
            ],
            [
                "Lean",
                "RArray",
                "branch"
            ],
            [
                "AddCommSemigroup",
                "toAddCommMagma"
            ],
            [
                "AddCommMagma",
                "toAdd"
            ],
            [
                "Eq"
            ],
            [
                "Preorder",
                "toLE"
            ],
            [
                "Rat",
                "instLT"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "Expr",
                "zero"
            ],
            [
                "AddRightCancelSemigroup",
                "toIsRightCancelAdd"
            ],
            [
                "Rat",
                "instField"
            ],
            [
                "instHAdd"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "pow"
            ],
            [
                "Semiring",
                "toMonoidWithZero"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "lt_norm"
            ],
            [
                "instOrderedRingOfIsStrictOrderedRing"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Mon",
                "unit"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Int"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "num"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "Field",
                "toGrindField"
            ],
            [
                "LE",
                "le"
            ],
            [
                "Lean",
                "Grind",
                "Linarith",
                "lt_unsat"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Poly",
                "add"
            ]
        ],
        "typeReferences": [
            [
                "Rat",
                "semiring"
            ],
            [
                "Nat",
                "cast"
            ],
            [
                "PartialOrder",
                "toPreorder"
            ],
            [
                "NonUnitalNonAssocCommSemiring",
                "toCommMagma"
            ],
            [
                "Preorder",
                "toLT"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "Rat",
                "instMul"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "Rat",
                "instNatCast"
            ],
            [
                "instOfNatNat"
            ],
            [
                "NonUnitalNonAssocCommRing",
                "toNonUnitalNonAssocCommSemiring"
            ],
            [
                "MonoidWithZero",
                "toMonoid"
            ],
            [
                "Rat",
                "instLT"
            ],
            [
                "NormedField",
                "toNormedCommRing"
            ],
            [
                "Rat",
                "linearOrder"
            ],
            [
                "instHPow"
            ],
            [
                "Rat",
                "instNormedField"
            ],
            [
                "CommMagma",
                "toMul"
            ],
            [
                "NonUnitalCommRing",
                "toNonUnitalNonAssocCommRing"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "Semiring",
                "toMonoidWithZero"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "LinearOrder",
                "toPartialOrder"
            ],
            [
                "Nat"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "Rat"
            ],
            [
                "False"
            ],
            [
                "instHMul"
            ],
            [
                "NonUnitalNormedCommRing",
                "toNonUnitalCommRing"
            ],
            [
                "NormedCommRing",
                "toNonUnitalNormedCommRing"
            ]
        ],
        "type": "∀ {ε : Rat},\n  (∀ (n : Nat), Rat.instLT.lt (instHPow.hPow (instHMul.hMul n.cast ε) 2) 2) →\n    ∀ (n : Nat), Rat.linearOrder.lt (instHPow.hPow 2 2) (instHPow.hPow (instHMul.hMul n.cast ε) 2) → False",
        "name": [
            "Rat",
            "exist_approx_sqrt_two",
            "_proof_1_2"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "Classical",
                "choose_spec"
            ],
            [
                "implies_congr"
            ],
            [
                "instAddNat"
            ],
            [
                "Eq",
                "trans"
            ],
            [
                "MulZeroClass",
                "toMul"
            ],
            [
                "AddGroupWithOne",
                "toAddMonoidWithOne"
            ],
            [
                "MonoidWithZero",
                "toMulZeroOneClass"
            ],
            [
                "Rat",
                "instMul"
            ],
            [
                "Classical",
                "choose"
            ],
            [
                "not_exists",
                "_simp_1"
            ],
            [
                "zero_pow"
            ],
            [
                "Nat",
                "instCharZero"
            ],
            [
                "NonUnitalNonAssocCommRing",
                "toNonUnitalNonAssocCommSemiring"
            ],
            [
                "mul_comm"
            ],
            [
                "Eq",
                "symm"
            ],
            [
                "MulOneClass",
                "toMul"
            ],
            [
                "NormedField",
                "toNormedCommRing"
            ],
            [
                "Nat",
                "ble"
            ],
            [
                "Nat",
                "ofNat_pos",
                "_simp_1"
            ],
            [
                "Rat",
                "instNormedField"
            ],
            [
                "Exists"
            ],
            [
                "NonUnitalCommRing",
                "toNonUnitalNonAssocCommRing"
            ],
            [
                "Nat",
                "recAux"
            ],
            [
                "MulZeroClass",
                "zero_mul"
            ],
            [
                "MulZeroOneClass",
                "toMulZeroClass"
            ],
            [
                "eq_false"
            ],
            [
                "Eq",
                "refl"
            ],
            [
                "AddMonoid",
                "toAddSemigroup"
            ],
            [
                "Classical",
                "byContradiction"
            ],
            [
                "AddMonoidWithOne",
                "toOne"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instAdd"
            ],
            [
                "Rat",
                "instAddLeftMono"
            ],
            [
                "Eq",
                "mpr"
            ],
            [
                "one_mul"
            ],
            [
                "AddMonoid",
                "toAddZeroClass"
            ],
            [
                "Rat",
                "semiring"
            ],
            [
                "gt_iff_lt"
            ],
            [
                "Bool"
            ],
            [
                "Rat",
                "instPartialOrder"
            ],
            [
                "NonUnitalNonAssocCommSemiring",
                "toCommMagma"
            ],
            [
                "Rat",
                "instZeroLEOneClass"
            ],
            [
                "Rat",
                "instCharZero"
            ],
            [
                "MulZeroOneClass",
                "toMulOneClass"
            ],
            [
                "instHDiv"
            ],
            [
                "Nat",
                "instAddMonoidWithOne"
            ],
            [
                "add_mul"
            ],
            [
                "Rat",
                "instIsStrictOrderedRing"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Rat",
                "instLT"
            ],
            [
                "Eq"
            ],
            [
                "Preorder",
                "toLE"
            ],
            [
                "propext"
            ],
            [
                "Rat",
                "instDiv"
            ],
            [
                "Mathlib",
                "Tactic",
                "PushNeg",
                "not_exists_eq"
            ],
            [
                "IsStrictOrderedRing",
                "toIsOrderedRing"
            ],
            [
                "IsOrderedRing",
                "toMulPosMono"
            ],
            [
                "mul_nonneg"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "instOfNatAtLeastTwo"
            ],
            [
                "div_lt_iff₀'"
            ],
            [
                "CharP",
                "ofCharZero"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Nat",
                "cast_add"
            ],
            [
                "LinearOrder",
                "toPartialOrder"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "MulZeroClass",
                "toZero"
            ],
            [
                "OfNat",
                "ofNat_ne_zero",
                "_simp_1"
            ],
            [
                "NonUnitalNonAssocSemiring",
                "toMulZeroClass"
            ],
            [
                "Nat",
                "exists_gt"
            ],
            [
                "Mathlib",
                "Meta",
                "Positivity",
                "pos_of_isNat"
            ],
            [
                "lt_trans"
            ],
            [
                "Nat",
                "cast_one"
            ],
            [
                "PartialOrder",
                "toPreorder"
            ],
            [
                "GroupWithZero",
                "toDivInvMonoid"
            ],
            [
                "sq_lt_sq₀"
            ],
            [
                "Preorder",
                "toLT"
            ],
            [
                "HMul",
                "hMul"
            ],
            [
                "GT",
                "gt"
            ],
            [
                "AddMonoidWithOne",
                "toAddMonoid"
            ],
            [
                "GE",
                "ge"
            ],
            [
                "NormedRing",
                "toRing"
            ],
            [
                "HDiv",
                "hDiv"
            ],
            [
                "Rat",
                "instLE"
            ],
            [
                "Distrib",
                "rightDistribClass"
            ],
            [
                "Rat",
                "instNatCast"
            ],
            [
                "not_false_eq_true"
            ],
            [
                "Semiring",
                "toNonAssocSemiring"
            ],
            [
                "Rat",
                "commGroupWithZero"
            ],
            [
                "Ring",
                "toAddGroupWithOne"
            ],
            [
                "forall_congr"
            ],
            [
                "Rat",
                "linearOrder"
            ],
            [
                "NonAssocSemiring",
                "toMulZeroOneClass"
            ],
            [
                "AddSemigroup",
                "toAdd"
            ],
            [
                "IsStrictOrderedRing",
                "toPosMulStrictMono"
            ],
            [
                "instHPow"
            ],
            [
                "CommMagma",
                "toMul"
            ],
            [
                "AddZeroClass",
                "toZero"
            ],
            [
                "NonUnitalNonAssocSemiring",
                "toDistrib"
            ],
            [
                "And"
            ],
            [
                "Rat",
                "not_exist_sqrt_two"
            ],
            [
                "NonUnitalNonAssocCommSemiring",
                "toNonUnitalNonAssocSemiring"
            ],
            [
                "Nat"
            ],
            [
                "AddMonoidWithOne",
                "toNatCast"
            ],
            [
                "id"
            ],
            [
                "instHMul"
            ],
            [
                "NonUnitalNormedCommRing",
                "toNonUnitalCommRing"
            ],
            [
                "instNatAtLeastTwo"
            ],
            [
                "Mathlib",
                "Meta",
                "NormNum",
                "isNat_ofNat"
            ],
            [
                "PosMulStrictMono",
                "toPosMulReflectLE"
            ],
            [
                "CommGroupWithZero",
                "toGroupWithZero"
            ],
            [
                "Nat",
                "cast"
            ],
            [
                "Rat",
                "nontrivial"
            ],
            [
                "Eq",
                "mp"
            ],
            [
                "lt_of_le_of_ne"
            ],
            [
                "PosMulReflectLE",
                "toPosMulReflectLT"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "congrArg"
            ],
            [
                "Nat",
                "cast_nonneg'"
            ],
            [
                "MulOneClass",
                "toOne"
            ],
            [
                "GroupWithZero",
                "toMonoidWithZero"
            ],
            [
                "MonoidWithZero",
                "toMonoid"
            ],
            [
                "NormedCommRing",
                "toNormedRing"
            ],
            [
                "Rat",
                "exist_approx_sqrt_two",
                "_proof_1_2"
            ],
            [
                "Zero",
                "toOfNat0"
            ],
            [
                "Not"
            ],
            [
                "True"
            ],
            [
                "instHAdd"
            ],
            [
                "Mathlib",
                "Tactic",
                "PushNeg",
                "not_lt_eq"
            ],
            [
                "Mathlib",
                "Tactic",
                "PushNeg",
                "not_and_eq"
            ],
            [
                "Rat",
                "instPosMulMono"
            ],
            [
                "Semiring",
                "toMonoidWithZero"
            ],
            [
                "DivInvMonoid",
                "toDiv"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "of_eq_true"
            ],
            [
                "One",
                "toOfNat1"
            ],
            [
                "le_of_lt"
            ],
            [
                "CharP",
                "cast_eq_zero"
            ],
            [
                "LE",
                "le"
            ],
            [
                "False"
            ],
            [
                "NormedCommRing",
                "toNonUnitalNormedCommRing"
            ]
        ],
        "typeReferences": [
            [
                "instHPow"
            ],
            [
                "Exists"
            ],
            [
                "instHAdd"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "And"
            ],
            [
                "GT",
                "gt"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "GE",
                "ge"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "HAdd",
                "hAdd"
            ],
            [
                "Rat",
                "instLE"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "Nat"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instAdd"
            ],
            [
                "Rat",
                "instLT"
            ]
        ],
        "type": "∀ {ε : Rat},\n  GT.gt ε 0 →\n    Exists fun x =>\n      And (GE.ge x 0)\n        (And (Rat.instLT.lt (instHPow.hPow x 2) 2) (Rat.instLT.lt 2 (instHPow.hPow (instHAdd.hAdd x ε) 2)))",
        "name": [
            "Rat",
            "exist_approx_sqrt_two"
        ],
        "kind": "theorem",
        "isProp": true
    },
    {
        "valueReferences": [
            [
                "implies_congr"
            ],
            [
                "Rat",
                "instInv_mathlib"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "simp"
            ],
            [
                "eagerReduce"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Mon",
                "mult"
            ],
            [
                "Lean",
                "Grind",
                "Field",
                "toCommRing"
            ],
            [
                "Rat",
                "instLE"
            ],
            [
                "forall_congr"
            ],
            [
                "instIsAddTorsionFree"
            ],
            [
                "HSub",
                "hSub"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Power",
                "mk"
            ],
            [
                "Rat",
                "linearOrder"
            ],
            [
                "Bool",
                "true"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "toRing"
            ],
            [
                "instHPow"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "mul"
            ],
            [
                "Rat",
                "instPreorder"
            ],
            [
                "instPreorder_mathlib"
            ],
            [
                "Neg",
                "neg"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "diseq_to_eq"
            ],
            [
                "Rat",
                "addCommGroup"
            ],
            [
                "Int",
                "instNegInt"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "div"
            ],
            [
                "Nat"
            ],
            [
                "instOfNat"
            ],
            [
                "Rat",
                "addCommMonoid"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "core"
            ],
            [
                "Eq",
                "refl"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Poly",
                "num"
            ],
            [
                "Classical",
                "byContradiction"
            ],
            [
                "Rat"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "var"
            ],
            [
                "Lean",
                "Grind",
                "imp_false_eq"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "neg"
            ],
            [
                "Rat",
                "semiring"
            ],
            [
                "Rat",
                "instIsOrderedAddMonoid"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "diseq0_to_eq"
            ],
            [
                "Bool"
            ],
            [
                "Rat",
                "instPartialOrder"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "mul"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "superpose"
            ],
            [
                "Rat",
                "instSub"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "Lean",
                "Grind",
                "OrderedRing",
                "instIsCharPOfNatNat"
            ],
            [
                "Lean",
                "RArray",
                "leaf"
            ],
            [
                "Rat",
                "instIsStrictOrderedRing"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Lean",
                "RArray",
                "branch"
            ],
            [
                "Rat",
                "instNeg"
            ],
            [
                "Rat",
                "instLT"
            ],
            [
                "Eq"
            ],
            [
                "Not"
            ],
            [
                "Rat",
                "instField"
            ],
            [
                "Inv",
                "inv"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "pow"
            ],
            [
                "instOrderedRingOfIsStrictOrderedRing"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Mon",
                "unit"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "sub"
            ],
            [
                "Int"
            ],
            [
                "LT",
                "lt"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Expr",
                "num"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Stepwise",
                "unsat_eq"
            ],
            [
                "Field",
                "toGrindField"
            ],
            [
                "False"
            ],
            [
                "Lean",
                "Grind",
                "intro_with_eq"
            ],
            [
                "instNoNatZeroDivisorsOfIsAddTorsionFree"
            ],
            [
                "instHSub"
            ],
            [
                "Lean",
                "Grind",
                "CommRing",
                "Poly",
                "add"
            ]
        ],
        "typeReferences": [
            [
                "Not"
            ],
            [
                "instHPow"
            ],
            [
                "Neg",
                "neg"
            ],
            [
                "Rat",
                "monoid"
            ],
            [
                "HPow",
                "hPow"
            ],
            [
                "GT",
                "gt"
            ],
            [
                "OfNat",
                "ofNat"
            ],
            [
                "Rat",
                "instOfNat"
            ],
            [
                "Nat"
            ],
            [
                "Monoid",
                "toNatPow"
            ],
            [
                "instOfNatNat"
            ],
            [
                "Rat"
            ],
            [
                "Rat",
                "instNeg"
            ],
            [
                "False"
            ],
            [
                "Ne"
            ],
            [
                "Eq"
            ],
            [
                "Rat",
                "instLT"
            ]
        ],
        "type": "∀ (x : Rat),\n  Eq (instHPow.hPow x 2) 2 →\n    Ne x 0 →\n      (∀ (x : Rat), Eq (instHPow.hPow x 2) 2 → Ne x 0 → GT.gt x 0 → False) →\n        Not (GT.gt x 0) → Eq (instHPow.hPow (Rat.instNeg.neg x) 2) 2",
        "name": [
            "Rat",
            "not_exist_sqrt_two",
            "_proof_1_2"
        ],
        "kind": "theorem",
        "isProp": true
    }
]