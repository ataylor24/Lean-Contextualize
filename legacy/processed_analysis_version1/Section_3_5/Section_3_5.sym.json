[{"valueReferences":[["Chapter3","OrderedPair","rec"]],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  {motive : Chapter3.OrderedPair → Sort u} →\n    (t : Chapter3.OrderedPair) → ((fst snd : inst.Object) → motive { fst := fst, snd := snd }) → motive t","name":["Chapter3","OrderedPair","recOn"],"kind":"definition","isProp":false},{"valueReferences":[["Subtype"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","mk","injEq"],["Function","instEmbeddingLikeEmbedding"],["Chapter3","SetTheory","Set","mem_cartesian"],["congrArg"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set","snd"],["congr"],["Subtype","property"],["Eq","symm"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"],["Exists"],["Exists","choose_spec"],["Chapter3","OrderedPair"],["And","right"],["Chapter3","SetTheory","Set","mk_cartesian","_proof_1"],["Function","Embedding"],["And"],["Chapter3","OrderedPair","mk"],["Exists","choose"],["Chapter3","SetTheory","Set","snd_of_mk_cartesian","_simp_1_2"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Exists","casesOn"],["Chapter3","SetTheory","Set"],["Eq","refl"],["id"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["exists_comm"]],"typeReferences":[["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (x : X.toSubtype) (y : Y.toSubtype),\n  Eq (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.mk_cartesian x y)) y","name":["Chapter3","SetTheory","Set","snd_of_mk_cartesian"],"kind":"theorem","isProp":true},{"valueReferences":[["LT","lt"],["instLTNat"],["Nat"],["Exists"],["Chapter3","SetTheory","Set","mem_Fin'"],["Exists","choose_spec"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["LT","lt"],["instLTNat"],["Nat"],["Exists"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (i : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n  Exists fun h => Eq i (Chapter3.SetTheory.Set.Fin_mk n (Chapter3.SetTheory.Set.Fin.toNat i) h)","name":["Chapter3","SetTheory","Set","Fin","toNat_spec"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Object"],["Lean","Grind","intro_with_eq'"],["DFunLike","coe"],["Subtype","val"],["Equiv"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["funext"],["EquivLike","toFunLike"],["Eq","symm"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Set","Tuple","ext","_proof_1_5"],["instLTNat"],["True"],["instHAdd"],["True","intro"],["Lean","Grind","nestedProof"],["OfNat","ofNat"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["Chapter3","SetTheory","nat"],["LE","le"],["False"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Subtype","casesOn"],["instLENat"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Function","Surjective"],["Subtype","val"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","Tuple","x"],["Chapter3","SetTheory","Set","Tuple","mk"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (X : inst.Set) (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype)\n  (surj : Function.Surjective x)\n  (x_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype → { X := X, x := x, surj := surj }.X.toSubtype)\n  (surj_1 : Function.Surjective x_1),\n  (∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n      Eq ({ X := X, x := x, surj := surj }.x n_1).val\n        ({ X := { X := X, x := x, surj := surj }.X, x := x_1, surj := surj_1 }.x n_1).val) →\n    ∀ (x_2 : (Chapter3.SetTheory.Set.Fin n).toSubtype), Eq (x x_2).val (x_1 x_2).val","name":["Chapter3","SetTheory","Set","Tuple","ext","_proof_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_1"],["Equiv","mk"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_7"],["Set"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_2"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Exists","choose"],["Subtype","val"],["Set","Elem"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_4"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_3"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_10"],["Subtype","mk"],["Eq"],["setOf"]],"typeReferences":[["Set","univ"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Set","Elem"],["Equiv"],["setOf"]],"type":"[inst : Chapter3.SetTheory] →\n  (I : inst.Set) →\n    (X : I.toSubtype → inst.Set) →\n      Equiv (Chapter3.SetTheory.Set.iProd X).toSubtype\n        (Set.univ.pi fun i => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x).Elem","name":["Chapter3","SetTheory","Set","iProd_equiv_pi"],"kind":"definition","isProp":false},{"valueReferences":[["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Subtype","ext"],["Chapter3","SetTheory","Set","Tuple","ext","match_1_1"],["Chapter3","SetTheory","Object"],["Function","Surjective"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple"],["Chapter3","SetTheory","Set","Tuple","ext","match_1_3"],["Chapter3","SetTheory","Set","Tuple","ext","_proof_1_6"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Eq","refl"],["funext"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","rec"],["Eq"],["Eq","ndrec"],["Chapter3","SetTheory","Set","Tuple","x"],["Chapter3","SetTheory","Set","Tuple","mk"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","Tuple","x"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {t t' : Chapter3.SetTheory.Set.Tuple n},\n  Eq t.X t'.X → (∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype), Eq (t.x n_1).val (t'.x n_1).val) → Eq t t'","name":["Chapter3","SetTheory","Set","Tuple","ext"],"kind":"theorem","isProp":true},{"valueReferences":[["PULift"],["Chapter3","SetTheory","Object"]],"typeReferences":[["Nat"],["Chapter3","SetTheory"]],"type":"[Chapter3.SetTheory] → Type u → Nat → Type (max (max u u_2) 0)","name":["Chapter3","OrderedPair","noConfusionType","withCtorType"],"kind":"definition","isProp":false},{"valueReferences":[["instAddNat"],["HAdd","hAdd"],["SizeOf","sizeOf"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["instHAdd"],["instSizeOfDefault"],["Chapter3","SetTheory","Set","Tuple","rec"],["OfNat","ofNat"]],"typeReferences":[["Nat"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"]],"type":"{inst : Chapter3.SetTheory} → {n : Nat} → Chapter3.SetTheory.Set.Tuple n → Nat","name":["Chapter3","SetTheory","Set","Tuple","_sizeOf_1"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","OrderedPair","toObject"],["Chapter3","OrderedPair"],["Function","Embedding"],["Coe","mk"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["DFunLike","coe"]],"typeReferences":[["Chapter3","OrderedPair"],["Coe"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Coe Chapter3.OrderedPair inst.Object","name":["Chapter3","OrderedPair","inst_coeObject"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Equiv","mk"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","empty_iProd_equiv","_proof_1"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Unit"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Chapter3","SetTheory","Set","empty_iProd_equiv","_proof_2"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"],["Equiv"],["Unit"]],"type":"[inst : Chapter3.SetTheory] →\n  (X : Chapter3.SetTheory.Set.instEmpty.emptyCollection.toSubtype → inst.Set) →\n    Equiv (Chapter3.SetTheory.Set.iProd X).toSubtype Unit","name":["Chapter3","SetTheory","Set","empty_iProd_equiv"],"kind":"definition","isProp":false},{"valueReferences":[["instAddNat"],["instLTNat"],["instHAdd"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Lean","Grind","Nat","lt_eq"],["Nat"],["Iff","of_eq"],["instOfNatNat"],["Iff","mpr"],["LE","le"],["instLENat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["instHAdd"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["LE","le"],["Chapter3","SetTheory","objects_mem_sets"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (m : Nat),\n  instLENat.le (instHAdd.hAdd m 1) n → Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin n) m.cast","name":["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Bool"],["Chapter3","SetTheory","specify"],["Subtype"],["Equiv","instEquivLike"],["Eq","trans"],["Chapter3","SetTheory","Set","mem_Fin'"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Equiv"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["funext"],["EquivLike","toFunLike"],["HSub","hSub"],["Equiv","symm"],["Bool","true"],["Nat","Simproc","add_le_add_le"],["of_decide_eq_true"],["instLTNat"],["instHAdd"],["Nat","decLe"],["OfNat","ofNat"],["Eq","mpr_prop"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["instSubNat"],["Eq","refl"],["Chapter3","SetTheory","nat"],["LE","le"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instHSub"],["instLENat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["Equiv"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["instLTNat"],["Exists"],["instHAdd"],["Chapter3","SetTheory","Set","Fin_mk"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (val : inst.Object)\n  (property :\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLENat.le (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      val),\n  Exists fun m => Exists fun h => Eq ⟨val, ⋯⟩ (Chapter3.SetTheory.Set.Fin_mk (instHAdd.hAdd n 1) m h)","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_13"],"kind":"theorem","isProp":true},{"valueReferences":[["Function","Embedding","mk"],["Chapter3","SetTheory","Set","instInsert"],["Chapter3","OrderedPair","toObject'","_proof_1"],["Chapter3","OrderedPair"],["Singleton","singleton"],["Chapter3","OrderedPair","snd"],["Function","Embedding"],["Insert","insert"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","OrderedPair","fst"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSingleton"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","OrderedPair"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Function.Embedding Chapter3.OrderedPair inst.Object","name":["Chapter3","OrderedPair","toObject'"],"kind":"definition","isProp":false},{"valueReferences":[["SProd","mk"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","cartesian"]],"typeReferences":[["Chapter3","SetTheory","Set"],["SProd"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → SProd inst.Set inst.Set inst.Set","name":["Chapter3","SetTheory","Set","inst_SProd"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Set","replace"],["Function","Embedding"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory","Set","slice","_proof_1"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Object → inst.Set → inst.Set","name":["Chapter3","SetTheory","Set","slice"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","tuple_inj"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (x y : (i : I.toSubtype) → (X i).toSubtype),\n  Eq (Eq (Chapter3.SetTheory.Set.tuple x) (Chapter3.SetTheory.Set.tuple y)) (Eq x y)","name":["Chapter3","SetTheory","Set","tuple_inj","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Eq","trans"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["or_true"],["zero_ne_one","_simp_1"],["one_ne_zero","_simp_1"],["Or"],["Chapter3","SetTheory","Set","iProd"],["Nat","instCharZero"],["OfNat","zero_ne_ofNat","_simp_1"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Insert","insert"],["OfNat","ofNat_ne_one","_simp_1"],["Nat"],["or_self"],["Function","LeftInverse"],["instNatAtLeastTwo"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instAddMonoidWithOne"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["Nat","instNeZeroSucc"],["or_false"],["Nat","instOne"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["True"],["Chapter3","SetTheory","Set","instInsert"],["OfNat","one_ne_ofNat","_simp_1"],["OfNat","ofNat"],["eq_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["OfNat","ofNat_ne_zero","_simp_1"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Subtype","mk"]],"typeReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Singleton","singleton"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instInsert"],["Insert","insert"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_1"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_2"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_3"],["Nat"],["Chapter3","SetTheory","Set"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Name","num"]],"type":"∀ [inst : Chapter3.SetTheory]\n  (X :\n    (Chapter3.SetTheory.Set.instInsert.insert 0\n          (Chapter3.SetTheory.Set.instInsert.insert 1 (Chapter3.SetTheory.Set.instSingleton.singleton 2))).toSubtype →\n      inst.Set),\n  Function.LeftInverse sorry sorry","name":["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (x y : (i : I.toSubtype) → (X i).toSubtype),\n  Iff (Eq (Chapter3.SetTheory.Set.tuple x) (Chapter3.SetTheory.Set.tuple y)) (Eq x y)","name":["Chapter3","SetTheory","Set","tuple_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Lean","Name","str"],["Inter","inter"],["Bool","false"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","fst"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I J : inst.Set} (A : I.toSubtype → inst.Set) (B : J.toSubtype → inst.Set),\n  Eq (Chapter3.SetTheory.Set.instIntersection.inter (I.iUnion A) (J.iUnion B))\n    ((Chapter3.SetTheory.Set.inst_SProd.sprod I J).iUnion fun p =>\n      Chapter3.SetTheory.Set.instIntersection.inter (A (Chapter3.SetTheory.Set.fst p))\n        (B (Chapter3.SetTheory.Set.snd p)))","name":["Chapter3","SetTheory","Set","iUnion_inter_iUnion"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["SProd","sprod"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instUnion"],["SProd","sprod"],["Union","union"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.inst_SProd.sprod (Chapter3.SetTheory.Set.instUnion.union A B) C)\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.inst_SProd.sprod A C)\n      (Chapter3.SetTheory.Set.inst_SProd.sprod B C))","name":["Chapter3","SetTheory","Set","union_prod"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["instLTNat"],["Bool"],["Eq","trans"],["instHAdd"],["Nat","decLe"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Lean","Grind","Nat","lt_eq"],["Nat"],["instSubNat"],["Iff","of_eq"],["instOfNatNat"],["Eq","refl"],["Iff","mpr"],["LE","le"],["HSub","hSub"],["instHSub"],["Bool","true"],["Nat","Simproc","add_le_add_le"],["instLENat"],["of_decide_eq_true"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["instHAdd"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["LE","le"],["Chapter3","SetTheory","objects_mem_sets"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat),\n  instLENat.le m n → Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)) m.cast","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],"kind":"theorem","isProp":true},{"valueReferences":[["HEq","refl"],["Chapter3","OrderedPair"],["Chapter3","OrderedPair","snd"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Chapter3","OrderedPair","fst"],["Eq","casesOn"],["Eq","refl"],["HEq"],["Eq","symm"],["Chapter3","OrderedPair","ext","match_1"],["Eq"],["Eq","ndrec"]],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","OrderedPair","snd"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","OrderedPair","fst"],["Chapter3","SetTheory"]],"type":"∀ {inst : Chapter3.SetTheory} {x y : Chapter3.OrderedPair}, Eq x.fst y.fst → Eq x.snd y.snd → Eq x y","name":["Chapter3","OrderedPair","ext"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_2"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["eq_true"],["Chapter3","SetTheory","Object"],["Lean","Grind","intro_with_eq'"],["heq_of_eq"],["Classical","choose"],["Equiv"],["Subtype","noConfusion"],["NatCast","natCast"],["eq_of_heq"],["funext"],["Eq","symm"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_4"],["Eq","rec"],["Eq","ndrec"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["HEq","trans"],["True","intro"],["Lean","Grind","nestedProof"],["Nat"],["Iff","of_eq"],["eq_false"],["Iff","mpr"],["Eq","refl"],["Classical","byContradiction"],["Chapter3","SetTheory","nat"],["HEq"],["Chapter3","SetTheory","mem"],["Equiv","instEquivLike"],["Chapter3","SetTheory","specify"],["Subtype"],["Chapter3","SetTheory","Set","mem_Fin'"],["Eq","mp"],["Classical","choose","congr_simp"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_1"],["Lean","Grind","nestedProof_congr"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_3"],["DFunLike","coe"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["congr"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["propext"],["HEq","refl"],["True"],["instHAdd"],["OfNat","ofNat"],["Eq","mpr_prop"],["exists_prop_congr"],["LT","lt"],["HAdd","hAdd"],["Chapter3","SetTheory","Set"],["LE","le"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["Subtype","mk"],["Subtype","casesOn"],["instLENat"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["LT","lt"],["instLTNat"],["Nat"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {i j : (Chapter3.SetTheory.Set.Fin n).toSubtype}\n  (w : instLTNat.lt (Chapter3.SetTheory.Set.Fin.toNat i) n),\n  Eq i (Chapter3.SetTheory.Set.Fin_mk n (Chapter3.SetTheory.Set.Fin.toNat i) w) →\n    ∀ (w : instLTNat.lt (Chapter3.SetTheory.Set.Fin.toNat j) n),\n      Eq j (Chapter3.SetTheory.Set.Fin_mk n (Chapter3.SetTheory.Set.Fin.toNat j) w) →\n        Eq (Chapter3.SetTheory.Set.Fin.toNat i) (Chapter3.SetTheory.Set.Fin.toNat j) → Eq i j","name":["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["Chapter3","SetTheory","Object","ofnat_eq'''"],["Membership","mem"],["Bool","false"],["eq_true"],["eagerReduce"],["Chapter3","SetTheory","Object"],["heq_of_eq"],["Subtype","val"],["Equiv"],["Chapter3","SetTheory","Object","ofnat_eq"],["Lean","Grind","Nat","lo_le"],["Lean","Grind","Nat","unsat_le_lo"],["NatCast","natCast"],["eq_of_heq"],["Eq","symm"],["Eq","ndrec"],["Bool","true"],["FunLike"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Lean","Grind","rfl_true"],["Nat","Linear","Expr","var"],["Chapter3","SetTheory","Set","mem_Fin","_proof_1_6"],["Lean","Grind","nestedProof"],["Nat"],["Nat","Linear","Expr","num"],["Eq","refl"],["Chapter3","SetTheory","nat"],["Classical","byContradiction"],["HEq"],["id"],["Eq","mpr"],["Nat","cast"],["Bool"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","Set","mem_Fin","_proof_1_5"],["Eq","mp"],["Nat","Linear","ExprCnstr","mk"],["Lean","Grind","nestedProof_congr"],["Nat","Linear","ExprCnstr","eq_of_toNormPoly_eq"],["DFunLike","coe"],["congrArg"],["Chapter3","SetTheory","Set","instNatCast"],["Lean","RArray","leaf"],["Lean","Grind","Nat","lt_eq"],["Nat","not_le_eq"],["DFunLike","coe","hcongr_6"],["instOfNatNat"],["Lean","Grind","Nat","le_of_eq_1"],["EquivLike","toFunLike"],["Subtype","property"],["Equiv","symm"],["Lean","RArray","branch"],["Eq"],["cast"],["Not"],["True"],["HEq","refl"],["instHAdd"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","Set","toSubtype"],["Nat","Linear","Expr","add"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["Subtype","mk"],["instLENat"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat","cast"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["Subtype","val"],["Equiv"],["congrArg"],["Chapter3","SetTheory","Set","instNatCast"],["Chapter3","SetTheory","Object","ofnat_eq"],["Subtype","property"],["EquivLike","toFunLike"],["Eq","symm"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["LT","lt"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Subtype","mk"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (x : inst.Object) (m : Nat),\n  instLTNat.lt m n →\n    ∀ (h : Eq x m.cast), instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm ⟨x, ⋯⟩) n","name":["Chapter3","SetTheory","Set","mem_Fin","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Lean","Name"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["ExistsUnique"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","coe_of_fun"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["ExistsUnique"],["Chapter3","SetTheory","Set","coe_of_fun"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  ExistsUnique fun S =>\n    ∀ (F : inst.Object),\n      Iff (Chapter3.SetTheory.objects_mem_sets.mem S F) (Exists fun f => Eq (Chapter3.SetTheory.Set.coe_of_fun f) F)","name":["Chapter3","SetTheory","Set","powerset_axiom'"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["And"],["SProd","sprod"],["Function","comp"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["ExistsUnique"],["Lean","Name","num"],["Chapter3","SetTheory","Set","fst"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["ExistsUnique"],["Chapter3","SetTheory","Set","fst"],["Function","comp"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y Z : inst.Set} (f : Z.toSubtype → X.toSubtype) (g : Z.toSubtype → Y.toSubtype),\n  ExistsUnique fun h =>\n    And (Eq (Function.comp Chapter3.SetTheory.Set.fst h) f) (Eq (Function.comp Chapter3.SetTheory.Set.snd h) g)","name":["Chapter3","SetTheory","Set","direct_sum"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["True"],["Eq","mp"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["And"],["eq_true"],["Chapter3","SetTheory","Object"],["True","intro"],["Chapter3","OrderedPair","mk"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["eq_false"],["Classical","byContradiction"],["Eq","symm"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","casesOn"],["Eq"],["Function","instFunLikeEmbedding"],["And","casesOn"]],"typeReferences":[["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (Y : inst.Set) (x_1 : Y.toSubtype) (y y' : inst.Object),\n  And\n      ((fun y z => Eq z (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x, snd := y.val }))\n        x_1 y)\n      ((fun y z => Eq z (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x, snd := y.val }))\n        x_1 y') →\n    Eq y y'","name":["Chapter3","SetTheory","Set","slice","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","tuple","_proof_1"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","coe_of_fun"],["Subtype","mk"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  {I : inst.Set} → {X : I.toSubtype → inst.Set} → ((i : I.toSubtype) → (X i).toSubtype) → inst.Object","name":["Chapter3","SetTheory","Set","tuple"],"kind":"definition","isProp":false},{"valueReferences":[["And","intro"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","Tuple","noConfusion"],["Chapter3","SetTheory","Set","toSubtype"],["HEq"],["And"],["Eq"],["Chapter3","SetTheory","Set","Tuple","mk"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["HEq"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple","mk"],["Chapter3","SetTheory","Set","Tuple"]],"type":"∀ {inst : Chapter3.SetTheory} {n : Nat} {X : inst.Set} {x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype}\n  {surj : Function.Surjective x} {X_1 : inst.Set} {x_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype → X_1.toSubtype}\n  {surj_1 : Function.Surjective x_1},\n  Eq { X := X, x := x, surj := surj } { X := X_1, x := x_1, surj := surj_1 } → And (Eq X X_1) (HEq x x_1)","name":["Chapter3","SetTheory","Set","Tuple","mk","inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Nat","instNeZeroSucc"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["or_false"],["one_ne_zero","_simp_1"],["Nat","instOne"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","one_ne_ofNat","_simp_1"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 0\n      (Chapter3.SetTheory.Set.instInsert.insert 1 (Chapter3.SetTheory.Set.instSingleton.singleton 2)))\n    1","name":["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Chapter3","OrderedPair"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["Eq"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","OrderedPair"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (p : Chapter3.OrderedPair), Eq p p","name":["Chapter3","OrderedPair","refl"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Set","slice"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Subtype","val"],["DFunLike","coe"],["Chapter3","SetTheory","Set","mem_slice"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["propext"]],"typeReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Set","slice"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"]],"type":"∀ [inst : Chapter3.SetTheory] (x z : inst.Object) (Y : inst.Set),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.slice x Y) z)\n    (Exists fun y => Eq z (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x, snd := y.val }))","name":["Chapter3","SetTheory","Set","mem_slice","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instNeZeroSucc"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["one_ne_zero","_simp_1"],["Nat","instOne"],["Or"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["False"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)) 1","name":["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["LT","lt"],["Exists","casesOn"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat"],["Nat","cast"],["And"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Eq"],["And","casesOn"]],"typeReferences":[["LT","lt"],["And","intro"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat"],["Nat","cast"],["Exists"],["And"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (x : inst.Object)\n  (motive : (Exists fun m => And (instLTNat.lt m n) (Eq x m.cast)) → Prop)\n  (h : Exists fun m => And (instLTNat.lt m n) (Eq x m.cast)),\n  (∀ (m : Nat) (hm : instLTNat.lt m n) (h : Eq x m.cast), motive ⋯) → motive h","name":["Chapter3","SetTheory","Set","mem_Fin","match_1_3"],"kind":"definition","isProp":true},{"valueReferences":[["implies_congr"],["True"],["Eq","trans"],["Eq","mp"],["Set"],["Chapter3","SetTheory","Set","tuple_mem_iProd"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Set","mem_univ","_simp_1"],["Subtype","val"],["Set","instMembership"],["Set","univ"],["forall_const","_simp_1"],["Chapter3","SetTheory","Set"],["instNonemptyOfInhabited"],["Eq","refl"],["Subtype","property"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instInhabitedTrue"],["setOf"]],"typeReferences":[["Set"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory"],["Set","Elem"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_3"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (x : (Set.univ.pi fun i => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x).Elem),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.iProd X)\n    (Chapter3.SetTheory.Set.tuple fun i => ⟨x.val i, ⋯⟩)","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Chapter3","SetTheory","Object"],["Equiv"],["NatCast","natCast"],["funext"],["HSub","hSub"],["Eq","ndrec"],["Nat","Simproc","add_le_add_le"],["Bool","true"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["Nat"],["Iff","of_eq"],["Eq","refl"],["Iff","mpr"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","mem"],["Equiv","instEquivLike"],["Chapter3","SetTheory","specify"],["Subtype"],["Bool"],["Chapter3","SetTheory","Set","mem_Fin'"],["DFunLike","coe"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["propext"],["of_decide_eq_true"],["instHAdd"],["Nat","decLe"],["OfNat","ofNat"],["exists_prop_congr"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Chapter3","SetTheory","Set"],["instSubNat"],["LE","le"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instHSub"],["instLENat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["Equiv"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["NatCast","natCast"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["instHAdd"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (val : inst.Object)\n  (property :\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLENat.le (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      val),\n  Exists fun x => Exists fun h => Eq ⟨val, ⋯⟩ ⟨Chapter3.SetTheory.Object.instNatCast.natCast x, ⋯⟩","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],"kind":"theorem","isProp":true},{"valueReferences":[["HEq","refl"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","Tuple","ext"],["Chapter3","SetTheory","Object"],["Eq","casesOn"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple"],["Iff","intro"],["And","intro"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Eq","refl"],["Eq","symm"],["HEq"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","ndrec"],["Eq"],["Chapter3","SetTheory","Set","Tuple","x"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","Tuple","x"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {t t' : Chapter3.SetTheory.Set.Tuple n},\n  Iff (Eq t t')\n    (And (Eq t.X t'.X) (∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype), Eq (t.x n_1).val (t'.x n_1).val))","name":["Chapter3","SetTheory","Set","Tuple","ext_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["LT","lt"],["instLTNat"],["Nat"],["Exists"],["Chapter3","SetTheory","Set","mem_Fin'"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Exists","choose"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {n : Nat} → (Chapter3.SetTheory.Set.Fin n).toSubtype → Nat","name":["Chapter3","SetTheory","Set","Fin","toNat"],"kind":"definition","isProp":false},{"valueReferences":[["LT","lt"],["instLTNat"],["Nat"],["Eq","refl"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","ndrec"],["Eq"],["Eq","rec"]],"typeReferences":[["LT","lt"],["instLTNat"],["Nat"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","ndrec"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n m m_1 : Nat) (e_m : Eq m m_1) (h : instLTNat.lt m n),\n  Eq (Chapter3.SetTheory.Set.Fin_mk n m h) (Chapter3.SetTheory.Set.Fin_mk n m_1 ⋯)","name":["Chapter3","SetTheory","Set","Fin_mk","congr_simp"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Chapter3","SetTheory","Object","instNatCast"],["Chapter3","SetTheory","Set"],["Nat","cast"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Eq","symm"],["Chapter3","SetTheory","Set","Fin","coe_toNat"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (i : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n  Eq i.val (Chapter3.SetTheory.Set.Fin.toNat i).cast","name":["Chapter3","SetTheory","Set","finite_choice","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Unit"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"typeReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Unit"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"type":"∀ [inst : Chapter3.SetTheory] (X : Chapter3.SetTheory.Set.instEmpty.emptyCollection.toSubtype → inst.Set),\n  Function.RightInverse sorry sorry","name":["Chapter3","SetTheory","Set","empty_iProd_equiv","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","Tuple","casesOn"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple","x"],["Chapter3","SetTheory","Set","Tuple","mk"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Function","Surjective"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","Tuple","x"],["Chapter3","SetTheory","Set","Tuple","mk"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (X : inst.Set) (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype)\n  (surj : Function.Surjective x)\n  (motive :\n    (t' : Chapter3.SetTheory.Set.Tuple n) →\n      Eq { X := X, x := x, surj := surj }.X t'.X →\n        (∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n            Eq ({ X := X, x := x, surj := surj }.x n_1).val (t'.x n_1).val) →\n          Prop)\n  (t' : Chapter3.SetTheory.Set.Tuple n) (hX : Eq { X := X, x := x, surj := surj }.X t'.X)\n  (hx :\n    ∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype), Eq ({ X := X, x := x, surj := surj }.x n_1).val (t'.x n_1).val),\n  (∀ (X_1 : inst.Set) (x_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype → X_1.toSubtype)\n      (surj_1 : Function.Surjective x_1)\n      (hX : Eq { X := X, x := x, surj := surj }.X { X := X_1, x := x_1, surj := surj_1 }.X)\n      (hx :\n        ∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n          Eq ({ X := X, x := x, surj := surj }.x n_1).val ({ X := X_1, x := x_1, surj := surj_1 }.x n_1).val),\n      motive { X := X_1, x := x_1, surj := surj_1 } hX hx) →\n    motive t' hX hx","name":["Chapter3","SetTheory","Set","Tuple","ext","match_1_3"],"kind":"definition","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Eq","trans"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["SProd","sprod"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instNeZeroSucc"],["zero_ne_one","_simp_1"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["one_ne_zero","_simp_1"],["or_false"],["Nat","instOne"],["Chapter3","SetTheory","Set","iProd"],["Or"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Subtype","mk"]],"typeReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Singleton","singleton"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instInsert"],["Insert","insert"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_1"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Name","num"],["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_2"]],"type":"∀ [inst : Chapter3.SetTheory]\n  (X :\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype →\n      inst.Set),\n  Function.RightInverse sorry sorry","name":["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Subtype"],["Equiv","mk"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","iProd_equiv_tuples","_proof_2"],["Chapter3","SetTheory","Set","iProd_equiv_tuples","_proof_1"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","Tuple","x"]],"typeReferences":[["Subtype"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Equiv"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","Tuple","x"]],"type":"[inst : Chapter3.SetTheory] →\n  (n : Nat) →\n    (X : (Chapter3.SetTheory.Set.Fin n).toSubtype → inst.Set) →\n      Equiv (Chapter3.SetTheory.Set.iProd X).toSubtype\n        (Subtype fun t =>\n          ∀ (i : (Chapter3.SetTheory.Set.Fin n).toSubtype), Chapter3.SetTheory.objects_mem_sets.mem (X i) (t.x i).val)","name":["Chapter3","SetTheory","Set","iProd_equiv_tuples"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Eq","mp"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Object","natCast_inj"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","Fin","coe_toNat"],["Eq"],["propext"],["congrArg"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["LT","lt"],["instLTNat"],["Nat"],["Chapter3","SetTheory","Set","Fin_mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (m : Nat) (h : instLTNat.lt m n),\n  Eq (Chapter3.SetTheory.Set.Fin.toNat (Chapter3.SetTheory.Set.Fin_mk n m h)) m","name":["Chapter3","SetTheory","Set","Fin","toNat_mk"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set), Function.LeftInverse sorry sorry","name":["Chapter3","SetTheory","Set","prod_commutator","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Set","specification_axiom''"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["propext"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} (P : A.toSubtype → Prop) (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (A.specify P) x) (Exists fun h => P ⟨x, h⟩)","name":["Chapter3","SetTheory","Set","mem_iProd","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.inst_SProd.sprod (Chapter3.SetTheory.Set.instSDiff.sdiff A B) C)\n    (Chapter3.SetTheory.Set.instSDiff.sdiff (Chapter3.SetTheory.Set.inst_SProd.sprod A C)\n      (Chapter3.SetTheory.Set.inst_SProd.sprod B C))","name":["Chapter3","SetTheory","Set","diff_prod"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Equiv"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["funext"],["EquivLike","toFunLike"],["Equiv","symm"],["instLTNat"],["instHAdd"],["OfNat","ofNat"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","nat"],["LE","le"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","objects_mem_sets"],["instLENat"]],"typeReferences":[["instAddNat"],["instLTNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","specify"],["instHAdd"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Equiv"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["LE","le"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (val : inst.Object),\n  Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m =>\n        instLENat.le (instHAdd.hAdd (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) 1) n)\n      val →\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      val","name":["Chapter3","SetTheory","Set","Tuple","ext","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Eq","symm"],["Chapter3","SetTheory","Object","natCast_inj"],["Chapter3","SetTheory","Object"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat), Eq (Eq n m) (Eq n.cast m.cast)","name":["Chapter3","SetTheory","Set","Fin","coe_eq_iff","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Ring","toNonAssocRing"],["Bool","false"],["eq_true"],["AddGroupWithOne","toAddMonoidWithOne"],["heq_of_eq"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_3"],["Equiv"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_6"],["Int","instCommSemiring"],["Classical","choose","hcongr_3"],["NatCast","natCast"],["le_of_not_gt"],["Eq","symm"],["Int","instLTInt"],["Bool","true"],["NonAssocSemiring","toAddCommMonoidWithOne"],["Lean","Grind","forall_propagator"],["instLatticeInt"],["instLTNat"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_4"],["Exists"],["Lean","Grind","not_not"],["Ring","toSemiring"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_15"],["instOfNat"],["eq_false"],["AddMonoid","toAddSemigroup"],["Chapter3","SetTheory","nat"],["Mathlib","Meta","NormNum","isNat_lt_true"],["Int","negOfNat"],["Int","instCharZero"],["Chapter3","SetTheory","Set","mem_Fin'"],["Mathlib","Tactic","Ring","add_mul"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Lean","Grind","Nat","lt_eq"],["Subtype","property"],["EquivLike","toFunLike"],["Mathlib","Tactic","Ring","neg_one_mul"],["Int","instIsStrictOrderedRing"],["Equiv","symm"],["Eq"],["instNatCastInt"],["Mathlib","Tactic","Ring","neg_zero"],["Int","instIsOrderedAddMonoid"],["instOfNatAtLeastTwo"],["HPow","hPow"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["Monoid","toNatPow"],["instHSub"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Preorder","toLT"],["Lean","Grind","not_eq_prop"],["Semiring","toNonAssocSemiring"],["Subtype","noConfusion"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Or"],["Lean","Grind","forall_imp_eq_or"],["eq_of_heq"],["forall_congr"],["Int","instLEInt"],["Lean","Grind","not_eq_of_eq_true"],["AddGroup","toSubNegMonoid"],["Eq","rec"],["Int","ofNat"],["SemilatticeInf","toPartialOrder"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Ring","mul_zero"],["Lean","Grind","nestedProof"],["Exists","casesOn"],["Mathlib","Tactic","Linarith","mul_neg"],["Nat"],["AddMonoidWithOne","toNatCast"],["Mathlib","Tactic","Ring","atom_pf"],["Iff","of_eq"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Chapter3","SetTheory","mem"],["Eq","mp"],["Classical","choose","congr_simp"],["Chapter3","SetTheory","Set","instEmpty"],["DFunLike","coe"],["Lean","Grind","of_eq_eq_true"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["of_decide_eq_true"],["Not"],["Lean","Grind","em"],["instHAdd"],["Distrib","toMul"],["Mathlib","Tactic","Ring","cast_pos"],["Mathlib","Tactic","Ring","add_congr"],["Eq","mpr_prop"],["LT","lt"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["instSubNat"],["Mathlib","Tactic","Ring","neg_congr"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Chapter3","SetTheory","Set","coe_of_fun"],["Subtype","mk"],["NormedCommRing","toNonUnitalNormedCommRing"],["instAddNat"],["SubtractionMonoid","toSubNegZeroMonoid"],["Chapter3","SetTheory","Set","nat_equiv"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["Eq","trans"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Lean","Grind","intro_with_eq'"],["Subtype","val"],["Classical","choose"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_13"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_11"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["SubNegMonoid","toSub"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Eq","ndrec"],["Function","instFunLikeEmbedding"],["Mathlib","Tactic","Ring","sub_pf"],["Chapter3","SetTheory","Object","instNatCast"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Function","Embedding"],["Chapter3","SetTheory","replace"],["Eq","refl"],["Classical","byContradiction"],["AddMonoidWithOne","toOne"],["HEq"],["Nat","rawCast"],["Chapter3","SetTheory","set_to_object"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Chapter3","SetTheory","specify"],["Bool"],["SubtractionCommMonoid","toSubtractionMonoid"],["Lean","Grind","not_exists"],["EmptyCollection","emptyCollection"],["Int","instRing"],["Int","add_one_le_iff"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["or_false"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instAdd"],["Mathlib","Tactic","Ring","mul_add"],["propext"],["lt_of_not_ge"],["Distrib","toAdd"],["IsStrictOrderedRing","toIsOrderedRing"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","casesOn"],["neg_neg_of_pos"],["And","casesOn"],["Mathlib","Tactic","Ring","zero_mul"],["Nat","cast_one"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["Chapter3","SetTheory","Set","tuple","_proof_1"],["HMul","hMul"],["Chapter3","SetTheory","Object"],["Int","rawCast"],["AddMonoidWithOne","toAddMonoid"],["Chapter3","SetTheory","Set","iUnion","_proof_1"],["Mathlib","Meta","NormNum","isNat_add"],["Ring","toAddGroupWithOne"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_14"],["funext"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Nat","Simproc","add_le_add_le"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["instHPow"],["HEq","trans"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["Chapter3","SetTheory","Set","Fin_mk"],["And"],["True","intro"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_12"],["Lean","Grind","forall_or_forall"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Iff","mpr"],["id"],["instHMul"],["instNatAtLeastTwo"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","union"],["Mathlib","Tactic","Ring","neg_mul"],["Mathlib","Meta","NormNum","isInt_add"],["Lean","Grind","nestedProof_congr"],["SubNegZeroMonoid","toNegZeroClass"],["Chapter3","SetTheory","Set","Fin_embed","_proof_2"],["congrArg"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["MonoidWithZero","toMonoid"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["Chapter3","SetTheory","Set","inst_pow"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["HEq","refl"],["True"],["Lean","Grind","alreadyNorm"],["CommSemiring","toSemiring"],["Nat","decLe"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["exists_prop_congr"],["Or","casesOn"],["NegZeroClass","toNeg"],["Chapter3","SetTheory","Set"],["Int","instSemiring"],["LE","le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Lean","Grind","intro_with_eq"],["Int","instAddMonoid"],["instLENat"]],"typeReferences":[["instAddNat"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["SubtractionMonoid","toSubNegZeroMonoid"],["Ring","toNonAssocRing"],["Eq","trans"],["Bool","false"],["AddGroupWithOne","toAddMonoidWithOne"],["Subtype","val"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Int","instCommSemiring"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["le_of_not_gt"],["SubNegMonoid","toSub"],["Int","instLTInt"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["instLTNat"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Ring","toSemiring"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Eq","refl"],["Mathlib","Meta","NormNum","isNat_lt_true"],["AddMonoidWithOne","toOne"],["Int","negOfNat"],["Int","instCharZero"],["Nat","rawCast"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Bool"],["Mathlib","Tactic","Ring","add_mul"],["SubtractionCommMonoid","toSubtractionMonoid"],["EmptyCollection","emptyCollection"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Int","add_one_le_iff"],["Chapter3","SetTheory"],["Int","instRing"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instIsStrictOrderedRing"],["Int","instAdd"],["Mathlib","Tactic","Ring","neg_one_mul"],["Eq"],["Mathlib","Tactic","Ring","mul_add"],["lt_of_not_ge"],["instNatCastInt"],["Distrib","toAdd"],["Mathlib","Tactic","Ring","neg_zero"],["IsStrictOrderedRing","toIsOrderedRing"],["Int","instIsOrderedAddMonoid"],["instOfNatAtLeastTwo"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["HPow","hPow"],["OfNat","ofNat"],["Int"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["Monoid","toNatPow"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["Chapter3","SetTheory","objects_mem_sets"],["Ne"],["neg_neg_of_pos"],["instHSub"],["Nat","cast_one"],["Mathlib","Tactic","Ring","zero_mul"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Preorder","toLT"],["Chapter3","SetTheory","Object"],["HMul","hMul"],["Int","rawCast"],["AddMonoidWithOne","toAddMonoid"],["Mathlib","Meta","NormNum","isNat_add"],["Semiring","toNonAssocSemiring"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Chapter3","SetTheory","Set","iProd"],["Ring","toAddGroupWithOne"],["Int","instLEInt"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["AddGroup","toSubNegMonoid"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Int","ofNat"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["SemilatticeInf","toPartialOrder"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["Chapter3","SetTheory","Set","Fin_mk"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Ring","mul_zero"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Linarith","mul_neg"],["Nat"],["Mathlib","Tactic","Ring","atom_pf"],["AddMonoidWithOne","toNatCast"],["Iff","mpr"],["id"],["instHMul"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["instNatAtLeastTwo"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Chapter3","SetTheory","Set","Fin","toNat"],["Nat","cast"],["Eq","mp"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["Chapter3","SetTheory","Set","instEmpty"],["SubNegZeroMonoid","toNegZeroClass"],["congrArg"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["MonoidWithZero","toMonoid"],["Mathlib","Tactic","Ring","sub_congr"],["Zero","toOfNat0"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Not"],["Lattice","toSemilatticeInf"],["instHAdd"],["Distrib","toMul"],["CommSemiring","toSemiring"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Ring","cast_pos"],["Chapter3","SetTheory","Set","Fin_embed"],["Mathlib","Tactic","Ring","add_congr"],["LT","lt"],["Chapter3","SetTheory","Set"],["NegZeroClass","toNeg"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Int","instSemiring"],["Mathlib","Tactic","Ring","neg_congr"],["LE","le"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Chapter3","SetTheory","Set","toSubtype"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["instLENat"],["Int","instAddMonoid"],["NormedCommRing","toNonUnitalNormedCommRing"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat),\n  (∀ {X : (Chapter3.SetTheory.Set.Fin n).toSubtype → inst.Set},\n      (∀ (i : (Chapter3.SetTheory.Set.Fin n).toSubtype), Ne (X i) Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n        Ne (Chapter3.SetTheory.Set.iProd X) Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n    ∀ {X : (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)).toSubtype → inst.Set},\n      (∀ (i : (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)).toSubtype),\n          Ne (X i) Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n        (∀ (i : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n            Ne ((fun i => X (Chapter3.SetTheory.Set.Fin_embed n (instHAdd.hAdd n 1) ⋯ i)) i)\n              Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n          ∀\n            (x' :\n              (i : (Chapter3.SetTheory.Set.Fin n).toSubtype) →\n                ((fun i => X (Chapter3.SetTheory.Set.Fin_embed n (instHAdd.hAdd n 1) ⋯ i)) i).toSubtype)\n            (a : inst.Object),\n            Chapter3.SetTheory.objects_mem_sets.mem (X (Chapter3.SetTheory.Set.Fin_mk (instHAdd.hAdd n 1) n ⋯)) a →\n              ∀ (i : (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)).toSubtype),\n                Not (Eq (Chapter3.SetTheory.Set.Fin.toNat i) n) →\n                  ∀ (this : instLTNat.lt (Chapter3.SetTheory.Set.Fin.toNat i) n),\n                    Eq (X i)\n                        ((fun i => X (Chapter3.SetTheory.Set.Fin_embed n (instHAdd.hAdd n 1) ⋯ i))\n                          (Chapter3.SetTheory.Set.Fin_mk n (Chapter3.SetTheory.Set.Fin.toNat i) this)) →\n                      Chapter3.SetTheory.objects_mem_sets.mem (X i)\n                        (x' (Chapter3.SetTheory.Set.Fin_mk n (Chapter3.SetTheory.Set.Fin.toNat i) this)).val","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_17"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Nat","cast"],["Subtype"],["Eq","trans"],["Eq","mp"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin","coe_toNat"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Subtype","coe_eq_iff"],["Iff","intro"],["congrArg"],["Eq","symm"],["Eq"],["Eq","ndrec"],["propext"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["True"],["Exists","casesOn"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","Fin","coe_eq_iff","_simp_1_1"],["Subtype","mk"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Nat"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (i : (Chapter3.SetTheory.Set.Fin n).toSubtype) {j : Nat},\n  Iff (Eq i.val j.cast) (Eq (Chapter3.SetTheory.Set.Fin.toNat i) j)","name":["Chapter3","SetTheory","Set","Fin","coe_eq_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["EmbeddingLike","apply_eq_iff_eq"],["Eq"],["DFunLike","coe"],["propext"]],"typeReferences":[["FunLike"],["EmbeddingLike"],["Eq"],["DFunLike","coe"]],"type":"∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [inst : FunLike F α β] [i : EmbeddingLike F α β] (f : F) {x y : α},\n  Eq (Eq (inst.coe f x) (inst.coe f y)) (Eq x y)","name":["Chapter3","SetTheory","Set","pair_eq_fst_snd","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["DFunLike","coe"],["Chapter3","SetTheory","Set","mem_cartesian"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Subtype","property"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (z : (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype),\n  Exists fun x =>\n    Exists fun y =>\n      Eq z.val (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x.val, snd := y.val })","name":["Chapter3","SetTheory","Set","fst","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Tuple","_sizeOf_1"],["Chapter3","SetTheory","Set","Tuple"],["SizeOf","mk"]],"typeReferences":[["Nat"],["SizeOf"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"]],"type":"{inst : Chapter3.SetTheory} → (n : Nat) → SizeOf (Chapter3.SetTheory.Set.Tuple n)","name":["Chapter3","SetTheory","Set","Tuple","_sizeOf_inst"],"kind":"definition","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Lean","Name"],["Lean","Name","str"],["Chapter3","SetTheory","Set","Fin"],["Bool","false"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Nat"],["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Iff"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {X : (Chapter3.SetTheory.Set.Fin n).toSubtype → inst.Set},\n  Iff (Eq (Chapter3.SetTheory.Set.iProd X) Chapter3.SetTheory.Set.instEmpty.emptyCollection)\n    (Exists fun i => Eq (X i) Chapter3.SetTheory.Set.instEmpty.emptyCollection)","name":["Chapter3","SetTheory","Set","iProd_empty_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"typeReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"type":"∀ [inst : Chapter3.SetTheory] (i : inst.Object) (X : inst.Set), Function.LeftInverse sorry sorry","name":["Chapter3","SetTheory","Set","singleton_iProd_equiv","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin","coe_eq_iff"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (i : (Chapter3.SetTheory.Set.Fin n).toSubtype) {j : Nat},\n  Eq (Eq i.val j.cast) (Eq (Chapter3.SetTheory.Set.Fin.toNat i) j)","name":["Chapter3","SetTheory","Set","Fin","coe_eq_iff","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Equiv","mk"],["Lean","Name"],["Singleton","singleton"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instInsert"],["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_3"],["Insert","insert"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_1"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_4"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Name","num"],["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_2"]],"typeReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["SProd","sprod"],["Chapter3","SetTheory"],["Equiv"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instNeZeroSucc"],["zero_ne_one","_simp_1"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["one_ne_zero","_simp_1"],["or_false"],["Nat","instOne"],["Chapter3","SetTheory","Set","iProd"],["Or"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"type":"[inst : Chapter3.SetTheory] →\n  (X :\n      (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype →\n        inst.Set) →\n    Equiv (Chapter3.SetTheory.Set.iProd X).toSubtype\n      (Chapter3.SetTheory.Set.inst_SProd.sprod (X ⟨0, ⋯⟩) (X ⟨1, ⋯⟩)).toSubtype","name":["Chapter3","SetTheory","Set","iProd_equiv_prod"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_6"],["Equiv","mk"],["Prod","mk"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_3"],["Set","Elem"],["Prod","fst"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_8"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_1"],["Set","instSProd"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_2"],["Set"],["Prod","snd"],["Set","instMembership"],["Prod"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Set","fst"],["setOf"]],"typeReferences":[["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","SetTheory"],["Equiv"],["Set","Elem"],["Prod"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Set","instSProd"],["Chapter3","SetTheory","Set","inst_SProd"],["setOf"]],"type":"[inst : Chapter3.SetTheory] →\n  (X Y : inst.Set) →\n    Equiv (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) x).Elem\n      (Set.instSProd.sprod (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n          (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x)).Elem","name":["Chapter3","SetTheory","Set","prod_equiv_prod"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["SProd","sprod"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instUnion"],["SProd","sprod"],["Union","union"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.inst_SProd.sprod A (Chapter3.SetTheory.Set.instUnion.union B C))\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.inst_SProd.sprod A B)\n      (Chapter3.SetTheory.Set.inst_SProd.sprod A C))","name":["Chapter3","SetTheory","Set","prod_union"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Subtype","val_inj"],["Eq"],["Subtype","val"],["propext"]],"typeReferences":[["Subtype"],["Eq"],["Subtype","val"]],"type":"∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, Eq (Eq a.val b.val) (Eq a b)","name":["Chapter3","SetTheory","Set","snd_of_mk_cartesian","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.inst_SProd.sprod A (Chapter3.SetTheory.Set.instIntersection.inter B C))\n    (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.inst_SProd.sprod A B)\n      (Chapter3.SetTheory.Set.inst_SProd.sprod A C))","name":["Chapter3","SetTheory","Set","prod_inter"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat","cast"],["Exists"],["Chapter3","SetTheory","Set","Fin_embed","_proof_1"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","mem_Fin"],["Subtype","val"],["congrArg"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["Subtype","property"],["id"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Eq"],["propext"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["LE","le"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["instLENat"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n N : Nat),\n  instLENat.le n N →\n    ∀ (i : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n      Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin N) i.val","name":["Chapter3","SetTheory","Set","Fin_embed","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Subtype","val"],["Chapter3","SetTheory","Set","slice","_proof_1"]],"typeReferences":[["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Function","instFunLikeEmbedding"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set) (val : inst.Object)\n  (property : Chapter3.SetTheory.objects_mem_sets.mem X val) (x : Y.toSubtype) (y y' : inst.Object),\n  And\n      (Eq y\n        (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := ⟨val, property⟩.val, snd := x.val }))\n      (Eq y'\n        (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject\n          { fst := ⟨val, property⟩.val, snd := x.val })) →\n    Eq y y'","name":["Chapter3","SetTheory","Set","cartesian","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["True"],["congrArg"],["eq_self"],["Chapter3","SetTheory","Set","mk_cartesian"],["of_eq_true"],["Chapter3","SetTheory","Set","snd"],["congr"],["funext"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst_of_mk_cartesian"],["Chapter3","SetTheory","Set","fst"],["Eq"],["Chapter3","SetTheory","Set","snd_of_mk_cartesian"]],"typeReferences":[["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y Z : inst.Set} (x : X.toSubtype → Y.toSubtype → Z.toSubtype),\n  Eq\n    (fun x_1 x_2 =>\n      x (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.mk_cartesian x_1 x_2))\n        (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.mk_cartesian x_1 x_2)))\n    x","name":["Chapter3","SetTheory","Set","curry_equiv","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Eq","symm"],["Subtype","val_inj"],["Eq"],["Subtype","val"],["propext"]],"typeReferences":[["Subtype"],["Eq"],["Subtype","val"]],"type":"∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, Eq (Eq a b) (Eq a.val b.val)","name":["Chapter3","SetTheory","Set","mem_Fin'","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","replace"],["Chapter3","SetTheory","Set","cartesian","_proof_2"],["Function","Embedding"],["Membership","mem"],["Chapter3","SetTheory","union"],["Chapter3","SetTheory","Set","slice"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Subtype","val"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Set → inst.Set → inst.Set","name":["Chapter3","SetTheory","Set","cartesian"],"kind":"definition","isProp":false},{"valueReferences":[["Fin","val"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin","toNat_lt"],["Fin","isLt"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["LT","lt"],["instLTNat"],["Nat"],["Fin","val"],["Chapter3","SetTheory","Set","Fin_mk"],["Fin"],["Fin","isLt"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (m : Fin n),\n  instLTNat.lt (Chapter3.SetTheory.Set.Fin.toNat (Chapter3.SetTheory.Set.Fin_mk n m.val ⋯)) n","name":["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory","Set","mem_iProd"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Subtype","property"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (t : (Chapter3.SetTheory.Set.iProd X).toSubtype), Exists fun x => Eq t.val (Chapter3.SetTheory.Set.tuple x)","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Chapter3","SetTheory","Object"],["Classical","choose"],["Equiv"],["NatCast","natCast"],["funext"],["HSub","hSub"],["Eq","ndrec"],["Nat","Simproc","add_le_add_le"],["Bool","true"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["Lean","Grind","nestedProof"],["Nat"],["Iff","of_eq"],["Iff","mpr"],["Eq","refl"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","mem"],["Equiv","instEquivLike"],["Chapter3","SetTheory","specify"],["Subtype"],["Bool"],["Chapter3","SetTheory","Set","mem_Fin'"],["Classical","choose","congr_simp"],["DFunLike","coe"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["propext"],["of_decide_eq_true"],["instHAdd"],["Nat","decLe"],["OfNat","ofNat"],["exists_prop_congr"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Chapter3","SetTheory","Set"],["instSubNat"],["LE","le"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instHSub"],["instLENat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Nat","cast"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["Classical","choose"],["Equiv"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_13"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["NatCast","natCast"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["instHAdd"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_12"],["Lean","Grind","nestedProof"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (val : inst.Object)\n  (property :\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLENat.le (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      val),\n  instLENat.le (instHAdd.hAdd (Classical.choose ⋯) 1) n →\n    Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin n) (Classical.choose ⋯).cast","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_14"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Chapter3","OrderedPair"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["Eq"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","OrderedPair"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {p q r : Chapter3.OrderedPair}, Eq p q → Eq q r → Eq p r","name":["Chapter3","OrderedPair","trans"],"kind":"theorem","isProp":true},{"valueReferences":[["HEq","refl"],["Chapter3","SetTheory","Set","Fin"],["And"],["Function","Surjective"],["Eq","casesOn"],["Chapter3","SetTheory","Set","Tuple"],["Eq","propIntro"],["And","intro"],["Chapter3","SetTheory","Set"],["Eq","refl"],["eq_of_heq"],["Chapter3","SetTheory","Set","Tuple","noConfusion"],["Eq","symm"],["HEq"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","ndrec"],["Eq"],["HEq","casesOn"],["Chapter3","SetTheory","Set","Tuple","mk"],["And","casesOn"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["HEq"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple","mk"],["Chapter3","SetTheory","Set","Tuple"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (X : inst.Set) (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype)\n  (surj : Function.Surjective x) (X_1 : inst.Set) (x_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype → X_1.toSubtype)\n  (surj_1 : Function.Surjective x_1),\n  Eq (Eq { X := X, x := x, surj := surj } { X := X_1, x := x_1, surj := surj_1 }) (And (Eq X X_1) (HEq x x_1))","name":["Chapter3","SetTheory","Set","Tuple","mk","injEq"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.inst_SProd.sprod (Chapter3.SetTheory.Set.instIntersection.inter A B) C)\n    (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.inst_SProd.sprod A C)\n      (Chapter3.SetTheory.Set.inst_SProd.sprod B C))","name":["Chapter3","SetTheory","Set","inter_prod"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","fst","_proof_1"],["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Exists","choose"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {X Y : inst.Set} → (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype → X.toSubtype","name":["Chapter3","SetTheory","Set","fst"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["ExistsUnique"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","graph"]],"typeReferences":[["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","toSubtype"],["ExistsUnique"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","graph"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y G : inst.Set},\n  Chapter3.SetTheory.Set.instSubset.Subset G (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) →\n    (∀ (x : X.toSubtype),\n        ExistsUnique fun y =>\n          Chapter3.SetTheory.objects_mem_sets.mem G\n            (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x.val, snd := y.val })) →\n      ExistsUnique fun f => Eq G (Chapter3.SetTheory.Set.graph f)","name":["Chapter3","SetTheory","Set","is_graph"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Chapter3","SetTheory","Set","Fin","toNat_spec"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","symm"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Nat"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin","_proof_1"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (m : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n  Eq (Chapter3.SetTheory.Set.Fin_mk n (Chapter3.SetTheory.Set.Fin.toNat m) ⋯) m","name":["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Bool"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Equiv"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["funext"],["EquivLike","toFunLike"],["HSub","hSub"],["Equiv","symm"],["Bool","true"],["Nat","Simproc","add_le_add_le"],["of_decide_eq_true"],["instLTNat"],["instHAdd"],["Nat","decLe"],["OfNat","ofNat"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["instSubNat"],["Eq","refl"],["Chapter3","SetTheory","nat"],["LE","le"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","objects_mem_sets"],["instHSub"],["instLENat"]],"typeReferences":[["instAddNat"],["instLTNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Chapter3","SetTheory","specify"],["Subtype"],["instHAdd"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["OfNat","ofNat"],["Equiv"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["LE","le"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (val : inst.Object),\n  Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLENat.le (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      val →\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m =>\n        instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) (instHAdd.hAdd n 1))\n      val","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"]],"type":"[inst : Chapter3.SetTheory] →\n  {n : Nat} → (self : Chapter3.SetTheory.Set.Tuple n) → (Chapter3.SetTheory.Set.Fin n).toSubtype → self.X.toSubtype","name":["Chapter3","SetTheory","Set","Tuple","x"],"kind":"definition","isProp":false},{"valueReferences":[["Eq","trans"],["True"],["SProd","sprod"],["congrArg"],["eq_self"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","snd"],["congr"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","mk_cartesian_fst_snd_eq"],["Chapter3","SetTheory","Set","fst_of_mk_cartesian"],["Chapter3","SetTheory","Set","fst"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","snd_of_mk_cartesian"]],"typeReferences":[["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y Z : inst.Set)\n  (x : (Chapter3.SetTheory.Set.inst_SProd.sprod (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) Z).toSubtype),\n  Eq\n    (Chapter3.SetTheory.Set.mk_cartesian\n      (Chapter3.SetTheory.Set.mk_cartesian\n        (Chapter3.SetTheory.Set.fst\n          (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.fst x))\n            (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.fst x))\n              (Chapter3.SetTheory.Set.snd x))))\n        (Chapter3.SetTheory.Set.fst\n          (Chapter3.SetTheory.Set.snd\n            (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.fst x))\n              (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.fst x))\n                (Chapter3.SetTheory.Set.snd x))))))\n      (Chapter3.SetTheory.Set.snd\n        (Chapter3.SetTheory.Set.snd\n          (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.fst x))\n            (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.fst x))\n              (Chapter3.SetTheory.Set.snd x))))))\n    x","name":["Chapter3","SetTheory","Set","prod_associator","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Eq","trans"],["Chapter3","SetTheory","Set","tuple","_proof_1"],["Membership","mem"],["Exists","intro"],["Chapter3","SetTheory","Set","mem_iProd","match_1_2"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Iff","intro"],["congrArg"],["Chapter3","SetTheory","Set","powerset_axiom","_simp_1"],["Chapter3","SetTheory","Set","iProd"],["funext"],["exists_eq","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","inst_pow"],["propext"],["Chapter3","SetTheory","Set","coe_of_fun_inj","_simp_1"],["instHPow"],["Exists"],["True"],["Chapter3","SetTheory","Set","specify"],["Chapter3","SetTheory","Set","tuple"],["HPow","hPow"],["exists_prop_congr"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","mem_iProd","match_1_4"],["Iff","of_eq"],["Eq","refl"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Chapter3","SetTheory","Set","coe_of_fun"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Chapter3","SetTheory","Set","mem_iProd","_simp_1_1"],["Subtype","mk"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (t : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.iProd X) t)\n    (Exists fun x => Eq t (Chapter3.SetTheory.Set.tuple x))","name":["Chapter3","SetTheory","Set","mem_iProd"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (t : inst.Object)\n  (motive : (Exists fun x => Eq t (Chapter3.SetTheory.Set.tuple x)) → Prop)\n  (h : Exists fun x => Eq t (Chapter3.SetTheory.Set.tuple x)),\n  (∀ (x : (i : I.toSubtype) → (X i).toSubtype) (hx : Eq t (Chapter3.SetTheory.Set.tuple x)), motive ⋯) → motive h","name":["Chapter3","SetTheory","Set","mem_iProd","match_1_4"],"kind":"definition","isProp":true},{"valueReferences":[["Exists"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","mem_iProd"],["congrArg"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (x : (i : I.toSubtype) → (X i).toSubtype),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.iProd X) (Chapter3.SetTheory.Set.tuple x)","name":["Chapter3","SetTheory","Set","tuple_mem_iProd"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","Tuple","casesOn"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple","x"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Function","Surjective"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","Tuple","mk"],["Chapter3","SetTheory","Set","Tuple","x"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {t' : Chapter3.SetTheory.Set.Tuple n}\n  (motive :\n    (t : Chapter3.SetTheory.Set.Tuple n) →\n      Eq t.X t'.X → (∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype), Eq (t.x n_1).val (t'.x n_1).val) → Prop)\n  (t : Chapter3.SetTheory.Set.Tuple n) (hX : Eq t.X t'.X)\n  (hx : ∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype), Eq (t.x n_1).val (t'.x n_1).val),\n  (∀ (X : inst.Set) (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype) (surj : Function.Surjective x)\n      (hX : Eq { X := X, x := x, surj := surj }.X t'.X)\n      (hx :\n        ∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n          Eq ({ X := X, x := x, surj := surj }.x n_1).val (t'.x n_1).val),\n      motive { X := X, x := x, surj := surj } hX hx) →\n    motive t hX hx","name":["Chapter3","SetTheory","Set","Tuple","ext","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["instAddNat"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["SubtractionMonoid","toSubNegZeroMonoid"],["Ring","toNonAssocRing"],["Eq","trans"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["AddGroupWithOne","toAddMonoidWithOne"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Int","instCommSemiring"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["NatCast","natCast"],["SubNegMonoid","toSub"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Ring","toSemiring"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Eq","refl"],["AddMonoidWithOne","toOne"],["Int","negOfNat"],["Nat","rawCast"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["SubtractionCommMonoid","toSubtractionMonoid"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Int","instRing"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instIsStrictOrderedRing"],["Mathlib","Tactic","Ring","neg_one_mul"],["lt_of_not_ge"],["instNatCastInt"],["Distrib","toAdd"],["Mathlib","Tactic","Ring","neg_zero"],["IsStrictOrderedRing","toIsOrderedRing"],["Int","instIsOrderedAddMonoid"],["HPow","hPow"],["OfNat","ofNat"],["Int"],["Nat","cast_add"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["AddCommGroup","toDivisionAddCommMonoid"],["Monoid","toNatPow"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["neg_neg_of_pos"],["instHSub"],["Nat","cast_one"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Preorder","toLT"],["Int","rawCast"],["HMul","hMul"],["AddMonoidWithOne","toAddMonoid"],["Semiring","toNonAssocSemiring"],["Ring","toAddGroupWithOne"],["Int","instLEInt"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["AddGroup","toSubNegMonoid"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Int","ofNat"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["SemilatticeInf","toPartialOrder"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Nat"],["AddMonoidWithOne","toNatCast"],["Mathlib","Tactic","Ring","atom_pf"],["id"],["instHMul"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Eq","mp"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["SubNegZeroMonoid","toNegZeroClass"],["congrArg"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["MonoidWithZero","toMonoid"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["instHAdd"],["CommSemiring","toSemiring"],["Distrib","toMul"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["Mathlib","Tactic","Ring","cast_pos"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Ring","add_congr"],["LT","lt"],["NegZeroClass","toNeg"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["Int","instSemiring"],["Mathlib","Tactic","Ring","neg_congr"],["LE","le"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["instLENat"],["Int","instAddMonoid"],["NormedCommRing","toNonUnitalNormedCommRing"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["instHAdd"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)) n.cast","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Insert","insert"],["And"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["And"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {a b c : inst.Object},\n  Iff\n    (Eq (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b))\n      (Chapter3.SetTheory.Set.instSingleton.singleton c))\n    (And (Eq a c) (Eq b c))","name":["Chapter3","SetTheory","Set","pair_eq_singleton_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iProd_of_const_equiv","_proof_1"],["sorryAx"],["Lean","Name","anonymous"],["Equiv","mk"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","iProd_of_const_equiv","_proof_2"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"],["Equiv"]],"type":"[inst : Chapter3.SetTheory] →\n  (I X : inst.Set) → Equiv (Chapter3.SetTheory.Set.iProd fun i => X).toSubtype (I.toSubtype → X.toSubtype)","name":["Chapter3","SetTheory","Set","iProd_of_const_equiv"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C D : inst.Set),\n  Eq\n    (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.inst_SProd.sprod A B)\n      (Chapter3.SetTheory.Set.inst_SProd.sprod C D))\n    (Chapter3.SetTheory.Set.inst_SProd.sprod (Chapter3.SetTheory.Set.instIntersection.inter A C)\n      (Chapter3.SetTheory.Set.instIntersection.inter B D))","name":["Chapter3","SetTheory","Set","inter_of_prod"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair","rec"]],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  {motive : Chapter3.OrderedPair → Sort u} →\n    (t : Chapter3.OrderedPair) → ((fst snd : inst.Object) → motive { fst := fst, snd := snd }) → motive t","name":["Chapter3","OrderedPair","casesOn"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Nat"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","Fin","coe_inj"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Nat"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {i j : (Chapter3.SetTheory.Set.Fin n).toSubtype},\n  Eq (Eq i j) (Eq (Chapter3.SetTheory.Set.Fin.toNat i) (Chapter3.SetTheory.Set.Fin.toNat j))","name":["Chapter3","SetTheory","Set","Fin","coe_inj","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Subtype"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set","instNatCast"],["Chapter3","SetTheory","Object","ofnat_eq"],["Chapter3","SetTheory","Set"],["NatCast","natCast"],["Subtype","property"],["Chapter3","SetTheory","nat"],["Eq","symm"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Chapter3","SetTheory","Set"],["NatCast","natCast"],["Chapter3","SetTheory","nat"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (m : Nat),\n  Eq x (Chapter3.SetTheory.Object.instNatCast.natCast m) → Chapter3.SetTheory.objects_mem_sets.mem inst.nat x","name":["Chapter3","SetTheory","Set","mem_Fin","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Eq","trans"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["SProd","sprod"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instNeZeroSucc"],["zero_ne_one","_simp_1"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["one_ne_zero","_simp_1"],["or_false"],["Nat","instOne"],["Chapter3","SetTheory","Set","iProd"],["Or"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["Chapter3","SetTheory","Set","toSubtype"],["Function","LeftInverse"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Subtype","mk"]],"typeReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Singleton","singleton"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instInsert"],["Insert","insert"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_1"],["Nat"],["Chapter3","SetTheory","Set"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Name","num"],["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_2"]],"type":"∀ [inst : Chapter3.SetTheory]\n  (X :\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype →\n      inst.Set),\n  Function.LeftInverse sorry sorry","name":["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Subtype"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","Tuple"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","Tuple","x"]],"typeReferences":[["Lean","Name","anonymous"],["sorryAx"],["Subtype"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","Tuple"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","Tuple","x"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (X : (Chapter3.SetTheory.Set.Fin n).toSubtype → inst.Set),\n  Function.RightInverse sorry sorry","name":["Chapter3","SetTheory","Set","iProd_equiv_tuples","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["imp_self","_simp_1"],["Eq","trans"],["Eq","mp"],["Chapter3","SetTheory","Set","tuple_mem_iProd"],["Set","pi"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory","Set","iProd"],["Subtype","coe_prop","_simp_1"],["forall_congr"],["Subtype","property"],["Eq"],["Exists"],["Set","mem_pi","_simp_1"],["True"],["Set"],["Chapter3","SetTheory","Set","tuple"],["Set","mem_univ","_simp_1"],["Exists","choose"],["Chapter3","SetTheory","Set","mem_iProd"],["Set","instMembership"],["Set","univ"],["implies_true"],["forall_const","_simp_1"],["Chapter3","SetTheory","Set"],["of_eq_true"],["instNonemptyOfInhabited"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instInhabitedTrue"],["setOf"]],"typeReferences":[["Set"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Exists","choose"],["Chapter3","SetTheory"],["Subtype","val"],["Set","Elem"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_4"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_3"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_8"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (x : (Set.univ.pi fun i => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x).Elem),\n  Set.instMembership.mem (Set.univ.pi fun i => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x) fun i =>\n    (⋯.choose i).val","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair","eq"],["Chapter3","OrderedPair"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Eq"],["propext"]],"typeReferences":[["Chapter3","OrderedPair"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x y x' y' : inst.Object),\n  Eq (Eq { fst := x, snd := y } { fst := x', snd := y' }) (And (Eq x x') (Eq y y'))","name":["Chapter3","OrderedPair","eq","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Eq","mp"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","mk","injEq"],["Function","instEmbeddingLikeEmbedding"],["Chapter3","SetTheory","Set","mem_cartesian"],["congrArg"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set","snd"],["congr"],["Subtype","property"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"],["Exists"],["True"],["Exists","choose_spec"],["Chapter3","OrderedPair"],["Function","Embedding"],["And"],["Chapter3","OrderedPair","mk"],["Exists","choose"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Exists","casesOn"],["eq_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["id"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["exists_comm"]],"typeReferences":[["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (z : (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype),\n  Eq z.val\n    (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject\n      { fst := (Chapter3.SetTheory.Set.fst z).val, snd := (Chapter3.SetTheory.Set.snd z).val })","name":["Chapter3","SetTheory","Set","pair_eq_fst_snd"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["And"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Lean","Name","num"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["And"],["Chapter3","SetTheory","Set","instEmpty"],["Ne"],["SProd","sprod"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A B C D : inst.Set},\n  Ne A Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n    Ne B Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n      Ne C Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n        Ne D Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n          Iff\n            (Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.inst_SProd.sprod A B)\n              (Chapter3.SetTheory.Set.inst_SProd.sprod C D))\n            (And (Chapter3.SetTheory.Set.instSubset.Subset A C) (Chapter3.SetTheory.Set.instSubset.Subset B D))","name":["Chapter3","SetTheory","Set","prod_subset_prod"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Lean","Name","num"],["Eq"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} {a b c : (i : I.toSubtype) → (X i).toSubtype},\n  Eq (Chapter3.SetTheory.Set.tuple a) (Chapter3.SetTheory.Set.tuple b) →\n    Eq (Chapter3.SetTheory.Set.tuple b) (Chapter3.SetTheory.Set.tuple c) →\n      Eq (Chapter3.SetTheory.Set.tuple a) (Chapter3.SetTheory.Set.tuple c)","name":["Chapter3","SetTheory","Set","tuple_trans"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["imp_self","_simp_1"],["Eq","trans"],["Eq","mp"],["Set","pi"],["Chapter3","SetTheory","Set","tuple_mem_iProd"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory","Set","iProd"],["Subtype","coe_prop","_simp_1"],["forall_congr"],["Subtype","property"],["Eq"],["Exists"],["True"],["Set","mem_pi","_simp_1"],["Set"],["Chapter3","SetTheory","Set","tuple"],["Set","mem_univ","_simp_1"],["Exists","choose"],["Chapter3","SetTheory","Set","mem_iProd"],["Set","instMembership"],["Set","univ"],["implies_true"],["forall_const","_simp_1"],["Chapter3","SetTheory","Set"],["of_eq_true"],["instNonemptyOfInhabited"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instInhabitedTrue"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_1"],["Set"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_2"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_5"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Exists","choose"],["Chapter3","SetTheory"],["Subtype","val"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (t : (Chapter3.SetTheory.Set.iProd X).toSubtype),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.iProd X)\n    (Chapter3.SetTheory.Set.tuple fun i => ⟨⟨fun i => (⋯.choose i).val, ⋯⟩.val i, ⋯⟩)","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_6"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Eq","trans"],["Chapter3","SetTheory","Set","mem_Fin'"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_2"],["Membership","mem"],["Classical","choose","congr_simp"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_1"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_3"],["Classical","choose"],["DFunLike","coe"],["Equiv"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["NatCast","natCast"],["funext"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Eq","ndrec"],["propext"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["instHAdd"],["Lean","Grind","nestedProof"],["OfNat","ofNat"],["exists_prop_congr"],["Eq","mpr_prop"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["Iff","of_eq"],["Eq","refl"],["Iff","mpr"],["Chapter3","SetTheory","nat"],["LE","le"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Chapter3","SetTheory","specify"],["Subtype"],["Equiv","instEquivLike"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_2"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_1"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_3"],["Chapter3","SetTheory"],["DFunLike","coe"],["Classical","choose"],["Equiv"],["NatCast","natCast"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["instHAdd"],["Lean","Grind","nestedProof"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (val : inst.Object)\n  (property :\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m =>\n        instLENat.le (instHAdd.hAdd (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) 1) n)\n      val),\n  instLENat.le (instHAdd.hAdd (Classical.choose ⋯) 1) n →\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      (Chapter3.SetTheory.Object.instNatCast.natCast (Classical.choose ⋯))","name":["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","replace"],["Chapter3","SetTheory","Set","cartesian","_proof_2"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Set","slice"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Subtype","val"],["DFunLike","coe"],["Exists","casesOn"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"],["And","casesOn"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set","replace"],["Chapter3","SetTheory","Set","cartesian","_proof_2"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Set","slice"],["And"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["And","intro"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (z : inst.Object) (X Y : inst.Set)\n  (motive :\n    (Exists fun S =>\n        And (Chapter3.SetTheory.objects_mem_sets.mem S z)\n          (Chapter3.SetTheory.objects_mem_sets.mem (X.replace ⋯)\n            (Function.instFunLikeEmbedding.coe inst.set_to_object S))) →\n      Prop)\n  (h :\n    Exists fun S =>\n      And (Chapter3.SetTheory.objects_mem_sets.mem S z)\n        (Chapter3.SetTheory.objects_mem_sets.mem (X.replace ⋯)\n          (Function.instFunLikeEmbedding.coe inst.set_to_object S))),\n  (∀ (S : inst.Set) (hz : Chapter3.SetTheory.objects_mem_sets.mem S z)\n      (hS :\n        Chapter3.SetTheory.objects_mem_sets.mem (X.replace ⋯) (Function.instFunLikeEmbedding.coe inst.set_to_object S)),\n      motive ⋯) →\n    motive h","name":["Chapter3","SetTheory","Set","mem_cartesian","match_1_2"],"kind":"definition","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Chapter3","OrderedPair"],["Lean","Name"],["Iff"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["Eq"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","OrderedPair"],["Iff"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (p q : Chapter3.OrderedPair), Iff (Eq p q) (Eq q p)","name":["Chapter3","OrderedPair","symm"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair","casesOn"],["Chapter3","SetTheory","Object"],["PULift","up"],["Chapter3","OrderedPair","noConfusionType","withCtor"],["Eq"]],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Sort u → Chapter3.OrderedPair → Chapter3.OrderedPair → Sort u","name":["Chapter3","OrderedPair","noConfusionType"],"kind":"definition","isProp":false},{"valueReferences":null,"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  {motive : Chapter3.OrderedPair → Sort u} →\n    ((fst snd : inst.Object) → motive { fst := fst, snd := snd }) → (t : Chapter3.OrderedPair) → motive t","name":["Chapter3","OrderedPair","rec"],"kind":"recursor","isProp":false},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","recursion"],["Chapter3","SetTheory","Set","nat_equiv"],["Lean","Name","anonymous"],["sorryAx"],["Nat","cast"],["Equiv","instEquivLike"],["Eq","trans"],["Lean","Name"],["existsUnique_of_exists_of_unique"],["Lean","Name","str"],["Bool","false"],["Exists","intro"],["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe'"],["DFunLike","coe"],["Equiv"],["congrArg"],["Chapter3","SetTheory","Set","instNatCast"],["And","intro"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","instOfNat"],["Equiv","symm"],["Eq"],["Eq","ndrec"],["True"],["instHAdd"],["Nat","recAux"],["And"],["Function","Bijective"],["Function","Surjective"],["OfNat","ofNat"],["HAdd","hAdd"],["Exists","casesOn"],["eq_self"],["Nat"],["Chapter3","Nat"],["of_eq_true"],["Eq","refl"],["Iff"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["ExistsUnique"],["Lean","Name","num"],["Function","Injective"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Nat","cast"],["Equiv","instEquivLike"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["Chapter3","SetTheory","Set","instNatCast"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","instOfNat"],["Equiv","symm"],["Eq"],["instHAdd"],["And"],["Function","Bijective"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["Iff"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["ExistsUnique"],["Ne"]],"type":"∀ [inst : Chapter3.SetTheory] (nat' : inst.Set) (zero : nat'.toSubtype) (succ : nat'.toSubtype → nat'.toSubtype),\n  (∀ (n : nat'.toSubtype), Ne (succ n) zero) →\n    (∀ (n m : nat'.toSubtype), Ne n m → Ne (succ n) (succ m)) →\n      (∀ (P : nat'.toSubtype → Prop),\n          P zero → (∀ (n : nat'.toSubtype), P n → P (succ n)) → ∀ (n : nat'.toSubtype), P n) →\n        ExistsUnique fun f =>\n          And (Function.Bijective f)\n            (And (Eq (f 0) zero)\n              (∀ (n : inst.nat.toSubtype) (n' : nat'.toSubtype),\n                Iff (Eq (f n) n')\n                  (Eq (f (instHAdd.hAdd (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm n) 1).cast)\n                    (succ n'))))","name":["Chapter3","SetTheory","Set","nat_unique"],"kind":"theorem","isProp":true},{"valueReferences":[["instHPow"],["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["HPow","hPow"],["Subtype","val"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","inst_pow"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {I : inst.Set} → (I.toSubtype → inst.Set) → inst.Set","name":["Chapter3","SetTheory","Set","iProd"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Decidable"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["SProd","sprod"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Decidable"],["Chapter3","SetTheory","Set","instUnion"],["SProd","sprod"],["Union","union"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  Decidable\n    (∀ (A B C D : inst.Set),\n      Eq\n        (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.inst_SProd.sprod A B)\n          (Chapter3.SetTheory.Set.inst_SProd.sprod C D))\n        (Chapter3.SetTheory.Set.inst_SProd.sprod (Chapter3.SetTheory.Set.instUnion.union A C)\n          (Chapter3.SetTheory.Set.instUnion.union B D)))","name":["Chapter3","SetTheory","Set","union_of_prod"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["PULift"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Function","Surjective"]],"typeReferences":[["Nat"],["Chapter3","SetTheory"]],"type":"[Chapter3.SetTheory] → Nat → Type u → Nat → Type (max (max (max u u_1) u_2) (max u u_1 u_2) 0)","name":["Chapter3","SetTheory","Set","Tuple","noConfusionType","withCtorType"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Nat"],["Chapter3","SetTheory","Set","Fin"],["CoeOut","mk"],["Chapter3","SetTheory","Set","toSubtype"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["CoeOut"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {n : Nat} → CoeOut (Chapter3.SetTheory.Set.Fin n).toSubtype Nat","name":["Chapter3","SetTheory","Set","Fin","inst_coeNat"],"kind":"definition","isProp":false},{"valueReferences":[["Subtype"],["Subtype","val_inj"],["Eq"],["Subtype","val"],["propext"]],"typeReferences":[["Subtype"],["Eq"],["Subtype","val"]],"type":"∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, Eq (Eq a.val b.val) (Eq a b)","name":["Chapter3","SetTheory","Set","fst_of_mk_cartesian","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["imp_self","_simp_1"],["Eq","trans"],["Set","pi"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory","Set","iProd"],["Subtype","coe_prop","_simp_1"],["Subtype","property"],["forall_congr"],["Eq"],["Exists"],["True"],["Set","mem_pi","_simp_1"],["Set"],["Chapter3","SetTheory","Set","tuple"],["Set","mem_univ","_simp_1"],["Exists","choose"],["Chapter3","SetTheory","Set","mem_iProd"],["Set","instMembership"],["Set","univ"],["implies_true"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_1"],["Set"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Exists","choose"],["Chapter3","SetTheory"],["Subtype","val"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (t : (Chapter3.SetTheory.Set.iProd X).toSubtype),\n  Set.instMembership.mem (Set.univ.pi fun i => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x) fun i =>\n    (⋯.choose i).val","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","mk","injEq"],["Function","instEmbeddingLikeEmbedding"],["Chapter3","SetTheory","Set","mem_cartesian"],["congrArg"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set","fst_of_mk_cartesian","_simp_1_2"],["congr"],["Subtype","property"],["Eq","symm"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"],["And","left"],["Exists"],["Exists","choose_spec"],["Chapter3","OrderedPair"],["Chapter3","SetTheory","Set","mk_cartesian","_proof_1"],["Function","Embedding"],["And"],["Chapter3","OrderedPair","mk"],["Exists","choose"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Exists","casesOn"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Set","fst"]],"typeReferences":[["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (x : X.toSubtype) (y : Y.toSubtype),\n  Eq (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.mk_cartesian x y)) x","name":["Chapter3","SetTheory","Set","fst_of_mk_cartesian"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Tuple","mk"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"]],"type":"[inst : Chapter3.SetTheory] →\n  {n : Nat} →\n    (X : inst.Set) →\n      (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype) →\n        Function.Surjective x → Chapter3.SetTheory.Set.Tuple n","name":["Chapter3","SetTheory","Set","Tuple","mk","_flat_ctor"],"kind":"definition","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Chapter3","OrderedPair"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Chapter3","OrderedPair","snd"],["Function","Embedding"],["Insert","insert"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","OrderedPair","fst"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Lean","Name","num"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"],["Function","Injective"]],"typeReferences":[["Chapter3","SetTheory","Set","instInsert"],["Chapter3","OrderedPair"],["Singleton","singleton"],["Chapter3","OrderedPair","snd"],["Function","Embedding"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","fst"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSingleton"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"],["Function","Injective"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Function.Injective fun p =>\n    Function.instFunLikeEmbedding.coe inst.set_to_object\n      (Chapter3.SetTheory.Set.instInsert.insert p.fst\n        (Chapter3.SetTheory.Set.instSingleton.singleton\n          (Function.instFunLikeEmbedding.coe inst.set_to_object\n            (Chapter3.SetTheory.Set.instInsert.insert p.fst (Chapter3.SetTheory.Set.instSingleton.singleton p.snd)))))","name":["Chapter3","OrderedPair","toObject'","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Decidable"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Decidable"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  Decidable\n    (∀ (A B C D : inst.Set),\n      Eq\n        (Chapter3.SetTheory.Set.instSDiff.sdiff (Chapter3.SetTheory.Set.inst_SProd.sprod A B)\n          (Chapter3.SetTheory.Set.inst_SProd.sprod C D))\n        (Chapter3.SetTheory.Set.inst_SProd.sprod (Chapter3.SetTheory.Set.instSDiff.sdiff A C)\n          (Chapter3.SetTheory.Set.instSDiff.sdiff B D)))","name":["Chapter3","SetTheory","Set","diff_of_prod"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","graph"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","graph"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f f' : X.toSubtype → Y.toSubtype),\n  Iff (Eq (Chapter3.SetTheory.Set.graph f) (Chapter3.SetTheory.Set.graph f')) (Eq f f')","name":["Chapter3","SetTheory","Set","graph_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Eq","trans"],["Eq","mp"],["Chapter3","SetTheory","Set","tuple_mem_iProd"],["Set","pi"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory","Set","iProd"],["Subtype","property"],["Eq"],["Exists"],["True"],["Set"],["Chapter3","SetTheory","Set","tuple"],["Set","mem_univ","_simp_1"],["Chapter3","SetTheory","Set","mem_iProd"],["Set","instMembership"],["Set","univ"],["forall_const","_simp_1"],["Chapter3","SetTheory","Set"],["instNonemptyOfInhabited"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["setOf"],["instInhabitedTrue"]],"typeReferences":[["Exists"],["Set"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Set","Elem"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_4"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_3"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (x : (Set.univ.pi fun i => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x).Elem),\n  Exists fun x_1 => Eq ⟨Chapter3.SetTheory.Set.tuple fun i => ⟨x.val i, ⋯⟩, ⋯⟩.val (Chapter3.SetTheory.Set.tuple x_1)","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_8"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Membership","mem"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set"],["Subtype","property"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","mem_iUnion"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (x : (i : I.toSubtype) → (X i).toSubtype)\n  (i : I.toSubtype), Chapter3.SetTheory.objects_mem_sets.mem (I.iUnion X) (x i).val","name":["Chapter3","SetTheory","Set","tuple","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["instLTNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Chapter3","SetTheory","Set","specify"],["DFunLike","coe"],["Equiv"],["LT","lt"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Nat → inst.Set","name":["Chapter3","SetTheory","Set","Fin"],"kind":"definition","isProp":false},{"valueReferences":null,"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple","mk"],["Chapter3","SetTheory","Set","Tuple"]],"type":"[inst : Chapter3.SetTheory] →\n  {n : Nat} →\n    {motive : Chapter3.SetTheory.Set.Tuple n → Sort u} →\n      ((X : inst.Set) →\n          (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype) →\n            (surj : Function.Surjective x) → motive { X := X, x := x, surj := surj }) →\n        (t : Chapter3.SetTheory.Set.Tuple n) → motive t","name":["Chapter3","SetTheory","Set","Tuple","rec"],"kind":"recursor","isProp":false},{"valueReferences":[["Eq","trans"],["Prod","mk"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["Prod","fst"],["congrArg"],["Subtype","prop"],["Chapter3","SetTheory","Set","snd"],["Subtype","coe_prop","_simp_1"],["Set","mem_prod","_simp_1"],["congr"],["Set","instSProd"],["True"],["Set"],["And","right"],["And"],["Prod","snd"],["Set","instMembership"],["Prod"],["and_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Set","fst"],["setOf"]],"typeReferences":[["Prod","mk"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Prod","snd"],["Chapter3","SetTheory"],["Subtype","val"],["Set","Elem"],["Set","instMembership"],["Prod"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_1"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Subtype","mk"],["Set","instSProd"],["Chapter3","SetTheory","Set","inst_SProd"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set)\n  (x : (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) x).Elem),\n  Set.instMembership.mem (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x)\n    ⟨{ fst := (Chapter3.SetTheory.Set.fst x).val, snd := (Chapter3.SetTheory.Set.snd x).val }, ⋯⟩.val.snd","name":["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_5"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["imp_self","_simp_1"],["Eq","trans"],["Eq","mp"],["Set","pi"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory","Set","iProd"],["Subtype","coe_prop","_simp_1"],["Subtype","property"],["forall_congr"],["Eq"],["Exists"],["True"],["Set","mem_pi","_simp_1"],["Set"],["Chapter3","SetTheory","Set","tuple"],["Set","mem_univ","_simp_1"],["Exists","choose"],["Chapter3","SetTheory","Set","mem_iProd"],["Set","instMembership"],["Set","univ"],["implies_true"],["forall_const","_simp_1"],["Chapter3","SetTheory","Set"],["of_eq_true"],["instNonemptyOfInhabited"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instInhabitedTrue"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_1"],["Set"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_2"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Exists","choose"],["Chapter3","SetTheory"],["Subtype","val"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (t : (Chapter3.SetTheory.Set.iProd X).toSubtype) (i : I.toSubtype),\n  Chapter3.SetTheory.objects_mem_sets.mem (X i) (⟨fun i => (⋯.choose i).val, ⋯⟩.val i)","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nonempty_of_inhabited"],["Ring","toNonAssocRing"],["Bool","false"],["AddGroupWithOne","toAddMonoidWithOne"],["Int","instCommSemiring"],["le_of_not_gt"],["Subtype","coe_eta"],["Int","instLTInt"],["Nat","lt_succ_iff"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["instLTNat"],["Exists"],["Chapter3","SetTheory","Set","mem_iProd"],["Ring","toSemiring"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_17"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Mathlib","Meta","NormNum","isNat_lt_true"],["Int","negOfNat"],["Int","instCharZero"],["Eq","mpr"],["Mathlib","Tactic","Ring","add_mul"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Subtype","property"],["Mathlib","Tactic","Ring","neg_one_mul"],["Int","instIsStrictOrderedRing"],["Chapter3","SetTheory","Set","nonempty_def"],["Chapter3","SetTheory","Set","finite_choice","_simp_1_2"],["Eq"],["instNatCastInt"],["Mathlib","Tactic","Ring","neg_zero"],["Int","instIsOrderedAddMonoid"],["instOfNatAtLeastTwo"],["HPow","hPow"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["eq_self"],["Monoid","toNatPow"],["Ne"],["instHSub"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Preorder","toLT"],["Semiring","toNonAssocSemiring"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Int","instLEInt"],["AddGroup","toSubNegMonoid"],["Int","ofNat"],["Eq","rec"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_1"],["SemilatticeInf","toPartialOrder"],["Nat","instPartialOrder"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Chapter3","SetTheory","Set","tuple"],["Mathlib","Tactic","Ring","mul_zero"],["Subtype","ext"],["Chapter3","SetTheory","Set","Fin","toNat_lt"],["Mathlib","Tactic","Linarith","mul_neg"],["Exists","casesOn"],["Nat"],["AddMonoidWithOne","toNatCast"],["Mathlib","Tactic","Ring","atom_pf"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Nat","cast"],["Eq","mp"],["Chapter3","SetTheory","Set","tuple_mem_iProd"],["Chapter3","SetTheory","Set","instEmpty"],["lt_of_le_of_ne"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Not"],["instHAdd"],["Distrib","toMul"],["Mathlib","Tactic","Ring","cast_pos"],["Chapter3","SetTheory","Set","Fin_embed"],["Mathlib","Tactic","Ring","add_congr"],["LT","lt"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["of_eq_true"],["Mathlib","Tactic","Ring","neg_congr"],["Nat","succ"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Chapter3","SetTheory","Set","toSubtype"],["Subtype","mk"],["NormedCommRing","toNonUnitalNormedCommRing"],["Classical","choose_spec"],["instAddNat"],["SubtractionMonoid","toSubNegZeroMonoid"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["Eq","trans"],["Exists","intro"],["Classical","choose"],["Subtype","val"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["False","elim"],["SubNegMonoid","toSub"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["Eq","ndrec"],["Chapter3","SetTheory","Object","instNatCast"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Nat","recAux"],["Eq","refl"],["AddMonoidWithOne","toOne"],["Nat","rawCast"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Bool"],["SubtractionCommMonoid","toSubtractionMonoid"],["EmptyCollection","emptyCollection"],["Int","instRing"],["Int","add_one_le_iff"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instAdd"],["Mathlib","Tactic","Ring","mul_add"],["propext"],["lt_of_not_ge"],["Distrib","toAdd"],["IsStrictOrderedRing","toIsOrderedRing"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["instDecidableEqNat"],["Chapter3","SetTheory","objects_mem_sets"],["neg_neg_of_pos"],["dite"],["Chapter3","SetTheory","Set","not_mem_empty"],["Mathlib","Tactic","Ring","zero_mul"],["Nat","cast_one"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["Iff","mp"],["HMul","hMul"],["Chapter3","SetTheory","Object"],["Int","rawCast"],["AddMonoidWithOne","toAddMonoid"],["Mathlib","Meta","NormNum","isNat_add"],["Ring","toAddGroupWithOne"],["Chapter3","SetTheory","Set","iProd"],["HSub","hSub"],["Chapter3","SetTheory","Set","eq_empty_iff_forall_notMem"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["Chapter3","SetTheory","Set","Fin_mk"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Iff","mpr"],["id"],["instHMul"],["instNatAtLeastTwo"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Chapter3","SetTheory","Object","natCast_inj","_simp_1"],["Chapter3","SetTheory","Set","Fin","toNat"],["Subtype"],["Mathlib","Tactic","Ring","neg_mul"],["Mathlib","Meta","NormNum","isInt_add"],["Chapter3","SetTheory","Set","Fin","coe_toNat"],["SubNegZeroMonoid","toNegZeroClass"],["congrArg"],["Chapter3","SetTheory","Set","Fin_embed","_proof_2"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["MonoidWithZero","toMonoid"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_10"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["True"],["CommSemiring","toSemiring"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["NegZeroClass","toNeg"],["Chapter3","SetTheory","Set"],["Int","instSemiring"],["LE","le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Int","instAddMonoid"],["instLENat"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["Ne"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {X : (Chapter3.SetTheory.Set.Fin n).toSubtype → inst.Set},\n  (∀ (i : (Chapter3.SetTheory.Set.Fin n).toSubtype), Ne (X i) Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n    Ne (Chapter3.SetTheory.Set.iProd X) Chapter3.SetTheory.Set.instEmpty.emptyCollection","name":["Chapter3","SetTheory","Set","finite_choice"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Nat","instNeZeroSucc"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["zero_ne_one","_simp_1"],["or_false"],["Nat","instOne"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["OfNat","zero_ne_ofNat","_simp_1"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["or_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 0\n      (Chapter3.SetTheory.Set.instInsert.insert 1 (Chapter3.SetTheory.Set.instSingleton.singleton 2)))\n    0","name":["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.inst_SProd.sprod A (Chapter3.SetTheory.Set.instSDiff.sdiff B C))\n    (Chapter3.SetTheory.Set.instSDiff.sdiff (Chapter3.SetTheory.Set.inst_SProd.sprod A B)\n      (Chapter3.SetTheory.Set.inst_SProd.sprod A C))","name":["Chapter3","SetTheory","Set","prod_diff"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["SubtractionMonoid","toSubNegZeroMonoid"],["Ring","toNonAssocRing"],["Eq","trans"],["Bool","false"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["AddGroupWithOne","toAddMonoidWithOne"],["Classical","choose"],["Equiv"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Int","instCommSemiring"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["NatCast","natCast"],["le_of_not_gt"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["SubNegMonoid","toSub"],["Int","instLTInt"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Eq","ndrec"],["Mathlib","Tactic","Ring","sub_pf"],["Bool","true"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Ring","toSemiring"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Eq","refl"],["Chapter3","SetTheory","nat"],["Mathlib","Meta","NormNum","isNat_lt_true"],["AddMonoidWithOne","toOne"],["Int","negOfNat"],["Int","instCharZero"],["Nat","rawCast"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Chapter3","SetTheory","specify"],["Bool"],["Chapter3","SetTheory","Set","mem_Fin'"],["Mathlib","Tactic","Ring","add_mul"],["SubtractionCommMonoid","toSubtractionMonoid"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Int","add_one_le_iff"],["Int","instRing"],["Lean","Grind","Nat","lt_eq"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["EquivLike","toFunLike"],["Int","instIsStrictOrderedRing"],["Int","instAdd"],["Mathlib","Tactic","Ring","neg_one_mul"],["Equiv","symm"],["Eq"],["Mathlib","Tactic","Ring","mul_add"],["propext"],["instNatCastInt"],["Distrib","toAdd"],["Mathlib","Tactic","Ring","neg_zero"],["IsStrictOrderedRing","toIsOrderedRing"],["Int","instIsOrderedAddMonoid"],["instOfNatAtLeastTwo"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["HPow","hPow"],["OfNat","ofNat"],["Int"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["Monoid","toNatPow"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["Chapter3","SetTheory","objects_mem_sets"],["neg_neg_of_pos"],["instHSub"],["Nat","cast_one"],["Mathlib","Tactic","Ring","zero_mul"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Membership","mem"],["Preorder","toLT"],["Chapter3","SetTheory","Object"],["HMul","hMul"],["Int","rawCast"],["AddMonoidWithOne","toAddMonoid"],["Mathlib","Meta","NormNum","isNat_add"],["Semiring","toNonAssocSemiring"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Ring","toAddGroupWithOne"],["funext"],["Int","instLEInt"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["AddGroup","toSubNegMonoid"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Int","ofNat"],["Nat","Simproc","add_le_add_le"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["SemilatticeInf","toPartialOrder"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Ring","mul_zero"],["Lean","Grind","nestedProof"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Linarith","mul_neg"],["Nat"],["Mathlib","Tactic","Ring","atom_pf"],["AddMonoidWithOne","toNatCast"],["Iff","of_eq"],["Iff","mpr"],["id"],["instHMul"],["Chapter3","SetTheory","mem"],["instNatAtLeastTwo"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Equiv","instEquivLike"],["Subtype"],["Eq","mp"],["Classical","choose","congr_simp"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["DFunLike","coe"],["SubNegZeroMonoid","toNegZeroClass"],["Chapter3","SetTheory","Set","Fin_embed","_proof_2"],["congrArg"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["MonoidWithZero","toMonoid"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["of_decide_eq_true"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["instHAdd"],["Distrib","toMul"],["CommSemiring","toSemiring"],["Nat","decLe"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Ring","cast_pos"],["Mathlib","Tactic","Ring","add_congr"],["exists_prop_congr"],["Eq","mpr_prop"],["LT","lt"],["Chapter3","SetTheory","Set"],["NegZeroClass","toNeg"],["instSubNat"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["Int","instSemiring"],["Mathlib","Tactic","Ring","neg_congr"],["LE","le"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Subtype","mk"],["instLENat"],["Int","instAddMonoid"],["NormedCommRing","toNonUnitalNormedCommRing"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["DFunLike","coe"],["Chapter3","SetTheory"],["Classical","choose"],["Equiv"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_13"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["NatCast","natCast"],["instOfNatNat"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_14"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["instHAdd"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_12"],["Lean","Grind","nestedProof"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (val : inst.Object)\n  (property :\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLENat.le (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      val)\n  (this : instLENat.le (instHAdd.hAdd (Classical.choose ⋯) 1) n),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1))\n    ⟨Chapter3.SetTheory.Object.instNatCast.natCast (Classical.choose ⋯), ⋯⟩.val","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_15"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Fin","val"],["Equiv","mk"],["Chapter3","SetTheory","Set","Fin_mk"],["Fin","mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Fin"],["Chapter3","SetTheory","Set","Fin","toNat_lt"],["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin","_proof_2"],["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin","_proof_4"],["Fin","isLt"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Fin"],["Chapter3","SetTheory"],["Equiv"]],"type":"[inst : Chapter3.SetTheory] → (n : Nat) → Equiv (Chapter3.SetTheory.Set.Fin n).toSubtype (Fin n)","name":["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin"],"kind":"definition","isProp":false},{"valueReferences":[["Eq","trans"],["Prod","mk"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["Prod","fst"],["congrArg"],["Subtype","prop"],["Chapter3","SetTheory","Set","snd"],["Subtype","coe_prop","_simp_1"],["Set","mem_prod","_simp_1"],["congr"],["Set","instSProd"],["And","left"],["True"],["Set"],["And"],["Prod","snd"],["Set","instMembership"],["Prod"],["and_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Set","fst"],["setOf"]],"typeReferences":[["Prod","mk"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","SetTheory"],["Subtype","val"],["Set","Elem"],["Set","instMembership"],["Prod","fst"],["Prod"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_1"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Subtype","mk"],["Set","instSProd"],["Chapter3","SetTheory","Set","inst_SProd"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set)\n  (x : (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) x).Elem),\n  Set.instMembership.mem (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n    ⟨{ fst := (Chapter3.SetTheory.Set.fst x).val, snd := (Chapter3.SetTheory.Set.snd x).val }, ⋯⟩.val.fst","name":["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["True"],["SProd","sprod"],["congrArg"],["eq_self"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","snd"],["congr"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","mk_cartesian_fst_snd_eq"],["Chapter3","SetTheory","Set","fst_of_mk_cartesian"],["Chapter3","SetTheory","Set","fst"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","snd_of_mk_cartesian"]],"typeReferences":[["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y Z : inst.Set)\n  (x : (Chapter3.SetTheory.Set.inst_SProd.sprod X (Chapter3.SetTheory.Set.inst_SProd.sprod Y Z)).toSubtype),\n  Eq\n    (Chapter3.SetTheory.Set.mk_cartesian\n      (Chapter3.SetTheory.Set.fst\n        (Chapter3.SetTheory.Set.fst\n          (Chapter3.SetTheory.Set.mk_cartesian\n            (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.fst x)\n              (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.snd x)))\n            (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.snd x)))))\n      (Chapter3.SetTheory.Set.mk_cartesian\n        (Chapter3.SetTheory.Set.snd\n          (Chapter3.SetTheory.Set.fst\n            (Chapter3.SetTheory.Set.mk_cartesian\n              (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.fst x)\n                (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.snd x)))\n              (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.snd x)))))\n        (Chapter3.SetTheory.Set.snd\n          (Chapter3.SetTheory.Set.mk_cartesian\n            (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.fst x)\n              (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.snd x)))\n            (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.snd x))))))\n    x","name":["Chapter3","SetTheory","Set","prod_associator","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Prod","mk"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["Prod","fst"],["congrArg"],["Chapter3","SetTheory","Set","snd"],["Set","mem_prod","_simp_1"],["Subtype","coe_prop","_simp_1"],["congr"],["Set","instSProd"],["True"],["Set"],["And"],["Prod","snd"],["Set","instMembership"],["Prod"],["and_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["setOf"]],"typeReferences":[["Prod","mk"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["Set","Elem"],["Set","instMembership"],["Prod"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Set","instSProd"],["Chapter3","SetTheory","Set","inst_SProd"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set)\n  (z : (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) x).Elem),\n  Set.instMembership.mem\n    (Set.instSProd.sprod (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    { fst := (Chapter3.SetTheory.Set.fst z).val, snd := (Chapter3.SetTheory.Set.snd z).val }","name":["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Subtype"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","Tuple","X"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","Tuple","x"]],"typeReferences":[["Lean","Name","anonymous"],["sorryAx"],["Subtype"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","toSubtype"],["Function","LeftInverse"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","Tuple","x"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (X : (Chapter3.SetTheory.Set.Fin n).toSubtype → inst.Set),\n  Function.LeftInverse sorry sorry","name":["Chapter3","SetTheory","Set","iProd_equiv_tuples","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["Chapter3","SetTheory","Set","nat_equiv"],["SubtractionMonoid","toSubNegZeroMonoid"],["Ring","toNonAssocRing"],["Eq","trans"],["Bool","false"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["AddGroupWithOne","toAddMonoidWithOne"],["Subtype","val"],["Classical","choose"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Equiv"],["Int","instCommSemiring"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["NatCast","natCast"],["SubNegMonoid","toSub"],["le_of_not_gt"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["Int","instLTInt"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["Eq","ndrec"],["Bool","true"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Ring","toSemiring"],["instOfNat"],["Eq","refl"],["AddMonoid","toAddSemigroup"],["Mathlib","Meta","NormNum","isNat_lt_true"],["AddMonoidWithOne","toOne"],["Chapter3","SetTheory","nat"],["Int","negOfNat"],["Int","instCharZero"],["Nat","rawCast"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Bool"],["Chapter3","SetTheory","specify"],["Chapter3","SetTheory","Set","mem_Fin'"],["Mathlib","Tactic","Ring","add_mul"],["SubtractionCommMonoid","toSubtractionMonoid"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Int","add_one_le_iff"],["Int","instRing"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Lean","Grind","Nat","lt_eq"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instIsStrictOrderedRing"],["Mathlib","Tactic","Ring","neg_one_mul"],["Int","instAdd"],["EquivLike","toFunLike"],["Equiv","symm"],["Mathlib","Tactic","Ring","mul_add"],["Eq"],["propext"],["instNatCastInt"],["Distrib","toAdd"],["Mathlib","Tactic","Ring","neg_zero"],["IsStrictOrderedRing","toIsOrderedRing"],["Int","instIsOrderedAddMonoid"],["instOfNatAtLeastTwo"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["HPow","hPow"],["OfNat","ofNat"],["Mathlib","Tactic","Ring","mul_congr"],["Int"],["Nat","cast_add"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["Monoid","toNatPow"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["Chapter3","SetTheory","objects_mem_sets"],["neg_neg_of_pos"],["instHSub"],["Nat","cast_one"],["Mathlib","Tactic","Ring","zero_mul"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Membership","mem"],["Preorder","toLT"],["Int","rawCast"],["Chapter3","SetTheory","Object"],["HMul","hMul"],["AddMonoidWithOne","toAddMonoid"],["Mathlib","Meta","NormNum","isNat_add"],["Semiring","toNonAssocSemiring"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Ring","toAddGroupWithOne"],["funext"],["Int","instLEInt"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["AddGroup","toSubNegMonoid"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Int","ofNat"],["Nat","Simproc","add_le_add_le"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["SemilatticeInf","toPartialOrder"],["AddSemigroup","toAdd"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Ring","mul_zero"],["Lean","Grind","nestedProof"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Linarith","mul_neg"],["Nat"],["Mathlib","Tactic","Ring","atom_pf"],["AddMonoidWithOne","toNatCast"],["Iff","of_eq"],["Iff","mpr"],["id"],["instHMul"],["Chapter3","SetTheory","mem"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["instNatAtLeastTwo"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Subtype"],["Equiv","instEquivLike"],["Eq","mp"],["Classical","choose","congr_simp"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["DFunLike","coe"],["SubNegZeroMonoid","toNegZeroClass"],["congrArg"],["Chapter3","SetTheory","Set","Fin_embed","_proof_2"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["MonoidWithZero","toMonoid"],["Mathlib","Tactic","Ring","sub_congr"],["Zero","toOfNat0"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["of_decide_eq_true"],["Lattice","toSemilatticeInf"],["instHAdd"],["CommSemiring","toSemiring"],["Distrib","toMul"],["Nat","decLe"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Ring","cast_pos"],["Mathlib","Tactic","Ring","add_congr"],["Eq","mpr_prop"],["exists_prop_congr"],["LT","lt"],["Chapter3","SetTheory","Set"],["NegZeroClass","toNeg"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["Mathlib","Tactic","Ring","neg_add"],["One","toOfNat1"],["instSubNat"],["Mathlib","Tactic","Ring","neg_congr"],["Int","instSemiring"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["LE","le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Subtype","mk"],["instLENat"],["Int","instAddMonoid"],["NormedCommRing","toNonUnitalNormedCommRing"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["Classical","choose"],["Equiv"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["NatCast","natCast"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["instHAdd"],["Lean","Grind","nestedProof"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (val : inst.Object)\n  (property :\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLENat.le (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      val),\n  instLENat.le (instHAdd.hAdd (Classical.choose ⋯) 1) n →\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m =>\n        instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) (instHAdd.hAdd n 1))\n      (Chapter3.SetTheory.Object.instNatCast.natCast (Classical.choose ⋯))","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_11"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instNeZeroSucc"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["zero_ne_one","_simp_1"],["or_false"],["Nat","instOne"],["Or"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["False"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)) 0","name":["Chapter3","SetTheory","Set","iProd_equiv_prod","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["HAdd","hAdd"],["SizeOf","sizeOf"],["Nat"],["instOfNatNat"],["instHAdd"],["Eq","refl"],["instSizeOfDefault"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"]],"typeReferences":[["instAddNat"],["Chapter3","OrderedPair"],["instHAdd"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["SizeOf","sizeOf"],["Chapter3","OrderedPair","_sizeOf_inst"],["instOfNatNat"],["instSizeOfDefault"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (fst snd : inst.Object),\n  Eq (Chapter3.OrderedPair._sizeOf_inst.sizeOf { fst := fst, snd := snd })\n    (instHAdd.hAdd (instHAdd.hAdd 1 ((instSizeOfDefault inst.Object).sizeOf fst))\n      ((instSizeOfDefault inst.Object).sizeOf snd))","name":["Chapter3","OrderedPair","mk","sizeOf_spec"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["True"],["Eq","trans"],["Set"],["Eq","mp"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Set","mem_univ","_simp_1"],["Subtype","val"],["Set","instMembership"],["Set","univ"],["forall_const","_simp_1"],["Chapter3","SetTheory","Set"],["instNonemptyOfInhabited"],["Eq","refl"],["Subtype","property"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["instInhabitedTrue"],["setOf"]],"typeReferences":[["Set"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Set","Elem"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (x : (Set.univ.pi fun i => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x).Elem) (i : I.toSubtype),\n  Chapter3.SetTheory.objects_mem_sets.mem (X i) (x.val i)","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["instHAdd"],["And"],["Exists","intro"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["congrArg"],["Eq","mpr_prop"],["HAdd","hAdd"],["LT","lt"],["And","intro"],["Lean","Grind","Nat","lt_eq"],["Nat"],["instOfNatNat"],["NatCast","natCast"],["funext"],["LE","le"],["Eq","ndrec"],["Eq"],["instLENat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["instHAdd"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["NatCast","natCast"],["LE","le"],["Eq"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] {m : Nat} (val : inst.Object) (w : Nat),\n  instLENat.le (instHAdd.hAdd w 1) m →\n    Eq val (Chapter3.SetTheory.Object.instNatCast.natCast w) →\n      Exists fun x =>\n        And (instLENat.le (instHAdd.hAdd x 1) m) (Eq val (Chapter3.SetTheory.Object.instNatCast.natCast x))","name":["Chapter3","SetTheory","Set","Fin","coe_eq_iff'","_proof_1_4"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"typeReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"type":"∀ [inst : Chapter3.SetTheory] (i : inst.Object) (X : inst.Set), Function.RightInverse sorry sorry","name":["Chapter3","SetTheory","Set","singleton_iProd_equiv","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Equiv","mk"],["Chapter3","OrderedPair"],["Chapter3","SetTheory","Set","mk_cartesian","_proof_1"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","curry_equiv","_proof_3"],["Chapter3","SetTheory","Set","curry_equiv","_proof_1"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Subtype","mk"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"],["Equiv"]],"type":"[inst : Chapter3.SetTheory] →\n  {X Y Z : inst.Set} →\n    Equiv (X.toSubtype → Y.toSubtype → Z.toSubtype)\n      ((Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype → Z.toSubtype)","name":["Chapter3","SetTheory","Set","curry_equiv"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","prod_associator","_proof_1"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","prod_associator","_proof_2"],["Chapter3","SetTheory","Set","snd"],["Equiv","mk"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"],["Equiv"]],"type":"[inst : Chapter3.SetTheory] →\n  (X Y Z : inst.Set) →\n    Equiv (Chapter3.SetTheory.Set.inst_SProd.sprod (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) Z).toSubtype\n      (Chapter3.SetTheory.Set.inst_SProd.sprod X (Chapter3.SetTheory.Set.inst_SProd.sprod Y Z)).toSubtype","name":["Chapter3","SetTheory","Set","prod_associator"],"kind":"definition","isProp":false},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Object"],["Exists","intro"],["Lean","Grind","intro_with_eq'"],["Subtype","val"],["Classical","choose"],["Equiv"],["And","intro"],["NatCast","natCast"],["funext"],["Eq","symm"],["Eq","ndrec"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["And"],["True","intro"],["Lean","Grind","nestedProof"],["Exists","casesOn"],["Nat"],["eq_false"],["Chapter3","SetTheory","nat"],["Classical","byContradiction"],["Chapter3","SetTheory","mem"],["Equiv","instEquivLike"],["Chapter3","SetTheory","specify"],["Subtype"],["Eq","mp"],["Classical","choose","congr_simp"],["DFunLike","coe"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["congr"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Not"],["True"],["instHAdd"],["OfNat","ofNat"],["Eq","mpr_prop"],["HAdd","hAdd"],["LT","lt"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin","coe_eq_iff'","_proof_1_4"],["LE","le"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Grind","intro_with_eq"],["instLENat"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat","cast"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["And"],["Chapter3","SetTheory","Object"],["Exists","choose"],["Chapter3","SetTheory"],["Subtype","val"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n m : Nat} (val : inst.Object)\n  (property : Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin n) val),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin m) ⟨val, property⟩.val →\n    ∀ (h1 : Exists fun m_1 => And (instLTNat.lt m_1 m) (Eq val m_1.cast))\n      (h2 : Exists fun m => And (instLTNat.lt m n) (Eq val m.cast)),\n      And (instLTNat.lt h1.choose m) (Eq val h1.choose.cast) →\n        And (instLTNat.lt h2.choose n) (Eq val h2.choose.cast) → Eq h1.choose.cast h2.choose.cast","name":["Chapter3","SetTheory","Set","Fin","coe_eq_iff'","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Function","Embedding","mk"],["Chapter3","SetTheory","Set","instInsert"],["Chapter3","OrderedPair"],["Singleton","singleton"],["Chapter3","OrderedPair","snd"],["Function","Embedding"],["Insert","insert"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","OrderedPair","fst"],["Chapter3","OrderedPair","toObject","_proof_1"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSingleton"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","OrderedPair"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Function.Embedding Chapter3.OrderedPair inst.Object","name":["Chapter3","OrderedPair","toObject"],"kind":"definition","isProp":false},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["Nat","Simproc","add_eq_gt"],["Equiv"],["Lean","Grind","eq_false_eq"],["funext"],["Eq","symm"],["Bool","true"],["instLTNat"],["Exists"],["Chapter3","SetTheory","Set","specify"],["And"],["Lean","Grind","not_not"],["True","intro"],["Nat","decLt"],["Nat"],["Eq","refl"],["eq_false"],["Iff"],["Classical","byContradiction"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","specification_axiom''"],["Chapter3","SetTheory","mem"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","specify"],["Bool"],["Eq","mp"],["DFunLike","coe"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["Lean","Grind","exists_prop"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Nat","le_zero_eq"],["of_decide_eq_true"],["Not"],["True"],["instHAdd"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Chapter3","SetTheory","Set"],["Lean","Grind","iff_eq"],["LE","le"],["and_false"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["instLENat"]],"typeReferences":[["Not"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object),\n  Not (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin 0) x)","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat","cast"],["Equiv","instEquivLike"],["Eq","trans"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["eq_true"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["Iff","intro"],["congrArg"],["Chapter3","SetTheory","Set","instNatCast"],["Chapter3","SetTheory","Object","ofnat_eq"],["congr"],["Subtype","property"],["EquivLike","toFunLike"],["Eq","symm"],["Equiv","symm"],["Eq"],["propext"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Chapter3","SetTheory","Object","ofnat_eq''"],["Exists"],["Chapter3","SetTheory","Set","mem_Fin","match_1_3"],["True"],["Chapter3","SetTheory","Set","specify"],["And"],["LT","lt"],["eq_self"],["and_self"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","mem_Fin","_proof_1_7"],["of_eq_true"],["Iff"],["Chapter3","SetTheory","nat"],["id"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","specification_axiom''"],["Chapter3","SetTheory","Set","mem_Fin","match_1_1"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Subtype","mk"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat","cast"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (x : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin n) x)\n    (Exists fun m => And (instLTNat.lt m n) (Eq x m.cast))","name":["Chapter3","SetTheory","Set","mem_Fin"],"kind":"theorem","isProp":true},{"valueReferences":null,"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"]],"type":"[inst : Chapter3.SetTheory] →\n  {n : Nat} →\n    (X : inst.Set) →\n      (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype) →\n        Function.Surjective x → Chapter3.SetTheory.Set.Tuple n","name":["Chapter3","SetTheory","Set","Tuple","mk"],"kind":"constructor","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","Tuple","X"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","Tuple","x"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set","Tuple"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","X"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","Tuple","x"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (t t' : Chapter3.SetTheory.Set.Tuple n),\n  Iff (Eq t t') (∀ (n_1 : (Chapter3.SetTheory.Set.Fin n).toSubtype), Eq (t.x n_1).val (t'.x n_1).val)","name":["Chapter3","SetTheory","Set","Tuple","eq"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Chapter3","SetTheory","specify"],["Subtype"],["Equiv","instEquivLike"],["Chapter3","SetTheory","Set","mem_Fin'"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Equiv"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["NatCast","natCast"],["instOfNatNat"],["funext"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Eq","ndrec"],["propext"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["instHAdd"],["OfNat","ofNat"],["exists_prop_congr"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["Iff","of_eq"],["Eq","refl"],["Iff","mpr"],["Chapter3","SetTheory","nat"],["LE","le"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Chapter3","SetTheory","specify"],["Subtype"],["Equiv","instEquivLike"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_2"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_1"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["NatCast","natCast"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["instHAdd"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (val : inst.Object)\n  (property :\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m =>\n        instLENat.le (instHAdd.hAdd (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) 1) n)\n      val),\n  Exists fun x => Exists fun h => Eq ⟨val, ⋯⟩ ⟨Chapter3.SetTheory.Object.instNatCast.natCast x, ⋯⟩","name":["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":null,"typeReferences":[["Chapter3","SetTheory"]],"type":"[Chapter3.SetTheory] → Type u_2","name":["Chapter3","OrderedPair"],"kind":"inductive","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Equiv","mk"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["Chapter3","SetTheory","Set","prod_commutator","_proof_2"],["Chapter3","SetTheory","Set","prod_commutator","_proof_1"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"],["Equiv"]],"type":"[inst : Chapter3.SetTheory] →\n  (X Y : inst.Set) →\n    Equiv (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype\n      (Chapter3.SetTheory.Set.inst_SProd.sprod Y X).toSubtype","name":["Chapter3","SetTheory","Set","prod_commutator"],"kind":"definition","isProp":false},{"valueReferences":[["instAddNat"],["HAdd","hAdd"],["SizeOf","sizeOf"],["Nat"],["instOfNatNat"],["instHAdd"],["Chapter3","OrderedPair","rec"],["instSizeOfDefault"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"]],"typeReferences":[["Nat"],["Chapter3","OrderedPair"],["Chapter3","SetTheory"]],"type":"{inst : Chapter3.SetTheory} → Chapter3.OrderedPair → Nat","name":["Chapter3","OrderedPair","_sizeOf_1"],"kind":"definition","isProp":false},{"valueReferences":[["cast"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","SetTheory","Set","mem_Fin","_proof_1_5"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Lean","Grind","nestedProof"],["congrArg"],["Chapter3","SetTheory","Set"],["NatCast","natCast"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","SetTheory","Set"],["NatCast","natCast"],["Chapter3","SetTheory","nat"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (m : Nat),\n  Eq x (Chapter3.SetTheory.Object.instNatCast.natCast m) → Chapter3.SetTheory.objects_mem_sets.mem inst.nat m.cast","name":["Chapter3","SetTheory","Set","mem_Fin","_proof_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["HEq","refl"],["Eq","refl"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","Tuple","noConfusionType"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","Tuple","casesOn"],["Eq"],["Eq","ndrec"],["Chapter3","SetTheory","Set","Tuple"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set","Tuple","noConfusionType"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"]],"type":"{inst : Chapter3.SetTheory} →\n  {n : Nat} →\n    {P : Sort u} →\n      {x1 x2 : Chapter3.SetTheory.Set.Tuple n} → Eq x1 x2 → Chapter3.SetTheory.Set.Tuple.noConfusionType P x1 x2","name":["Chapter3","SetTheory","Set","Tuple","noConfusion"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Set","pair_eq_fst_snd"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Eq","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","OrderedPair","mk"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (z : (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype),\n  Eq\n    (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject\n      { fst := (Chapter3.SetTheory.Set.fst z).val, snd := (Chapter3.SetTheory.Set.snd z).val })\n    z.val","name":["Chapter3","SetTheory","Set","curry_equiv","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["DFunLike","coe"],["Chapter3","SetTheory","Set","mem_cartesian"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Subtype","property"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["exists_comm"]],"typeReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (z : (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype),\n  Exists fun b =>\n    Exists fun a =>\n      Eq z.val (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := a.val, snd := b.val })","name":["Chapter3","SetTheory","Set","snd","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["instHAdd"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["OfNat","ofNat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat","cast"],["instHAdd"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat),\n  instLTNat.lt m (instHAdd.hAdd n 1) →\n    Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)) m.cast","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_12"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat","decEq"],["Nat"],["Chapter3","OrderedPair","casesOn"],["Chapter3","SetTheory","Object"],["Eq","ndrec"],["Eq"],["dite"],["Chapter3","OrderedPair","noConfusionType","withCtorType"],["PULift","down"]],"typeReferences":[["Nat"],["Chapter3","OrderedPair"],["Chapter3","SetTheory"],["Chapter3","OrderedPair","noConfusionType","withCtorType"]],"type":"[inst : Chapter3.SetTheory] →\n  (P : Type u) →\n    (ctorIdx : Nat) → Chapter3.OrderedPair.noConfusionType.withCtorType P ctorIdx → P → Chapter3.OrderedPair → P","name":["Chapter3","OrderedPair","noConfusionType","withCtor"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","Tuple","rec"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple","mk"],["Chapter3","SetTheory","Set","Tuple"]],"type":"[inst : Chapter3.SetTheory] →\n  {n : Nat} →\n    {motive : Chapter3.SetTheory.Set.Tuple n → Sort u} →\n      (t : Chapter3.SetTheory.Set.Tuple n) →\n        ((X : inst.Set) →\n            (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype) →\n              (surj : Function.Surjective x) → motive { X := X, x := x, surj := surj }) →\n          motive t","name":["Chapter3","SetTheory","Set","Tuple","casesOn"],"kind":"definition","isProp":false},{"valueReferences":[["instAddNat"],["HAdd","hAdd"],["SizeOf","sizeOf"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["instHAdd"],["Eq","refl"],["instSizeOfDefault"],["OfNat","ofNat"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","Tuple","_sizeOf_inst"],["instHAdd"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory"],["Function","Surjective"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","Tuple"],["HAdd","hAdd"],["Nat"],["SizeOf","sizeOf"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["instSizeOfDefault"],["Eq"],["Chapter3","SetTheory","Set","Tuple","mk"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (X : inst.Set) (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype)\n  (surj : Function.Surjective x),\n  Eq ((Chapter3.SetTheory.Set.Tuple._sizeOf_inst n).sizeOf { X := X, x := x, surj := surj })\n    (instHAdd.hAdd 1 ((instSizeOfDefault inst.Set).sizeOf X))","name":["Chapter3","SetTheory","Set","Tuple","mk","sizeOf_spec"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Subtype","mk","injEq"],["Subtype"],["Nat","cast"],["Chapter3","SetTheory","Set","mem_Fin'"],["Eq","trans"],["Eq","mp"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","Fin","coe_eq_iff'","_proof_1_5"],["Subtype","val"],["congrArg"],["congr"],["funext"],["Eq"],["Eq","ndrec"],["propext"],["Chapter3","SetTheory","Set","Fin","coe_eq_iff'","_simp_1_1"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["Exists","choose_spec"],["True"],["Chapter3","SetTheory","Set","Fin_mk"],["And"],["Exists","choose"],["exists_prop_congr"],["LT","lt"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Iff","of_eq"],["Eq","refl"],["id"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Subtype","casesOn"],["Chapter3","SetTheory","Object","natCast_inj","_simp_1"],["Exists","choose","congr_simp"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Nat"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n m : Nat} (i : (Chapter3.SetTheory.Set.Fin n).toSubtype)\n  (hi : Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin m) i.val),\n  Eq (Chapter3.SetTheory.Set.Fin.toNat ⟨i.val, hi⟩) (Chapter3.SetTheory.Set.Fin.toNat i)","name":["Chapter3","SetTheory","Set","Fin","coe_eq_iff'"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair","casesOn"],["Chapter3","OrderedPair"],["Eq","refl"],["Chapter3","OrderedPair","noConfusionType"],["Chapter3","SetTheory","Object"],["Eq"],["Eq","ndrec"]],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","OrderedPair","noConfusionType"],["Eq"],["Chapter3","SetTheory"]],"type":"{inst : Chapter3.SetTheory} →\n  {P : Sort u} → {x1 x2 : Chapter3.OrderedPair} → Eq x1 x2 → Chapter3.OrderedPair.noConfusionType P x1 x2","name":["Chapter3","OrderedPair","noConfusion"],"kind":"definition","isProp":false},{"valueReferences":[["instHPow"],["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Exists","intro"],["Chapter3","SetTheory","Object"],["HPow","hPow"],["Exists","casesOn"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","inst_pow"],["Eq"]],"typeReferences":[["instHPow"],["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Exists","intro"],["Chapter3","SetTheory","Object"],["HPow","hPow"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","inst_pow"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (t : inst.Object)\n  (motive : (Exists fun h => Exists fun x => Eq t (Chapter3.SetTheory.Set.tuple x)) → Prop)\n  (h : Exists fun h => Exists fun x => Eq t (Chapter3.SetTheory.Set.tuple x)),\n  (∀ (ht : Chapter3.SetTheory.objects_mem_sets.mem (instHPow.hPow (I.iUnion X) I) t)\n      (x : (i : I.toSubtype) → (X i).toSubtype) (h : Eq t (Chapter3.SetTheory.Set.tuple x)), motive ⋯) →\n    motive h","name":["Chapter3","SetTheory","Set","mem_iProd","match_1_2"],"kind":"definition","isProp":true},{"valueReferences":[["Eq","trans"],["Prod","mk"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["congrArg"],["Prod","fst"],["Chapter3","SetTheory","Set","mk_cartesian"],["Subtype","prop"],["Chapter3","SetTheory","Set","snd"],["Subtype","coe_prop","_simp_1"],["Set","mem_prod","_simp_1"],["congr"],["Set","instSProd"],["And","left"],["True"],["Set"],["And","right"],["And"],["Prod","snd"],["Set","instMembership"],["Prod"],["and_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Subtype","mk"],["setOf"]],"typeReferences":[["Set"],["Prod","mk"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Prod","snd"],["SProd","sprod"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_3"],["Subtype","val"],["Chapter3","SetTheory"],["Set","Elem"],["Prod","fst"],["Set","instMembership"],["Prod"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Set","fst"],["Set","instSProd"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_2"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set)\n  (x :\n    (Set.instSProd.sprod (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n        (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x)).Elem),\n  Set.instMembership.mem\n    (Set.instSProd.sprod (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    { fst := (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.mk_cartesian ⟨x.val.fst, ⋯⟩ ⟨x.val.snd, ⋯⟩)).val,\n      snd := (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.mk_cartesian ⟨x.val.fst, ⋯⟩ ⟨x.val.snd, ⋯⟩)).val }","name":["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair","_sizeOf_1"],["Chapter3","OrderedPair"],["SizeOf","mk"]],"typeReferences":[["Chapter3","OrderedPair"],["SizeOf"],["Chapter3","SetTheory"]],"type":"{inst : Chapter3.SetTheory} → SizeOf Chapter3.OrderedPair","name":["Chapter3","OrderedPair","_sizeOf_inst"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["instLTNat"],["Eq","trans"],["True"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_5"],["Iff","intro"],["congrArg"],["LT","lt"],["Exists","casesOn"],["implies_true"],["eq_self"],["Chapter3","SetTheory","Set","Fin","toNat_spec"],["Nat"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["implies_congr_ctx"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Nat"],["Iff"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {i j : (Chapter3.SetTheory.Set.Fin n).toSubtype},\n  Iff (Eq i j) (Eq (Chapter3.SetTheory.Set.Fin.toNat i) (Chapter3.SetTheory.Set.Fin.toNat j))","name":["Chapter3","SetTheory","Set","Fin","coe_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["DFunLike","coe"],["Chapter3","SetTheory","Set","mem_cartesian"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["propext"]],"typeReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] (z : inst.Object) (X Y : inst.Set),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) z)\n    (Exists fun x =>\n      Exists fun y =>\n        Eq z (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x.val, snd := y.val }))","name":["Chapter3","SetTheory","Set","mem_cartesian","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Exists","choose"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","snd","_proof_1"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {X Y : inst.Set} → (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype → Y.toSubtype","name":["Chapter3","SetTheory","Set","snd"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["OfNat","ofNat"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["SProd","sprod"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set), Function.RightInverse sorry sorry","name":["Chapter3","SetTheory","Set","prod_commutator","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["SubtractionMonoid","toSubNegZeroMonoid"],["Ring","toNonAssocRing"],["Eq","trans"],["Bool","false"],["AddGroupWithOne","toAddMonoidWithOne"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Int","instCommSemiring"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["NatCast","natCast"],["le_of_not_gt"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["SubNegMonoid","toSub"],["Int","instLTInt"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["instLTNat"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Ring","toSemiring"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Eq","refl"],["Mathlib","Meta","NormNum","isNat_lt_true"],["AddMonoidWithOne","toOne"],["Int","negOfNat"],["Int","instCharZero"],["Nat","rawCast"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Bool"],["Mathlib","Tactic","Ring","add_mul"],["SubtractionCommMonoid","toSubtractionMonoid"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Int","add_one_le_iff"],["Int","instRing"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instIsStrictOrderedRing"],["Int","instAdd"],["Mathlib","Tactic","Ring","neg_one_mul"],["Mathlib","Tactic","Ring","mul_add"],["instNatCastInt"],["Distrib","toAdd"],["Mathlib","Tactic","Ring","neg_zero"],["IsStrictOrderedRing","toIsOrderedRing"],["Int","instIsOrderedAddMonoid"],["instOfNatAtLeastTwo"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["HPow","hPow"],["OfNat","ofNat"],["Int"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["Monoid","toNatPow"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["neg_neg_of_pos"],["instHSub"],["Nat","cast_one"],["Mathlib","Tactic","Ring","zero_mul"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Preorder","toLT"],["HMul","hMul"],["Int","rawCast"],["AddMonoidWithOne","toAddMonoid"],["Mathlib","Meta","NormNum","isNat_add"],["Semiring","toNonAssocSemiring"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Ring","toAddGroupWithOne"],["Int","instLEInt"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["AddGroup","toSubNegMonoid"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Int","ofNat"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["SemilatticeInf","toPartialOrder"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Ring","mul_zero"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Linarith","mul_neg"],["Nat"],["Mathlib","Tactic","Ring","atom_pf"],["AddMonoidWithOne","toNatCast"],["Iff","mpr"],["id"],["instHMul"],["instNatAtLeastTwo"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Eq","mp"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["SubNegZeroMonoid","toNegZeroClass"],["Chapter3","SetTheory","Set","Fin_embed","_proof_2"],["congrArg"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["MonoidWithZero","toMonoid"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["instHAdd"],["Distrib","toMul"],["CommSemiring","toSemiring"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Ring","cast_pos"],["Mathlib","Tactic","Ring","add_congr"],["LT","lt"],["NegZeroClass","toNeg"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["Int","instSemiring"],["Mathlib","Tactic","Ring","neg_congr"],["LE","le"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Int","instAddMonoid"],["NormedCommRing","toNonUnitalNormedCommRing"]],"typeReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["instLTNat"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","specify"],["instHAdd"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["OfNat","ofNat"],["Equiv"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat)\n  (i :\n    Subtype fun x =>\n      Chapter3.SetTheory.objects_mem_sets.mem\n        (inst.specify inst.nat fun m =>\n          instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n        x),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)) i.val","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["HEq","refl"],["Chapter3","OrderedPair"],["Chapter3","OrderedPair","snd"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","fst"],["Eq","casesOn"],["Iff","intro"],["And","intro"],["Chapter3","OrderedPair","ext"],["Eq","refl"],["HEq"],["Eq","symm"],["Eq"],["Eq","ndrec"],["And","casesOn"]],"typeReferences":[["Chapter3","OrderedPair"],["Iff"],["Chapter3","OrderedPair","snd"],["And"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","OrderedPair","fst"],["Chapter3","SetTheory"]],"type":"∀ {inst : Chapter3.SetTheory} {x y : Chapter3.OrderedPair}, Iff (Eq x y) (And (Eq x.fst y.fst) (Eq x.snd y.snd))","name":["Chapter3","OrderedPair","ext_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["HEq","refl"],["eq_of_heq"],["HEq"],["Eq","ndrec"],["Classical","choose"]],"typeReferences":[["Exists"],["HEq"],["Eq"],["Classical","choose"]],"type":"∀ (α α' : Sort u),\n  Eq α α' →\n    ∀ (p : α → Prop) (p' : α' → Prop),\n      HEq p p' →\n        ∀ (h : Exists fun x => p x) (h' : Exists fun x => p' x),\n          HEq h h' → HEq (Classical.choose h) (Classical.choose h')","name":["Classical","choose","hcongr_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Subtype","val"],["Chapter3","SetTheory","Set","Fin_embed","_proof_2"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set","Fin"],["LE","le"],["Chapter3","SetTheory","Set","toSubtype"],["instLENat"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  (n N : Nat) → instLENat.le n N → (Chapter3.SetTheory.Set.Fin n).toSubtype → (Chapter3.SetTheory.Set.Fin N).toSubtype","name":["Chapter3","SetTheory","Set","Fin_embed"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["instLTNat"],["True"],["Eq","trans"],["Chapter3","SetTheory","Set","Fin_mk"],["Fin"],["Chapter3","SetTheory","Set","Fin","toNat_lt"],["congrArg"],["LT","lt"],["eq_self"],["Nat"],["Fin","val"],["of_eq_true"],["Chapter3","SetTheory","Set","Fin","toNat_mk"],["Eq","refl"],["Fin","mk"],["Eq","rec"],["Eq"],["Eq","ndrec"],["Fin","isLt"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Nat"],["Fin","val"],["Chapter3","SetTheory","Set","Fin_mk"],["Fin","mk"],["Fin"],["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin","_proof_3"],["Eq"],["Fin","isLt"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (m : Fin n),\n  Eq ⟨Chapter3.SetTheory.Set.Fin.toNat (Chapter3.SetTheory.Set.Fin_mk n m.val ⋯), ⋯⟩ m","name":["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat","decEq"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","ndrec"],["Eq"],["dite"],["Chapter3","SetTheory","Set","Tuple","casesOn"],["Function","Surjective"],["Chapter3","SetTheory","Set","Tuple","noConfusionType","withCtorType"],["PULift","down"]],"typeReferences":[["Nat"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"],["Chapter3","SetTheory","Set","Tuple","noConfusionType","withCtorType"]],"type":"[inst : Chapter3.SetTheory] →\n  (n : Nat) →\n    (P : Type u) →\n      (ctorIdx : Nat) →\n        Chapter3.SetTheory.Set.Tuple.noConfusionType.withCtorType n P ctorIdx → P → Chapter3.SetTheory.Set.Tuple n → P","name":["Chapter3","SetTheory","Set","Tuple","noConfusionType","withCtor"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["LT","lt"],["instLTNat"],["Nat"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → (n m : Nat) → instLTNat.lt m n → (Chapter3.SetTheory.Set.Fin n).toSubtype","name":["Chapter3","SetTheory","Set","Fin_mk"],"kind":"definition","isProp":false},{"valueReferences":[],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"]],"type":"[inst : Chapter3.SetTheory] → {n : Nat} → Chapter3.SetTheory.Set.Tuple n → inst.Set","name":["Chapter3","SetTheory","Set","Tuple","X"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","iProd_empty_iff"],["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Eq"],["propext"]],"typeReferences":[["Nat"],["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {X : (Chapter3.SetTheory.Set.Fin n).toSubtype → inst.Set},\n  Eq (Eq (Chapter3.SetTheory.Set.iProd X) Chapter3.SetTheory.Set.instEmpty.emptyCollection)\n    (Exists fun i => Eq (X i) Chapter3.SetTheory.Set.instEmpty.emptyCollection)","name":["Chapter3","SetTheory","Set","iProd_empty_iff","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["rfl"],["Chapter3","SetTheory","Set","Fin","toNat"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","SetTheory","Set","Fin_mk"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Object"],["Subtype","val"],["congrArg"],["LT","lt"],["Exists","casesOn"],["Chapter3","SetTheory","Set","Fin","toNat_spec"],["Nat"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (i : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n  Eq (Chapter3.SetTheory.Set.Fin.toNat i).cast i.val","name":["Chapter3","SetTheory","Set","Fin","coe_toNat"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Chapter3","SetTheory","specify"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Equiv"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["instOfNatNat"],["funext"],["EquivLike","toFunLike"],["Equiv","symm"],["instLTNat"],["instHAdd"],["OfNat","ofNat"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","nat"],["LE","le"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","objects_mem_sets"],["instLENat"]],"typeReferences":[["instAddNat"],["instLTNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","specify"],["instHAdd"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Equiv"],["LT","lt"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["LE","le"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (val : inst.Object),\n  Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m =>\n        instLENat.le (instHAdd.hAdd (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) 1) n)\n      val →\n    Chapter3.SetTheory.objects_mem_sets.mem\n      (inst.specify inst.nat fun m => instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n      val","name":["Chapter3","SetTheory","Set","Fin","coe_inj","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["instLTNat"],["Equiv","instEquivLike"],["Chapter3","SetTheory","specify"],["Subtype"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","iUnion","_proof_1"],["DFunLike","coe"],["Equiv"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["instLTNat"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","specify"],["Function","Embedding"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat)\n  {X :\n    (Subtype fun x =>\n        Chapter3.SetTheory.objects_mem_sets.mem\n          (inst.specify inst.nat fun m =>\n            instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n          x) →\n      inst.Set}\n  (x :\n    (inst.specify inst.nat fun m =>\n        instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n).toSubtype)\n  (y y' : inst.Object),\n  And (Eq y (Function.instFunLikeEmbedding.coe inst.set_to_object (X x)))\n      (Eq y' (Function.instFunLikeEmbedding.coe inst.set_to_object (X x))) →\n    Eq y y'","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Lean","Name","anonymous"],["sorryAx"],["Nat","cast"],["instHAdd"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["And"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","instNatCast"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instOfNat"],["ExistsUnique"],["Lean","Name","num"],["Eq"]],"typeReferences":[["instAddNat"],["Nat","cast"],["instHAdd"],["And"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","instNatCast"],["HAdd","hAdd"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instOfNat"],["ExistsUnique"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (X : inst.Set) (f : inst.nat.toSubtype → X.toSubtype → X.toSubtype) (c : X.toSubtype),\n  ExistsUnique fun a => And (Eq (a 0) c) (∀ (n : Nat), Eq (a (instHAdd.hAdd n 1).cast) (f n.cast (a n.cast)))","name":["Chapter3","SetTheory","Set","recursion"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Tuple","noConfusionType","withCtor"],["Chapter3","SetTheory","Set","Fin"],["HEq"],["Chapter3","SetTheory","Set","toSubtype"],["PULift","up"],["Eq"],["Chapter3","SetTheory","Set","Tuple","casesOn"],["Function","Surjective"]],"typeReferences":[["Nat"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple"]],"type":"[inst : Chapter3.SetTheory] →\n  {n : Nat} → Sort u → Chapter3.SetTheory.Set.Tuple n → Chapter3.SetTheory.Set.Tuple n → Sort u","name":["Chapter3","SetTheory","Set","Tuple","noConfusionType"],"kind":"definition","isProp":false},{"valueReferences":[["Set"],["And","right"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Prod","snd"],["SProd","sprod"],["Subtype","val"],["Set","instMembership"],["Prod","fst"],["Prod"],["Chapter3","SetTheory","Set"],["Subtype","prop"],["Chapter3","SetTheory","objects_mem_sets"],["Set","instSProd"],["setOf"]],"typeReferences":[["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Prod","snd"],["Subtype","val"],["Chapter3","SetTheory"],["Set","Elem"],["Set","instMembership"],["Prod"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Set","instSProd"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set)\n  (z :\n    (Set.instSProd.sprod (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n        (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x)).Elem),\n  Set.instMembership.mem (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x) z.val.snd","name":["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["iff_self"],["True"],["Eq","trans"],["of_eq_true"],["Chapter3","OrderedPair"],["Iff"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Eq"],["Chapter3","OrderedPair","mk","injEq"],["congrArg"]],"typeReferences":[["Chapter3","OrderedPair"],["Iff"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x y x' y' : inst.Object),\n  Iff (Eq { fst := x, snd := y } { fst := x', snd := y' }) (And (Eq x x') (Eq y y'))","name":["Chapter3","OrderedPair","eq"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Equiv","mk"],["Lean","Name"],["Singleton","singleton"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_5"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_4"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instInsert"],["Insert","insert"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_1"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_2"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_3"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Name","num"]],"typeReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["SProd","sprod"],["Chapter3","SetTheory"],["Equiv"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Nat","instNeZeroSucc"],["zero_ne_one","_simp_1"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["one_ne_zero","_simp_1"],["or_false"],["Nat","instOne"],["Chapter3","SetTheory","Set","iProd"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["OfNat","zero_ne_ofNat","_simp_1"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat_ne_one","_simp_1"],["OfNat","one_ne_ofNat","_simp_1"],["OfNat","ofNat"],["eq_self"],["or_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["OfNat","ofNat_ne_zero","_simp_1"],["MulZeroClass","toZero"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"type":"[inst : Chapter3.SetTheory] →\n  (X :\n      (Chapter3.SetTheory.Set.instInsert.insert 0\n            (Chapter3.SetTheory.Set.instInsert.insert 1 (Chapter3.SetTheory.Set.instSingleton.singleton 2))).toSubtype →\n        inst.Set) →\n    Equiv (Chapter3.SetTheory.Set.iProd X).toSubtype\n      (Chapter3.SetTheory.Set.inst_SProd.sprod (X ⟨0, ⋯⟩)\n          (Chapter3.SetTheory.Set.inst_SProd.sprod (X ⟨1, ⋯⟩) (X ⟨2, ⋯⟩))).toSubtype","name":["Chapter3","SetTheory","Set","iProd_equiv_prod_triple"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Set","mk_cartesian","_proof_1"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (x : X.toSubtype) (y : Y.toSubtype),\n  Eq (Chapter3.SetTheory.Set.mk_cartesian x y)\n    ⟨Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x.val, snd := y.val }, ⋯⟩","name":["Chapter3","SetTheory","Set","mk_cartesian","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Classical","choose_spec"],["Nat","cast"],["Subtype"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Iff","mp"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Chapter3","SetTheory","Object"],["Exists","intro"],["Chapter3","SetTheory","Set","mem_Fin"],["Classical","choose"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set","mem_Fin'","_simp_1_1"],["Subtype","property"],["Eq"],["And","left"],["instLTNat"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["True"],["Chapter3","SetTheory","Set","Fin_mk"],["And","right"],["And"],["LT","lt"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["LT","lt"],["instLTNat"],["Nat"],["Exists"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (x : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n  Exists fun m => Exists fun h => Eq x (Chapter3.SetTheory.Set.Fin_mk n m h)","name":["Chapter3","SetTheory","Set","mem_Fin'"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair","mk"]],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Object → inst.Object → Chapter3.OrderedPair","name":["Chapter3","OrderedPair","mk","_flat_ctor"],"kind":"definition","isProp":false},{"valueReferences":[["Subtype"],["Eq","trans"],["Prod","mk"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["congrArg"],["Prod","fst"],["Chapter3","SetTheory","Set","mk_cartesian"],["Subtype","prop"],["Chapter3","SetTheory","Set","snd"],["Subtype","coe_prop","_simp_1"],["Set","mem_prod","_simp_1"],["congr"],["Subtype","coe_eta"],["Chapter3","SetTheory","Set","mk_cartesian_fst_snd_eq"],["Eq"],["Set","instSProd"],["Chapter3","SetTheory","Set","inst_SProd"],["And","left"],["True"],["Set"],["And","right"],["And"],["Prod","snd"],["Set","instMembership"],["Prod"],["eq_self"],["and_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Subtype","mk"],["setOf"]],"typeReferences":[["Subtype"],["Membership","mem"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_5"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_4"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["Set","Elem"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Subtype","mk"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set)\n  (x : (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) x).Elem),\n  Eq\n    (Chapter3.SetTheory.Set.mk_cartesian ⟨(Chapter3.SetTheory.Set.fst x).val, ⋯⟩\n      ⟨(Chapter3.SetTheory.Set.snd x).val, ⋯⟩)\n    x","name":["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_6"],"kind":"theorem","isProp":true},{"valueReferences":[["exists_apply_eq_apply'","_simp_1"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["and_true"],["SProd","sprod"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","mk","injEq"],["Function","instEmbeddingLikeEmbedding"],["congrArg"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set","mem_cartesian","_simp_1"],["Chapter3","SetTheory","Set","snd"],["exists_and_left","_simp_1"],["funext"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Exists"],["True"],["Chapter3","OrderedPair"],["Function","Embedding"],["And"],["Chapter3","OrderedPair","mk"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"]],"typeReferences":[["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (x : (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y)\n    (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject\n      { fst := (Chapter3.SetTheory.Set.fst x).val, snd := (Chapter3.SetTheory.Set.snd x).val })","name":["Chapter3","SetTheory","Set","curry_equiv","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Tuple","rec"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple","mk"],["Chapter3","SetTheory","Set","Tuple"]],"type":"[inst : Chapter3.SetTheory] →\n  {n : Nat} →\n    {motive : Chapter3.SetTheory.Set.Tuple n → Sort u} →\n      (t : Chapter3.SetTheory.Set.Tuple n) →\n        ((X : inst.Set) →\n            (x : (Chapter3.SetTheory.Set.Fin n).toSubtype → X.toSubtype) →\n              (surj : Function.Surjective x) → motive { X := X, x := x, surj := surj }) →\n          motive t","name":["Chapter3","SetTheory","Set","Tuple","recOn"],"kind":"definition","isProp":false},{"valueReferences":[["Eq","trans"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Exists","intro"],["SProd","sprod"],["Chapter3","SetTheory","Set","mem_cartesian","match_1_2"],["Subtype","val"],["Chapter3","SetTheory","Set","mem_cartesian","_simp_1_1"],["Chapter3","SetTheory","Set","slice","_proof_1"],["Chapter3","OrderedPair","mk","injEq"],["Function","instEmbeddingLikeEmbedding"],["And","intro"],["funext"],["Eq","symm"],["Subtype","exists","_simp_1"],["Function","instFunLikeEmbedding"],["Eq","ndrec"],["Exists"],["Chapter3","SetTheory","Set","cartesian","_proof_2"],["Function","Embedding"],["And"],["Chapter3","OrderedPair","mk"],["true_and"],["Chapter3","SetTheory","Set","replacement_axiom","_simp_1"],["Exists","casesOn"],["Iff","of_eq"],["Iff"],["Eq","refl"],["id"],["Eq","mpr"],["Chapter3","SetTheory","set_to_object"],["Subtype"],["exists_apply_eq_apply'","_simp_1"],["Eq","mp"],["Chapter3","SetTheory","union"],["Chapter3","SetTheory","Set","replacement_axiom"],["DFunLike","coe"],["congrArg"],["Iff","intro"],["Chapter3","OrderedPair","toObject"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["propext"],["True"],["Chapter3","OrderedPair"],["Chapter3","SetTheory","Set","slice"],["exists_prop","_simp_1"],["exists_prop_congr"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["eq_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] (z : inst.Object) (X Y : inst.Set),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y) z)\n    (Exists fun x =>\n      Exists fun y =>\n        Eq z (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x.val, snd := y.val }))","name":["Chapter3","SetTheory","Set","mem_cartesian"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","union"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","union_axiom"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["propext"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","union"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set) (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (inst.union A) x)\n    (Exists fun S =>\n      And (Chapter3.SetTheory.objects_mem_sets.mem S x)\n        (Chapter3.SetTheory.objects_mem_sets.mem A (Function.instFunLikeEmbedding.coe inst.set_to_object S)))","name":["Chapter3","SetTheory","Set","mem_cartesian","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["exists_apply_eq_apply'","_simp_1"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["and_true"],["SProd","sprod"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","mk","injEq"],["Function","instEmbeddingLikeEmbedding"],["congrArg"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set","mem_cartesian","_simp_1"],["Chapter3","SetTheory","Set","snd"],["exists_and_left","_simp_1"],["funext"],["Subtype","coe_eta"],["Eq","rec"],["Eq","ndrec"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","curry_equiv","_simp_1"],["Exists"],["True"],["Chapter3","OrderedPair"],["Function","Embedding"],["And"],["Chapter3","OrderedPair","mk"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["eq_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Set","fst"]],"typeReferences":[["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","curry_equiv","_proof_2"],["Chapter3","SetTheory","Set","fst"],["Subtype","mk"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y Z : inst.Set}\n  (x : (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype → Z.toSubtype),\n  Eq\n    (fun x_1 =>\n      x\n        ⟨Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject\n            { fst := (Chapter3.SetTheory.Set.fst x_1).val, snd := (Chapter3.SetTheory.Set.snd x_1).val },\n          ⋯⟩)\n    x","name":["Chapter3","SetTheory","Set","curry_equiv","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["exists_prop"],["Exists"],["And"],["propext"]],"typeReferences":[["Exists"],["And"],["Eq"]],"type":"∀ {b a : Prop}, Eq (Exists fun _h => b) (And a b)","name":["Chapter3","SetTheory","Set","Fin","coe_eq_iff'","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","specify"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {X Y : inst.Set} → (X.toSubtype → Y.toSubtype) → inst.Set","name":["Chapter3","SetTheory","Set","graph"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["instLTNat"],["Equiv","instEquivLike"],["Chapter3","SetTheory","specify"],["Subtype"],["Chapter3","SetTheory","Set","tuple","_proof_1"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Equiv"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set","nat_equiv"],["instLTNat"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","specify"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat)\n  {X :\n    (Subtype fun x =>\n        Chapter3.SetTheory.objects_mem_sets.mem\n          (inst.specify inst.nat fun m =>\n            instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n          x) →\n      inst.Set}\n  (x :\n    (i :\n        Subtype fun x =>\n          Chapter3.SetTheory.objects_mem_sets.mem\n            (inst.specify inst.nat fun m =>\n              instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n            x) →\n      Subtype fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x)\n  (i :\n    Subtype fun x =>\n      Chapter3.SetTheory.objects_mem_sets.mem\n        (inst.specify inst.nat fun m =>\n          instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n)\n        x),\n  Chapter3.SetTheory.objects_mem_sets.mem\n    ((inst.specify inst.nat fun m =>\n          instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) n).iUnion\n      X)\n    (x i).val","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Lean","Name","num"],["Eq"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (a : (i : I.toSubtype) → (X i).toSubtype),\n  Eq (Chapter3.SetTheory.Set.tuple a) (Chapter3.SetTheory.Set.tuple a)","name":["Chapter3","SetTheory","Set","tuple_refl"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair","casesOn"]],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory"]],"type":"∀ {inst : Chapter3.SetTheory} (motive : Chapter3.OrderedPair → Prop) (h : Chapter3.OrderedPair),\n  (∀ (fst snd : inst.Object), motive { fst := fst, snd := snd }) → motive h","name":["Chapter3","OrderedPair","ext","match_1"],"kind":"definition","isProp":true},{"valueReferences":[["implies_congr"],["Chapter3","SetTheory","Set","tuple_inj"],["imp_self","_simp_1"],["Eq","trans"],["Eq","mp"],["Chapter3","SetTheory","Set","tuple_mem_iProd"],["Set","pi"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set","iProd"],["Subtype","coe_prop","_simp_1"],["funext"],["forall_congr"],["Subtype","property"],["Eq","symm"],["Eq"],["Exists"],["Exists","choose_spec"],["True"],["Set","mem_pi","_simp_1"],["Set"],["Chapter3","SetTheory","Set","tuple"],["Subtype","ext"],["Set","mem_univ","_simp_1"],["Exists","choose"],["Chapter3","SetTheory","Set","mem_iProd"],["Set","instMembership"],["Set","univ"],["implies_true"],["forall_const","_simp_1"],["Chapter3","SetTheory","Set"],["of_eq_true"],["instNonemptyOfInhabited"],["Eq","refl"],["id"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instInhabitedTrue"],["setOf"]],"typeReferences":[["Subtype"],["Set"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Exists","choose"],["Subtype","val"],["Chapter3","SetTheory"],["Set","Elem"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_4"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_3"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_9"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_8"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (x : (Set.univ.pi fun i => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (X i) x).Elem),\n  Eq ⟨fun i => (⋯.choose i).val, ⋯⟩ x","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_10"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Chapter3.OrderedPair → inst.Object","name":["Chapter3","OrderedPair","snd"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Unit"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"typeReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Unit"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Function","LeftInverse"],["Lean","Name","num"]],"type":"∀ [inst : Chapter3.SetTheory] (X : Chapter3.SetTheory.Set.instEmpty.emptyCollection.toSubtype → inst.Set),\n  Function.LeftInverse sorry sorry","name":["Chapter3","SetTheory","Set","empty_iProd_equiv","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Nat"],["Chapter3","SetTheory","Set","Tuple","X"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","Tuple","x"],["Chapter3","SetTheory","Set","Tuple"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (self : Chapter3.SetTheory.Set.Tuple n), Function.Surjective self.x","name":["Chapter3","SetTheory","Set","Tuple","surj"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Equiv","mk"],["Lean","Name"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Chapter3","SetTheory","Set","singleton_iProd_equiv","_proof_2"],["Chapter3","SetTheory","Set","singleton_iProd_equiv","_proof_1"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Equiv"]],"type":"[inst : Chapter3.SetTheory] →\n  (i : inst.Object) → (X : inst.Set) → Equiv (Chapter3.SetTheory.Set.iProd fun x => X).toSubtype X.toSubtype","name":["Chapter3","SetTheory","Set","singleton_iProd_equiv"],"kind":"definition","isProp":false},{"valueReferences":[["Subtype","mk","injEq"],["Subtype"],["Chapter3","SetTheory","Set","pair_eq_fst_snd"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["DFunLike","coe"],["Subtype","val"],["congrArg"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set","snd"],["Subtype","property"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","OrderedPair"],["Function","Embedding"],["Chapter3","SetTheory","Set","mk_cartesian","_proof_1"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Subtype","mk"],["Chapter3","SetTheory","Set","fst"],["Chapter3","SetTheory","Set","mk_cartesian","eq_1"]],"typeReferences":[["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","fst"],["SProd","sprod"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (z : (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype),\n  Eq (Chapter3.SetTheory.Set.mk_cartesian (Chapter3.SetTheory.Set.fst z) (Chapter3.SetTheory.Set.snd z)) z","name":["Chapter3","SetTheory","Set","mk_cartesian_fst_snd_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["And","intro"],["Chapter3","OrderedPair","noConfusion"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Eq"]],"typeReferences":[["Chapter3","OrderedPair"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ {inst : Chapter3.SetTheory} {fst snd fst_1 snd_1 : inst.Object},\n  Eq { fst := fst, snd := snd } { fst := fst_1, snd := snd_1 } → And (Eq fst fst_1) (Eq snd snd_1)","name":["Chapter3","OrderedPair","mk","inj"],"kind":"theorem","isProp":true},{"valueReferences":null,"typeReferences":[["Nat"],["Chapter3","SetTheory"]],"type":"[Chapter3.SetTheory] → Nat → Type (max u_1 u_2)","name":["Chapter3","SetTheory","Set","Tuple"],"kind":"inductive","isProp":false},{"valueReferences":[["HEq","refl"],["Chapter3","OrderedPair"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Eq","casesOn"],["Eq","propIntro"],["And","intro"],["Chapter3","OrderedPair","noConfusion"],["Eq","refl"],["Eq","symm"],["HEq"],["Eq"],["Eq","ndrec"],["And","casesOn"]],"typeReferences":[["Chapter3","OrderedPair"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (fst snd fst_1 snd_1 : inst.Object),\n  Eq (Eq { fst := fst, snd := snd } { fst := fst_1, snd := snd_1 }) (And (Eq fst fst_1) (Eq snd snd_1))","name":["Chapter3","OrderedPair","mk","injEq"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Chapter3","OrderedPair"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Chapter3","OrderedPair","snd"],["Function","Embedding"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","fst"],["DFunLike","coe"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Lean","Name","num"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"],["Function","Injective"]],"typeReferences":[["Chapter3","SetTheory","Set","instInsert"],["Chapter3","OrderedPair"],["Singleton","singleton"],["Chapter3","OrderedPair","snd"],["Function","Embedding"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","fst"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSingleton"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"],["Function","Injective"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Function.Injective fun p =>\n    Function.instFunLikeEmbedding.coe inst.set_to_object\n      (Chapter3.SetTheory.Set.instInsert.insert\n        (Function.instFunLikeEmbedding.coe inst.set_to_object (Chapter3.SetTheory.Set.instSingleton.singleton p.fst))\n        (Chapter3.SetTheory.Set.instSingleton.singleton\n          (Function.instFunLikeEmbedding.coe inst.set_to_object\n            (Chapter3.SetTheory.Set.instInsert.insert p.fst (Chapter3.SetTheory.Set.instSingleton.singleton p.snd)))))","name":["Chapter3","OrderedPair","toObject","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Eq","trans"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["or_true"],["zero_ne_one","_simp_1"],["one_ne_zero","_simp_1"],["Or"],["Chapter3","SetTheory","Set","iProd"],["Nat","instCharZero"],["OfNat","zero_ne_ofNat","_simp_1"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Insert","insert"],["OfNat","ofNat_ne_one","_simp_1"],["Function","RightInverse"],["Nat"],["or_self"],["instNatAtLeastTwo"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instAddMonoidWithOne"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["Nat","instNeZeroSucc"],["or_false"],["Nat","instOne"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["True"],["Chapter3","SetTheory","Set","instInsert"],["OfNat","one_ne_ofNat","_simp_1"],["OfNat","ofNat"],["eq_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["OfNat","ofNat_ne_zero","_simp_1"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Subtype","mk"]],"typeReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Singleton","singleton"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instInsert"],["Insert","insert"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_1"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_2"],["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_3"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Name","num"]],"type":"∀ [inst : Chapter3.SetTheory]\n  (X :\n    (Chapter3.SetTheory.Set.instInsert.insert 0\n          (Chapter3.SetTheory.Set.instInsert.insert 1 (Chapter3.SetTheory.Set.instSingleton.singleton 2))).toSubtype →\n      inst.Set),\n  Function.RightInverse sorry sorry","name":["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Eq","trans"],["Prod","mk"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["Set","Elem"],["congrArg"],["Prod","fst"],["Chapter3","SetTheory","Set","mk_cartesian"],["Subtype","prop"],["Chapter3","SetTheory","Set","snd"],["Subtype","coe_prop","_simp_1"],["Set","mem_prod","_simp_1"],["congr"],["Subtype","coe_eta"],["Eq","rec"],["Eq","ndrec"],["Set","instSProd"],["Eq"],["And","left"],["True"],["Prod","mk","eta"],["Set"],["And","right"],["And"],["Prod","snd"],["Set","instMembership"],["Prod"],["eq_self"],["and_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","Set","fst_of_mk_cartesian"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Set","fst"],["Chapter3","SetTheory","Set","snd_of_mk_cartesian"],["setOf"]],"typeReferences":[["Prod","mk"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Prod","snd"],["SProd","sprod"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_3"],["Subtype","val"],["Chapter3","SetTheory"],["Set","Elem"],["Prod","fst"],["Set","instMembership"],["Prod"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_7"],["Chapter3","SetTheory","Set","mk_cartesian"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","snd"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","fst"],["Subtype","mk"],["Set","instSProd"],["Eq"],["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_2"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set)\n  (x :\n    (Set.instSProd.sprod (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n        (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x)).Elem),\n  Eq\n    ⟨{ fst := (Chapter3.SetTheory.Set.fst (Chapter3.SetTheory.Set.mk_cartesian ⟨x.val.fst, ⋯⟩ ⟨x.val.snd, ⋯⟩)).val,\n        snd := (Chapter3.SetTheory.Set.snd (Chapter3.SetTheory.Set.mk_cartesian ⟨x.val.fst, ⋯⟩ ⟨x.val.snd, ⋯⟩)).val },\n      ⋯⟩\n    x","name":["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_8"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instAddMonoidWithOne"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["Or"],["instOfNatNat"],["Nat","instCharZero"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat_ne_one","_simp_1"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["OfNat","ofNat_ne_zero","_simp_1"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 0\n      (Chapter3.SetTheory.Set.instInsert.insert 1 (Chapter3.SetTheory.Set.instSingleton.singleton 2)))\n    2","name":["Chapter3","SetTheory","Set","iProd_equiv_prod_triple","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","toSubtype"],["Function","LeftInverse"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Function","LeftInverse"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"type":"∀ [inst : Chapter3.SetTheory] (I X : inst.Set), Function.LeftInverse sorry sorry","name":["Chapter3","SetTheory","Set","iProd_of_const_equiv","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair"],["Function","Embedding"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","replacement_axiom"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory","Set","slice","_proof_1"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"]],"typeReferences":[["Exists"],["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Set","slice"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (x z : inst.Object) (Y : inst.Set),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.slice x Y) z)\n    (Exists fun y => Eq z (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x, snd := y.val }))","name":["Chapter3","SetTheory","Set","mem_slice"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Set","mk_cartesian","_proof_1"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Chapter3","OrderedPair","mk"],["Subtype","val"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  {X Y : inst.Set} → X.toSubtype → Y.toSubtype → (Chapter3.SetTheory.Set.inst_SProd.sprod X Y).toSubtype","name":["Chapter3","SetTheory","Set","mk_cartesian"],"kind":"definition","isProp":false},{"valueReferences":[],"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Chapter3.OrderedPair → inst.Object","name":["Chapter3","OrderedPair","fst"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat_spec"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["LT","lt"],["instLTNat"],["Nat"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (m : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n  instLTNat.lt (Chapter3.SetTheory.Set.Fin.toNat m) n","name":["Chapter3","SetTheory","Set","Fin","Fin_equiv_Fin","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat","cast"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["And"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","mem_Fin"],["congrArg"],["LT","lt"],["And","intro"],["Nat"],["Chapter3","SetTheory","Set"],["Eq","refl"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["LT","lt"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat"],["Nat","cast"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","Fin"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat),\n  instLTNat.lt m n → Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.Fin n) m.cast","name":["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["instAddNat"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Object"],["Lean","Grind","intro_with_eq'"],["Subtype","val"],["Equiv"],["Lean","Grind","Nat","lo_le"],["Or"],["NatCast","natCast"],["Lean","Grind","eq_false_of_imp_eq_true"],["forall_congr"],["funext"],["Eq","symm"],["HSub","hSub"],["Bool","true"],["Nat","Simproc","add_le_add_le"],["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Exists"],["Lean","Grind","rfl_true"],["And"],["True","intro"],["Lean","Grind","forall_or_forall"],["Exists","casesOn"],["Nat"],["Eq","refl"],["Chapter3","SetTheory","nat"],["Classical","byContradiction"],["Chapter3","SetTheory","mem"],["Bool"],["Lean","Grind","not_and"],["Equiv","instEquivLike"],["Chapter3","SetTheory","specify"],["Subtype"],["Eq","mp"],["Lean","Grind","not_exists"],["DFunLike","coe"],["congrArg"],["Lean","Grind","Nat","lt_eq"],["or_false"],["Nat","not_le_eq"],["instOfNatNat"],["EquivLike","toFunLike"],["Equiv","symm"],["Eq"],["of_decide_eq_true"],["Not"],["Lean","Grind","Nat","le_eq_false_of_lo"],["True"],["instHAdd"],["Nat","decLe"],["OfNat","ofNat"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Chapter3","SetTheory","Set"],["instSubNat"],["LE","le"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","casesOn"],["Subtype","mk"],["Lean","Grind","intro_with_eq"],["instHSub"],["instLENat"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["instLTNat"],["Nat","cast"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["LE","le"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["instLENat"]],"type":"∀ [inst : Chapter3.SetTheory] (n N : Nat),\n  instLENat.le n N →\n    ∀ (i : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n      (Exists fun m => And (instLTNat.lt m n) (Eq i.val m.cast)) →\n        Exists fun m => And (instLTNat.lt m N) (Eq i.val m.cast)","name":["Chapter3","SetTheory","Set","Fin_embed","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Ring","toNonAssocRing"],["Bool","false"],["eq_true"],["AddGroupWithOne","toAddMonoidWithOne"],["heq_of_eq"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_3"],["Equiv"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_6"],["Int","instCommSemiring"],["NatCast","natCast"],["le_of_not_gt"],["Eq","symm"],["Int","instLTInt"],["Bool","true"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["instLTNat"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_4"],["Exists"],["Lean","Grind","not_not"],["Ring","toSemiring"],["instOfNat"],["eq_false"],["AddMonoid","toAddSemigroup"],["Chapter3","SetTheory","nat"],["Mathlib","Meta","NormNum","isNat_lt_true"],["Int","negOfNat"],["Int","instCharZero"],["Chapter3","SetTheory","Set","mem_Fin'"],["Mathlib","Tactic","Ring","add_mul"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Lean","Grind","Nat","lt_eq"],["EquivLike","toFunLike"],["Mathlib","Tactic","Ring","neg_one_mul"],["Int","instIsStrictOrderedRing"],["Equiv","symm"],["Eq"],["instNatCastInt"],["Mathlib","Tactic","Ring","neg_zero"],["Int","instIsOrderedAddMonoid"],["instOfNatAtLeastTwo"],["HPow","hPow"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["Monoid","toNatPow"],["instHSub"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Membership","mem"],["Preorder","toLT"],["Semiring","toNonAssocSemiring"],["Subtype","noConfusion"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Or"],["Lean","Grind","forall_imp_eq_or"],["eq_of_heq"],["forall_congr"],["Int","instLEInt"],["AddGroup","toSubNegMonoid"],["Int","ofNat"],["SemilatticeInf","toPartialOrder"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Ring","mul_zero"],["Lean","Grind","nestedProof"],["Mathlib","Tactic","Linarith","mul_neg"],["Nat"],["AddMonoidWithOne","toNatCast"],["Mathlib","Tactic","Ring","atom_pf"],["Iff","of_eq"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Chapter3","SetTheory","mem"],["Eq","mp"],["Classical","choose","congr_simp"],["Chapter3","SetTheory","Set","instEmpty"],["DFunLike","coe"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_7"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["of_decide_eq_true"],["Not"],["instHAdd"],["Distrib","toMul"],["Mathlib","Tactic","Ring","cast_pos"],["Mathlib","Tactic","Ring","add_congr"],["Eq","mpr_prop"],["LT","lt"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["instSubNat"],["Mathlib","Tactic","Ring","neg_congr"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["False"],["Chapter3","SetTheory","Set","coe_of_fun"],["Subtype","mk"],["NormedCommRing","toNonUnitalNormedCommRing"],["instAddNat"],["SubtractionMonoid","toSubNegZeroMonoid"],["Chapter3","SetTheory","Set","nat_equiv"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["Eq","trans"],["Chapter3","SetTheory","Set","Fin_mk","_proof_1"],["Lean","Grind","intro_with_eq'"],["Subtype","val"],["Classical","choose"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["SubNegMonoid","toSub"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Eq","ndrec"],["Function","instFunLikeEmbedding"],["Mathlib","Tactic","Ring","sub_pf"],["Chapter3","SetTheory","Object","instNatCast"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_8"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Function","Embedding"],["Chapter3","SetTheory","replace"],["Eq","refl"],["Classical","byContradiction"],["AddMonoidWithOne","toOne"],["HEq"],["Nat","rawCast"],["Chapter3","SetTheory","set_to_object"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Chapter3","SetTheory","specify"],["Bool"],["SubtractionCommMonoid","toSubtractionMonoid"],["EmptyCollection","emptyCollection"],["Int","instRing"],["Int","add_one_le_iff"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["or_false"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instAdd"],["Mathlib","Tactic","Ring","mul_add"],["propext"],["lt_of_not_ge"],["Distrib","toAdd"],["IsStrictOrderedRing","toIsOrderedRing"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","casesOn"],["neg_neg_of_pos"],["Mathlib","Tactic","Ring","zero_mul"],["Nat","cast_one"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["Chapter3","SetTheory","Set","tuple","_proof_1"],["HMul","hMul"],["Chapter3","SetTheory","Object"],["Int","rawCast"],["AddMonoidWithOne","toAddMonoid"],["Chapter3","SetTheory","Set","iUnion","_proof_1"],["Mathlib","Meta","NormNum","isNat_add"],["Ring","toAddGroupWithOne"],["funext"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Nat","Simproc","add_le_add_le"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["True","intro"],["Lean","Grind","forall_or_forall"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Iff","mpr"],["id"],["instHMul"],["instNatAtLeastTwo"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Equiv","instEquivLike"],["Subtype"],["Chapter3","SetTheory","union"],["Mathlib","Tactic","Ring","neg_mul"],["Mathlib","Meta","NormNum","isInt_add"],["Lean","Grind","nestedProof_congr"],["SubNegZeroMonoid","toNegZeroClass"],["Chapter3","SetTheory","Set","Fin_embed","_proof_2"],["congrArg"],["Chapter3","SetTheory","Set","finite_choice","_proof_1_9"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["MonoidWithZero","toMonoid"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["Chapter3","SetTheory","Set","inst_pow"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["HEq","refl"],["True"],["CommSemiring","toSemiring"],["Nat","decLe"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["exists_prop_congr"],["NegZeroClass","toNeg"],["Chapter3","SetTheory","Set"],["Int","instSemiring"],["LE","le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Lean","Grind","intro_with_eq"],["Int","instAddMonoid"],["instLENat"]],"typeReferences":[["instAddNat"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["SubtractionMonoid","toSubNegZeroMonoid"],["Ring","toNonAssocRing"],["Eq","trans"],["Bool","false"],["AddGroupWithOne","toAddMonoidWithOne"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Int","instCommSemiring"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["le_of_not_gt"],["SubNegMonoid","toSub"],["Int","instLTInt"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["instLTNat"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Ring","toSemiring"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Eq","refl"],["Mathlib","Meta","NormNum","isNat_lt_true"],["AddMonoidWithOne","toOne"],["Int","negOfNat"],["Int","instCharZero"],["Nat","rawCast"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["Bool"],["Mathlib","Tactic","Ring","add_mul"],["SubtractionCommMonoid","toSubtractionMonoid"],["EmptyCollection","emptyCollection"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Int","add_one_le_iff"],["Chapter3","SetTheory"],["Int","instRing"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instIsStrictOrderedRing"],["Int","instAdd"],["Mathlib","Tactic","Ring","neg_one_mul"],["Eq"],["Mathlib","Tactic","Ring","mul_add"],["lt_of_not_ge"],["instNatCastInt"],["Distrib","toAdd"],["Mathlib","Tactic","Ring","neg_zero"],["IsStrictOrderedRing","toIsOrderedRing"],["Int","instIsOrderedAddMonoid"],["instOfNatAtLeastTwo"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["HPow","hPow"],["OfNat","ofNat"],["Int"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["Monoid","toNatPow"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["Chapter3","SetTheory","objects_mem_sets"],["Ne"],["neg_neg_of_pos"],["instHSub"],["Nat","cast_one"],["Mathlib","Tactic","Ring","zero_mul"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Membership","mem"],["Chapter3","SetTheory","Set","Fin"],["Preorder","toLT"],["Chapter3","SetTheory","Object"],["HMul","hMul"],["Int","rawCast"],["AddMonoidWithOne","toAddMonoid"],["Mathlib","Meta","NormNum","isNat_add"],["Semiring","toNonAssocSemiring"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Chapter3","SetTheory","Set","iProd"],["Ring","toAddGroupWithOne"],["Int","instLEInt"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["AddGroup","toSubNegMonoid"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Int","ofNat"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["SemilatticeInf","toPartialOrder"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["Chapter3","SetTheory","Set","Fin_mk"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Ring","mul_zero"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Linarith","mul_neg"],["Nat"],["Mathlib","Tactic","Ring","atom_pf"],["AddMonoidWithOne","toNatCast"],["Iff","mpr"],["id"],["instHMul"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["instNatAtLeastTwo"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Chapter3","SetTheory","Set","Fin","toNat"],["Nat","cast"],["Eq","mp"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["Chapter3","SetTheory","Set","instEmpty"],["SubNegZeroMonoid","toNegZeroClass"],["congrArg"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["MonoidWithZero","toMonoid"],["Mathlib","Tactic","Ring","sub_congr"],["Zero","toOfNat0"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["instHAdd"],["Distrib","toMul"],["CommSemiring","toSemiring"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Ring","cast_pos"],["Chapter3","SetTheory","Set","Fin_embed"],["Mathlib","Tactic","Ring","add_congr"],["LT","lt"],["Chapter3","SetTheory","Set"],["NegZeroClass","toNeg"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Int","instSemiring"],["Mathlib","Tactic","Ring","neg_congr"],["LE","le"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Chapter3","SetTheory","Set","toSubtype"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["instLENat"],["Int","instAddMonoid"],["NormedCommRing","toNonUnitalNormedCommRing"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat),\n  (∀ {X : (Chapter3.SetTheory.Set.Fin n).toSubtype → inst.Set},\n      (∀ (i : (Chapter3.SetTheory.Set.Fin n).toSubtype), Ne (X i) Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n        Ne (Chapter3.SetTheory.Set.iProd X) Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n    ∀ {X : (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)).toSubtype → inst.Set},\n      (∀ (i : (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)).toSubtype),\n          Ne (X i) Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n        (∀ (i : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n            Ne ((fun i => X (Chapter3.SetTheory.Set.Fin_embed n (instHAdd.hAdd n 1) ⋯ i)) i)\n              Chapter3.SetTheory.Set.instEmpty.emptyCollection) →\n          ∀\n            (x' :\n              (i : (Chapter3.SetTheory.Set.Fin n).toSubtype) →\n                ((fun i => X (Chapter3.SetTheory.Set.Fin_embed n (instHAdd.hAdd n 1) ⋯ i)) i).toSubtype)\n            (a : inst.Object),\n            Chapter3.SetTheory.objects_mem_sets.mem (X (Chapter3.SetTheory.Set.Fin_mk (instHAdd.hAdd n 1) n ⋯)) a →\n              ∀ (i : (Chapter3.SetTheory.Set.Fin (instHAdd.hAdd n 1)).toSubtype),\n                Eq (Chapter3.SetTheory.Set.Fin.toNat i) n →\n                  Eq i (Chapter3.SetTheory.Set.Fin_mk (instHAdd.hAdd n 1) n ⋯) →\n                    Chapter3.SetTheory.objects_mem_sets.mem (X i) a","name":["Chapter3","SetTheory","Set","finite_choice","_proof_1_10"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["LT","lt"],["instLTNat"],["Chapter3","SetTheory","Set","Fin","toNat_spec"],["Nat"],["Chapter3","SetTheory","Set","Fin_mk"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Exists","choose"]],"typeReferences":[["Chapter3","SetTheory","Set","Fin","toNat"],["LT","lt"],["instLTNat"],["Nat"],["Chapter3","SetTheory","Set","Fin"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} (i : (Chapter3.SetTheory.Set.Fin n).toSubtype),\n  instLTNat.lt (Chapter3.SetTheory.Set.Fin.toNat i) n","name":["Chapter3","SetTheory","Set","Fin","toNat_lt"],"kind":"theorem","isProp":true},{"valueReferences":[["exists_apply_eq_apply'","_simp_1"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["and_true"],["SProd","sprod"],["DFunLike","coe"],["Subtype","val"],["Chapter3","OrderedPair","mk","injEq"],["Function","instEmbeddingLikeEmbedding"],["congrArg"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set","mem_cartesian","_simp_1"],["exists_and_left","_simp_1"],["funext"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","inst_SProd"],["Exists"],["True"],["Chapter3","OrderedPair"],["Function","Embedding"],["And"],["Chapter3","OrderedPair","mk"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","OrderedPair"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","OrderedPair","mk"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","OrderedPair","toObject"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","inst_SProd"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (x : X.toSubtype) (y : Y.toSubtype),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.inst_SProd.sprod X Y)\n    (Function.instFunLikeEmbedding.coe Chapter3.OrderedPair.toObject { fst := x.val, snd := y.val })","name":["Chapter3","SetTheory","Set","mk_cartesian","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Subtype","val"],["Chapter3","SetTheory","Set","slice","_proof_1"],["Chapter3","OrderedPair","toObject"],["Eq","symm"],["Function","instFunLikeEmbedding"],["Eq"],["True"],["Chapter3","OrderedPair"],["Function","Embedding"],["And"],["True","intro"],["Chapter3","OrderedPair","mk"],["Chapter3","SetTheory","replace"],["Lean","Grind","nestedProof"],["Chapter3","SetTheory","Set"],["eq_false"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","casesOn"],["Subtype","mk"],["Chapter3","SetTheory","Set","cartesian","_proof_1"],["Chapter3","SetTheory","set_to_object"],["And","casesOn"]],"typeReferences":[["Function","Embedding"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","slice"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Subtype","val"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set) (x : X.toSubtype) (y y' : inst.Object),\n  And\n      ((fun x z => Eq z (Function.instFunLikeEmbedding.coe inst.set_to_object (Chapter3.SetTheory.Set.slice x.val Y))) x\n        y)\n      ((fun x z => Eq z (Function.instFunLikeEmbedding.coe inst.set_to_object (Chapter3.SetTheory.Set.slice x.val Y))) x\n        y') →\n    Eq y y'","name":["Chapter3","SetTheory","Set","cartesian","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Chapter3","SetTheory","Set","tuple_inj"],["imp_self","_simp_1"],["Eq","trans"],["Eq","mp"],["Chapter3","SetTheory","Set","tuple_mem_iProd"],["Set","pi"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set","iProd"],["Subtype","coe_prop","_simp_1"],["forall_congr"],["Subtype","property"],["Eq"],["propext"],["Exists"],["Exists","choose_spec"],["Set","mem_pi","_simp_1"],["True"],["Set"],["Chapter3","SetTheory","Set","tuple"],["Subtype","ext"],["Set","mem_univ","_simp_1"],["Exists","choose"],["Chapter3","SetTheory","Set","mem_iProd"],["Set","instMembership"],["Set","univ"],["implies_true"],["forall_const","_simp_1"],["Chapter3","SetTheory","Set"],["of_eq_true"],["instNonemptyOfInhabited"],["Eq","refl"],["id"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["setOf"],["instInhabitedTrue"]],"typeReferences":[["Subtype"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_1"],["Set"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_2"],["Set","pi"],["Membership","mem"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_5"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["Exists","choose"],["Chapter3","SetTheory"],["Subtype","val"],["Set","instMembership"],["Set","univ"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_6"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (X : I.toSubtype → inst.Set)\n  (t : (Chapter3.SetTheory.Set.iProd X).toSubtype),\n  Eq ⟨Chapter3.SetTheory.Set.tuple fun i => ⟨⟨fun i => (⋯.choose i).val, ⋯⟩.val i, ⋯⟩, ⋯⟩ t","name":["Chapter3","SetTheory","Set","iProd_equiv_pi","_proof_7"],"kind":"theorem","isProp":true},{"valueReferences":null,"typeReferences":[["Chapter3","OrderedPair"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Object → inst.Object → Chapter3.OrderedPair","name":["Chapter3","OrderedPair","mk"],"kind":"constructor","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["instLTNat"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Equiv"],["Exists","casesOn"],["LT","lt"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["instLTNat"],["Equiv","instEquivLike"],["Exists"],["Membership","mem"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["LT","lt"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat) (x : inst.Object)\n  (motive :\n    (Exists fun h => instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm ⟨x, h⟩) n) → Prop)\n  (h : Exists fun h => instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm ⟨x, h⟩) n),\n  (∀ (h1 : Chapter3.SetTheory.objects_mem_sets.mem inst.nat x)\n      (h2 : instLTNat.lt (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm ⟨x, h1⟩) n), motive ⋯) →\n    motive h","name":["Chapter3","SetTheory","Set","mem_Fin","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Decidable"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["And"],["SProd","sprod"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Lean","Name","num"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Decidable"],["Iff"],["And"],["SProd","sprod"],["Chapter3","SetTheory","Set","inst_SProd"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"[inst : Chapter3.SetTheory] →\n  Decidable\n    (∀ (A B C D : inst.Set),\n      Iff\n        (Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.inst_SProd.sprod A B)\n          (Chapter3.SetTheory.Set.inst_SProd.sprod C D))\n        (And (Chapter3.SetTheory.Set.instSubset.Subset A C) (Chapter3.SetTheory.Set.instSubset.Subset B D)))","name":["Chapter3","SetTheory","Set","prod_subset_prod'"],"kind":"definition","isProp":false},{"valueReferences":[["Function","RightInverse"],["Nat"],["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Function","RightInverse"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","iProd"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"]],"type":"∀ [inst : Chapter3.SetTheory] (I X : inst.Set), Function.RightInverse sorry sorry","name":["Chapter3","SetTheory","Set","iProd_of_const_equiv","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Prod","snd"],["SProd","sprod"],["Subtype","val"],["Set","instMembership"],["Prod","fst"],["Prod"],["Chapter3","SetTheory","Set"],["Subtype","prop"],["Chapter3","SetTheory","objects_mem_sets"],["Set","instSProd"],["And","left"],["setOf"]],"typeReferences":[["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["SProd","sprod"],["Subtype","val"],["Chapter3","SetTheory"],["Set","Elem"],["Set","instMembership"],["Prod","fst"],["Prod"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Set","instSProd"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set)\n  (z :\n    (Set.instSProd.sprod (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n        (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x)).Elem),\n  Set.instMembership.mem (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x) z.val.fst","name":["Chapter3","SetTheory","Set","prod_equiv_prod","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["Iff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","tuple"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} {X : I.toSubtype → inst.Set} (a b : (i : I.toSubtype) → (X i).toSubtype),\n  Iff (Eq (Chapter3.SetTheory.Set.tuple a) (Chapter3.SetTheory.Set.tuple b))\n    (Eq (Chapter3.SetTheory.Set.tuple b) (Chapter3.SetTheory.Set.tuple a))","name":["Chapter3","SetTheory","Set","tuple_symm"],"kind":"theorem","isProp":true}]
