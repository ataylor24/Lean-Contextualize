[{"valueReferences":[["Chapter3","SetTheory","singleton_axiom"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Singleton","singleton"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instSingleton.singleton a) x) (Eq x a)","name":["Chapter3","SetTheory","Set","mem_singleton"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Subtype"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Set → Type u_2","name":["Chapter3","SetTheory","Set","toSubtype"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instIntersection.inter a b) a","name":["Chapter3","SetTheory","Set","instDistribLattice","_proof_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","instNatCast"],["Chapter3","SetTheory","Object","ofnat_eq"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","symm"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat}, Eq n.cast n.cast.val","name":["Chapter3","SetTheory","Object","natCast_inj","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","mem_union","_simp_1"],["True"],["Chapter3","SetTheory","Set","instInsert"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Union","union"],["congrArg"],["Chapter3","SetTheory","Set"],["iff_self"],["of_eq_true"],["Or"],["congr"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","pair_eq"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a b : inst.Object),\n  Iff\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b)) x)\n    (Or (Eq x a) (Eq x b))","name":["Chapter3","SetTheory","Set","mem_pair"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instIntersection.inter A B) B","name":["Chapter3","SetTheory","Set","inter_subset_right"],"kind":"theorem","isProp":true},{"valueReferences":[["CompleteLattice","instOmegaCompletePartialOrder"],["Lean","Name","anonymous"],["sorryAx"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Lean","Name"],["Lean","Name","str"],["OmegaCompletePartialOrder","toPartialOrder"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["CompleteBooleanAlgebra","toCompleteLattice"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Order","Frame","toHeytingAlgebra"],["Chapter3","SetTheory","Set","instOrderBot"],["instOfNatNat"],["Disjoint"],["HeytingAlgebra","toOrderBot"],["SemilatticeInf","toPartialOrder"],["CompleteDistribLattice","toFrame"],["Chapter3","SetTheory","Set","instDistribLattice"],["Lattice","toSemilatticeInf"],["Set"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["DistribLattice","toLattice"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["setOf"]],"typeReferences":[["CompleteDistribLattice","toFrame"],["CompleteLattice","instOmegaCompletePartialOrder"],["Chapter3","SetTheory","Set","instDistribLattice"],["Lattice","toSemilatticeInf"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Set"],["Membership","mem"],["OmegaCompletePartialOrder","toPartialOrder"],["Chapter3","SetTheory","Object"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["CompleteBooleanAlgebra","toCompleteLattice"],["Chapter3","SetTheory"],["Order","Frame","toHeytingAlgebra"],["Chapter3","SetTheory","Set","instOrderBot"],["DistribLattice","toLattice"],["Chapter3","SetTheory","Set"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["Disjoint"],["Chapter3","SetTheory","objects_mem_sets"],["HeytingAlgebra","toOrderBot"],["SemilatticeInf","toPartialOrder"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Iff\n    (Disjoint (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    (Disjoint X Y)","name":["Chapter3","SetTheory","Set","coe_Disjoint"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Eq","mp"],["Lean","Name"],["Chapter3","SetTheory","Set","mem_union"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["congrArg"],["Iff","intro"],["False","elim"],["Or"],["instOfNatNat"],["Eq"],["propext"],["Not"],["OfNat","ofNat"],["Or","casesOn"],["Classical","or_iff_not_imp_left"],["Nat"],["Chapter3","SetTheory","Set"],["Iff","mpr"],["Chapter3","SetTheory","Set","ext"],["id"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.instUnion.union A B) C)\n    (Chapter3.SetTheory.Set.instUnion.union A (Chapter3.SetTheory.Set.instUnion.union B C))","name":["Chapter3","SetTheory","Set","union_assoc"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","mem_triple"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a b c : inst.Object),\n  Eq\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (Chapter3.SetTheory.Set.instInsert.insert a\n        (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))\n      x)\n    (Or (Eq x a) (Or (Eq x b) (Eq x c)))","name":["Chapter3","SetTheory","Set","mem_triple","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_iff_iff","_simp_1"],["Iff","intro"],["Set","instMembership"],["congrArg"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Iff"],["Chapter3","SetTheory","Set","ext"],["id"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","ndrec"],["Eq"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Iff\n    (Eq (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    (Eq X Y)","name":["Chapter3","SetTheory","Set","coe_inj'"],"kind":"theorem","isProp":true},{"valueReferences":[["rfl"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set) (x : A.toSubtype), Eq x.val x.val","name":["Chapter3","SetTheory","Set","subtype_coe"],"kind":"theorem","isProp":true},{"valueReferences":[["List","nil"],["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Inter","inter"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["List","TFAE"],["Lean","Name","num"],["Eq"],["List","cons"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["List","nil"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","instUnion"],["List","TFAE"],["Union","union"],["Eq"],["List","cons"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  (List.cons (Chapter3.SetTheory.Set.instSubset.Subset A B)\n      (List.cons (Eq (Chapter3.SetTheory.Set.instUnion.union A B) B)\n        (List.cons (Eq (Chapter3.SetTheory.Set.instIntersection.inter A B) A) List.nil))).TFAE","name":["Chapter3","SetTheory","Set","subset_tfae"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Iff"],["Function","Embedding"],["And"],["Chapter3","SetTheory","union"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Function","instFunLikeEmbedding"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [self : Chapter3.SetTheory] (A : self.Set) (x : self.Object),\n  Iff (self.mem x (self.union A))\n    (Exists fun S => And (self.mem x S) (self.mem (Function.instFunLikeEmbedding.coe self.set_to_object S) A))","name":["Chapter3","SetTheory","union_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Eq","refl"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object),\n  Eq\n    (Chapter3.SetTheory.Set.instInsert.insert a\n      (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.instSingleton.singleton a)\n      (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))","name":["Chapter3","SetTheory","Set","triple_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","extensionality"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set},\n  (∀ (x : inst.Object),\n      Iff (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x)) →\n    Eq X Y","name":["Chapter3","SetTheory","Set","ext"],"kind":"theorem","isProp":true},{"valueReferences":null,"typeReferences":[["Not"],["Subtype"],["Exists"],["Function","Embedding"],["And"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["Nat"],["Or"],["Iff"],["Eq"],["Function","instFunLikeEmbedding"]],"type":"(Set : Type u) →\n  (Object : Type v) →\n    (set_to_object : Function.Embedding Set Object) →\n      (mem : Object → Set → Prop) →\n        (∀ (X Y : Set), (∀ (x : Object), Iff (mem x X) (mem x Y)) → Eq X Y) →\n          (emptyset : Set) →\n            (∀ (x : Object), Not (mem x emptyset)) →\n              (singleton : Object → Set) →\n                (∀ (x y : Object), Iff (mem x (singleton y)) (Eq x y)) →\n                  (union_pair : Set → Set → Set) →\n                    (∀ (X Y : Set) (x : Object), Iff (mem x (union_pair X Y)) (Or (mem x X) (mem x Y))) →\n                      (specify : (A : Set) → ((Subtype fun x => mem x A) → Prop) → Set) →\n                        (∀ (A : Set) (P : (Subtype fun x => mem x A) → Prop),\n                            And (∀ (x : Object), mem x (specify A P) → mem x A)\n                              (∀ (x : Subtype fun x => mem x A), Iff (mem x.val (specify A P)) (P x))) →\n                          (replace :\n                              (A : Set) →\n                                (P : (Subtype fun x => mem x A) → Object → Prop) →\n                                  (∀ (x : Subtype fun x => mem x A) (y y' : Object), And (P x y) (P x y') → Eq y y') →\n                                    Set) →\n                            (∀ (A : Set) (P : (Subtype fun x => mem x A) → Object → Prop)\n                                (hP : ∀ (x : Subtype fun x => mem x A) (y y' : Object), And (P x y) (P x y') → Eq y y')\n                                (y : Object), Iff (mem y (replace A P hP)) (Exists fun x => P x y)) →\n                              (nat : Set) →\n                                Equiv Nat (Subtype fun x => mem x nat) →\n                                  (∀ (A : Set),\n                                      (Exists fun x => mem x A) →\n                                        Exists fun x =>\n                                          And (mem x A)\n                                            (∀ (S : Set),\n                                              Eq x (Function.instFunLikeEmbedding.coe set_to_object S) →\n                                                Not (Exists fun y => And (mem y A) (mem y S)))) →\n                                    (pow : Set → Set → Set) →\n                                      (function_to_object :\n                                          (X Y : Set) →\n                                            Function.Embedding ((Subtype fun x => mem x X) → Subtype fun x => mem x Y)\n                                              Object) →\n                                        (∀ (X Y : Set) (F : Object),\n                                            Iff (mem F (pow X Y))\n                                              (Exists fun f =>\n                                                Eq (Function.instFunLikeEmbedding.coe (function_to_object Y X) f) F)) →\n                                          (union : Set → Set) →\n                                            (∀ (A : Set) (x : Object),\n                                                Iff (mem x (union A))\n                                                  (Exists fun S =>\n                                                    And (mem x S)\n                                                      (mem (Function.instFunLikeEmbedding.coe set_to_object S) A))) →\n                                              Chapter3.SetTheory","name":["Chapter3","SetTheory","mk"],"kind":"constructor","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["instOfNatNat"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Set","instUnion"],["EmptyCollection","emptyCollection"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A B X : inst.Set},\n  Eq (Chapter3.SetTheory.Set.instUnion.union A B) X →\n    Eq (Chapter3.SetTheory.Set.instIntersection.inter A B) Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n      Eq A (Chapter3.SetTheory.Set.instSDiff.sdiff X B)","name":["Chapter3","SetTheory","Set","partition_left"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Set"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["Set","instSingletonSet"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Set"],["Singleton","singleton"],["Chapter3","SetTheory","Object"],["Set","instSingletonSet"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object),\n  Eq (Set.instSingletonSet.singleton x) (Set.instSingletonSet.singleton x)","name":["Chapter3","SetTheory","Set","coe_singleton"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","union_pair_axiom"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Union","union"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (X Y : inst.Set),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instUnion.union X Y) x)\n    (Or (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","mem_union"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","mem_union"],["Membership","mem"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Union","union"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Membership","mem"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (X Y : inst.Set),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instUnion.union X Y) x)\n    (Or (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","mem_union","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":null,"typeReferences":[],"type":"Type (max (u + 1) (v + 1))","name":["Chapter3","SetTheory"],"kind":"inductive","isProp":false},{"valueReferences":null,"typeReferences":[["Not"],["Subtype"],["Exists"],["Function","Embedding"],["And"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["Nat"],["Or"],["Chapter3","SetTheory","mk"],["Iff"],["Function","instFunLikeEmbedding"],["Eq"]],"type":"{motive : Chapter3.SetTheory → Sort u_1} →\n  ((Set : Type u) →\n      (Object : Type v) →\n        (set_to_object : Function.Embedding Set Object) →\n          (mem : Object → Set → Prop) →\n            (extensionality : ∀ (X Y : Set), (∀ (x : Object), Iff (mem x X) (mem x Y)) → Eq X Y) →\n              (emptyset : Set) →\n                (emptyset_mem : ∀ (x : Object), Not (mem x emptyset)) →\n                  (singleton : Object → Set) →\n                    (singleton_axiom : ∀ (x y : Object), Iff (mem x (singleton y)) (Eq x y)) →\n                      (union_pair : Set → Set → Set) →\n                        (union_pair_axiom :\n                            ∀ (X Y : Set) (x : Object), Iff (mem x (union_pair X Y)) (Or (mem x X) (mem x Y))) →\n                          (specify : (A : Set) → ((Subtype fun x => mem x A) → Prop) → Set) →\n                            (specification_axiom :\n                                ∀ (A : Set) (P : (Subtype fun x => mem x A) → Prop),\n                                  And (∀ (x : Object), mem x (specify A P) → mem x A)\n                                    (∀ (x : Subtype fun x => mem x A), Iff (mem x.val (specify A P)) (P x))) →\n                              (replace :\n                                  (A : Set) →\n                                    (P : (Subtype fun x => mem x A) → Object → Prop) →\n                                      (∀ (x : Subtype fun x => mem x A) (y y' : Object),\n                                          And (P x y) (P x y') → Eq y y') →\n                                        Set) →\n                                (replacement_axiom :\n                                    ∀ (A : Set) (P : (Subtype fun x => mem x A) → Object → Prop)\n                                      (hP :\n                                        ∀ (x : Subtype fun x => mem x A) (y y' : Object),\n                                          And (P x y) (P x y') → Eq y y')\n                                      (y : Object), Iff (mem y (replace A P hP)) (Exists fun x => P x y)) →\n                                  (nat : Set) →\n                                    (nat_equiv : Equiv Nat (Subtype fun x => mem x nat)) →\n                                      (regularity_axiom :\n                                          ∀ (A : Set),\n                                            (Exists fun x => mem x A) →\n                                              Exists fun x =>\n                                                And (mem x A)\n                                                  (∀ (S : Set),\n                                                    Eq x (Function.instFunLikeEmbedding.coe set_to_object S) →\n                                                      Not (Exists fun y => And (mem y A) (mem y S)))) →\n                                        (pow : Set → Set → Set) →\n                                          (function_to_object :\n                                              (X Y : Set) →\n                                                Function.Embedding\n                                                  ((Subtype fun x => mem x X) → Subtype fun x => mem x Y) Object) →\n                                            (powerset_axiom :\n                                                ∀ (X Y : Set) (F : Object),\n                                                  Iff (mem F (pow X Y))\n                                                    (Exists fun f =>\n                                                      Eq (Function.instFunLikeEmbedding.coe (function_to_object Y X) f)\n                                                        F)) →\n                                              (union : Set → Set) →\n                                                (union_axiom :\n                                                    ∀ (A : Set) (x : Object),\n                                                      Iff (mem x (union A))\n                                                        (Exists fun S =>\n                                                          And (mem x S)\n                                                            (mem (Function.instFunLikeEmbedding.coe set_to_object S)\n                                                              A))) →\n                                                  motive\n                                                    { Set := Set, Object := Object, set_to_object := set_to_object,\n                                                      mem := mem, extensionality := extensionality,\n                                                      emptyset := emptyset, emptyset_mem := emptyset_mem,\n                                                      singleton := singleton, singleton_axiom := singleton_axiom,\n                                                      union_pair := union_pair, union_pair_axiom := union_pair_axiom,\n                                                      specify := specify, specification_axiom := specification_axiom,\n                                                      replace := replace, replacement_axiom := replacement_axiom,\n                                                      nat := nat, nat_equiv := nat_equiv,\n                                                      regularity_axiom := regularity_axiom, pow := pow,\n                                                      function_to_object := function_to_object,\n                                                      powerset_axiom := powerset_axiom, union := union,\n                                                      union_axiom := union_axiom }) →\n    (t : Chapter3.SetTheory) → motive t","name":["Chapter3","SetTheory","rec"],"kind":"recursor","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset A (Chapter3.SetTheory.Set.instUnion.union A B)","name":["Chapter3","SetTheory","Set","subset_union_left"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset Chapter3.SetTheory.Set.instEmpty.emptyCollection A","name":["Chapter3","SetTheory","Set","empty_subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["eq_false"],["Membership","mem"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory","Set","not_mem_empty"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["False"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["EmptyCollection","emptyCollection"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem Chapter3.SetTheory.Set.instEmpty.emptyCollection x) False","name":["Chapter3","SetTheory","Set","not_mem_empty","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","union_pair"],["Iff"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory"]],"type":"∀ [self : Chapter3.SetTheory] (X Y : self.Set) (x : self.Object),\n  Iff (self.mem x (self.union_pair X Y)) (Or (self.mem x X) (self.mem x Y))","name":["Chapter3","SetTheory","union_pair_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A B A' B' : inst.Set},\n  Chapter3.SetTheory.Set.instSubset.Subset A' A →\n    Chapter3.SetTheory.Set.instSubset.Subset B' B →\n      Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instIntersection.inter A' B')\n        (Chapter3.SetTheory.Set.instIntersection.inter A B)","name":["Chapter3","SetTheory","Set","subset_inter_subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["DFunLike","coe"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Equiv"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","nat_coe_eq_iff'"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {m : Chapter3.Nat.toSubtype} {n : Nat},\n  Eq (Eq m.val (Chapter3.SetTheory.Object.instOfNat.ofNat n))\n    (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) ((instOfNatNat n).ofNat n))","name":["Chapter3","SetTheory","Set","nat_coe_eq_iff'","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["Chapter3","SetTheory","Set","instIntersection"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","instSDiff"],["Inter","inter"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A B X : inst.Set},\n  Eq (Chapter3.SetTheory.Set.instSDiff.sdiff X (Chapter3.SetTheory.Set.instUnion.union A B))\n    (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.instSDiff.sdiff X A)\n      (Chapter3.SetTheory.Set.instSDiff.sdiff X B))","name":["Chapter3","SetTheory","Set","compl_union"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Set"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Set","instHasSubset"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"],["setOf"]],"typeReferences":[["Set","instHasSubset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Iff\n    (Set.instHasSubset.Subset (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    (Chapter3.SetTheory.Set.instSubset.Subset X Y)","name":["Chapter3","SetTheory","Set","coe_subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["True"],["Chapter3","SetTheory","Set","specify"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Set","specification_axiom"],["eq_true"],["Chapter3","SetTheory","Object"],["Exists","intro"],["Chapter3","SetTheory","Set","specification_axiom''","match_1_1"],["Chapter3","SetTheory","Set","specification_axiom'"],["Subtype","val"],["Iff","intro"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["propext"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} (P : A.toSubtype → Prop) (x : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (A.specify P) x) (Exists fun h => P ⟨x, h⟩)","name":["Chapter3","SetTheory","Set","specification_axiom''"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","objects_mem_sets"],["EmptyCollection","emptyCollection"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X : inst.Set},\n  Iff (Eq X Chapter3.SetTheory.Set.instEmpty.emptyCollection)\n    (∀ (x : inst.Object), Not (Chapter3.SetTheory.objects_mem_sets.mem X x))","name":["Chapter3","SetTheory","Set","eq_empty_iff_forall_notMem"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","replacement_axiom"],["propext"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} {P : A.toSubtype → inst.Object → Prop}\n  (hP : ∀ (x : A.toSubtype) (y y' : inst.Object), And (P x y) (P x y') → Eq y y') (y : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (A.replace hP) y) (Exists fun x => P x y)","name":["Chapter3","SetTheory","Set","replacement_axiom","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Eq","refl"],["Chapter3","SetTheory","Object"],["NatCast"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set","instNatCast"],["NatCast","mk"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["NatCast"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory], Eq Chapter3.SetTheory.Object.instNatCast { natCast := fun n => n.cast.val }","name":["Chapter3","SetTheory","Object","instNatCast","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset a b →\n    Chapter3.SetTheory.Set.instSubset.Subset a c →\n      Chapter3.SetTheory.Set.instSubset.Subset a (Chapter3.SetTheory.Set.instIntersection.inter b c)","name":["Chapter3","SetTheory","Set","instDistribLattice","_proof_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","empty_subset"],["Chapter3","SetTheory","Set","instDistribLattice"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["Chapter3","SetTheory","Set"],["Bot","mk"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Preorder","toLE"],["OrderBot","mk"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["Chapter3","SetTheory","Set","instDistribLattice"],["DistribLattice","toLattice"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["Chapter3","SetTheory","Set"],["Preorder","toLE"],["Chapter3","SetTheory"],["OrderBot"],["SemilatticeInf","toPartialOrder"]],"type":"[inst : Chapter3.SetTheory] → OrderBot inst.Set","name":["Chapter3","SetTheory","Set","instOrderBot"],"kind":"definition","isProp":false},{"valueReferences":[["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Set","specification_axiom"],["Iff","mp"],["Chapter3","SetTheory","Object"],["eq_true"],["Chapter3","SetTheory","Set","specification_axiom'"],["Subtype","val"],["Iff","intro"],["congrArg"],["Chapter3","SetTheory","Set","instSDiff"],["Eq"],["Not"],["True"],["Chapter3","SetTheory","Set","specify"],["And"],["Chapter3","SetTheory","Set","mem_sdiff","match_1_1"],["true_and"],["Chapter3","SetTheory","Set"],["Iff","mpr"],["id"],["SDiff","sdiff"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["Iff"],["Membership","mem"],["And"],["SDiff","sdiff"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (X Y : inst.Set),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instSDiff.sdiff X Y) x)\n    (And (Chapter3.SetTheory.objects_mem_sets.mem X x) (Not (Chapter3.SetTheory.objects_mem_sets.mem Y x)))","name":["Chapter3","SetTheory","Set","mem_sdiff"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Equiv","apply_eq_iff_eq"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Equiv","instEquivLike"],["Chapter3","Nat"],["Iff"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory"],["Equiv"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Chapter3.Nat.toSubtype),\n  Iff\n    (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm n)\n      (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m))\n    (Eq n m)","name":["Chapter3","SetTheory","Set","nat_equiv_symm_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","coe_inj"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set) (x y : A.toSubtype), Eq (Eq x.val y.val) (Eq x y)","name":["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","specify"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → (A : inst.Set) → (A.toSubtype → Prop) → inst.Set","name":["Chapter3","SetTheory","Set","specify"],"kind":"definition","isProp":false},{"valueReferences":[["Nat","cast"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Iff","rfl"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1_2"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Eq"],["Chapter3","SetTheory","Set","nat_equiv_inj","_simp_1"]],"typeReferences":[["Nat"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat),\n  Iff (Eq (Chapter3.SetTheory.Object.instOfNat.ofNat n) (Chapter3.SetTheory.Object.instOfNat.ofNat m))\n    (Eq ((instOfNatNat n).ofNat n) ((instOfNatNat m).ofNat m))","name":["Chapter3","SetTheory","Set","ofNat_inj'"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Set"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Set","instInsert"],["Set","instSingletonSet"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Set"],["Singleton","singleton"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Set","instInsert"],["Set","instSingletonSet"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x y : inst.Object),\n  Eq (Set.instInsert.insert x (Set.instSingletonSet.singleton y))\n    (Set.instInsert.insert x (Set.instSingletonSet.singleton y))","name":["Chapter3","SetTheory","Set","coe_pair"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Set"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["SDiff","sdiff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"],["Set","instSDiff"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Set"],["Membership","mem"],["SDiff","sdiff"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"],["setOf"],["Set","instSDiff"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Eq\n    (Set.instSDiff.sdiff (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    (Set.instSDiff.sdiff (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","coe_diff"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Nat","cast"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe'"],["DFunLike","coe"],["Subtype","val"],["Equiv"],["Chapter3","SetTheory","Object","instOfNat"],["Iff","intro"],["congrArg"],["Chapter3","SetTheory","Set","instNatCast"],["instOfNatNat"],["EquivLike","toFunLike"],["Eq","symm"],["Equiv","symm"],["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe"],["Eq","ndrec"],["Eq"],["True"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Subtype","mk"],["Subtype","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["Subtype","val"],["Equiv"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {m : Chapter3.Nat.toSubtype} {n : Nat},\n  Iff (Eq m.val (Chapter3.SetTheory.Object.instOfNat.ofNat n))\n    (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m) ((instOfNatNat n).ofNat n))","name":["Chapter3","SetTheory","Set","nat_coe_eq_iff'"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → self.Set → self.Set → self.Set","name":["Chapter3","SetTheory","pow"],"kind":"definition","isProp":false},{"valueReferences":[["Nat","cast"],["HEq","refl"],["Eq","casesOn"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","nat_equiv_inj"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","Nat"],["instOfNatNat"],["Eq","refl"],["Iff"],["eq_of_heq"],["Eq","symm"],["HEq"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instOfNat"],["Eq","mpr"],["Eq","ndrec"],["Eq"]],"typeReferences":[["Nat"],["Chapter3","Nat"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","instOfNat"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat),\n  Iff (Eq (Chapter3.SetTheory.Set.instOfNat.ofNat n) (Chapter3.SetTheory.Set.instOfNat.ofNat m))\n    (Eq ((instOfNatNat n).ofNat n) ((instOfNatNat m).ofNat m))","name":["Chapter3","SetTheory","Set","ofNat_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set), Eq (Chapter3.SetTheory.Set.instUnion.union A A) A","name":["Chapter3","SetTheory","Set","union_self"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","mk"]],"typeReferences":[["Not"],["Subtype"],["Exists"],["Function","Embedding"],["And"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["Nat"],["Or"],["Iff"],["Eq"],["Function","instFunLikeEmbedding"]],"type":"(Set : Type u) →\n  (Object : Type v) →\n    (set_to_object : Function.Embedding Set Object) →\n      (mem : Object → Set → Prop) →\n        (∀ (X Y : Set), (∀ (x : Object), Iff (mem x X) (mem x Y)) → Eq X Y) →\n          (emptyset : Set) →\n            (∀ (x : Object), Not (mem x emptyset)) →\n              (singleton : Object → Set) →\n                (∀ (x y : Object), Iff (mem x (singleton y)) (Eq x y)) →\n                  (union_pair : Set → Set → Set) →\n                    (∀ (X Y : Set) (x : Object), Iff (mem x (union_pair X Y)) (Or (mem x X) (mem x Y))) →\n                      (specify : (A : Set) → ((Subtype fun x => mem x A) → Prop) → Set) →\n                        (∀ (A : Set) (P : (Subtype fun x => mem x A) → Prop),\n                            And (∀ (x : Object), mem x (specify A P) → mem x A)\n                              (∀ (x : Subtype fun x => mem x A), Iff (mem x.val (specify A P)) (P x))) →\n                          (replace :\n                              (A : Set) →\n                                (P : (Subtype fun x => mem x A) → Object → Prop) →\n                                  (∀ (x : Subtype fun x => mem x A) (y y' : Object), And (P x y) (P x y') → Eq y y') →\n                                    Set) →\n                            (∀ (A : Set) (P : (Subtype fun x => mem x A) → Object → Prop)\n                                (hP : ∀ (x : Subtype fun x => mem x A) (y y' : Object), And (P x y) (P x y') → Eq y y')\n                                (y : Object), Iff (mem y (replace A P hP)) (Exists fun x => P x y)) →\n                              (nat : Set) →\n                                Equiv Nat (Subtype fun x => mem x nat) →\n                                  (∀ (A : Set),\n                                      (Exists fun x => mem x A) →\n                                        Exists fun x =>\n                                          And (mem x A)\n                                            (∀ (S : Set),\n                                              Eq x (Function.instFunLikeEmbedding.coe set_to_object S) →\n                                                Not (Exists fun y => And (mem y A) (mem y S)))) →\n                                    (pow : Set → Set → Set) →\n                                      (function_to_object :\n                                          (X Y : Set) →\n                                            Function.Embedding ((Subtype fun x => mem x X) → Subtype fun x => mem x Y)\n                                              Object) →\n                                        (∀ (X Y : Set) (F : Object),\n                                            Iff (mem F (pow X Y))\n                                              (Exists fun f =>\n                                                Eq (Function.instFunLikeEmbedding.coe (function_to_object Y X) f) F)) →\n                                          (union : Set → Set) →\n                                            (∀ (A : Set) (x : Object),\n                                                Iff (mem x (union A))\n                                                  (Exists fun S =>\n                                                    And (mem x S)\n                                                      (mem (Function.instFunLikeEmbedding.coe set_to_object S) A))) →\n                                              Chapter3.SetTheory","name":["Chapter3","SetTheory","mk","_flat_ctor"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["HasSSubset","mk"],["HasSubset","Subset"],["And"],["Ne"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["HasSSubset"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → HasSSubset inst.Set","name":["Chapter3","SetTheory","Set","instSSubset"],"kind":"definition","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Or"],["instOfNatNat"],["Iff"],["ExistsUnique"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["ExistsUnique"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Object),\n  ExistsUnique fun X => ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem X x) (Or (Eq x a) (Eq x b))","name":["Chapter3","SetTheory","Set","pair_uniq"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Equiv","instEquivLike"],["Chapter3","Nat"],["OfNat","mk"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["DFunLike","coe"],["Equiv"]],"typeReferences":[["Nat"],["Chapter3","Nat"],["OfNat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {n : Nat} → OfNat Chapter3.Nat.toSubtype n","name":["Chapter3","SetTheory","Set","instOfNat"],"kind":"definition","isProp":false},{"valueReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Set","specification_axiom''"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["propext"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} (P : A.toSubtype → Prop) (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (A.specify P) x) (Exists fun h => P ⟨x, h⟩)","name":["Chapter3","SetTheory","Set","specification_axiom''","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Subtype","val"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} {P : A.toSubtype → Prop},\n  Exists fun B =>\n    And (Chapter3.SetTheory.Set.instSubset.Subset B A)\n      (∀ (x : A.toSubtype), Iff (Chapter3.SetTheory.objects_mem_sets.mem B x.val) (P x))","name":["Chapter3","SetTheory","Set","specification_from_replacement"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Set","name":["Chapter3","SetTheory","Set","empty"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instIntersection.inter A (Chapter3.SetTheory.Set.instUnion.union B C))\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.instIntersection.inter A B)\n      (Chapter3.SetTheory.Set.instIntersection.inter A C))","name":["Chapter3","SetTheory","Set","inter_union_distrib_left"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["And"],["Iff","rfl"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["And"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Set),\n  Iff (And (Chapter3.SetTheory.Set.instSubset.Subset a b) (Not (Chapter3.SetTheory.Set.instSubset.Subset b a)))\n    (And (Chapter3.SetTheory.Set.instSubset.Subset a b) (Not (Chapter3.SetTheory.Set.instSubset.Subset b a)))","name":["Chapter3","SetTheory","Set","instDistribLattice","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Not"],["Chapter3","SetTheory","emptyset"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory"]],"type":"∀ [self : Chapter3.SetTheory] (x : self.Object), Not (self.mem x self.emptyset)","name":["Chapter3","SetTheory","emptyset_mem"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Chapter3","Nat"],["Equiv","symm_apply_apply"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat","cast"],["Equiv","instEquivLike"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Chapter3.Nat.toSubtype),\n  Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm n).cast n","name":["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe'"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Set"],["Lean","Name","str"],["Inter","inter"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"],["Set","instInter"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Set"],["Membership","mem"],["Inter","inter"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"],["Set","instInter"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Eq\n    (Set.instInter.inter (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    (Set.instInter.inter (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","coe_intersection"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Insert","insert"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Object),\n  Eq (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b))\n    (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton a))","name":["Chapter3","SetTheory","Set","pair_comm"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["OfNat","ofNat"],["Nat"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instOfNat"],["Equiv","symm"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat),\n  Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm (Chapter3.SetTheory.Set.instOfNat.ofNat n)) n","name":["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe''"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset a c →\n    Chapter3.SetTheory.Set.instSubset.Subset b c →\n      Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instUnion.union a b) c","name":["Chapter3","SetTheory","Set","instDistribLattice","_proof_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","mem_insert"],["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Object) (X : inst.Set),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instInsert.insert b X) a)\n    (Or (Eq a b) (Chapter3.SetTheory.objects_mem_sets.mem X a))","name":["Chapter3","SetTheory","Set","mem_insert","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["EmptyCollection","mk"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","emptyset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"],["EmptyCollection"]],"type":"[inst : Chapter3.SetTheory] → EmptyCollection inst.Set","name":["Chapter3","SetTheory","Set","instEmpty"],"kind":"definition","isProp":false},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set"],["sorryAx"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set), Chapter3.SetTheory.Set.instSubset.Subset A A","name":["Chapter3","SetTheory","Set","subset_self"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instIntersection.inter A B) A","name":["Chapter3","SetTheory","Set","inter_subset_left"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","mem_pair"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a b : inst.Object),\n  Eq\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b)) x)\n    (Or (Eq x a) (Eq x b))","name":["Chapter3","SetTheory","Set","mem_pair","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["And"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Exists"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["And"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Exists fun A =>\n    Exists fun B =>\n      Exists fun A' =>\n        Exists fun B' =>\n          And (Chapter3.SetTheory.Set.instSubset.Subset A' A)\n            (And (Chapter3.SetTheory.Set.instSubset.Subset B' B)\n              (Not\n                (Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instSDiff.sdiff A' B')\n                  (Chapter3.SetTheory.Set.instSDiff.sdiff A B))))","name":["Chapter3","SetTheory","Set","subset_diff_subset_counter"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Subtype"],["Exists"],["Chapter3","SetTheory","noConfusionType","withCtor"],["Function","Embedding"],["And"],["Chapter3","SetTheory","casesOn"],["DFunLike","coe"],["Subtype","val"],["Equiv"],["Nat"],["Or"],["Iff"],["HEq"],["PULift","up"],["Function","instFunLikeEmbedding"],["Eq"]],"typeReferences":[["Chapter3","SetTheory"]],"type":"Sort u_1 → Chapter3.SetTheory → Chapter3.SetTheory → Sort u_1","name":["Chapter3","SetTheory","noConfusionType"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["Subtype"],["Exists"],["PULift"],["Function","Embedding"],["And"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["Nat"],["Or"],["Iff"],["Function","instFunLikeEmbedding"],["Eq"]],"typeReferences":[["Nat"]],"type":"Type u_1 → Nat → Type (max (max (max (u + 1) u_1) (v + 1)) (max (u + 1) u_1 (v + 1)) 0)","name":["Chapter3","SetTheory","noConfusionType","withCtorType"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","instNatCast"],["rfl"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"]],"typeReferences":[["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","instOfNat"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat}, Eq n.cast (Chapter3.SetTheory.Set.instOfNat.ofNat n)","name":["Chapter3","SetTheory","Set","nat_coe_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Nat","decEq"],["Exists"],["Subtype"],["Function","Embedding"],["And"],["Chapter3","SetTheory","casesOn"],["DFunLike","coe"],["Subtype","val"],["Equiv"],["Nat"],["Or"],["Iff"],["Chapter3","SetTheory","noConfusionType","withCtorType"],["Eq","ndrec"],["Function","instFunLikeEmbedding"],["dite"],["Eq"],["PULift","down"]],"typeReferences":[["Nat"],["Chapter3","SetTheory","noConfusionType","withCtorType"],["Chapter3","SetTheory"]],"type":"(P : Type u_1) →\n  (ctorIdx : Nat) → Chapter3.SetTheory.noConfusionType.withCtorType P ctorIdx → P → Chapter3.SetTheory → P","name":["Chapter3","SetTheory","noConfusionType","withCtor"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","coe_inj'"],["propext"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Eq\n    (Eq (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    (Eq X Y)","name":["Chapter3","SetTheory","Set","coe_inj'","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → self.Set → self.Set → self.Set","name":["Chapter3","SetTheory","union_pair"],"kind":"definition","isProp":false},{"valueReferences":[["Subtype","coe_inj"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set) (x y : A.toSubtype), Iff (Eq x.val y.val) (Eq x y)","name":["Chapter3","SetTheory","Set","coe_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","SetTheory","Object","natCast_inj"],["Chapter3","SetTheory","Object"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat), Eq (Eq n.cast m.cast) (Eq n m)","name":["Chapter3","SetTheory","Object","natCast_inj","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["HasSSubset","SSubset"],["Chapter3","SetTheory","Set"],["Iff","rfl"],["Chapter3","SetTheory","Set","instSSubset"]],"typeReferences":[["HasSSubset","SSubset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["And"],["Ne"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","Set","instSSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Iff (Chapter3.SetTheory.Set.instSSubset.SSubset X Y) (And (Chapter3.SetTheory.Set.instSubset.Subset X Y) (Ne X Y))","name":["Chapter3","SetTheory","Set","ssubset_def"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["And"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Or"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["And"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {a b c d : inst.Object},\n  Eq (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b))\n      (Chapter3.SetTheory.Set.instInsert.insert c (Chapter3.SetTheory.Set.instSingleton.singleton d)) →\n    Or (And (Eq a c) (Eq b d)) (And (Eq a d) (Eq b c))","name":["Chapter3","SetTheory","Set","pair_eq_pair"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → self.Set","name":["Chapter3","SetTheory","nat"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["ExistsUnique"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["ExistsUnique"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a : inst.Object),\n  ExistsUnique fun X => ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem X x) (Eq x a)","name":["Chapter3","SetTheory","Set","singleton_uniq"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Set","subset_def"],["Chapter3","SetTheory","Object"],["congrArg"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","instSubset"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A B C : inst.Set},\n  Chapter3.SetTheory.Set.instSubset.Subset A B →\n    Chapter3.SetTheory.Set.instSubset.Subset B C → Chapter3.SetTheory.Set.instSubset.Subset A C","name":["Chapter3","SetTheory","Set","subset_trans"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","nat_equiv"]],"typeReferences":[["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"],["Equiv"]],"type":"[inst : Chapter3.SetTheory] → Equiv Nat Chapter3.Nat.toSubtype","name":["Chapter3","SetTheory","Set","nat_equiv"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Union","union"],["Insert","mk"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Insert inst.Object inst.Set","name":["Chapter3","SetTheory","Set","instInsert"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","mem_union","_simp_1"],["True"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["congrArg"],["Chapter3","SetTheory","Set"],["iff_self"],["of_eq_true"],["Or"],["congr"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a b c : inst.Object),\n  Iff\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (Chapter3.SetTheory.Set.instInsert.insert a\n        (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))\n      x)\n    (Or (Eq x a) (Or (Eq x b) (Eq x c)))","name":["Chapter3","SetTheory","Set","mem_triple"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Subtype"],["Equiv","instEquivLike"],["True"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["Equiv","apply_symm_apply"],["congrArg"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["of_eq_true"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Equiv","instEquivLike"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Chapter3.Nat.toSubtype},\n  Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm n).cast n.val","name":["Chapter3","SetTheory","Object","ofnat_eq''"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["Chapter3","SetTheory","Set","instIntersection"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","instSDiff"],["Inter","inter"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A B X : inst.Set},\n  Eq (Chapter3.SetTheory.Set.instSDiff.sdiff X (Chapter3.SetTheory.Set.instIntersection.inter A B))\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.instSDiff.sdiff X A)\n      (Chapter3.SetTheory.Set.instSDiff.sdiff X B))","name":["Chapter3","SetTheory","Set","compl_inter"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Set","instEmpty"],["Union","union"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Set","instUnion"],["EmptyCollection","emptyCollection"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instUnion.union A Chapter3.SetTheory.Set.instEmpty.emptyCollection) A","name":["Chapter3","SetTheory","Set","union_empty"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","union_subset_iff"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["And"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory","Set","instSubset"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["And"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instUnion.union A B) C)\n    (And (Chapter3.SetTheory.Set.instSubset.Subset A C) (Chapter3.SetTheory.Set.instSubset.Subset B C))","name":["Chapter3","SetTheory","Set","union_subset_iff","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Set","instEmpty"],["Union","union"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Set","instUnion"],["EmptyCollection","emptyCollection"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instUnion.union Chapter3.SetTheory.Set.instEmpty.emptyCollection A) A","name":["Chapter3","SetTheory","Set","empty_union"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Singleton","singleton"],["Bool","false"],["Lean","Name","str"],["Insert","insert"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a : inst.Object),\n  Eq (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton a))\n    (Chapter3.SetTheory.Set.instSingleton.singleton a)","name":["Chapter3","SetTheory","Set","pair_self"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["instOfNatNat"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","ofNat_inj'"],["Eq"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"],["propext"]],"typeReferences":[["Nat"],["instOfNatNat"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat),\n  Eq (Eq (Chapter3.SetTheory.Object.instOfNat.ofNat n) (Chapter3.SetTheory.Object.instOfNat.ofNat m))\n    (Eq ((instOfNatNat n).ofNat n) ((instOfNatNat m).ofNat m))","name":["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Insert"],["Chapter3","SetTheory","Set","instInsert"],["Eq","refl"],["Chapter3","SetTheory","Object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Insert"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Union","union"],["Eq"],["Chapter3","SetTheory"],["Insert","mk"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Eq Chapter3.SetTheory.Set.instInsert\n    { insert := fun x X => Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.instSingleton.singleton x) X }","name":["Chapter3","SetTheory","Set","instInsert","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["SemilatticeInf","toMin"],["Chapter3","SetTheory","Set","union_inter_distrib_left"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["congrArg"],["PartialOrder","mk"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Eq","symm"],["Chapter3","SetTheory","Set","subset_self"],["LT","mk"],["Eq"],["SemilatticeInf","mk"],["Not"],["Chapter3","SetTheory","Set","subset_trans"],["And"],["Iff","rfl"],["OfNat","ofNat"],["Max","max"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Min","min"],["SemilatticeSup","toMax"],["LE","mk"],["id"],["Eq","mpr"],["SemilatticeSup","mk"],["Preorder","mk"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","Set","subset_antisymm"]],"typeReferences":[["SemilatticeInf","toMin"],["Inter","inter"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_7"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_1"],["PartialOrder","mk"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","subset_self"],["LT","mk"],["SemilatticeInf","mk"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_4"],["Not"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_6"],["Chapter3","SetTheory","Set","subset_trans"],["And"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_5"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_2"],["Max","max"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Min","min"],["LE","mk"],["SemilatticeSup","toMax"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_3"],["SemilatticeSup","mk"],["Preorder","mk"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","Set","subset_antisymm"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y Z : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset\n    (SemilatticeInf.toMin.min (SemilatticeSup.toMax.max X Y) (SemilatticeSup.toMax.max X Z))\n    (SemilatticeSup.toMax.max X (SemilatticeInf.toMin.min Y Z))","name":["Chapter3","SetTheory","Set","instDistribLattice","_proof_8"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff","rfl"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Iff (Chapter3.SetTheory.Set.instSubset.Subset X Y)\n    (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem X x → Chapter3.SetTheory.objects_mem_sets.mem Y x)","name":["Chapter3","SetTheory","Set","subset_def"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","pair_empty"],["sorryAx"],["Chapter3","SetTheory","Set","singleton_empty"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Ne"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set","pair_empty"],["Chapter3","SetTheory","Set","singleton_empty"],["Chapter3","SetTheory","Set"],["Ne"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory], Ne Chapter3.SetTheory.Set.singleton_empty Chapter3.SetTheory.Set.pair_empty","name":["Chapter3","SetTheory","Set","singleton_empty_neq_pair"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset B (Chapter3.SetTheory.Set.instUnion.union A B)","name":["Chapter3","SetTheory","Set","subset_union_right"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Equiv","instEquivLike"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","nat_equiv_symm_inj"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Eq"],["DFunLike","coe"],["Equiv"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Equiv","instEquivLike"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory"],["Equiv"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Chapter3.Nat.toSubtype),\n  Eq\n    (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm n)\n      (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm m))\n    (Eq n m)","name":["Chapter3","SetTheory","Set","nat_equiv_symm_inj","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["NatCast","mk"],["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Equiv","instEquivLike"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["DFunLike","coe"],["Equiv"]],"typeReferences":[["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["NatCast"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → NatCast Chapter3.Nat.toSubtype","name":["Chapter3","SetTheory","Set","instNatCast"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","ofNat_inj'"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Iff"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] {m n : Nat}, Iff (Eq m.cast (Chapter3.SetTheory.Object.instOfNat.ofNat n)) (Eq m n)","name":["Chapter3","SetTheory","Set","nat_coe_eq_iff"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Exists"],["Subtype"],["Chapter3","SetTheory","function_to_object"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","pow"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","mem"],["Eq"],["Function","instFunLikeEmbedding"]],"type":"∀ [self : Chapter3.SetTheory] (X Y : self.Set) (F : self.Object),\n  Iff (self.mem F (self.pow X Y))\n    (Exists fun f => Eq (Function.instFunLikeEmbedding.coe (self.function_to_object Y X) f) F)","name":["Chapter3","SetTheory","powerset_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Chapter3","SetTheory","Set","singleton_empty"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","empty"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Ne"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set","empty"],["Chapter3","SetTheory","Set","singleton_empty"],["Chapter3","SetTheory","Set"],["Ne"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory], Ne Chapter3.SetTheory.Set.empty Chapter3.SetTheory.Set.singleton_empty","name":["Chapter3","SetTheory","Set","emptyset_neq_singleton"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","specify"],["True"],["Eq","trans"],["Membership","mem"],["Inter","inter"],["Iff","mp"],["And"],["Chapter3","SetTheory","Set","specification_axiom"],["eq_true"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","specification_axiom'"],["true_and"],["Subtype","val"],["congrArg"],["Iff","intro"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Iff","mpr"],["id"],["Chapter3","SetTheory","Set","mem_inter","match_1_1"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Subtype","mk"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Iff"],["Inter","inter"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (X Y : inst.Set),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instIntersection.inter X Y) x)\n    (And (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","mem_inter"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["iff_self"],["of_eq_true"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["setOf"],["Set","instMembership"]],"type":"∀ [inst : Chapter3.SetTheory] (X : inst.Set) (x : inst.Object),\n  Iff (Set.instMembership.mem (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x) x)\n    (Chapter3.SetTheory.objects_mem_sets.mem X x)","name":["Chapter3","SetTheory","Set","mem_coe"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","pair_empty"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","empty"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Ne"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set","pair_empty"],["Chapter3","SetTheory","Set","empty"],["Chapter3","SetTheory","Set"],["Ne"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory], Ne Chapter3.SetTheory.Set.empty Chapter3.SetTheory.Set.pair_empty","name":["Chapter3","SetTheory","Set","emptyset_neq_pair"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Set"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Set","instEmptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Set","instEmptyCollection"],["EmptyCollection","emptyCollection"],["Eq"],["Chapter3","SetTheory"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Eq (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Chapter3.SetTheory.Set.instEmpty.emptyCollection x)\n    Set.instEmptyCollection.emptyCollection","name":["Chapter3","SetTheory","Set","coe_empty"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Eq","refl"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Object),\n  Eq (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b))\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.instSingleton.singleton a)\n      (Chapter3.SetTheory.Set.instSingleton.singleton b))","name":["Chapter3","SetTheory","Set","pair_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Nat","cast"],["True"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["iff_self"],["of_eq_true"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object","natCast_inj","_simp_1_2"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","nat_equiv_inj","_simp_1"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Iff"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat), Iff (Eq n.cast m.cast) (Eq n m)","name":["Chapter3","SetTheory","Object","natCast_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["CoeSort","mk"]],"typeReferences":[["Chapter3","SetTheory","Set"],["CoeSort"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → CoeSort inst.Set (Type v)","name":["Chapter3","instCoeSortSetType"],"kind":"definition","isProp":false},{"valueReferences":[["Subtype"],["Subtype","val_inj"],["Eq"],["Subtype","val"],["propext"]],"typeReferences":[["Subtype"],["Eq"],["Subtype","val"]],"type":"∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, Eq (Eq a.val b.val) (Eq a b)","name":["Chapter3","SetTheory","Object","natCast_inj","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Subtype","property"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set) (x : A.toSubtype), Chapter3.SetTheory.objects_mem_sets.mem A x.val","name":["Chapter3","SetTheory","Set","subtype_property"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","mem_pair","_simp_1"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Iff","mp"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["congrArg"],["Iff","intro"],["not_or"],["False","elim"],["Or"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Eq"],["Not"],["Chapter3","SetTheory","Set","mem_triple","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["Chapter3","SetTheory","Set","mem_union","_simp_1"],["And"],["Insert","insert"],["Or","casesOn"],["Classical","or_iff_not_imp_left"],["Chapter3","SetTheory","Set"],["Iff"],["Iff","mpr"],["Chapter3","SetTheory","Set","ext"],["id"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object),\n  Eq\n    (Chapter3.SetTheory.Set.instUnion.union\n      (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b))\n      (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))\n    (Chapter3.SetTheory.Set.instInsert.insert a\n      (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))","name":["Chapter3","SetTheory","Set","pair_union_pair"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","nat"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Set","name":["Chapter3","Nat"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["And"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["And"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Iff (Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instUnion.union A B) C)\n    (And (Chapter3.SetTheory.Set.instSubset.Subset A C) (Chapter3.SetTheory.Set.instSubset.Subset B C))","name":["Chapter3","SetTheory","Set","union_subset_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A X : inst.Set},\n  Eq (Chapter3.SetTheory.Set.instIntersection.inter A (Chapter3.SetTheory.Set.instSDiff.sdiff X A))\n    Chapter3.SetTheory.Set.instEmpty.emptyCollection","name":["Chapter3","SetTheory","Set","inter_compl"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Chapter3","Nat"],["Equiv","symm_apply_apply"],["Chapter3","SetTheory","Set","toSubtype"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Nat","cast"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (n : Nat), Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm n.cast) n","name":["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Subtype"],["Chapter3","SetTheory","Set"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] →\n  (X Y : self.Set) → Function.Embedding ((Subtype fun x => self.mem x X) → Subtype fun x => self.mem x Y) self.Object","name":["Chapter3","SetTheory","function_to_object"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["Set"],["Membership","mem"],["Coe","mk"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Set"],["Coe"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Coe inst.Set (Set inst.Object)","name":["Chapter3","SetTheory","Set","inst_coe_set"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","coe_eq_iff"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory","set_to_object"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Eq\n    (Eq (Function.instFunLikeEmbedding.coe inst.set_to_object X)\n      (Function.instFunLikeEmbedding.coe inst.set_to_object Y))\n    (Eq X Y)","name":["Chapter3","SetTheory","Set","coe_eq_iff","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Nat"],["Subtype"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory"],["Equiv"]],"type":"[self : Chapter3.SetTheory] → Equiv Nat (Subtype fun x => self.mem x self.nat)","name":["Chapter3","SetTheory","nat_equiv"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","empty"],["Chapter3","SetTheory","Set","singleton_empty"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Function","Embedding"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["DFunLike","coe"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Set","name":["Chapter3","SetTheory","Set","pair_empty"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Equiv","instEquivLike"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["Coe","mk"],["Equiv","symm"],["DFunLike","coe"],["Equiv"]],"typeReferences":[["Nat"],["Chapter3","Nat"],["Coe"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Coe Chapter3.Nat.toSubtype Nat","name":["Chapter3","SetTheory","Set","toNat"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","subset_self"],["eq_true"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["True"],["HasSubset","Subset"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set), Eq (Chapter3.SetTheory.Set.instSubset.Subset A A) True","name":["Chapter3","SetTheory","Set","subset_self","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set","specify"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} (P : A.toSubtype → Prop),\n  Chapter3.SetTheory.Set.instSubset.Subset (A.specify P) A","name":["Chapter3","SetTheory","Set","specify_subset"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → self.Set","name":["Chapter3","SetTheory","emptyset"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["Mathlib","Tactic","PushNeg","not_exists_eq"],["Exists"],["Eq","trans"],["True"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["congrArg"],["Chapter3","SetTheory","Set","not_mem_empty","_simp_1"],["False","elim"],["Chapter3","SetTheory","Set"],["iff_self"],["of_eq_true"],["eq_false"],["congr"],["Iff"],["Chapter3","SetTheory","Set","ext"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","objects_mem_sets"],["Ne"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X : inst.Set},\n  Ne X Chapter3.SetTheory.Set.instEmpty.emptyCollection → Exists fun x => Chapter3.SetTheory.objects_mem_sets.mem X x","name":["Chapter3","SetTheory","Set","nonempty_def"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Subtype"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → (A : self.Set) → ((Subtype fun x => self.mem x A) → Prop) → self.Set","name":["Chapter3","SetTheory","specify"],"kind":"definition","isProp":false},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → self.Set → self.Set","name":["Chapter3","SetTheory","union"],"kind":"definition","isProp":false},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [self : Chapter3.SetTheory] (X Y : self.Set), (∀ (x : self.Object), Iff (self.mem x X) (self.mem x Y)) → Eq X Y","name":["Chapter3","SetTheory","extensionality"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","union_pair"],["Union","mk"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Union"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Union inst.Set","name":["Chapter3","SetTheory","Set","instUnion"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","empty_subset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instEmpty"],["eq_true"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["True"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instSubset.Subset Chapter3.SetTheory.Set.instEmpty.emptyCollection A) True","name":["Chapter3","SetTheory","Set","empty_subset","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A X : inst.Set},\n  Chapter3.SetTheory.Set.instSubset.Subset A X → Eq (Chapter3.SetTheory.Set.instUnion.union A X) X","name":["Chapter3","SetTheory","Set","subset_union"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset a (Chapter3.SetTheory.Set.instUnion.union a b)","name":["Chapter3","SetTheory","Set","instDistribLattice","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instIntersection.inter A B) (Chapter3.SetTheory.Set.instIntersection.inter B A)","name":["Chapter3","SetTheory","Set","inter_comm"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","replace"]],"typeReferences":[["Chapter3","SetTheory","Set"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  (A : inst.Set) →\n    {P : A.toSubtype → inst.Object → Prop} →\n      (∀ (x : A.toSubtype) (y y' : inst.Object), And (P x y) (P x y') → Eq y y') → inst.Set","name":["Chapter3","SetTheory","Set","replace"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","mem_inter"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (X Y : inst.Set),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instIntersection.inter X Y) x)\n    (And (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","mem_inter","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Insert","insert"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Object),\n  Eq\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.instSingleton.singleton a)\n      (Chapter3.SetTheory.Set.instSingleton.singleton b))\n    (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b))","name":["Chapter3","SetTheory","Set","singleton_union_singleton"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","empty"],["Chapter3","SetTheory","Set"],["Singleton","singleton"],["Function","Embedding"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["DFunLike","coe"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Set","name":["Chapter3","SetTheory","Set","singleton_empty"],"kind":"definition","isProp":false},{"valueReferences":[["Nat"],["Chapter3","Nat"],["instOfNatNat"],["Chapter3","SetTheory","Set","instOfNat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","ofNat_inj"],["Eq"],["OfNat","ofNat"],["propext"]],"typeReferences":[["Nat"],["Chapter3","Nat"],["instOfNatNat"],["Chapter3","SetTheory","Set","instOfNat"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat),\n  Eq (Eq (Chapter3.SetTheory.Set.instOfNat.ofNat n) (Chapter3.SetTheory.Set.instOfNat.ofNat m))\n    (Eq ((instOfNatNat n).ofNat n) ((instOfNatNat m).ofNat m))","name":["Chapter3","SetTheory","Set","ofNat_inj","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instIntersection.inter A (Chapter3.SetTheory.Set.instUnion.union A B)) A","name":["Chapter3","SetTheory","Set","inter_union_cancel"],"kind":"theorem","isProp":true},{"valueReferences":[["SemilatticeInf","toMin"],["PartialOrder","toPreorder"],["Inter","inter"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory","Set","instOrderBot"],["Chapter3","SetTheory","Set","instIntersection"],["Disjoint"],["eq_of_heq"],["Eq","symm"],["OrderBot","toBot"],["Eq"],["Preorder","toLE"],["Eq","ndrec"],["SemilatticeInf","toPartialOrder"],["Chapter3","SetTheory","Set","instDistribLattice"],["Lattice","toSemilatticeInf"],["HEq","refl"],["Bot","bot"],["Eq","casesOn"],["DistribLattice","toLattice"],["Chapter3","SetTheory","Set"],["Min","min"],["Iff"],["Eq","refl"],["HEq"],["disjoint_iff"],["Eq","mpr"]],"typeReferences":[["Chapter3","SetTheory","Set","instDistribLattice"],["Lattice","toSemilatticeInf"],["Inter","inter"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set"],["DistribLattice","toLattice"],["Chapter3","SetTheory","Set","instOrderBot"],["Chapter3","SetTheory","Set","instIntersection"],["Iff"],["Disjoint"],["Eq"],["SemilatticeInf","toPartialOrder"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Iff (Disjoint A B)\n    (Eq (Chapter3.SetTheory.Set.instIntersection.inter A B) Chapter3.SetTheory.Set.instEmpty.emptyCollection)","name":["Chapter3","SetTheory","Set","disjoint_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["implies_congr"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instEmpty"],["Mathlib","Tactic","PushNeg","not_ne_eq"],["EmptyCollection","emptyCollection"],["Mathlib","Tactic","Contrapose","mtr"],["congrArg"],["Chapter3","SetTheory","Set"],["Eq","refl"],["id"],["Chapter3","SetTheory","Set","eq_empty_iff_forall_notMem"],["Chapter3","SetTheory","objects_mem_sets"],["Ne"],["Eq","mpr"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["Ne"],["Chapter3","SetTheory","objects_mem_sets"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X : inst.Set} {x : inst.Object},\n  Chapter3.SetTheory.objects_mem_sets.mem X x → Ne X Chapter3.SetTheory.Set.instEmpty.emptyCollection","name":["Chapter3","SetTheory","Set","nonempty_of_inhabited"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["Chapter3","SetTheory","Set","instIntersection"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","instSDiff"],["Inter","inter"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instUnion.union A B)\n    (Chapter3.SetTheory.Set.instUnion.union\n      (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.instSDiff.sdiff A B)\n        (Chapter3.SetTheory.Set.instIntersection.inter A B))\n      (Chapter3.SetTheory.Set.instSDiff.sdiff B A))","name":["Chapter3","SetTheory","Set","union_eq_partition"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["SDiff","mk"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set"],["SDiff"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → SDiff inst.Set","name":["Chapter3","SetTheory","Set","instSDiff"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A X : inst.Set},\n  Chapter3.SetTheory.Set.instSubset.Subset A X →\n    Eq (Chapter3.SetTheory.Set.instUnion.union A (Chapter3.SetTheory.Set.instSDiff.sdiff X A)) X","name":["Chapter3","SetTheory","Set","union_compl"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Iff"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","singleton"]],"type":"∀ [self : Chapter3.SetTheory] (x y : self.Object), Iff (self.mem x (self.singleton y)) (Eq x y)","name":["Chapter3","SetTheory","singleton_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B B' : inst.Set),\n  Eq B B' → Eq (Chapter3.SetTheory.Set.instUnion.union A B) (Chapter3.SetTheory.Set.instUnion.union A B')","name":["Chapter3","SetTheory","Set","union_congr_right"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instUnion.union A (Chapter3.SetTheory.Set.instIntersection.inter A B)) A","name":["Chapter3","SetTheory","Set","union_inter_cancel"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Chapter3","SetTheory","specify"],["Iff"],["Chapter3","SetTheory","specification_axiom"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Subtype","val"],["And","left"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} {P : A.toSubtype → Prop} {x : inst.Object},\n  Chapter3.SetTheory.objects_mem_sets.mem (A.specify P) x → Chapter3.SetTheory.objects_mem_sets.mem A x","name":["Chapter3","SetTheory","Set","specification_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["instOfNatNat"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Set","instUnion"],["EmptyCollection","emptyCollection"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A B X : inst.Set},\n  Eq (Chapter3.SetTheory.Set.instUnion.union A B) X →\n    Eq (Chapter3.SetTheory.Set.instIntersection.inter A B) Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n      Eq B (Chapter3.SetTheory.Set.instSDiff.sdiff X A)","name":["Chapter3","SetTheory","Set","partition_right"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","instDistribLattice","_proof_7"],["Inter","inter"],["Lattice","mk"],["Chapter3","SetTheory","Set","instUnion"],["DistribLattice","mk"],["Union","union"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_1"],["PartialOrder","mk"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","subset_self"],["LT","mk"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_4"],["Not"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_6"],["Chapter3","SetTheory","Set","subset_trans"],["And"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_5"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_2"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_8"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["LE","mk"],["SemilatticeSup","mk"],["Chapter3","SetTheory","Set","instDistribLattice","_proof_3"],["Preorder","mk"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","Set","subset_antisymm"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"],["DistribLattice"]],"type":"[inst : Chapter3.SetTheory] → DistribLattice inst.Set","name":["Chapter3","SetTheory","Set","instDistribLattice"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","rec"]],"typeReferences":[["Not"],["Subtype"],["Exists"],["Function","Embedding"],["And"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["Nat"],["Or"],["Chapter3","SetTheory","mk"],["Iff"],["Function","instFunLikeEmbedding"],["Eq"]],"type":"{motive : Chapter3.SetTheory → Sort u_1} →\n  (t : Chapter3.SetTheory) →\n    ((Set : Type u) →\n        (Object : Type v) →\n          (set_to_object : Function.Embedding Set Object) →\n            (mem : Object → Set → Prop) →\n              (extensionality : ∀ (X Y : Set), (∀ (x : Object), Iff (mem x X) (mem x Y)) → Eq X Y) →\n                (emptyset : Set) →\n                  (emptyset_mem : ∀ (x : Object), Not (mem x emptyset)) →\n                    (singleton : Object → Set) →\n                      (singleton_axiom : ∀ (x y : Object), Iff (mem x (singleton y)) (Eq x y)) →\n                        (union_pair : Set → Set → Set) →\n                          (union_pair_axiom :\n                              ∀ (X Y : Set) (x : Object), Iff (mem x (union_pair X Y)) (Or (mem x X) (mem x Y))) →\n                            (specify : (A : Set) → ((Subtype fun x => mem x A) → Prop) → Set) →\n                              (specification_axiom :\n                                  ∀ (A : Set) (P : (Subtype fun x => mem x A) → Prop),\n                                    And (∀ (x : Object), mem x (specify A P) → mem x A)\n                                      (∀ (x : Subtype fun x => mem x A), Iff (mem x.val (specify A P)) (P x))) →\n                                (replace :\n                                    (A : Set) →\n                                      (P : (Subtype fun x => mem x A) → Object → Prop) →\n                                        (∀ (x : Subtype fun x => mem x A) (y y' : Object),\n                                            And (P x y) (P x y') → Eq y y') →\n                                          Set) →\n                                  (replacement_axiom :\n                                      ∀ (A : Set) (P : (Subtype fun x => mem x A) → Object → Prop)\n                                        (hP :\n                                          ∀ (x : Subtype fun x => mem x A) (y y' : Object),\n                                            And (P x y) (P x y') → Eq y y')\n                                        (y : Object), Iff (mem y (replace A P hP)) (Exists fun x => P x y)) →\n                                    (nat : Set) →\n                                      (nat_equiv : Equiv Nat (Subtype fun x => mem x nat)) →\n                                        (regularity_axiom :\n                                            ∀ (A : Set),\n                                              (Exists fun x => mem x A) →\n                                                Exists fun x =>\n                                                  And (mem x A)\n                                                    (∀ (S : Set),\n                                                      Eq x (Function.instFunLikeEmbedding.coe set_to_object S) →\n                                                        Not (Exists fun y => And (mem y A) (mem y S)))) →\n                                          (pow : Set → Set → Set) →\n                                            (function_to_object :\n                                                (X Y : Set) →\n                                                  Function.Embedding\n                                                    ((Subtype fun x => mem x X) → Subtype fun x => mem x Y) Object) →\n                                              (powerset_axiom :\n                                                  ∀ (X Y : Set) (F : Object),\n                                                    Iff (mem F (pow X Y))\n                                                      (Exists fun f =>\n                                                        Eq\n                                                          (Function.instFunLikeEmbedding.coe (function_to_object Y X) f)\n                                                          F)) →\n                                                (union : Set → Set) →\n                                                  (union_axiom :\n                                                      ∀ (A : Set) (x : Object),\n                                                        Iff (mem x (union A))\n                                                          (Exists fun S =>\n                                                            And (mem x S)\n                                                              (mem (Function.instFunLikeEmbedding.coe set_to_object S)\n                                                                A))) →\n                                                    motive\n                                                      { Set := Set, Object := Object, set_to_object := set_to_object,\n                                                        mem := mem, extensionality := extensionality,\n                                                        emptyset := emptyset, emptyset_mem := emptyset_mem,\n                                                        singleton := singleton, singleton_axiom := singleton_axiom,\n                                                        union_pair := union_pair, union_pair_axiom := union_pair_axiom,\n                                                        specify := specify, specification_axiom := specification_axiom,\n                                                        replace := replace, replacement_axiom := replacement_axiom,\n                                                        nat := nat, nat_equiv := nat_equiv,\n                                                        regularity_axiom := regularity_axiom, pow := pow,\n                                                        function_to_object := function_to_object,\n                                                        powerset_axiom := powerset_axiom, union := union,\n                                                        union_axiom := union_axiom }) →\n      motive t","name":["Chapter3","SetTheory","recOn"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["ExistsUnique"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["ExistsUnique"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  ExistsUnique fun X => ∀ (x : inst.Object), Not (Chapter3.SetTheory.objects_mem_sets.mem X x)","name":["Chapter3","SetTheory","Set","empty_unique"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["And"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Iff"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Iff"],["Inter","inter"],["And"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Iff (Chapter3.SetTheory.Set.instSubset.Subset C (Chapter3.SetTheory.Set.instIntersection.inter A B))\n    (And (Chapter3.SetTheory.Set.instSubset.Subset C A) (Chapter3.SetTheory.Set.instSubset.Subset C B))","name":["Chapter3","SetTheory","Set","subset_inter_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","instNatCast"],["rfl"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat}, Eq n.cast.val n.cast","name":["Chapter3","SetTheory","Object","ofnat_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["HasSubset","mk"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → HasSubset inst.Set","name":["Chapter3","SetTheory","Set","instSubset"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","apply_eq_iff_eq"]],"typeReferences":[["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","Nat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat), Iff (Eq n.cast m.cast) (Eq n m)","name":["Chapter3","SetTheory","Set","nat_equiv_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Matrix","vecCons"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Function","onFun"],["Fin"],["Pairwise"],["Chapter3","SetTheory","Set","instOrderBot"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["Chapter3","SetTheory","Set","instIntersection"],["Disjoint"],["SemilatticeInf","toPartialOrder"],["Chapter3","SetTheory","Set","instDistribLattice"],["Lattice","toSemilatticeInf"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["DistribLattice","toLattice"],["Nat","succ"],["Matrix","vecEmpty"],["SDiff","sdiff"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set","instDistribLattice"],["Matrix","vecCons"],["Lattice","toSemilatticeInf"],["Inter","inter"],["Fin"],["Function","onFun"],["Pairwise"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set","instOrderBot"],["Chapter3","SetTheory","Set"],["DistribLattice","toLattice"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","instSDiff"],["Nat","succ"],["instOfNatNat"],["Disjoint"],["Matrix","vecEmpty"],["SDiff","sdiff"],["SemilatticeInf","toPartialOrder"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Pairwise\n    (Function.onFun Disjoint\n      (Matrix.vecCons (Chapter3.SetTheory.Set.instSDiff.sdiff A B)\n        (Matrix.vecCons (Chapter3.SetTheory.Set.instIntersection.inter A B)\n          (Matrix.vecCons (Chapter3.SetTheory.Set.instSDiff.sdiff B A) Matrix.vecEmpty))))","name":["Chapter3","SetTheory","Set","pairwise_disjoint"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Function","Embedding","inj'"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set},\n  Eq (Function.instFunLikeEmbedding.coe inst.set_to_object X) (Function.instFunLikeEmbedding.coe inst.set_to_object Y) →\n    Eq X Y","name":["Chapter3","SetTheory","Set","coe_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} (P : A.toSubtype → Prop) (x : inst.Object)\n  (motive : (Exists fun h => P ⟨x, h⟩) → Prop) (h : Exists fun h => P ⟨x, h⟩),\n  (∀ (h : Chapter3.SetTheory.objects_mem_sets.mem A x) (hP : P ⟨x, h⟩), motive ⋯) → motive h","name":["Chapter3","SetTheory","Set","specification_axiom''","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Chapter3","SetTheory","replacement_axiom"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","replace"],["Iff"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} {P : A.toSubtype → inst.Object → Prop}\n  (hP : ∀ (x : A.toSubtype) (y y' : inst.Object), And (P x y) (P x y') → Eq y y') (y : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (A.replace hP) y) (Exists fun x => P x y)","name":["Chapter3","SetTheory","Set","replacement_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  (A : inst.Set) → {x : inst.Object} → Chapter3.SetTheory.objects_mem_sets.mem A x → A.toSubtype","name":["Chapter3","SetTheory","Set","subtype_mk"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["And","casesOn"]],"typeReferences":[["Not"],["And","intro"],["Chapter3","SetTheory","Set"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (X Y : inst.Set)\n  (motive :\n    And (Chapter3.SetTheory.objects_mem_sets.mem X x) (Not (Chapter3.SetTheory.objects_mem_sets.mem Y x)) → Prop)\n  (h : And (Chapter3.SetTheory.objects_mem_sets.mem X x) (Not (Chapter3.SetTheory.objects_mem_sets.mem Y x))),\n  (∀ (hX : Chapter3.SetTheory.objects_mem_sets.mem X x) (hY : Not (Chapter3.SetTheory.objects_mem_sets.mem Y x)),\n      motive ⋯) →\n    motive h","name":["Chapter3","SetTheory","Set","mem_sdiff","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set), Eq (Chapter3.SetTheory.Set.instIntersection.inter A A) A","name":["Chapter3","SetTheory","Set","inter_self"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → self.Object → self.Set","name":["Chapter3","SetTheory","singleton"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A A' B : inst.Set),\n  Eq A A' → Eq (Chapter3.SetTheory.Set.instUnion.union A B) (Chapter3.SetTheory.Set.instUnion.union A' B)","name":["Chapter3","SetTheory","Set","union_congr_left"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["And","casesOn"]],"typeReferences":[["And","intro"],["Chapter3","SetTheory","Set"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (X Y : inst.Set)\n  (motive : And (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x) → Prop)\n  (h : And (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x)),\n  (∀ (hX : Chapter3.SetTheory.objects_mem_sets.mem X x) (hY : Chapter3.SetTheory.objects_mem_sets.mem Y x), motive ⋯) →\n    motive h","name":["Chapter3","SetTheory","Set","mem_inter","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → Type v","name":["Chapter3","SetTheory","Object"],"kind":"definition","isProp":false},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["Eq"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset A B → Chapter3.SetTheory.Set.instSubset.Subset B A → Eq A B","name":["Chapter3","SetTheory","Set","subset_antisymm"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Set"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"],["Set","instUnion"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Eq\n    (Set.instUnion.union (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    (Set.instUnion.union (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","coe_union"],"kind":"theorem","isProp":true},{"valueReferences":[["rfl"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat}, Eq (Chapter3.SetTheory.Object.instOfNat.ofNat n) n.cast","name":["Chapter3","SetTheory","Object","ofnat_eq'"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv_inj"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (n m : Nat), Eq (Eq n.cast m.cast) (Eq n m)","name":["Chapter3","SetTheory","Set","nat_equiv_inj","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","mem_union","_simp_1"],["True"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["congrArg"],["Chapter3","SetTheory","Set"],["iff_self"],["of_eq_true"],["Or"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Iff"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Object) (X : inst.Set),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instInsert.insert b X) a)\n    (Or (Eq a b) (Chapter3.SetTheory.objects_mem_sets.mem X a))","name":["Chapter3","SetTheory","Set","mem_insert"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Eq","refl"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","subtype_mk"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","subtype_mk"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} {x : inst.Object} (hx : Chapter3.SetTheory.objects_mem_sets.mem A x),\n  Eq (A.subtype_mk hx).val x","name":["Chapter3","SetTheory","Set","subtype_mk_coe"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Not"],["Exists"],["Chapter3","SetTheory","Set"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [self : Chapter3.SetTheory] (A : self.Set),\n  (Exists fun x => self.mem x A) →\n    Exists fun x =>\n      And (self.mem x A)\n        (∀ (S : self.Set),\n          Eq x (Function.instFunLikeEmbedding.coe self.set_to_object S) →\n            Not (Exists fun y => And (self.mem y A) (self.mem y S)))","name":["Chapter3","SetTheory","regularity_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["HasSSubset","SSubset"],["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["And"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Ne"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","instSSubset"]],"typeReferences":[["Not"],["HasSSubset","SSubset"],["Exists"],["Singleton","singleton"],["And"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Ne"],["Eq"],["Chapter3","SetTheory","Set","instSSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set),\n  Ne A Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n    Iff\n      (Not\n        (Exists fun B =>\n          And (Chapter3.SetTheory.Set.instSSubset.SSubset B A) (Ne B Chapter3.SetTheory.Set.instEmpty.emptyCollection)))\n      (Exists fun x => Eq A (Chapter3.SetTheory.Set.instSingleton.singleton x))","name":["Chapter3","SetTheory","Set","singleton_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instUnion.union A B) (Chapter3.SetTheory.Set.instUnion.union B A)","name":["Chapter3","SetTheory","Set","union_comm"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","mem_singleton"],["Chapter3","SetTheory","Set"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instSingleton.singleton a) x) (Eq x a)","name":["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","instNatCast"],["Chapter3","Nat"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["NatCast"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["Chapter3","SetTheory","Set","instNatCast"],["NatCast","mk"],["Nat"],["Chapter3","Nat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","toSubtype"],["NatCast"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Eq Chapter3.SetTheory.Set.instNatCast\n    { natCast := fun n => EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv n }","name":["Chapter3","SetTheory","Set","instNatCast","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","instNatCast"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["OfNat","mk"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Nat"],["OfNat"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {n : Nat} → OfNat inst.Object n","name":["Chapter3","SetTheory","Object","instOfNat"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","nat_coe_eq_iff"],["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat"],["Nat","cast"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory] {m n : Nat}, Eq (Eq m.cast (Chapter3.SetTheory.Object.instOfNat.ofNat n)) (Eq m n)","name":["Chapter3","SetTheory","Set","nat_coe_eq_iff","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Subtype"],["Chapter3","SetTheory","Set"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Eq"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] →\n  (A : self.Set) →\n    (P : (Subtype fun x => self.mem x A) → self.Object → Prop) →\n      (∀ (x : Subtype fun x => self.mem x A) (y y' : self.Object), And (P x y) (P x y') → Eq y y') → self.Set","name":["Chapter3","SetTheory","replace"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["Membership","mem"],["And"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","mem_sdiff"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["propext"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["Membership","mem"],["And"],["SDiff","sdiff"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object) (X Y : inst.Set),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.instSDiff.sdiff X Y) x)\n    (And (Chapter3.SetTheory.objects_mem_sets.mem X x) (Not (Chapter3.SetTheory.objects_mem_sets.mem Y x)))","name":["Chapter3","SetTheory","Set","mem_sdiff","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set"],["sorryAx"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A A' B : inst.Set},\n  Eq A A' → Chapter3.SetTheory.Set.instSubset.Subset A B → Chapter3.SetTheory.Set.instSubset.Subset A' B","name":["Chapter3","SetTheory","Set","subset_congr_left"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Singleton","mk"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","singleton"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Singleton"]],"type":"[inst : Chapter3.SetTheory] → Singleton inst.Object inst.Set","name":["Chapter3","SetTheory","Set","instSingleton"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["Inter","mk"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Inter"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Inter inst.Set","name":["Chapter3","SetTheory","Set","instIntersection"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["And"],["Chapter3","SetTheory","Set","subset_inter_iff"],["Chapter3","SetTheory","Set","instSubset"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["And"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instSubset.Subset C (Chapter3.SetTheory.Set.instIntersection.inter A B))\n    (And (Chapter3.SetTheory.Set.instSubset.Subset C A) (Chapter3.SetTheory.Set.instSubset.Subset C B))","name":["Chapter3","SetTheory","Set","subset_inter_iff","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.instIntersection.inter A B) C)\n    (Chapter3.SetTheory.Set.instIntersection.inter A (Chapter3.SetTheory.Set.instIntersection.inter B C))","name":["Chapter3","SetTheory","Set","inter_assoc"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → Type u","name":["Chapter3","SetTheory","Set"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A X : inst.Set},\n  Chapter3.SetTheory.Set.instSubset.Subset A X → Eq (Chapter3.SetTheory.Set.instUnion.union X A) X","name":["Chapter3","SetTheory","Set","union_subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Nat","cast"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Subtype","val"],["Equiv"],["congrArg"],["Equiv","symm_apply_apply"],["EquivLike","toFunLike"],["Subtype","coe_eta"],["Equiv","symm"],["Eq"],["Eq","ndrec"],["Chapter3","SetTheory","Object","instNatCast"],["True"],["eq_self"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Chapter3","SetTheory","Object","instNatCast"],["Equiv","instEquivLike"],["Nat","cast"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Equiv"],["Nat"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["Equiv","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat} {hn : Chapter3.SetTheory.objects_mem_sets.mem inst.nat n.cast},\n  Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm ⟨n.cast, hn⟩) n","name":["Chapter3","SetTheory","Object","ofnat_eq'''"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set"],["sorryAx"],["Chapter3","SetTheory","Set","specify"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["Eq"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A A' : inst.Set},\n  Eq A A' →\n    ∀ {P : A.toSubtype → Prop} {P' : A'.toSubtype → Prop},\n      (∀ (x : inst.Object) (h : Chapter3.SetTheory.objects_mem_sets.mem A x)\n          (h' : Chapter3.SetTheory.objects_mem_sets.mem A' x), Iff (P ⟨x, h⟩) (P' ⟨x, h'⟩)) →\n        Eq (A.specify P) (A'.specify P')","name":["Chapter3","SetTheory","Set","specify_congr"],"kind":"theorem","isProp":true},{"valueReferences":[["HEq","refl"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Iff","rfl"],["Eq","casesOn"],["Iff","intro"],["Chapter3","SetTheory","Set"],["Iff"],["Eq","refl"],["Chapter3","SetTheory","Set","ext"],["HEq"],["Eq","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Eq","ndrec"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set},\n  Iff (Eq X Y)\n    (∀ (x : inst.Object),\n      Iff (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","ext_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Chapter3","SetTheory","specify"],["Iff"],["And","right"],["Chapter3","SetTheory","specification_axiom"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} (P : A.toSubtype → Prop) (x : A.toSubtype),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (A.specify P) x.val) (P x)","name":["Chapter3","SetTheory","Set","specification_axiom'"],"kind":"theorem","isProp":true},{"valueReferences":[["HasSSubset","SSubset"],["Nat"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","instSSubset"]],"typeReferences":[["HasSSubset","SSubset"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Chapter3.SetTheory.Set.instSSubset.SSubset A B →\n    Chapter3.SetTheory.Set.instSSubset.SSubset B C → Chapter3.SetTheory.Set.instSSubset.SSubset A C","name":["Chapter3","SetTheory","Set","ssubset_trans"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Subtype"],["HEq","refl"],["Chapter3","SetTheory","noConfusionType"],["Eq","refl"],["Function","Embedding"],["And"],["Chapter3","SetTheory","casesOn"],["Eq"],["Eq","ndrec"],["Chapter3","SetTheory"],["Equiv"]],"typeReferences":[["Chapter3","SetTheory","noConfusionType"],["Eq"],["Chapter3","SetTheory"]],"type":"{P : Sort u_1} → {x1 x2 : Chapter3.SetTheory} → Eq x1 x2 → Chapter3.SetTheory.noConfusionType P x1 x2","name":["Chapter3","SetTheory","noConfusion"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A B C : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instUnion.union A (Chapter3.SetTheory.Set.instIntersection.inter B C))\n    (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.instUnion.union A B)\n      (Chapter3.SetTheory.Set.instUnion.union A C))","name":["Chapter3","SetTheory","Set","union_inter_distrib_left"],"kind":"theorem","isProp":true},{"valueReferences":[["HasSSubset","SSubset"],["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Set"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSSubset"],["Set","instHasSSubset"],["setOf"]],"typeReferences":[["HasSSubset","SSubset"],["Chapter3","SetTheory","Set"],["Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSSubset"],["setOf"],["Set","instHasSSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Iff\n    (Set.instHasSSubset.SSubset (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x)\n      (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x))\n    (Chapter3.SetTheory.Set.instSSubset.SSubset X Y)","name":["Chapter3","SetTheory","Set","coe_ssubset"],"kind":"theorem","isProp":true},{"valueReferences":[["Membership","mk"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Object"],["Membership"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Membership inst.Object inst.Set","name":["Chapter3","SetTheory","objects_mem_sets"],"kind":"definition","isProp":false},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → Function.Embedding self.Set self.Object","name":["Chapter3","SetTheory","set_to_object"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset b (Chapter3.SetTheory.Set.instUnion.union a b)","name":["Chapter3","SetTheory","Set","instDistribLattice","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","specify"],["Subtype"],["Chapter3","SetTheory","Set"],["Iff"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [self : Chapter3.SetTheory] (A : self.Set) (P : (Subtype fun x => self.mem x A) → Prop),\n  And (∀ (x : self.Object), self.mem x (self.specify A P) → self.mem x A)\n    (∀ (x : Subtype fun x => self.mem x A), Iff (self.mem x.val (self.specify A P)) (P x))","name":["Chapter3","SetTheory","specification_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","instNatCast"],["Chapter3","SetTheory","Object","ofnat_eq"],["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Eq","symm"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Object","instNatCast"],["Nat","cast"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {n : Nat}, Eq n.cast n.cast.val","name":["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","rec"]],"typeReferences":[["Not"],["Subtype"],["Exists"],["Function","Embedding"],["And"],["Chapter3","SetTheory"],["Subtype","val"],["DFunLike","coe"],["Equiv"],["Nat"],["Or"],["Chapter3","SetTheory","mk"],["Iff"],["Function","instFunLikeEmbedding"],["Eq"]],"type":"{motive : Chapter3.SetTheory → Sort u_1} →\n  (t : Chapter3.SetTheory) →\n    ((Set : Type u) →\n        (Object : Type v) →\n          (set_to_object : Function.Embedding Set Object) →\n            (mem : Object → Set → Prop) →\n              (extensionality : ∀ (X Y : Set), (∀ (x : Object), Iff (mem x X) (mem x Y)) → Eq X Y) →\n                (emptyset : Set) →\n                  (emptyset_mem : ∀ (x : Object), Not (mem x emptyset)) →\n                    (singleton : Object → Set) →\n                      (singleton_axiom : ∀ (x y : Object), Iff (mem x (singleton y)) (Eq x y)) →\n                        (union_pair : Set → Set → Set) →\n                          (union_pair_axiom :\n                              ∀ (X Y : Set) (x : Object), Iff (mem x (union_pair X Y)) (Or (mem x X) (mem x Y))) →\n                            (specify : (A : Set) → ((Subtype fun x => mem x A) → Prop) → Set) →\n                              (specification_axiom :\n                                  ∀ (A : Set) (P : (Subtype fun x => mem x A) → Prop),\n                                    And (∀ (x : Object), mem x (specify A P) → mem x A)\n                                      (∀ (x : Subtype fun x => mem x A), Iff (mem x.val (specify A P)) (P x))) →\n                                (replace :\n                                    (A : Set) →\n                                      (P : (Subtype fun x => mem x A) → Object → Prop) →\n                                        (∀ (x : Subtype fun x => mem x A) (y y' : Object),\n                                            And (P x y) (P x y') → Eq y y') →\n                                          Set) →\n                                  (replacement_axiom :\n                                      ∀ (A : Set) (P : (Subtype fun x => mem x A) → Object → Prop)\n                                        (hP :\n                                          ∀ (x : Subtype fun x => mem x A) (y y' : Object),\n                                            And (P x y) (P x y') → Eq y y')\n                                        (y : Object), Iff (mem y (replace A P hP)) (Exists fun x => P x y)) →\n                                    (nat : Set) →\n                                      (nat_equiv : Equiv Nat (Subtype fun x => mem x nat)) →\n                                        (regularity_axiom :\n                                            ∀ (A : Set),\n                                              (Exists fun x => mem x A) →\n                                                Exists fun x =>\n                                                  And (mem x A)\n                                                    (∀ (S : Set),\n                                                      Eq x (Function.instFunLikeEmbedding.coe set_to_object S) →\n                                                        Not (Exists fun y => And (mem y A) (mem y S)))) →\n                                          (pow : Set → Set → Set) →\n                                            (function_to_object :\n                                                (X Y : Set) →\n                                                  Function.Embedding\n                                                    ((Subtype fun x => mem x X) → Subtype fun x => mem x Y) Object) →\n                                              (powerset_axiom :\n                                                  ∀ (X Y : Set) (F : Object),\n                                                    Iff (mem F (pow X Y))\n                                                      (Exists fun f =>\n                                                        Eq\n                                                          (Function.instFunLikeEmbedding.coe (function_to_object Y X) f)\n                                                          F)) →\n                                                (union : Set → Set) →\n                                                  (union_axiom :\n                                                      ∀ (A : Set) (x : Object),\n                                                        Iff (mem x (union A))\n                                                          (Exists fun S =>\n                                                            And (mem x S)\n                                                              (mem (Function.instFunLikeEmbedding.coe set_to_object S)\n                                                                A))) →\n                                                    motive\n                                                      { Set := Set, Object := Object, set_to_object := set_to_object,\n                                                        mem := mem, extensionality := extensionality,\n                                                        emptyset := emptyset, emptyset_mem := emptyset_mem,\n                                                        singleton := singleton, singleton_axiom := singleton_axiom,\n                                                        union_pair := union_pair, union_pair_axiom := union_pair_axiom,\n                                                        specify := specify, specification_axiom := specification_axiom,\n                                                        replace := replace, replacement_axiom := replacement_axiom,\n                                                        nat := nat, nat_equiv := nat_equiv,\n                                                        regularity_axiom := regularity_axiom, pow := pow,\n                                                        function_to_object := function_to_object,\n                                                        powerset_axiom := powerset_axiom, union := union,\n                                                        union_axiom := union_axiom }) →\n      motive t","name":["Chapter3","SetTheory","casesOn"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","instNatCast"],["NatCast","mk"],["Nat","cast"],["Chapter3","Nat"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Object"],["NatCast"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → NatCast inst.Object","name":["Chapter3","SetTheory","Object","instNatCast"],"kind":"definition","isProp":false},{"valueReferences":[],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[self : Chapter3.SetTheory] → self.Object → self.Set → Prop","name":["Chapter3","SetTheory","mem"],"kind":"definition","isProp":false},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (a b : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instIntersection.inter a b) b","name":["Chapter3","SetTheory","Set","instDistribLattice","_proof_6"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Function","Embedding"],["Coe","mk"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["DFunLike","coe"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Coe"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Coe inst.Set inst.Object","name":["Chapter3","SetTheory","sets_are_objects"],"kind":"definition","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Set","Elem"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"],["Set","Elem"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (X : inst.Set),\n  Eq (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem X x).Elem X.toSubtype","name":["Chapter3","SetTheory","Set","coe_subtype"],"kind":"theorem","isProp":true},{"valueReferences":[],"typeReferences":[["Exists"],["Subtype"],["Chapter3","SetTheory","Set"],["Iff"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","replace"]],"type":"∀ [self : Chapter3.SetTheory] (A : self.Set) (P : (Subtype fun x => self.mem x A) → self.Object → Prop)\n  (hP : ∀ (x : Subtype fun x => self.mem x A) (y y' : self.Object), And (P x y) (P x y') → Eq y y') (y : self.Object),\n  Iff (self.mem y (self.replace A P hP)) (Exists fun x => P x y)","name":["Chapter3","SetTheory","replacement_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {A B A' B' : inst.Set},\n  Chapter3.SetTheory.Set.instSubset.Subset A' A →\n    Chapter3.SetTheory.Set.instSubset.Subset B' B →\n      Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.instUnion.union A' B')\n        (Chapter3.SetTheory.Set.instUnion.union A B)","name":["Chapter3","SetTheory","Set","subset_union_subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","emptyset_mem"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.Object),\n  Not (Chapter3.SetTheory.objects_mem_sets.mem Chapter3.SetTheory.Set.instEmpty.emptyCollection x)","name":["Chapter3","SetTheory","Set","not_mem_empty"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","coe_eq"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Eq","ndrec"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory","set_to_object"],["Iff","intro"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Iff\n    (Eq (Function.instFunLikeEmbedding.coe inst.set_to_object X)\n      (Function.instFunLikeEmbedding.coe inst.set_to_object Y))\n    (Eq X Y)","name":["Chapter3","SetTheory","Set","coe_eq_iff"],"kind":"theorem","isProp":true}]
