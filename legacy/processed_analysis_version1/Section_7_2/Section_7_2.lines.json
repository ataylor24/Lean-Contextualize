[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":57},{"state":[],"start":58},{"state":[],"start":62},{"state":[],"start":105},{"state":[],"start":106},{"state":[],"start":202},{"state":[],"start":290},{"state":[],"start":385},{"state":[],"start":478},{"state":[],"start":488},{"state":[],"start":489},{"state":[],"start":537},{"state":[],"start":538},{"state":[],"start":572},{"state":[],"start":615},{"state":[],"start":616},{"state":[],"start":619},{"state":[],"start":620},{"state":[],"start":639},{"state":[],"start":640},{"state":[],"start":658},{"state":[],"start":659},{"state":[],"start":663},{"state":[],"start":754},{"state":[],"start":840},{"state":[],"start":843},{"state":[],"start":850},{"state":[],"start":873},{"state":[],"start":883},{"state":[],"start":903},{"state":[],"start":935},{"state":[],"start":936},{"state":[],"start":998},{"state":[],"start":1055},{"state":[],"start":1076},{"state":[],"start":1087},{"state":[],"start":1133},{"state":[],"start":1156},{"state":[],"start":1160},{"state":[],"start":1161},{"state":[],"start":1169},{"state":[],"start":1256},{"state":[],"start":1257},{"state":[],"start":1328},{"state":[],"start":1337},{"state":[],"start":1388},{"state":[],"start":1409},{"state":[],"start":1410},{"state":[],"start":1497},{"state":[],"start":1554},{"state":[],"start":1555},{"state":[],"start":1603},{"state":[],"start":1691},{"state":[],"start":1692},{"state":[{"type":"s.partial (N + 1) = s.partial N + s.seq (N + 1)","tag":[],"mvarId":["_uniq",9072],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",9069],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",9070],"binderInfo":"implicit"},{"type":"N ≥ s.m - 1","name":["h"],"isProp":true,"id":["_uniq",9071],"binderInfo":"default"}]}],"start":1810},{"state":[{"type":"∑ n ∈ Finset.Icc s.m (N + 1), s.seq n = ∑ n ∈ Finset.Icc s.m N, s.seq n + s.seq (N + 1)","tag":[],"mvarId":["_uniq",9073],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",9069],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",9070],"binderInfo":"implicit"},{"type":"N ≥ s.m - 1","name":["h"],"isProp":true,"id":["_uniq",9071],"binderInfo":"default"}]}],"start":1834},{"state":[{"type":"∑ n ∈ Finset.Icc s.m (N + 1), s.seq n = s.seq (N + 1) + s.partial N","tag":[],"mvarId":["_uniq",9133],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",9069],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",9070],"binderInfo":"implicit"},{"type":"N ≥ s.m - 1","name":["h"],"isProp":true,"id":["_uniq",9071],"binderInfo":"default"}]}],"start":1866},{"state":[{"type":"Finset.Icc s.m (N + 1) = insert (N + 1) (Finset.Icc s.m N)","tag":["h","e'_2","h"],"mvarId":["_uniq",14609],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",9069],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",9070],"binderInfo":"implicit"},{"type":"N ≥ s.m - 1","name":["h"],"isProp":true,"id":["_uniq",9071],"binderInfo":"default"}]}],"start":1934},{"state":[],"start":1997},{"state":[],"start":1998},{"state":[{"type":"s.partial N = 0","tag":[],"mvarId":["_uniq",17665],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",17662],"binderInfo":"implicit"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",17663],"binderInfo":"implicit"},{"type":"N < s.m","name":["h"],"isProp":true,"id":["_uniq",17664],"binderInfo":"default"}]}],"start":2085},{"state":[{"type":"∑ n ∈ Finset.Icc s.m N, s.seq n = 0","tag":[],"mvarId":["_uniq",17666],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",17662],"binderInfo":"implicit"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",17663],"binderInfo":"implicit"},{"type":"N < s.m","name":["h"],"isProp":true,"id":["_uniq",17664],"binderInfo":"default"}]}],"start":2109},{"state":[{"type":"∀ x ∈ Finset.Icc s.m N, s.seq x = 0","tag":[],"mvarId":["_uniq",17954],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",17662],"binderInfo":"implicit"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",17663],"binderInfo":"implicit"},{"type":"N < s.m","name":["h"],"isProp":true,"id":["_uniq",17664],"binderInfo":"default"}]}],"start":2135},{"state":[],"start":2167},{"state":[],"start":2168},{"state":[],"start":2267},{"state":[],"start":2268},{"state":[],"start":2338},{"state":[],"start":2339},{"state":[],"start":2399},{"state":[],"start":2400},{"state":[],"start":2418},{"state":[],"start":2512},{"state":[],"start":2513},{"state":[],"start":2597},{"state":[],"start":2625},{"state":[],"start":2626},{"state":[],"start":2646},{"state":[{"type":"s.sum = L","tag":[],"mvarId":["_uniq",21926],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21923],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",21924],"binderInfo":"implicit"},{"type":"s.convergesTo L","name":["h"],"isProp":true,"id":["_uniq",21925],"binderInfo":"default"}]}],"start":2738},{"state":[{"type":"Exists.choose ⋯ = L","tag":[],"mvarId":["_uniq",22087],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",21923],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",21924],"binderInfo":"implicit"},{"type":"s.convergesTo L","name":["h"],"isProp":true,"id":["_uniq",21925],"binderInfo":"default"}]}],"start":2779},{"state":[],"start":2852},{"state":[],"start":2853},{"state":[],"start":2955},{"state":[],"start":2994},{"state":[],"start":2995},{"state":[{"type":"s.convergesTo s.sum","tag":[],"mvarId":["_uniq",23121],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",23119],"binderInfo":"implicit"},{"type":"s.converges","name":["h"],"isProp":true,"id":["_uniq",23120],"binderInfo":"default"}]}],"start":3084},{"state":[],"start":3121},{"state":[],"start":3122},{"state":[],"start":3143},{"state":[],"start":3230},{"state":[],"start":3231},{"state":[{"type":"example_7_2_4.partial N = 1 - 2 ^ (-N)","tag":[],"mvarId":["_uniq",23822],"isProp":true,"context":[{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",23820],"binderInfo":"implicit"},{"type":"N ≥ 1","name":["hN"],"isProp":true,"id":["_uniq",23821],"binderInfo":"default"}]}],"start":3334},{"state":[],"start":3342},{"state":[],"start":3343},{"state":[],"start":3415},{"state":[],"start":3416},{"state":[],"start":3482},{"state":[],"start":3483},{"state":[],"start":3570},{"state":[],"start":3571},{"state":[{"type":"example_7_2_4'.partial N = 2 ^ (N + 1) - 2","tag":[],"mvarId":["_uniq",24364],"isProp":true,"context":[{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",24362],"binderInfo":"implicit"},{"type":"N ≥ 1","name":["hN"],"isProp":true,"id":["_uniq",24363],"binderInfo":"default"}]}],"start":3677},{"state":[],"start":3685},{"state":[],"start":3686},{"state":[],"start":3755},{"state":[],"start":3756},{"state":[],"start":3798},{"state":[],"start":3851},{"state":[{"type":"s.converges ↔ ∀ ε > 0, ∃ N ≥ s.m, ∀ p ≥ N, ∀ q ≥ N, |∑ n ∈ Finset.Icc p q, s.seq n| ≤ ε","tag":[],"mvarId":["_uniq",24943],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",24942],"binderInfo":"default"}]}],"start":3973},{"state":[],"start":3981},{"state":[],"start":3982},{"state":[],"start":4034},{"state":[],"start":4098},{"state":[{"type":"Filter.Tendsto s.seq Filter.atTop (nhds 0)","tag":[],"mvarId":["_uniq",25250],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",25248],"binderInfo":"implicit"},{"type":"s.converges","name":["h"],"isProp":true,"id":["_uniq",25249],"binderInfo":"default"}]}],"start":4144},{"state":[],"start":4152},{"state":[],"start":4153},{"state":[],"start":4245},{"state":[{"type":"s.diverges","tag":[],"mvarId":["_uniq",25557],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",25555],"binderInfo":"implicit"},{"type":"¬Filter.Tendsto s.seq Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",25556],"binderInfo":"default"}]}],"start":4266},{"state":[],"start":4274},{"state":[],"start":4275},{"state":[],"start":4296},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => 1) n.toNat else 0, vanish := ⋯ }.diverges","tag":[],"mvarId":["_uniq",25674],"isProp":true,"context":[]}],"start":4375},{"state":[{"type":"¬Filter.Tendsto { m := 0, seq := fun n => if n ≥ 0 then (fun n => 1) n.toNat else 0, vanish := ⋯ }.seq Filter.atTop\n    (nhds 0)","tag":["h"],"mvarId":["_uniq",25680],"isProp":true,"context":[]}],"start":4403},{"state":[],"start":4411},{"state":[],"start":4412},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (-1) ^ n) n.toNat else 0, vanish := ⋯ }.diverges","tag":[],"mvarId":["_uniq",25876],"isProp":true,"context":[]}],"start":4495},{"state":[{"type":"¬Filter.Tendsto { m := 0, seq := fun n => if n ≥ 0 then (fun n => (-1) ^ n) n.toNat else 0, vanish := ⋯ }.seq\n    Filter.atTop (nhds 0)","tag":["h"],"mvarId":["_uniq",25882],"isProp":true,"context":[]}],"start":4523},{"state":[],"start":4531},{"state":[],"start":4532},{"state":[],"start":4579},{"state":[],"start":4655},{"state":[],"start":4656},{"state":[],"start":4720},{"state":[],"start":4721},{"state":[],"start":4804},{"state":[],"start":4805},{"state":[],"start":4874},{"state":[{"type":"s.converges","tag":[],"mvarId":["_uniq",26360],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",26358],"binderInfo":"implicit"},{"type":"s.absConverges","name":["h"],"isProp":true,"id":["_uniq",26359],"binderInfo":"default"}]}],"start":4967},{"state":[],"start":4975},{"state":[],"start":4976},{"state":[{"type":"|s.sum| ≤ s.abs.sum","tag":[],"mvarId":["_uniq",26400],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",26398],"binderInfo":"implicit"},{"type":"s.absConverges","name":["h"],"isProp":true,"id":["_uniq",26399],"binderInfo":"default"}]}],"start":5060},{"state":[],"start":5068},{"state":[],"start":5069},{"state":[],"start":5121},{"state":[],"start":5221},{"state":[],"start":5243},{"state":[{"type":"(mk' fun n => (-1) ^ (↑n : ℤ) * a n).converges ↔ Filter.Tendsto a Filter.atTop (nhds 0)","tag":[],"mvarId":["_uniq",27165],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"}]}],"start":5338},{"state":[{"type":"(mk' fun n => (-1) ^ (↑n : ℤ) * a n).converges ↔ Filter.Tendsto a Filter.atTop (nhds 0)","tag":[],"mvarId":["_uniq",27165],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"}]}],"start":5411},{"state":[{"type":"(mk' fun n => (-1) ^ (↑n : ℤ) * a n).converges → Filter.Tendsto a Filter.atTop (nhds 0)","tag":["mp"],"mvarId":["_uniq",27172],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"}]},{"type":"Filter.Tendsto a Filter.atTop (nhds 0) → (mk' fun n => (-1) ^ (↑n : ℤ) * a n).converges","tag":["mpr"],"mvarId":["_uniq",27173],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"}]}],"start":5425},{"state":[{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","tag":["mp"],"mvarId":["_uniq",27186],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto (mk' fun n => (-1) ^ (↑n : ℤ) * a n).seq Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",27183],"binderInfo":"default"}]}],"start":5468},{"state":[{"type":"Filter.Tendsto (fun b => dist (a b) 0) Filter.atTop (nhds 0)","tag":["mp"],"mvarId":["_uniq",27408],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto (fun b => dist ((mk' fun n => (-1) ^ (↑n : ℤ) * a n).seq b) 0) Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",27312],"binderInfo":"default"}]}],"start":5516},{"state":[{"type":"Filter.Tendsto (fun b => dist (a b) 0) Filter.atTop (nhds 0)","tag":["mp"],"mvarId":["_uniq",27675],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => dist ((mk' fun n => (-1) ^ (↑n : ℤ) * a n).seq (↑x : ℤ)) 0) Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",27672],"binderInfo":"default"}]}],"start":5576},{"state":[{"type":"dist (a n) 0 = dist ((mk' fun n => (-1) ^ (↑n : ℤ) * a n).seq (↑n : ℤ)) 0","tag":["h","e'_3","h","h"],"mvarId":["_uniq",29103],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => dist ((mk' fun n => (-1) ^ (↑n : ℤ) * a n).seq (↑x : ℤ)) 0) Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",27672],"binderInfo":"default"},{"type":"{ n // n ≥ m } = (↑(Set.Ici m) : Type)","name":["e_1✝"],"isProp":true,"id":["_uniq",28933],"binderInfo":"default"},{"type":"{ n // n ≥ m }","name":["n"],"isProp":false,"id":["_uniq",29102],"binderInfo":"default"}]}],"start":5607},{"state":[{"type":"Filter.Tendsto a Filter.atTop (nhds 0) → (mk' fun n => (-1) ^ (↑n : ℤ) * a n).converges","tag":["mpr"],"mvarId":["_uniq",27173],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"}]}],"start":5629},{"state":[{"type":"(mk' fun n => (-1) ^ (↑n : ℤ) * a n).converges","tag":["mpr"],"mvarId":["_uniq",32191],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"}]}],"start":5639},{"state":[{"type":"∃ L, Filter.Tendsto (mk' fun n => (-1) ^ (↑n : ℤ) * a n).partial Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",32194],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"}]}],"start":5670},{"state":[{"type":"∃ L, Filter.Tendsto b.partial Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",32502],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]}]}],"start":5716},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",32583],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]}]}],"start":5737},{"state":[{"type":"S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","tag":[],"mvarId":["_uniq",35043],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",32655],"binderInfo":"implicit"},{"type":"N ≥ m","name":["hN"],"isProp":true,"id":["_uniq",32663],"binderInfo":"default"}]}],"start":5834},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",35046],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]}]}],"start":5909},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",50461],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]}]}],"start":6036},{"state":[{"type":"S (N + 2) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩ + (-1) ^ (N + 2) * a ⟨N + 2, ⋯⟩","tag":[],"mvarId":["_uniq",49621],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",40402],"binderInfo":"implicit"},{"type":"N ≥ m","name":["hN"],"isProp":true,"id":["_uniq",40410],"binderInfo":"default"}]}],"start":6140},{"state":[],"start":6219},{"state":[{"type":"S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩ + (-1) ^ (N + 2) * a ⟨N + 2, ⋯⟩ =\n  S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩ + -1 * (-1) ^ (N + 1) * a ⟨N + 2, ⋯⟩","tag":[],"mvarId":["_uniq",50312],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",40402],"binderInfo":"implicit"},{"type":"N ≥ m","name":["hN"],"isProp":true,"id":["_uniq",40410],"binderInfo":"default"}]}],"start":6324},{"state":[],"start":6373},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",50461],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]}]}],"start":6396},{"state":[{"type":"S (N + 2) ≥ S N","tag":[],"mvarId":["_uniq",77835],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",77650],"binderInfo":"implicit"},{"type":"N ≥ m","name":["hN"],"isProp":true,"id":["_uniq",77658],"binderInfo":"default"},{"type":"Odd N","name":["h'"],"isProp":true,"id":["_uniq",77749],"binderInfo":"default"}]}],"start":6468},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",77841],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]}]}],"start":6531},{"state":[{"type":"S (N + 2) ≤ S N","tag":[],"mvarId":["_uniq",84572],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",84315],"binderInfo":"implicit"},{"type":"N ≥ m","name":["hN"],"isProp":true,"id":["_uniq",84322],"binderInfo":"default"},{"type":"Even N","name":["h'"],"isProp":true,"id":["_uniq",84487],"binderInfo":"default"}]}],"start":6604},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",84578],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]}]}],"start":6667},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",91547],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]}]}],"start":6754},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",102442],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]}]}],"start":6869},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",102997],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]}]}],"start":6964},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",119029],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]}]}],"start":7029},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",119029],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]}]}],"start":7201},{"state":[{"type":"S N - a ⟨N + 1, ⋯⟩ ≤ S n ∧ S n ≤ S N","tag":[],"mvarId":["_uniq",138093],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",119035],"binderInfo":"implicit"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",119037],"binderInfo":"implicit"},{"type":"N ≥ m","name":["hN"],"isProp":true,"id":["_uniq",119044],"binderInfo":"default"},{"type":"Even N","name":["h'"],"isProp":true,"id":["_uniq",119210],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",119215],"binderInfo":"default"}]}],"start":7326},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",138096],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]},{"value":"fun {N n} hN h' hn => sorry","type":"∀ {N n : ℤ} (hN : N ≥ m) (h' : Even N) (hn : n ≥ N), S N - a ⟨N + 1, ⋯⟩ ≤ S n ∧ S n ≤ S N","name":["why4"],"isProp":true,"id":["_uniq",138095]}]}],"start":7336},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",138640],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]},{"value":"fun {N n} hN h' hn => sorry","type":"∀ {N n : ℤ} (hN : N ≥ m) (h' : Even N) (hn : n ≥ N), S N - a ⟨N + 1, ⋯⟩ ≤ S n ∧ S n ≤ S N","name":["why4"],"isProp":true,"id":["_uniq",138095]},{"value":"fun {ε} hε => sorry","type":"∀ {ε : ℝ}, ε > 0 → ∃ N, ∀ n ≥ N, ∀ m ≥ N, |S n - S m| ≤ ε","name":["why5"],"isProp":true,"id":["_uniq",138639]}]}],"start":7437},{"state":[{"type":"CauchySeq S","tag":[],"mvarId":["_uniq",138888],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]},{"value":"fun {N n} hN h' hn => sorry","type":"∀ {N n : ℤ} (hN : N ≥ m) (h' : Even N) (hn : n ≥ N), S N - a ⟨N + 1, ⋯⟩ ≤ S n ∧ S n ≤ S N","name":["why4"],"isProp":true,"id":["_uniq",138095]},{"value":"fun {ε} hε => sorry","type":"∀ {ε : ℝ}, ε > 0 → ∃ N, ∀ n ≥ N, ∀ m ≥ N, |S n - S m| ≤ ε","name":["why5"],"isProp":true,"id":["_uniq",138639]}]}],"start":7464},{"state":[{"type":"∀ ε > 0, ∃ N, ∀ n ≥ N, dist (S n) (S N) < ε","tag":[],"mvarId":["_uniq",139403],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]},{"value":"fun {N n} hN h' hn => sorry","type":"∀ {N n : ℤ} (hN : N ≥ m) (h' : Even N) (hn : n ≥ N), S N - a ⟨N + 1, ⋯⟩ ≤ S n ∧ S n ≤ S N","name":["why4"],"isProp":true,"id":["_uniq",138095]},{"value":"fun {ε} hε => sorry","type":"∀ {ε : ℝ}, ε > 0 → ∃ N, ∀ n ≥ N, ∀ m ≥ N, |S n - S m| ≤ ε","name":["why5"],"isProp":true,"id":["_uniq",138639]}]}],"start":7495},{"state":[{"type":"∀ n ≥ N, dist (S n) (S N) < ε","tag":["h"],"mvarId":["_uniq",139703],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]},{"value":"fun {N n} hN h' hn => sorry","type":"∀ {N n : ℤ} (hN : N ≥ m) (h' : Even N) (hn : n ≥ N), S N - a ⟨N + 1, ⋯⟩ ≤ S n ∧ S n ≤ S N","name":["why4"],"isProp":true,"id":["_uniq",138095]},{"value":"fun {ε} hε => sorry","type":"∀ {ε : ℝ}, ε > 0 → ∃ N, ∀ n ≥ N, ∀ m ≥ N, |S n - S m| ≤ ε","name":["why5"],"isProp":true,"id":["_uniq",138639]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",139467],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",139470],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",139689],"binderInfo":"default"},{"type":"∀ n ≥ N, ∀ m ≥ N, |S n - S m| ≤ ε / 2","name":["hN"],"isProp":true,"id":["_uniq",139692],"binderInfo":"default"}]}],"start":7558},{"state":[{"type":"∃ L, Filter.Tendsto S Filter.atTop (nhds L)","tag":["mpr"],"mvarId":["_uniq",138890],"isProp":true,"context":[{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",27160],"binderInfo":"implicit"},{"type":"{ n // n ≥ m } → ℝ","name":["a"],"isProp":false,"id":["_uniq",27161],"binderInfo":"implicit"},{"type":"∀ (n : { n // n ≥ m }), a n ≥ 0","name":["ha"],"isProp":true,"id":["_uniq",27162],"binderInfo":"default"},{"type":"Antitone a","name":["ha'"],"isProp":true,"id":["_uniq",27163],"binderInfo":"default"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["h"],"isProp":true,"id":["_uniq",32190],"binderInfo":"default"},{"value":"mk' fun n => (-1) ^ (↑n : ℤ) * a n","type":"Series","name":["b"],"isProp":false,"id":["_uniq",32481]},{"value":"b.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",32561]},{"value":"fun {N} hN =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (S (N + 1)) (b.partial (N + 1)) (Eq.refl (S (N + 1)))\n        (S N + (-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.partial N + b.seq (N + 1))\n        (eq_of_heq\n          ((fun α β γ self a a_1 a' e'_6 =>\n              Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_6 ≍ x → a + a_1 ≍ a + a') e'_6\n                (fun h =>\n                  Eq.ndrec (motive := fun a' => ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a + a_1 ≍ a + a')\n                    (fun e_6 h => HEq.refl (a + a_1)) (Eq.symm h) e'_6)\n                (Eq.refl a') (HEq.refl e'_6))\n            ℝ ℝ ℝ instHAdd (S N) ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩) (b.seq (N + 1))\n            (of_eq_true\n              (Eq.trans\n                (congrArg (Eq ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))\n                  (dite_cond_eq_true\n                    (Eq.trans ge_iff_le._simp_1\n                      (eq_true\n                        (have this := converges_of_alternating._proof_1 hN;\n                        this)))))\n                (eq_self ((-1) ^ (N + 1) * a ⟨N + 1, converges_of_alternating._proof_1 hN⟩))))))))\n    (partial_succ b\n      (le_of_not_gt fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf m) (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (m ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        (m ^ Nat.rawCast 1 * Nat.rawCast 1 + (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b.m)\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (m ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul m (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ⋯ ⋯) ⋯\n                            ⋯))\n                        ⋯)))\n                  ⋯)\n                ⋯))\n            ⋯)))","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 1) = S N + (-1) ^ (N + 1) * a ⟨N + 1, ⋯⟩","name":["claim0"],"isProp":true,"id":["_uniq",35045]},{"value":"fun {N} hN =>\n  Trans.trans\n    (Trans.trans\n      (Eq.mpr\n        (id\n          (congrArg (fun x => S (N + 2) = x + (-1) ^ (N + 2) * a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)\n            (Eq.symm (claim0 hN))))\n        (Eq.mpr\n          (id\n            (congr\n              (congrArg (fun x => Eq (S x))\n                (have this :=\n                  Eq.trans\n                    (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                      (Mathlib.Tactic.Abel.termg 1 2 0)\n                      (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                      (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                      (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                        (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                    (Eq.symm\n                      (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                        (Mathlib.Tactic.Abel.termg 1 1 0)\n                        (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                        (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                        (Mathlib.Tactic.Abel.term_atomg 1)\n                        (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                          (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                          (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                            (Mathlib.Meta.NormNum.IsNat.to_eq\n                              (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                              (Eq.refl 2))\n                            (zero_add 0)))));\n                this))\n              (congrArg (HAdd.hAdd (S (N + 1)))\n                (congr\n                  (congrArg (fun x => HMul.hMul ((-1) ^ x))\n                    (have this :=\n                      Eq.trans\n                        (Mathlib.Tactic.Abel.subst_into_addg N 2 (Mathlib.Tactic.Abel.termg 1 N 0)\n                          (Mathlib.Tactic.Abel.termg 1 2 0)\n                          (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 2 0))\n                          (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 2)\n                          (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 2 0)\n                            (Mathlib.Tactic.Abel.termg 1 2 0) (zero_add (Mathlib.Tactic.Abel.termg 1 2 0))))\n                        (Eq.symm\n                          (Mathlib.Tactic.Abel.subst_into_addg (N + 1) 1\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                            (Mathlib.Tactic.Abel.termg 1 1 0)\n                            (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 2 1 0))\n                            (Mathlib.Tactic.Abel.subst_into_addg N 1 (Mathlib.Tactic.Abel.termg 1 N 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 N (Mathlib.Tactic.Abel.termg 1 1 0))\n                              (Mathlib.Tactic.Abel.term_atomg N) (Mathlib.Tactic.Abel.term_atomg 1)\n                              (Mathlib.Tactic.Abel.term_add_constg 1 N 0 (Mathlib.Tactic.Abel.termg 1 1 0)\n                                (Mathlib.Tactic.Abel.termg 1 1 0) (zero_add (Mathlib.Tactic.Abel.termg 1 1 0))))\n                            (Mathlib.Tactic.Abel.term_atomg 1)\n                            (Mathlib.Tactic.Abel.term_add_constg 1 N (Mathlib.Tactic.Abel.termg 1 1 0)\n                              (Mathlib.Tactic.Abel.termg 1 1 0) (Mathlib.Tactic.Abel.termg 2 1 0)\n                              (Mathlib.Tactic.Abel.term_add_termg 1 1 0 1 0 2 0\n                                (Mathlib.Meta.NormNum.IsNat.to_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1))\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl 2))\n                                  (Eq.refl 2))\n                                (zero_add 0)))));\n                    this))\n                  (congrArg ⋯ ⋯)))))\n          ⋯))\n      ⋯)\n    ⋯","type":"∀ {N : ℤ} (hN : N ≥ m), S (N + 2) = S N + (-1) ^ (N + 1) * (a ⟨N + 1, ⋯⟩ - a ⟨N + 2, ⋯⟩)","name":["claim1"],"isProp":true,"id":["_uniq",50460]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (congrArg\n                    (fun x =>\n                      x *\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                    ((fun x_0 x_1 x_2 => (fun x_0 x_1 x_2 => Even.neg_one_zpow (Odd.add_one h')) x_0 x_1 x_2) ℝ\n                      CommGroupWithZero.toDivisionCommMonoid.toDivisionMonoid NonUnitalNonAssocRing.toHasDistribNeg))\n                  (one_mul\n                    (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                      a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))))))\n          ge_iff_le._simp_1)\n        (Eq.trans (le_mul_iff_one_le_right'._simp_4 (S N)) one_le_div'._simp_4)))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Odd N → S (N + 2) ≥ S N","name":["claim2"],"isProp":true,"id":["_uniq",77837]},{"value":"fun {N} hN h' =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≤ S N)\n            (Eq.trans (claim1 hN)\n              (congrArg (HAdd.hAdd (S N))\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg\n                      (fun x =>\n                        x *\n                          (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                            a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n                      ((fun x_0 x_1 => (fun x_0 x_1 => Odd.neg_one_zpow (Even.add_one h')) x_0 x_1) ℝ\n                        Real.instDivisionRing))\n                    (neg_mul 1\n                      (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                        a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                  (Eq.trans\n                    (congrArg Neg.neg\n                      (one_mul\n                        (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩ -\n                          a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))\n                    (neg_sub (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩)\n                      (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩)))))))\n          (mul_le_iff_le_one_right'._simp_4 (S N)))\n        (Eq.trans tsub_le_iff_right._simp_1\n          (congrArg (LE.le (a ⟨N + 2, converges_of_alternating._proof_4 claim0 hN⟩))\n            (zero_add (a ⟨N + 1, converges_of_alternating._proof_3 claim0 hN⟩))))))\n    (ha'\n      (of_eq_true\n        (Eq.trans Subtype.mk_le_mk._simp_1 (Eq.trans (mul_le_mul_iff_left._simp_4 N) Nat.one_le_ofNat._simp_1))))","type":"∀ {N : ℤ}, N ≥ m → Even N → S (N + 2) ≤ S N","name":["claim3"],"isProp":true,"id":["_uniq",84574]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ)) ≤ S N","name":["why1"],"isProp":true,"id":["_uniq",91542]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≥ S N - a ⟨N + 1, ⋯⟩","name":["why2"],"isProp":true,"id":["_uniq",102437]},{"value":"fun {N} hN h' k => sorry","type":"∀ {N : ℤ}, N ≥ m → Even N → ∀ (k : ℕ), S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ))","name":["why3"],"isProp":true,"id":["_uniq",102992]},{"value":"fun {N} hN h' k => ⟨ge_iff_le.mp (why2 hN h' k), ⟨why3 hN h' k, why1 hN h' k⟩⟩","type":"∀ {N : ℤ} (hN : N ≥ m) (h' : Even N) (k : ℕ),\n  S N - a ⟨N + 1, ⋯⟩ ≤ S (N + 2 * (↑k : ℤ) + 1) ∧\n    S (N + 2 * (↑k : ℤ) + 1) ≤ S (N + 2 * (↑k : ℤ)) ∧ S (N + 2 * (↑k : ℤ)) ≤ S N","name":["claim4"],"isProp":true,"id":["_uniq",119028]},{"value":"fun {N n} hN h' hn => sorry","type":"∀ {N n : ℤ} (hN : N ≥ m) (h' : Even N) (hn : n ≥ N), S N - a ⟨N + 1, ⋯⟩ ≤ S n ∧ S n ≤ S N","name":["why4"],"isProp":true,"id":["_uniq",138095]},{"value":"fun {ε} hε => sorry","type":"∀ {ε : ℝ}, ε > 0 → ∃ N, ∀ n ≥ N, ∀ m ≥ N, |S n - S m| ≤ ε","name":["why5"],"isProp":true,"id":["_uniq",138639]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext Metric.cauchySeq_iff'))) fun ε hε =>\n  (fun N hN =>\n      Exists.intro N fun n hn =>\n        Eq.mpr (id (congrArg (fun _a => _a < ε) (Real.dist_eq (S n) (S N))))\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.atom_pf |S n - S N|)\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul |S n - S N| (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (|S n - S N| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right |S n - S N| (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2)))))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  (|S n - S N| ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0)))\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 2)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (|S n - S N| ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.zero_mul\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                (|S n - S N| ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (ε ^ Nat.rawCast 1 * Nat.rawCast 2 +\n                                (|S n - S N| ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap\n                          (Mathlib.Tactic.Ring.add_overlap_pf ε (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                                  (Eq.refl (Int.ofNat 1))))))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (|S n - S N| ^ Nat.rawCast 1 * (Int.negOfNat 2).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                          (Mathlib.Tactic.Ring.atom_pf |S n - S N|)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right |S n - S N| (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (|S n - S N| ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (|S n - S N| ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (|S n - S N| ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.atom_pf ε)\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul ⋯) ⋯))\n                        ⋯)\n                      ⋯)\n                    ⋯))\n                ⋯)))\n    ⋯ ⋯","type":"CauchySeq S","name":["this"],"isProp":true,"id":["_uniq",138889]}]}],"start":7624},{"state":[],"start":7667},{"state":[],"start":7668},{"state":[],"start":7690},{"state":[],"start":7797},{"state":[],"start":7798},{"state":[{"type":"example_7_2_13.converges","tag":[],"mvarId":["_uniq",141935],"isProp":true,"context":[]}],"start":7862},{"state":[],"start":7870},{"state":[],"start":7871},{"state":[{"type":"¬example_7_2_13.absConverges","tag":[],"mvarId":["_uniq",141940],"isProp":true,"context":[]}],"start":7941},{"state":[],"start":7949},{"state":[],"start":7950},{"state":[{"type":"example_7_2_13.condConverges","tag":[],"mvarId":["_uniq",141945],"isProp":true,"context":[]}],"start":8019},{"state":[],"start":8027},{"state":[],"start":8028},{"state":[],"start":8072},{"state":[],"start":8087},{"state":[],"start":8108},{"state":[],"start":8172},{"state":[],"start":8230},{"state":[],"start":8234},{"state":[],"start":8235},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ } +\n    { m := 0, seq := fun n => if n ≥ 0 then b n.toNat else 0, vanish := ⋯ } =\n  { m := 0, seq := fun n => if n ≥ 0 then (fun n => a n + b n) n.toNat else 0, vanish := ⋯ }","tag":[],"mvarId":["_uniq",145254],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",145252],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",145253],"binderInfo":"default"}]}],"start":8333},{"state":[{"type":"({ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ } +\n        { m := 0, seq := fun n => if n ≥ 0 then b n.toNat else 0, vanish := ⋯ }).seq\n    n =\n  { m := 0, seq := fun n => if n ≥ 0 then (fun n => a n + b n) n.toNat else 0, vanish := ⋯ }.seq n","tag":["seq","h"],"mvarId":["_uniq",145332],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",145252],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",145253],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",145331],"binderInfo":"default"}]}],"start":8346},{"state":[],"start":8400},{"state":[],"start":8401},{"state":[],"start":8528},{"state":[],"start":8629},{"state":[{"type":"(s + t).convergesTo (L + M)","tag":[],"mvarId":["_uniq",151847],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",151841],"binderInfo":"implicit"},{"type":"Series","name":["t"],"isProp":false,"id":["_uniq",151842],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",151843],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",151844],"binderInfo":"implicit"},{"type":"s.convergesTo L","name":["hs"],"isProp":true,"id":["_uniq",151845],"binderInfo":"default"},{"type":"t.convergesTo M","name":["ht"],"isProp":true,"id":["_uniq",151846],"binderInfo":"default"}]}],"start":8667},{"state":[],"start":8675},{"state":[],"start":8676},{"state":[],"start":8746},{"state":[],"start":8810},{"state":[],"start":8811},{"state":[],"start":8861},{"state":[],"start":8877},{"state":[],"start":8890},{"state":[],"start":8940},{"state":[],"start":8963},{"state":[],"start":8967},{"state":[],"start":8968},{"state":[{"type":"c • { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ } =\n  { m := 0, seq := fun n => if n ≥ 0 then (fun n => c * a n) n.toNat else 0, vanish := ⋯ }","tag":[],"mvarId":["_uniq",154596],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",154594],"binderInfo":"default"},{"type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",154595],"binderInfo":"default"}]}],"start":9065},{"state":[{"type":"(c • { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }).seq n =\n  { m := 0, seq := fun n => if n ≥ 0 then (fun n => c * a n) n.toNat else 0, vanish := ⋯ }.seq n","tag":["seq","h"],"mvarId":["_uniq",154674],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",154594],"binderInfo":"default"},{"type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",154595],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",154673],"binderInfo":"default"}]}],"start":9078},{"state":[],"start":9136},{"state":[],"start":9137},{"state":[],"start":9264},{"state":[],"start":9342},{"state":[{"type":"(c • s).convergesTo (c * L)","tag":[],"mvarId":["_uniq",161098],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",161094],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",161095],"binderInfo":"implicit"},{"type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",161096],"binderInfo":"implicit"},{"type":"s.convergesTo L","name":["hs"],"isProp":true,"id":["_uniq",161097],"binderInfo":"default"}]}],"start":9382},{"state":[],"start":9390},{"state":[],"start":9391},{"state":[],"start":9450},{"state":[],"start":9516},{"state":[],"start":9517},{"state":[],"start":9641},{"state":[],"start":9685},{"state":[],"start":9700},{"state":[],"start":9721},{"state":[],"start":9785},{"state":[],"start":9808},{"state":[],"start":9812},{"state":[],"start":9813},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ } -\n    { m := 0, seq := fun n => if n ≥ 0 then b n.toNat else 0, vanish := ⋯ } =\n  { m := 0, seq := fun n => if n ≥ 0 then (fun n => a n - b n) n.toNat else 0, vanish := ⋯ }","tag":[],"mvarId":["_uniq",164030],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",164028],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",164029],"binderInfo":"default"}]}],"start":9911},{"state":[{"type":"({ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ } -\n        { m := 0, seq := fun n => if n ≥ 0 then b n.toNat else 0, vanish := ⋯ }).seq\n    n =\n  { m := 0, seq := fun n => if n ≥ 0 then (fun n => a n - b n) n.toNat else 0, vanish := ⋯ }.seq n","tag":["seq","h"],"mvarId":["_uniq",164108],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",164028],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",164029],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",164107],"binderInfo":"default"}]}],"start":9924},{"state":[],"start":9978},{"state":[],"start":9979},{"state":[],"start":10080},{"state":[{"type":"(s - t).convergesTo (L - M)","tag":[],"mvarId":["_uniq",171239],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",171233],"binderInfo":"implicit"},{"type":"Series","name":["t"],"isProp":false,"id":["_uniq",171234],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",171235],"binderInfo":"implicit"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",171236],"binderInfo":"implicit"},{"type":"s.convergesTo L","name":["hs"],"isProp":true,"id":["_uniq",171237],"binderInfo":"default"},{"type":"t.convergesTo M","name":["ht"],"isProp":true,"id":["_uniq",171238],"binderInfo":"default"}]}],"start":10118},{"state":[],"start":10126},{"state":[],"start":10127},{"state":[],"start":10197},{"state":[],"start":10261},{"state":[],"start":10262},{"state":[],"start":10365},{"state":[],"start":10366},{"state":[],"start":10427},{"state":[{"type":"s.converges ↔ (s.from (s.m + (↑k : ℤ))).converges","tag":[],"mvarId":["_uniq",171767],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",171765],"binderInfo":"default"},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",171766],"binderInfo":"default"}]}],"start":10527},{"state":[],"start":10535},{"state":[],"start":10536},{"state":[],"start":10598},{"state":[{"type":"s.sum = ∑ n ∈ Finset.Ico s.m (s.m + (↑k : ℤ)), s.seq n + (s.from (s.m + (↑k : ℤ))).sum","tag":[],"mvarId":["_uniq",172191],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",172188],"binderInfo":"implicit"},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",172189],"binderInfo":"default"},{"type":"s.converges","name":["h"],"isProp":true,"id":["_uniq",172190],"binderInfo":"default"}]}],"start":10681},{"state":[],"start":10689},{"state":[],"start":10690},{"state":[],"start":10751},{"state":[],"start":10822},{"state":[{"type":"(mk' fun n => s.seq ((↑n : ℤ) - L)).convergesTo x","tag":[],"mvarId":["_uniq",172540],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",172536],"binderInfo":"implicit"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",172537],"binderInfo":"implicit"},{"type":"s.convergesTo x","name":["h"],"isProp":true,"id":["_uniq",172538],"binderInfo":"default"},{"type":"ℤ","name":["L"],"isProp":false,"id":["_uniq",172539],"binderInfo":"default"}]}],"start":10893},{"state":[],"start":10901},{"state":[],"start":10902},{"state":[],"start":10960},{"state":[],"start":11041},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (n + 1) - a n) n.toNat else 0, vanish := ⋯ }.convergesTo (a 0)","tag":[],"mvarId":["_uniq",172979],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",172977],"binderInfo":"implicit"},{"type":"Filter.Tendsto a Filter.atTop (nhds 0)","name":["ha"],"isProp":true,"id":["_uniq",172978],"binderInfo":"default"}]}],"start":11108},{"state":[],"start":11116},{"state":[],"start":11117},{"state":[],"start":11139},{"state":[],"start":11140},{"state":[],"start":11179},{"state":[{"type":"Decidable (mk' fun n => (-1) ^ (↑n : ℤ)).converges","tag":[],"mvarId":["_uniq",173219],"isProp":false,"context":[]}],"start":11255},{"state":[{"type":"Decidable (mk' fun n => (-1) ^ (↑n : ℤ)).converges","tag":[],"mvarId":["_uniq",173219],"isProp":false,"context":[]}],"start":11334},{"state":[],"start":11342},{"state":[],"start":11343},{"state":[],"start":11344},{"state":[],"start":11357},{"state":[],"start":11357}]
