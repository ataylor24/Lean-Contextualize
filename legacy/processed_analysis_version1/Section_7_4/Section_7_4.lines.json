[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":51},{"state":[],"start":55},{"state":[],"start":106},{"state":[],"start":107},{"state":[],"start":491},{"state":[],"start":492},{"state":[],"start":540},{"state":[],"start":541},{"state":[],"start":606},{"state":[],"start":609},{"state":[],"start":610},{"state":[],"start":629},{"state":[],"start":630},{"state":[{"type":"(∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","tag":[],"mvarId":["_uniq",451],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",448],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",449],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",450],"binderInfo":"default"}]}],"start":787},{"state":[{"type":"Finset.Icc 0 N = Finset.image Int.ofNat (Finset.Iic N.toNat)","tag":["h","e'_2","h"],"mvarId":["_uniq",3172],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",448],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",449],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",450],"binderInfo":"default"}]}],"start":845},{"state":[{"type":"0 ≤ x ∧ x ≤ N → ∃ a ≤ N.toNat, (↑a : ℤ) = x","tag":["h","e'_2","h","h","mp"],"mvarId":["_uniq",13385],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",448],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",449],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",450],"binderInfo":"default"},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",5483],"binderInfo":"default"}]},{"type":"(∃ a ≤ N.toNat, (↑a : ℤ) = x) → 0 ≤ x ∧ x ≤ N","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",13386],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",448],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",449],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",450],"binderInfo":"default"},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",5483],"binderInfo":"default"}]}],"start":876},{"state":[{"type":"(∃ a ≤ N.toNat, (↑a : ℤ) = x) → 0 ≤ x ∧ x ≤ N","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",13386],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",448],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",449],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",450],"binderInfo":"default"},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",5483],"binderInfo":"default"}]}],"start":923},{"state":[],"start":935},{"state":[],"start":936},{"state":[],"start":961},{"state":[],"start":1074},{"state":[],"start":1122},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",14608],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"}]}],"start":1225},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",14608],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"}]}],"start":1298},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",14648],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]}]}],"start":1342},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","tag":[],"mvarId":["_uniq",14799],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]}]}],"start":1380},{"state":[{"type":"0 ≤ a (f n.toNat)","tag":["pos","_@","_hyg",511],"mvarId":["_uniq",16519],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",14806],"binderInfo":"default"},{"type":"n ≥ 0","name":["h"],"isProp":true,"id":["_uniq",14867],"binderInfo":"default"}]}],"start":1431},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",14802],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]}]}],"start":1468},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",19927],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]}]}],"start":1498},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20098],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]}]}],"start":1529},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20440],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]}]}],"start":1587},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20561],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]}]}],"start":1646},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20578],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]}]}],"start":1664},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20709],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]}]}],"start":1683},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20878],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]}]}],"start":1765},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20903],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"}]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","tag":["this"],"mvarId":["_uniq",20900],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]}]}],"start":1815},{"state":[{"type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20912],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"}]}],"start":1856},{"state":[{"type":"Filter.Tendsto { m := 0, seq := fun n => if 0 ≤ n then a n.toNat else 0, vanish := ⋯ }.partial Filter.atTop\n  (nhds (iSup S))","tag":["h"],"mvarId":["_uniq",25091],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"}]}],"start":1914},{"state":[{"type":"(Set.range S).Nonempty","tag":[],"mvarId":["_uniq",25113],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"}]},{"type":"BddAbove (Set.range S)","tag":[],"mvarId":["_uniq",25114],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"}]}],"start":1971},{"state":[{"type":"BddAbove (Set.range S)","tag":[],"mvarId":["_uniq",25114],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"}]}],"start":1996},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",20914],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup S)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0) (fun n => if 0 ≤ n then a n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 a))))\n      (tendsto_atTop_isLUB hSmono\n        (isLUB_csSup\n          (Exists.intro (S 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq =>\n                              Eq.rec (motive := fun seq_2 e_seq =>\n                                ∀ (vanish : ∀ (n : ⋯), ⋯ → seq n = ⋯),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m, seq := seq_2,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                          (Eq.refl m) })\n                                ⋯ ⋯)\n                            ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["Ssum"],"isProp":true,"id":["_uniq",20913]}]}],"start":2059},{"state":[{"type":"L' = { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",122064],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup S)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0) (fun n => if 0 ≤ n then a n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 a))))\n      (tendsto_atTop_isLUB hSmono\n        (isLUB_csSup\n          (Exists.intro (S 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq =>\n                              Eq.rec (motive := fun seq_2 e_seq =>\n                                ∀ (vanish : ∀ (n : ⋯), ⋯ → seq n = ⋯),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m, seq := seq_2,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                          (Eq.refl m) })\n                                ⋯ ⋯)\n                            ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["Ssum"],"isProp":true,"id":["_uniq",20913]}]}],"start":2102},{"state":[{"type":"Filter.Tendsto { m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial Filter.atTop\n  (nhds (iSup T))","tag":["h"],"mvarId":["_uniq",126243],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup S)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0) (fun n => if 0 ≤ n then a n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 a))))\n      (tendsto_atTop_isLUB hSmono\n        (isLUB_csSup\n          (Exists.intro (S 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq =>\n                              Eq.rec (motive := fun seq_2 e_seq =>\n                                ∀ (vanish : ∀ (n : ⋯), ⋯ → seq n = ⋯),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m, seq := seq_2,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                          (Eq.refl m) })\n                                ⋯ ⋯)\n                            ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["Ssum"],"isProp":true,"id":["_uniq",20913]}]}],"start":2161},{"state":[{"type":"(Set.range T).Nonempty","tag":[],"mvarId":["_uniq",126272],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup S)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0) (fun n => if 0 ≤ n then a n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 a))))\n      (tendsto_atTop_isLUB hSmono\n        (isLUB_csSup\n          (Exists.intro (S 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq =>\n                              Eq.rec (motive := fun seq_2 e_seq =>\n                                ∀ (vanish : ∀ (n : ⋯), ⋯ → seq n = ⋯),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m, seq := seq_2,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                          (Eq.refl m) })\n                                ⋯ ⋯)\n                            ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["Ssum"],"isProp":true,"id":["_uniq",20913]}]},{"type":"BddAbove (Set.range T)","tag":[],"mvarId":["_uniq",126273],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup S)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0) (fun n => if 0 ≤ n then a n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 a))))\n      (tendsto_atTop_isLUB hSmono\n        (isLUB_csSup\n          (Exists.intro (S 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq =>\n                              Eq.rec (motive := fun seq_2 e_seq =>\n                                ∀ (vanish : ∀ (n : ⋯), ⋯ → seq n = ⋯),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m, seq := seq_2,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                          (Eq.refl m) })\n                                ⋯ ⋯)\n                            ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["Ssum"],"isProp":true,"id":["_uniq",20913]}]}],"start":2218},{"state":[{"type":"BddAbove (Set.range T)","tag":[],"mvarId":["_uniq",126273],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup S)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0) (fun n => if 0 ≤ n then a n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 a))))\n      (tendsto_atTop_isLUB hSmono\n        (isLUB_csSup\n          (Exists.intro (S 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq =>\n                              Eq.rec (motive := fun seq_2 e_seq =>\n                                ∀ (vanish : ∀ (n : ⋯), ⋯ → seq n = ⋯),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m, seq := seq_2,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                          (Eq.refl m) })\n                                ⋯ ⋯)\n                            ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["Ssum"],"isProp":true,"id":["_uniq",20913]}]}],"start":2243},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.converges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",122066],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup S)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0) (fun n => if 0 ≤ n then a n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 a))))\n      (tendsto_atTop_isLUB hSmono\n        (isLUB_csSup\n          (Exists.intro (S 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq =>\n                              Eq.rec (motive := fun seq_2 e_seq =>\n                                ∀ (vanish : ∀ (n : ⋯), ⋯ → seq n = ⋯),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m, seq := seq_2,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                          (Eq.refl m) })\n                                ⋯ ⋯)\n                            ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["Ssum"],"isProp":true,"id":["_uniq",20913]},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup T)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0) (fun n => if 0 ≤ n then af n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (af n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 af))))\n      (tendsto_atTop_isLUB hTmono\n        (isLUB_csSup\n          (Exists.intro (T 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq => Eq.rec (motive := ⋯) ⋯ ⋯) ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L' = { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","name":["Tsum"],"isProp":true,"id":["_uniq",122065]}]}],"start":2305},{"state":[{"type":"∃ M, ∀ (N : ℤ), { m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial N ≤ M","tag":[],"mvarId":["_uniq",247697],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","name":["this"],"isProp":true,"id":["_uniq",20902],"binderInfo":"default"},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup S)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0) (fun n => if 0 ≤ n then a n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 a))))\n      (tendsto_atTop_isLUB hSmono\n        (isLUB_csSup\n          (Exists.intro (S 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq =>\n                              Eq.rec (motive := fun seq_2 e_seq =>\n                                ∀ (vanish : ∀ (n : ⋯), ⋯ → seq n = ⋯),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m, seq := seq_2,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                          (Eq.refl m) })\n                                ⋯ ⋯)\n                            ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L = { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["Ssum"],"isProp":true,"id":["_uniq",20913]},{"value":"Eq.symm\n  (sum_of_converges\n    (Eq.mpr\n      (id\n        (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop (nhds (iSup T)))\n          ((fun m m_1 e_m =>\n              Eq.rec (motive := fun m_2 e_m =>\n                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                  { m := m, seq := seq, vanish := vanish } =\n                    { m := m_2, seq := seq_1,\n                      vanish :=\n                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                (fun seq seq_1 e_seq =>\n                  Eq.rec (motive := fun seq_2 e_seq =>\n                    ∀ (vanish : ∀ n < m, seq n = 0),\n                      { m := m, seq := seq, vanish := vanish } =\n                        { m := m, seq := seq_2,\n                          vanish :=\n                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                e_m)\n            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0) (fun n => if 0 ≤ n then af n.toNat else 0)\n            (funext fun n => ite_congr ge_iff_le._simp_1 (fun a => Eq.refl (af n.toNat)) fun a => Eq.refl 0)\n            (instCoe._proof_1 af))))\n      (tendsto_atTop_isLUB hTmono\n        (isLUB_csSup\n          (Exists.intro (T 0)\n            (of_eq_true\n              (Eq.trans\n                (Eq.trans\n                  (congr\n                    (congrArg (fun x => Membership.mem (Set.range x.partial))\n                      ((fun m m_1 e_m =>\n                          Eq.rec (motive := fun m_2 e_m =>\n                            ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                              { m := m, seq := seq, vanish := vanish } =\n                                { m := m_2, seq := seq_1,\n                                  vanish :=\n                                    Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                      (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                            (fun seq seq_1 e_seq => Eq.rec (motive := ⋯) ⋯ ⋯) ⋯)\n                        ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))\n                    ⋯)\n                  ⋯)\n                ⋯)))\n          ⋯))))","type":"L' = { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","name":["Tsum"],"isProp":true,"id":["_uniq",122065]}]}],"start":2370},{"state":[{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","tag":["this"],"mvarId":["_uniq",20900],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]}]}],"start":2389},{"state":[{"type":"T M ≤ L","tag":[],"mvarId":["_uniq",247768],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"}]}],"start":2426},{"state":[{"type":"T M ≤ L","tag":["pos","_@","_hyg",1625],"mvarId":["_uniq",247835],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"}]},{"type":"T M ≤ L","tag":["neg","_@","_hyg",1625],"mvarId":["_uniq",247842],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"¬M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247841],"binderInfo":"default"}]}],"start":2452},{"state":[{"type":"T M ≤ L","tag":["neg","_@","_hyg",1625],"mvarId":["_uniq",247842],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"¬M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247841],"binderInfo":"default"}]},{"type":"T M ≤ L","tag":["pos","_@","_hyg",1625],"mvarId":["_uniq",247835],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"}]}],"start":2461},{"state":[{"type":"T M ≤ L","tag":["neg","_@","_hyg",1625],"mvarId":["_uniq",247889],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"¬M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247841],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.neg_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1)))))\n                  Mathlib.Tactic.Ring.neg_zero))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.atom_pf M)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge hM))))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"M < 0","name":["hM'"],"isProp":true,"id":["_uniq",247888]}]}],"start":2499},{"state":[{"type":"0 ≤ L","tag":["neg","_@","_hyg",1625],"mvarId":["_uniq",254597],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"¬M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247841],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.neg_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1)))))\n                  Mathlib.Tactic.Ring.neg_zero))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.atom_pf M)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge hM))))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"M < 0","name":["hM'"],"isProp":true,"id":["_uniq",247888]}]}],"start":2535},{"state":[{"type":"BddAbove (Set.range S)","tag":["neg","_@","_hyg",1625],"mvarId":["_uniq",254607],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"¬M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247841],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.neg_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1)))))\n                  Mathlib.Tactic.Ring.neg_zero))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (M ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.atom_pf M)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul M (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (M ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero M (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge hM))))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"M < 0","name":["hM'"],"isProp":true,"id":["_uniq",247888]}]}],"start":2575},{"state":[{"type":"T M ≤ L","tag":["pos","_@","_hyg",1625],"mvarId":["_uniq",247835],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"}]}],"start":2633},{"state":[{"type":"T M ≤ L","tag":["pos","_@","_hyg",1625],"mvarId":["_uniq",259854],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]}]}],"start":2665},{"state":[{"type":"∃ N, ∀ m ∈ Y, f m ≤ N","tag":[],"mvarId":["_uniq",260126],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]}]}],"start":2715},{"state":[{"type":"f m ≤ (Finset.image f Y).sup id","tag":["h"],"mvarId":["_uniq",260443],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",260439],"binderInfo":"default"},{"type":"m ∈ Y","name":["hm"],"isProp":true,"id":["_uniq",260442],"binderInfo":"default"}]}],"start":2756},{"state":[{"type":"T M ≤ L","tag":["pos","_@","_hyg",1625],"mvarId":["_uniq",260128],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]},{"value":"Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n  Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm)","type":"∃ N, ∀ m ∈ Y, f m ≤ N","name":["hN"],"isProp":true,"id":["_uniq",260127]}]}],"start":2799},{"state":[{"type":"T M ≤ L","tag":["pos","_@","_hyg",1625],"mvarId":["_uniq",265153],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",265146],"binderInfo":"default"},{"type":"∀ m ∈ Y, f m ≤ N","name":["hN"],"isProp":true,"id":["_uniq",265150],"binderInfo":"default"}]}],"start":2824},{"state":[{"type":"T M ≤ L","tag":["pos","_@","_hyg",1625],"mvarId":["_uniq",265153],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",265146],"binderInfo":"default"},{"type":"∀ m ∈ Y, f m ≤ N","name":["hN"],"isProp":true,"id":["_uniq",265150],"binderInfo":"default"}]}],"start":2833},{"state":[],"start":2920},{"state":[],"start":3029},{"state":[{"type":"∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n ≤ ∑ n ∈ Finset.Iic N, a n","tag":[],"mvarId":["_uniq",265558],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",265146],"binderInfo":"default"},{"type":"∀ m ∈ Y, f m ≤ N","name":["hN"],"isProp":true,"id":["_uniq",265150],"binderInfo":"default"}]}],"start":3069},{"state":[{"type":"(f '' (↑Y : Set ℕ)).toFinset ⊆ Finset.Iic N","tag":["h"],"mvarId":["_uniq",277468],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",265146],"binderInfo":"default"},{"type":"∀ m ∈ Y, f m ≤ N","name":["hN"],"isProp":true,"id":["_uniq",265150],"binderInfo":"default"}]},{"type":"∀ i ∈ Finset.Iic N, i ∉ (f '' (↑Y : Set ℕ)).toFinset → 0 ≤ a i","tag":["hf"],"mvarId":["_uniq",277469],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",265146],"binderInfo":"default"},{"type":"∀ m ∈ Y, f m ≤ N","name":["hN"],"isProp":true,"id":["_uniq",265150],"binderInfo":"default"}]}],"start":3121},{"state":[{"type":"∀ i ∈ Finset.Iic N, i ∉ (f '' (↑Y : Set ℕ)).toFinset → 0 ≤ a i","tag":["hf"],"mvarId":["_uniq",277469],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"type":"ℤ","name":["M"],"isProp":false,"id":["_uniq",247761],"binderInfo":"default"},{"type":"M ≥ 0","name":["hM"],"isProp":true,"id":["_uniq",247834],"binderInfo":"default"},{"value":"Finset.Iic M.toNat","type":"Finset ℕ","name":["Y"],"isProp":false,"id":["_uniq",259853]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",265146],"binderInfo":"default"},{"type":"∀ m ∈ Y, f m ≤ N","name":["hN"],"isProp":true,"id":["_uniq",265150],"binderInfo":"default"}]}],"start":3149},{"state":[],"start":3193},{"state":[],"start":3283},{"state":[{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","tag":["this"],"mvarId":["_uniq",247772],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]}]}],"start":3381},{"state":[{"type":"(∃ Q, ∀ (M : ℤ), T M ≤ Q) ∧ L = L'","tag":["this"],"mvarId":["_uniq",468510],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]}]}],"start":3434},{"state":[{"type":"L = L'","tag":["this"],"mvarId":["_uniq",469254],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]}]}],"start":3451},{"state":[{"type":"S N ≤ L'","tag":[],"mvarId":["_uniq",469263],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"}]}],"start":3490},{"state":[{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",469330],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"}]},{"type":"S N ≤ L'","tag":["neg","_@","_hyg",2452],"mvarId":["_uniq",469337],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469336],"binderInfo":"default"}]}],"start":3516},{"state":[{"type":"S N ≤ L'","tag":["neg","_@","_hyg",2452],"mvarId":["_uniq",469337],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469336],"binderInfo":"default"}]},{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",469330],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"}]}],"start":3525},{"state":[{"type":"S N ≤ L'","tag":["neg","_@","_hyg",2452],"mvarId":["_uniq",469384],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469336],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.neg_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1)))))\n                  Mathlib.Tactic.Ring.neg_zero))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.atom_pf N)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge hN))))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"N < 0","name":["hN'"],"isProp":true,"id":["_uniq",469383]}]}],"start":3563},{"state":[{"type":"0 ≤ L'","tag":["neg","_@","_hyg",2452],"mvarId":["_uniq",476092],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469336],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.neg_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1)))))\n                  Mathlib.Tactic.Ring.neg_zero))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.atom_pf N)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge hN))))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"N < 0","name":["hN'"],"isProp":true,"id":["_uniq",469383]}]}],"start":3599},{"state":[{"type":"BddAbove (Set.range T)","tag":["neg","_@","_hyg",2452],"mvarId":["_uniq",476102],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"¬N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469336],"binderInfo":"default"},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.neg_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1)))))\n                  Mathlib.Tactic.Ring.neg_zero))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.atom_pf N)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr (lt_of_not_ge hN))))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))","type":"N < 0","name":["hN'"],"isProp":true,"id":["_uniq",469383]}]}],"start":3639},{"state":[{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",469330],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"}]}],"start":3697},{"state":[{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",481349],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]}]}],"start":3729},{"state":[{"type":"∃ M, ∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","tag":[],"mvarId":["_uniq",481648],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]}]}],"start":3796},{"state":[{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ (X.preimage f ⋯).sup id","tag":["h"],"mvarId":["_uniq",481657],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]}]}],"start":3858},{"state":[{"type":"∃ m, f m = n ∧ m ≤ (X.preimage f ⋯).sup id","tag":["h"],"mvarId":["_uniq",481977],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",481964],"binderInfo":"default"},{"type":"n ∈ X","name":["hn"],"isProp":true,"id":["_uniq",481967],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",481973],"binderInfo":"default"},{"type":"f m = n","name":["hm"],"isProp":true,"id":["_uniq",481976],"binderInfo":"default"}]}],"start":3901},{"state":[{"type":"m ≤ (X.preimage f ⋯).sup id","tag":["h"],"mvarId":["_uniq",481996],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",481964],"binderInfo":"default"},{"type":"n ∈ X","name":["hn"],"isProp":true,"id":["_uniq",481967],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",481973],"binderInfo":"default"},{"type":"f m = n","name":["hm"],"isProp":true,"id":["_uniq",481976],"binderInfo":"default"}]}],"start":3932},{"state":[{"type":"m ∈ X.preimage f ⋯","tag":["h"],"mvarId":["_uniq",482313],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",481964],"binderInfo":"default"},{"type":"n ∈ X","name":["hn"],"isProp":true,"id":["_uniq",481967],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",481973],"binderInfo":"default"},{"type":"f m = n","name":["hm"],"isProp":true,"id":["_uniq",481976],"binderInfo":"default"}]}],"start":3968},{"state":[{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",481650],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"value":"Exists.intro ((X.preimage f (Set.injOn_of_injective hf.left)).sup id) fun n hn =>\n  (fun m hm =>\n      Exists.intro m\n        ⟨hm,\n          Finset.le_sup\n            (of_eq_true\n              (Eq.trans Finset.mem_preimage._simp_1 (Eq.trans (congrArg (Membership.mem X) hm) (eq_true hn))))⟩)\n    (Classical.choose (hf.right n)) (Classical.choose_spec (hf.right n))","type":"∃ M, ∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",481649]}]}],"start":4009},{"state":[{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",482514],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"}]}],"start":4034},{"state":[{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",482514],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"}]}],"start":4092},{"state":[{"type":"(∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","tag":[],"mvarId":["_uniq",482961],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N✝"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N✝ ≥ 0","name":["hN✝"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N✝.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",482519],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",482521],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",482562],"binderInfo":"default"}]}],"start":4191},{"state":[{"type":"Finset.Icc 0 N = Finset.image Int.ofNat (Finset.Iic N.toNat)","tag":["h","e'_2","h"],"mvarId":["_uniq",485687],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N✝"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N✝ ≥ 0","name":["hN✝"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N✝.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",482519],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",482521],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",482562],"binderInfo":"default"}]}],"start":4249},{"state":[{"type":"0 ≤ x ∧ x ≤ N → ∃ a ≤ N.toNat, (↑a : ℤ) = x","tag":["h","e'_2","h","h","mp"],"mvarId":["_uniq",495900],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N✝"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N✝ ≥ 0","name":["hN✝"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N✝.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",482519],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",482521],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",482562],"binderInfo":"default"},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",487998],"binderInfo":"default"}]},{"type":"(∃ a ≤ N.toNat, (↑a : ℤ) = x) → 0 ≤ x ∧ x ≤ N","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",495901],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N✝"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N✝ ≥ 0","name":["hN✝"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N✝.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",482519],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",482521],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",482562],"binderInfo":"default"},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",487998],"binderInfo":"default"}]}],"start":4280},{"state":[{"type":"(∃ a ≤ N.toNat, (↑a : ℤ) = x) → 0 ≤ x ∧ x ≤ N","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",495901],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N✝"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N✝ ≥ 0","name":["hN✝"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N✝.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["b"],"isProp":false,"id":["_uniq",482519],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",482521],"binderInfo":"implicit"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",482562],"binderInfo":"default"},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",487998],"binderInfo":"default"}]}],"start":4327},{"state":[{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",482964],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]}]}],"start":4339},{"state":[{"type":"S N ≤ L'","tag":["pos","_@","_hyg",2452],"mvarId":["_uniq",482964],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]}]}],"start":4348},{"state":[],"start":4409},{"state":[{"type":"∑ n ∈ X, a n = ∑ n ∈ Finset.image f ({x ∈ Finset.Iic M | f x ∈ X}), a n","tag":[],"mvarId":["_uniq",504167],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]}]}],"start":4485},{"state":[{"type":"a✝ ∈ X → ∃ a, (a ≤ M ∧ f a ∈ X) ∧ f a = a✝","tag":["e_s","h","mp"],"mvarId":["_uniq",510041],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]},{"type":"ℕ","name":["a✝"],"isProp":false,"id":["_uniq",507988],"binderInfo":"default"}]},{"type":"(∃ a, (a ≤ M ∧ f a ∈ X) ∧ f a = a✝) → a✝ ∈ X","tag":["e_s","h","mpr"],"mvarId":["_uniq",510042],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]},{"type":"ℕ","name":["a✝"],"isProp":false,"id":["_uniq",507988],"binderInfo":"default"}]}],"start":4523},{"state":[{"type":"(∃ a, (a ≤ M ∧ f a ∈ X) ∧ f a = a✝) → a✝ ∈ X","tag":["e_s","h","mpr"],"mvarId":["_uniq",510042],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]},{"type":"ℕ","name":["a✝"],"isProp":false,"id":["_uniq",507988],"binderInfo":"default"}]}],"start":4586},{"state":[],"start":4639},{"state":[{"type":"∑ n ∈ Finset.image f ({x ∈ Finset.Iic M | f x ∈ X}), a n ≤ ∑ m ∈ Finset.Iic M, af m","tag":[],"mvarId":["_uniq",504324],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]}]}],"start":4680},{"state":[{"type":"∑ x ∈ Finset.Iic M with f x ∈ X, a (f x) ≤ ∑ m ∈ Finset.Iic M, af m","tag":[],"mvarId":["_uniq",564419],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]}]}],"start":4744},{"state":[{"type":"{x ∈ Finset.Iic M | f x ∈ X} ⊆ Finset.Iic M","tag":["h"],"mvarId":["_uniq",565932],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]}]},{"type":"∀ i ∈ Finset.Iic M, i ∉ {x ∈ Finset.Iic M | f x ∈ X} → 0 ≤ a (f i)","tag":["hf"],"mvarId":["_uniq",565933],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]}]}],"start":4796},{"state":[{"type":"∀ i ∈ Finset.Iic M, i ∉ {x ∈ Finset.Iic M | f x ∈ X} → 0 ≤ a (f i)","tag":["hf"],"mvarId":["_uniq",565933],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (Series.sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",469256],"binderInfo":"default"},{"type":"N ≥ 0","name":["hN"],"isProp":true,"id":["_uniq",469329],"binderInfo":"default"},{"value":"Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",481348]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",482509],"binderInfo":"default"},{"type":"∀ n ∈ X, ∃ m, f m = n ∧ m ≤ M","name":["hM"],"isProp":true,"id":["_uniq",482513],"binderInfo":"default"},{"value":"fun b {N_1} hN_1 =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n        (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n        (Finset.sum_congr\n          (Finset.ext fun x =>\n            Eq.mpr\n              (id\n                (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                  (Eq.trans Finset.mem_image._simp_1\n                    (congrArg Exists\n                      (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n              {\n                mp := fun h =>\n                  match h with\n                  | ⟨left, right⟩ =>\n                    Exists.intro x.toNat\n                      (Decidable.byContradiction fun a => converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                mpr :=\n                  converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M hM b\n                    hN_1 x })\n          fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n        (∑ n ∈ Finset.Iic N_1.toNat, b n)\n        (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n        (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n    (Finset.sum_image\n      (of_eq_true\n        (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n          (of_eq_true\n            (Eq.trans\n              (forall_congr fun x =>\n                Eq.trans\n                  (forall_congr fun y =>\n                    Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                  (implies_true ℕ))\n              (implies_true ℕ))))))","type":"∀ (b : ℕ → ℝ) {N : ℤ}, N ≥ 0 → (∑ n ∈ Finset.Icc 0 N, if 0 ≤ n then b n.toNat else 0) = ∑ n ∈ Finset.Iic N.toNat, b n","name":["sum_eq_sum"],"isProp":true,"id":["_uniq",482963]}]}],"start":4812},{"state":[],"start":4857},{"state":[],"start":4945},{"state":[{"type":"L = L'","tag":["this"],"mvarId":["_uniq",469267],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",14602],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.nonneg","name":["ha"],"isProp":true,"id":["_uniq",14603],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",14604],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",14605],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",14606],"binderInfo":"default"},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",14617]},{"value":"fun n =>\n  if h : n ≥ 0 then\n    Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => x ≥ 0) (ite_cond_eq_true (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_true h))))\n          ge_iff_le._simp_1))\n      (converges_of_permute_nonneg._proof_1 hconv hf n h (ha (↑(f n.toNat) : ℤ)))\n  else\n    of_eq_true\n      (Eq.trans\n        (Eq.trans\n          (congrArg (fun x => x ≥ 0) (ite_cond_eq_false (af n.toNat) 0 (Eq.trans ge_iff_le._simp_1 (eq_false h))))\n          ge_iff_le._simp_1)\n        (le_refl._simp_1 0))","type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.nonneg","name":["haf"],"isProp":true,"id":["_uniq",14800]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["S"],"isProp":false,"id":["_uniq",19926]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial","type":"ℤ → ℝ","name":["T"],"isProp":false,"id":["_uniq",20097]},{"value":"partial_of_nonneg ha","type":"Monotone S","name":["hSmono"],"isProp":true,"id":["_uniq",20439]},{"value":"partial_of_nonneg haf","type":"Monotone T","name":["hTmono"],"isProp":true,"id":["_uniq",20560]},{"value":"iSup S","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",20577]},{"value":"iSup T","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",20708]},{"value":"(converges_of_nonneg_iff ha).mp hconv","type":"∃ Q, ∀ (N : ℤ), S N ≤ Q","name":["hSBound"],"isProp":true,"id":["_uniq",20877]},{"value":"fun M =>\n  if hM : M ≥ 0 then\n    let Y := Finset.Iic M.toNat;\n    have hN :=\n      Exists.intro ((Finset.image f Y).sup id) fun m hm =>\n        Finset.le_sup (converges_of_permute_nonneg._proof_3 ha hconv hf haf hSmono hTmono hSBound M hM m hm);\n    (fun N hN =>\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Eq.mpr\n                  (id\n                    (congr\n                      (congrArg Eq\n                        (Eq.trans\n                          (congrArg (fun x => x.partial M)\n                            ((fun m m_1 e_m =>\n                                Eq.rec (motive := fun m_2 e_m =>\n                                  ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                    { m := m, seq := seq, vanish := vanish } =\n                                      { m := m_2, seq := seq_1,\n                                        vanish :=\n                                          Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                  (fun seq seq_1 e_seq =>\n                                    Eq.rec (motive := fun seq_2 e_seq =>\n                                      ∀ (vanish : ∀ n < m, seq n = 0),\n                                        { m := m, seq := seq, vanish := vanish } =\n                                          { m := m, seq := seq_2,\n                                            vanish :=\n                                              Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                                (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                                (Eq.refl m) })\n                                      (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                  e_m)\n                              0 0 (Eq.refl 0) (fun n => if n ≥ 0 then af n.toNat else 0)\n                              (fun n => if 0 ≤ n then a (f n.toNat) else 0)\n                              (funext fun n =>\n                                ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a (f n.toNat))) fun a => Eq.refl 0)\n                              (instCoe._proof_1 af)))\n                          (Finset.sum_congr (Eq.refl (Finset.Icc 0 M)) fun x a_1 =>\n                            Eq.refl (if 0 ≤ x then a (f x.toNat) else 0))))\n                      (Finset.sum_congr (Eq.refl Y) fun x a_1 => Eq.refl (a (f x)))))\n                  (sum_eq_sum af hM))\n                (Eq.symm\n                  (Eq.mpr\n                    (eq_of_heq\n                      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                                (fun e_2 h =>\n                                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1))\n                                    e'_3\n                                    (fun h =>\n                                      Eq.ndrec (motive := fun a' =>\n                                        ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                    (Eq.refl a'_1) (HEq.refl e'_3))\n                                (Eq.symm h) e'_2)\n                            (Eq.refl a') (HEq.refl e'_2))\n                        ℝ (∑ n ∈ (f '' (↑Y : Set ℕ)).toFinset, a n) (∑ x ∈ Finset.image (fun ⦃x₁⦄ => f x₁) Y, a x)\n                        (Finset.sum_congr\n                          (of_eq_true\n                            (Eq.trans\n                              (congrArg (fun x => x = Finset.image (fun ⦃x₁⦄ => f x₁) Y)\n                                (Eq.trans (Set.toFinset_image f (↑Y : Set ℕ))\n                                  (congrArg (Finset.image f) (Finset.toFinset_coe Y))))\n                              (eq_self (Finset.image f Y))))\n                          fun x a_1 => Eq.refl (a x))\n                        (∑ m ∈ Y, af m) (∑ x ∈ Y, a (f x)) (Eq.refl (∑ m ∈ Y, af m))))\n                    (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => Function.Bijective.injective hf))))\n              (Finset.sum_le_sum_of_subset_of_nonneg\n                (fun ⦃a_1⦄ a_2 =>\n                  Eq.mpr (id Finset.mem_Iic._simp_1)\n                    (Exists.casesOn (Eq.mp (congrArg converges (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯) ⋯))\n                ⋯))\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (M : ℤ), T M ≤ L","name":["hTL"],"isProp":true,"id":["_uniq",247770]},{"value":"Exists.intro L hTL","type":"∃ Q, ∀ (M : ℤ), T M ≤ Q","name":["hTbound"],"isProp":true,"id":["_uniq",468509]},{"value":"fun N =>\n  if hN : N ≥ 0 then\n    let X := Finset.Iic N.toNat;\n    have hM :=\n      Exists.intro ((X.preimage f (Set.injOn_of_injective hf.left)).sup id) fun n hn =>\n        (fun m hm =>\n            Exists.intro m\n              ⟨hm,\n                Finset.le_sup\n                  (of_eq_true\n                    (Eq.trans Finset.mem_preimage._simp_1 (Eq.trans (congrArg (Membership.mem X) hm) (eq_true hn))))⟩)\n          (Classical.choose (hf.right n)) (Classical.choose_spec (hf.right n));\n    (fun M hM =>\n        have sum_eq_sum := fun b {N_1} hN_1 =>\n          Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (∑ n ∈ Finset.Icc 0 N_1, if 0 ≤ n then b n.toNat else 0)\n                (∑ x ∈ Finset.image Int.ofNat (Finset.Iic N_1.toNat), if 0 ≤ x then b x.toNat else 0)\n                (Finset.sum_congr\n                  (Finset.ext fun x =>\n                    Eq.mpr\n                      (id\n                        (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                          (Eq.trans Finset.mem_image._simp_1\n                            (congrArg Exists\n                              (funext fun a => congrArg (fun x_1 => x_1 ∧ (↑a : ℤ) = x) Finset.mem_Iic._simp_1)))))\n                      {\n                        mp := fun h =>\n                          match h with\n                          | ⟨left, right⟩ =>\n                            Exists.intro x.toNat\n                              (Decidable.byContradiction fun a =>\n                                converges_of_permute_nonneg._proof_5 N hN_1 x left right a),\n                        mpr :=\n                          converges_of_permute_nonneg._proof_6 ha hconv hf haf hSmono hTmono hSBound hTL hTbound N hN M\n                            hM b hN_1 x })\n                  fun x a => Eq.refl (if 0 ≤ x then b x.toNat else 0))\n                (∑ n ∈ Finset.Iic N_1.toNat, b n)\n                (∑ x ∈ Finset.Iic N_1.toNat, if 0 ≤ Int.ofNat x then b (Int.ofNat x).toNat else 0)\n                (Finset.sum_congr (Eq.refl (Finset.Iic N_1.toNat)) fun x a => Eq.refl (b x))))\n            (Finset.sum_image\n              (of_eq_true\n                (Set.injOn_of_eq_iff_eq._simp_1 (↑(Finset.Iic N_1.toNat) : Set ℕ)\n                  (of_eq_true\n                    (Eq.trans\n                      (forall_congr fun x =>\n                        Eq.trans\n                          (forall_congr fun y =>\n                            Eq.trans (congrArg (fun x_1 => x_1 ↔ x = y) Nat.cast_inj._simp_1) (iff_self (x = y)))\n                          (implies_true ℕ))\n                      (implies_true ℕ))))));\n        Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg (fun x => x = ∑ n ∈ Finset.Iic N.toNat, a n)\n                      (Eq.trans\n                        (congrArg (fun x => x.partial N)\n                          ((fun m m_1 e_m =>\n                              Eq.rec (motive := fun m_2 e_m =>\n                                ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                                  { m := m, seq := seq, vanish := vanish } =\n                                    { m := m_2, seq := seq_1,\n                                      vanish :=\n                                        Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                          (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                                (fun seq seq_1 e_seq =>\n                                  Eq.rec (motive := fun seq_2 e_seq =>\n                                    ∀ (vanish : ∀ n < m, seq n = 0),\n                                      { m := m, seq := seq, vanish := vanish } =\n                                        { m := m, seq := seq_2,\n                                          vanish :=\n                                            Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                              (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq)\n                                              (Eq.refl m) })\n                                    (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                                e_m)\n                            0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0)\n                            (fun n => if 0 ≤ n then a n.toNat else 0)\n                            (funext fun n =>\n                              ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n                            (instCoe._proof_1 a)))\n                        ((fun b {N} hN => sum_eq_sum b hN) a (of_eq_true (Eq.trans ge_iff_le._simp_1 (eq_true hN))))))\n                    (eq_self (∑ n ∈ Finset.Iic N.toNat, a n))))\n                ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n                    Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n                      (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n                  X (Finset.image f ({x ∈ Finset.Iic M | f x ∈ X})) (Finset.ext fun a => Eq.mpr (id ⋯) ⋯) ⋯ ⋯ ⋯))\n              ⋯)\n            ⋯)\n          ⋯)\n      ⋯ ⋯\n  else ⋯","type":"∀ (N : ℤ), S N ≤ L'","name":["hSL'"],"isProp":true,"id":["_uniq",469265]}]}],"start":5044},{"state":[],"start":5085},{"state":[],"start":5086},{"state":[],"start":5107},{"state":[],"start":5202},{"state":[],"start":5203},{"state":[],"start":5246},{"state":[{"type":"{ m := 0,\n    seq := fun n => if n ≥ 0 then (fun n => if Even n then 1 / ((↑n : ℝ) + 2) ^ 2 else 1 / (↑n : ℝ) ^ 2) n.toNat else 0,\n    vanish := ⋯ }.converges","tag":[],"mvarId":["_uniq",842444],"isProp":true,"context":[]}],"start":5335},{"state":[],"start":5345},{"state":[],"start":5346},{"state":[],"start":5389},{"state":[{"type":"{ m := 0,\n      seq := fun n =>\n        if n ≥ 0 then (fun n => if Even n then 1 / ((↑n : ℝ) + 2) ^ 2 else 1 / (↑n : ℝ) ^ 2) n.toNat else 0,\n      vanish := ⋯ }.sum =\n  { m := 0, seq := fun n => if n ≥ 0 then (fun n => 1 / ((↑n : ℝ) + 1) ^ 2) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",846434],"isProp":true,"context":[]}],"start":5517},{"state":[],"start":5527},{"state":[],"start":5528},{"state":[],"start":5579},{"state":[],"start":5665},{"state":[],"start":5713},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",846632],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"}]}],"start":5818},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",846632],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"}]}],"start":5891},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",846723],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]}]}],"start":5921},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",846828],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.absConverges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]}],"start":5966},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",846831],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]}],"start":5994},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",846963],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]}],"start":6098},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs =\n  { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := ⋯ }","tag":["h","e'_2","h","e'_2","h","e'_1"],"mvarId":["_uniq",847842],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a n|) n.toNat else 0, vanish := ⋯ }.nonneg","tag":["convert_1"],"mvarId":["_uniq",847119],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a n|) n.toNat else 0, vanish := ⋯ }.converges","tag":["convert_2"],"mvarId":["_uniq",847120],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]}],"start":6176},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a n|) n.toNat else 0, vanish := ⋯ }.nonneg","tag":["convert_1"],"mvarId":["_uniq",847119],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a n|) n.toNat else 0, vanish := ⋯ }.converges","tag":["convert_2"],"mvarId":["_uniq",847120],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]}],"start":6222},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a n|) n.toNat else 0, vanish := ⋯ }.converges","tag":["convert_2"],"mvarId":["_uniq",847120],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]}]}],"start":6270},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum =\n    { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",846965],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]}]}],"start":6320},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  L' = { m := 0, seq := fun n => if n ≥ 0 then (fun n => a (f n)) n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",889289],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",889219]}]}],"start":6347},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  L' = { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",889403],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",889219]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",889379]}]}],"start":6391},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.absConverges ∧\n  L' = { m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.sum","tag":[],"mvarId":["_uniq",889571],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",889219]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",889379]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.convergesTo L'","name":["this"],"isProp":true,"id":["_uniq",889570],"binderInfo":"default"}]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.convergesTo L'","tag":["this"],"mvarId":["_uniq",889568],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",889219]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",889379]}]}],"start":6431},{"state":[{"type":"{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.abs.converges","tag":[],"mvarId":["_uniq",893398],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",889219]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",889379]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.convergesTo L'","name":["this"],"isProp":true,"id":["_uniq",889570],"binderInfo":"default"}]}],"start":6478},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.convergesTo L'","tag":["this"],"mvarId":["_uniq",889568],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",889219]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",889379]}]}],"start":6532},{"state":[{"type":"∀ (ε : ℝ),\n  0 < ε →\n    ∃ a,\n      ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1078203],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",889219]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",889379]}]}],"start":6593},{"state":[{"type":"∃ a, ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1078208],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.converges","name":["ha"],"isProp":true,"id":["_uniq",846629],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",846630],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",846631],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",846722]},{"value":"converges_of_absConverges ha","type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",846827]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun a b b' e'_2 =>\n        Eq.casesOn (motive := fun a_1 x => b' = a_1 → e'_2 ≍ x → (a ∧ b) ≍ (a ∧ b')) e'_2\n          (fun h =>\n            Eq.ndrec (motive := fun b' => ∀ (e_2 : b = b'), e_2 ≍ Eq.refl b → (a ∧ b) ≍ (a ∧ b'))\n              (fun e_2 h => HEq.refl (a ∧ b)) (Eq.symm h) e'_2)\n          (Eq.refl b') (HEq.refl e'_2))\n      { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n          vanish := instCoe._proof_1 fun n => |a (f n)| }.converges\n      (L =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      ({ m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum =\n        { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0,\n            vanish := instCoe._proof_1 fun n => |a (f n)| }.sum)\n      (eq_of_heq\n        ((fun α a a' e'_2 a_1 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a_1))\n                  (fun e_2 h => HEq.refl (a = a_1)) (Eq.symm h) e'_2)\n              (Eq.refl a') (HEq.refl e'_2))\n          ℝ L\n          { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }.sum\n          (eq_of_heq\n            ((fun s s' e'_1 =>\n                Eq.casesOn (motive := fun a x => s' = a → e'_1 ≍ x → s.sum ≍ s'.sum) e'_1\n                  (fun h =>\n                    Eq.ndrec (motive := fun s' => ∀ (e_1 : s = s'), e_1 ≍ Eq.refl s → s.sum ≍ s'.sum)\n                      (fun e_1 h => HEq.refl s.sum) (Eq.symm h) e'_1)\n                  (Eq.refl s') (HEq.refl e'_1))\n              { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs\n              { m := 0, seq := fun n => if n ≥ 0 then |a n.toNat| else 0, vanish := instCoe._proof_1 fun n => |a n| }\n              (Eq.mpr (id (Eq.trans (Eq.trans (congr ⋯ ⋯) ⋯) ⋯)) ⋯)))\n          ⋯))))\n  ⋯","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",846964]},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",889219]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",889379]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078204],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078207],"binderInfo":"default"}]}],"start":6608},{"state":[{"type":"∃ a, ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1078239],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"}]}],"start":6646},{"state":[{"type":"∃ a, ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1079289],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"}]}],"start":6710},{"state":[{"type":"∃ N ≥ N₁, |{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","tag":[],"mvarId":["_uniq",1079556],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"}]}],"start":6776},{"state":[{"type":"∃ N ≥ N₁, |{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","tag":[],"mvarId":["_uniq",1079568],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.convergesTo\n  { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","name":["hconv"],"isProp":true,"id":["_uniq",1079565],"binderInfo":"default"}]}],"start":6811},{"state":[{"type":"∃ N ≥ N₁, |{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","tag":[],"mvarId":["_uniq",1092276],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"∀ (ε : ℝ),\n  0 < ε →\n    ∃ a_2,\n      ∀ (b : ℤ),\n        a_2 ≤ b →\n          |{ m := 0, seq := fun n => if 0 ≤ n then a n.toNat else 0, vanish := ⋯ }.partial b -\n                { m := 0, seq := fun n => if 0 ≤ n then a n.toNat else 0, vanish := ⋯ }.sum| <\n            ε","name":["hconv"],"isProp":true,"id":["_uniq",1092273],"binderInfo":"default"}]}],"start":6883},{"state":[{"type":"∃ N ≥ N₁, |{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","tag":[],"mvarId":["_uniq",1092436],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"∀ (ε : ℝ),\n  0 < ε →\n    ∃ a_2,\n      ∀ (b : ℤ),\n        a_2 ≤ b →\n          |{ m := 0, seq := fun n => if 0 ≤ n then a n.toNat else 0, vanish := ⋯ }.partial b -\n                { m := 0, seq := fun n => if 0 ≤ n then a n.toNat else 0, vanish := ⋯ }.sum| <\n            ε","name":["hconv"],"isProp":true,"id":["_uniq",1092273],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1092430],"binderInfo":"default"},{"type":"∀ (b : ℤ),\n  N ≤ b →\n    |{ m := 0, seq := fun n => if 0 ≤ n then a n.toNat else 0, vanish := ⋯ }.partial b -\n          { m := 0, seq := fun n => if 0 ≤ n then a n.toNat else 0, vanish := ⋯ }.sum| <\n      ε / 2","name":["hN"],"isProp":true,"id":["_uniq",1092433],"binderInfo":"default"}]}],"start":6928},{"state":[{"type":"∃ a, ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1079558],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"value":"(fun N hN =>\n    Exists.intro (max N N₁)\n      ⟨absConverges_of_permute._proof_14 ha✝ hf habs ε hε N₁ ha hN₁\n          (Eq.mp\n            (Eq.trans\n              (Eq.trans\n                (congr\n                  (congrArg (fun x => Filter.Tendsto x.partial Filter.atTop)\n                    ((fun m m_1 e_m =>\n                        Eq.rec (motive := fun m_2 e_m =>\n                          ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                            { m := m, seq := seq, vanish := vanish } =\n                              { m := m_2, seq := seq_1,\n                                vanish :=\n                                  Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                                    (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n                          (fun seq seq_1 e_seq =>\n                            Eq.rec (motive := fun seq_2 e_seq =>\n                              ∀ (vanish : ∀ n < m, seq n = 0),\n                                { m := m, seq := seq, vanish := vanish } =\n                                  { m := m, seq := seq_2,\n                                    vanish :=\n                                      Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                              (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n                          e_m)\n                      0 0 (Eq.refl 0) (fun n => if n ≥ 0 then a n.toNat else 0)\n                      (fun n => if 0 ≤ n then a n.toNat else 0)\n                      (funext fun n => ite_congr ge_iff_le._simp_1 (fun a_1 => Eq.refl (a n.toNat)) fun a => Eq.refl 0)\n                      (instCoe._proof_1 a)))\n                  (congrArg (fun x => nhds x.sum) (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯ ⋯,\n        ⋯⟩)\n  ⋯ ⋯","type":"∃ N ≥ N₁, |{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["this"],"isProp":true,"id":["_uniq",1079557]}]}],"start":6976},{"state":[{"type":"∃ a, ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1184591],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"}]}],"start":7005},{"state":[{"type":"∃ a, ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1184635],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]}]}],"start":7043},{"state":[{"type":"∃ a, ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1186712],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]}]}],"start":7089},{"state":[{"type":"∃ M, ∀ n ≤ N.toNat, finv n ≤ M","tag":[],"mvarId":["_uniq",1186743],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]}]}],"start":7143},{"state":[{"type":"∀ n ≤ N.toNat, finv n ≤ (Finset.image finv (Finset.Iic N.toNat)).sup id","tag":["h"],"mvarId":["_uniq",1186752],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]}]}],"start":7194},{"state":[{"type":"finv n ≤ (Finset.image finv (Finset.Iic N.toNat)).sup id","tag":["h"],"mvarId":["_uniq",1187096],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",1187092],"binderInfo":"default"},{"type":"n ≤ N.toNat","name":["hn"],"isProp":true,"id":["_uniq",1187095],"binderInfo":"default"}]}],"start":7209},{"state":[{"type":"∃ a, ∀ (b : ℤ), a ≤ b → |{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial b - L'| < ε","tag":["this"],"mvarId":["_uniq",1186745],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"value":"Exists.intro ((Finset.image finv (Finset.Iic N.toNat)).sup id) fun n hn =>\n  Finset.le_sup\n    (Eq.mpr\n      (id\n        (Eq.trans Finset.mem_image._simp_1\n          (congrArg Exists\n            (funext fun a =>\n              congrArg (fun x => x ∧ finv a = if h : ∃ x, f x = n then h.choose else Classical.arbitrary ℕ)\n                Finset.mem_Iic._simp_1))))\n      (Exists.intro n ⟨hn, Eq.refl (finv n)⟩))","type":"∃ M, ∀ n ≤ N.toNat, finv n ≤ M","name":["this"],"isProp":true,"id":["_uniq",1186744]}]}],"start":7284},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1194016],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"}]}],"start":7330},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1194059],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]}]}],"start":7371},{"state":[{"type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","tag":[],"mvarId":["_uniq",1196288],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]}]}],"start":7437},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1196290],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]}]}],"start":7447},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1196545],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]}],"start":7516},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1197275],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]}]}],"start":7621},{"state":[{"type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n","tag":[],"mvarId":["_uniq",1197196],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]}],"start":7681},{"state":[],"start":7738},{"state":[{"type":"∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","tag":[],"mvarId":["_uniq",1197206],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]}],"start":7754},{"state":[{"type":"Finset.image f (Finset.Iic M'.toNat) = Finset.Iic N.toNat ∪ X","tag":["h","e'_2","h"],"mvarId":["_uniq",1200938],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]},{"type":"DecidableEq ℕ","tag":["convert_7"],"mvarId":["_uniq",1198710],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]},{"type":"Disjoint (Finset.Iic N.toNat) X","tag":["convert_8"],"mvarId":["_uniq",1198711],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]}],"start":7795},{"state":[{"type":"DecidableEq ℕ","tag":["convert_7"],"mvarId":["_uniq",1198710],"isProp":false,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]},{"type":"Disjoint (Finset.Iic N.toNat) X","tag":["convert_8"],"mvarId":["_uniq",1198711],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]}],"start":7817},{"state":[{"type":"Disjoint (Finset.Iic N.toNat) X","tag":["convert_8"],"mvarId":["_uniq",1198711],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]}]}],"start":7840},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1197275],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]}]}],"start":7931},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1206070],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"}]}],"start":7963},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1206082],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]}]}],"start":7989},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1206562],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]}]}],"start":8046},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1207768],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"value":"Trans.trans\n  (Trans.trans (Finset.abs_sum_le_sum_abs a X)\n    (Finset.sum_le_sum_of_subset_of_nonneg why2\n      (of_eq_true\n        (Eq.trans\n          (forall_congr fun i =>\n            Eq.trans\n              (implies_congr Finset.mem_Icc._simp_1\n                (Eq.trans (implies_congr (Eq.refl (i ∉ X)) (one_le_mabs._simp_4 (a i))) (implies_true (i ∉ X))))\n              (implies_true (N.toNat + 1 ≤ i ∧ i ≤ q)))\n          (implies_true ℕ)))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n|)\n        |∑ n ∈ Finset.Icc ((↑N.toNat : ℤ) + 1) (↑q : ℤ),\n            { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs.seq n|\n        (Eq.mpr\n          (id\n            (congrArg (fun x => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = |x|)\n              (Finset.sum_congr\n                (congrArg (fun x => Finset.Icc (x + 1) (↑q : ℤ)) (Eq.trans (Int.ofNat_toNat N) (sup_of_le_left hNpos)))\n                fun x a_1 =>\n                dite_congr ge_iff_le._simp_1\n                  (fun h =>\n                    congrArg _root_.abs\n                      (ite_congr ge_iff_le._simp_1 (fun a_2 => Eq.refl (a x.toNat)) fun a => Eq.refl 0))\n                  fun h => Eq.refl 0)))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = _a)\n                (abs_of_nonneg\n                  (Finset.sum_nonneg fun i x =>\n                    Mathlib.Meta.Positivity.ite_nonneg✝ (0 ≤ i)\n                      (IsAbsoluteValue.abv_nonneg _root_.abs (if 0 ≤ i then a i.toNat else 0))\n                      (Mathlib.Meta.Positivity.nonneg_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))))\n            (Eq.symm\n              (Eq.mpr\n                (eq_of_heq\n                  ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                            (fun e_2 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                    (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                (Eq.refl a'_1) (HEq.refl e'_3))\n                            (Eq.symm h) e'_2)\n                        (Eq.refl a') (HEq.refl e'_2))\n                    ℝ (∑ x ∈ Finset.Icc (N + 1) (↑q : ℤ), if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (∑ x ∈ Finset.image (fun n => (↑n : ℤ)) (Finset.Icc (N.toNat + 1) q),\n                      if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (Finset.sum_congr\n                      (Finset.ext fun x =>\n                        Eq.mpr\n                          (id\n                            (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                              (Eq.trans Finset.mem_image._simp_1 (congrArg Exists (funext ⋯)))))\n                          ⋯)\n                      ⋯)\n                    ⋯ ⋯ ⋯))\n                ⋯))))\n        ⋯))\n    ⋯)","type":"|∑ n ∈ X, a n| ≤ ε / 2","name":["claim2"],"isProp":true,"id":["_uniq",1207767]}]}],"start":8098},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1207768],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"value":"Trans.trans\n  (Trans.trans (Finset.abs_sum_le_sum_abs a X)\n    (Finset.sum_le_sum_of_subset_of_nonneg why2\n      (of_eq_true\n        (Eq.trans\n          (forall_congr fun i =>\n            Eq.trans\n              (implies_congr Finset.mem_Icc._simp_1\n                (Eq.trans (implies_congr (Eq.refl (i ∉ X)) (one_le_mabs._simp_4 (a i))) (implies_true (i ∉ X))))\n              (implies_true (N.toNat + 1 ≤ i ∧ i ≤ q)))\n          (implies_true ℕ)))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n|)\n        |∑ n ∈ Finset.Icc ((↑N.toNat : ℤ) + 1) (↑q : ℤ),\n            { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs.seq n|\n        (Eq.mpr\n          (id\n            (congrArg (fun x => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = |x|)\n              (Finset.sum_congr\n                (congrArg (fun x => Finset.Icc (x + 1) (↑q : ℤ)) (Eq.trans (Int.ofNat_toNat N) (sup_of_le_left hNpos)))\n                fun x a_1 =>\n                dite_congr ge_iff_le._simp_1\n                  (fun h =>\n                    congrArg _root_.abs\n                      (ite_congr ge_iff_le._simp_1 (fun a_2 => Eq.refl (a x.toNat)) fun a => Eq.refl 0))\n                  fun h => Eq.refl 0)))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = _a)\n                (abs_of_nonneg\n                  (Finset.sum_nonneg fun i x =>\n                    Mathlib.Meta.Positivity.ite_nonneg✝ (0 ≤ i)\n                      (IsAbsoluteValue.abv_nonneg _root_.abs (if 0 ≤ i then a i.toNat else 0))\n                      (Mathlib.Meta.Positivity.nonneg_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))))\n            (Eq.symm\n              (Eq.mpr\n                (eq_of_heq\n                  ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                            (fun e_2 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                    (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                (Eq.refl a'_1) (HEq.refl e'_3))\n                            (Eq.symm h) e'_2)\n                        (Eq.refl a') (HEq.refl e'_2))\n                    ℝ (∑ x ∈ Finset.Icc (N + 1) (↑q : ℤ), if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (∑ x ∈ Finset.image (fun n => (↑n : ℤ)) (Finset.Icc (N.toNat + 1) q),\n                      if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (Finset.sum_congr\n                      (Finset.ext fun x =>\n                        Eq.mpr\n                          (id\n                            (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                              (Eq.trans Finset.mem_image._simp_1 (congrArg Exists (funext ⋯)))))\n                          ⋯)\n                      ⋯)\n                    ⋯ ⋯ ⋯))\n                ⋯))))\n        ⋯))\n    ⋯)","type":"|∑ n ∈ X, a n| ≤ ε / 2","name":["claim2"],"isProp":true,"id":["_uniq",1207767]}]}],"start":8153},{"state":[{"type":"∑ n ∈ X, |a n| ≤ ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n|","tag":[],"mvarId":["_uniq",1207571],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]}]}],"start":8205},{"state":[],"start":8266},{"state":[{"type":"∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| ≤ ε / 2","tag":[],"mvarId":["_uniq",1207706],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]}]}],"start":8287},{"state":[{"type":"∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| =\n  |∑ n ∈ Finset.Icc ((↑N.toNat : ℤ) + 1) (↑q : ℤ),\n      { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n|","tag":["h","e'_3"],"mvarId":["_uniq",1211910],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]}]}],"start":8336},{"state":[{"type":"(∑ x ∈ Finset.Icc (N + 1) (↑q : ℤ), if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0) =\n  ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n|","tag":["h","e'_3"],"mvarId":["_uniq",1254168],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]}]}],"start":8397},{"state":[{"type":"Finset.Icc (N + 1) (↑q : ℤ) = Finset.image (fun n => (↑n : ℤ)) (Finset.Icc (N.toNat + 1) q)","tag":["h","e'_2","h"],"mvarId":["_uniq",1257057],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]}]}],"start":8477},{"state":[{"type":"N + 1 ≤ x ∧ x ≤ (↑q : ℤ) → ∃ a, (N.toNat + 1 ≤ a ∧ a ≤ q) ∧ (↑a : ℤ) = x","tag":["h","e'_2","h","h","mp"],"mvarId":["_uniq",1264755],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",1257749],"binderInfo":"default"}]},{"type":"(∃ a, (N.toNat + 1 ≤ a ∧ a ≤ q) ∧ (↑a : ℤ) = x) → N + 1 ≤ x ∧ x ≤ (↑q : ℤ)","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",1264756],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",1257749],"binderInfo":"default"}]}],"start":8508},{"state":[{"type":"(∃ a, (N.toNat + 1 ≤ a ∧ a ≤ q) ∧ (↑a : ℤ) = x) → N + 1 ≤ x ∧ x ≤ (↑q : ℤ)","tag":["h","e'_2","h","h","mpr"],"mvarId":["_uniq",1264756],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"type":"ℤ","name":["x"],"isProp":false,"id":["_uniq",1257749],"binderInfo":"default"}]}],"start":8555},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1207768],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"value":"Trans.trans\n  (Trans.trans (Finset.abs_sum_le_sum_abs a X)\n    (Finset.sum_le_sum_of_subset_of_nonneg why2\n      (of_eq_true\n        (Eq.trans\n          (forall_congr fun i =>\n            Eq.trans\n              (implies_congr Finset.mem_Icc._simp_1\n                (Eq.trans (implies_congr (Eq.refl (i ∉ X)) (one_le_mabs._simp_4 (a i))) (implies_true (i ∉ X))))\n              (implies_true (N.toNat + 1 ≤ i ∧ i ≤ q)))\n          (implies_true ℕ)))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n|)\n        |∑ n ∈ Finset.Icc ((↑N.toNat : ℤ) + 1) (↑q : ℤ),\n            { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs.seq n|\n        (Eq.mpr\n          (id\n            (congrArg (fun x => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = |x|)\n              (Finset.sum_congr\n                (congrArg (fun x => Finset.Icc (x + 1) (↑q : ℤ)) (Eq.trans (Int.ofNat_toNat N) (sup_of_le_left hNpos)))\n                fun x a_1 =>\n                dite_congr ge_iff_le._simp_1\n                  (fun h =>\n                    congrArg _root_.abs\n                      (ite_congr ge_iff_le._simp_1 (fun a_2 => Eq.refl (a x.toNat)) fun a => Eq.refl 0))\n                  fun h => Eq.refl 0)))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = _a)\n                (abs_of_nonneg\n                  (Finset.sum_nonneg fun i x =>\n                    Mathlib.Meta.Positivity.ite_nonneg✝ (0 ≤ i)\n                      (IsAbsoluteValue.abv_nonneg _root_.abs (if 0 ≤ i then a i.toNat else 0))\n                      (Mathlib.Meta.Positivity.nonneg_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))))\n            (Eq.symm\n              (Eq.mpr\n                (eq_of_heq\n                  ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                            (fun e_2 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                    (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                (Eq.refl a'_1) (HEq.refl e'_3))\n                            (Eq.symm h) e'_2)\n                        (Eq.refl a') (HEq.refl e'_2))\n                    ℝ (∑ x ∈ Finset.Icc (N + 1) (↑q : ℤ), if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (∑ x ∈ Finset.image (fun n => (↑n : ℤ)) (Finset.Icc (N.toNat + 1) q),\n                      if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (Finset.sum_congr\n                      (Finset.ext fun x =>\n                        Eq.mpr\n                          (id\n                            (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                              (Eq.trans Finset.mem_image._simp_1 (congrArg Exists (funext ⋯)))))\n                          ⋯)\n                      ⋯)\n                    ⋯ ⋯ ⋯))\n                ⋯))))\n        ⋯))\n    ⋯)","type":"|∑ n ∈ X, a n| ≤ ε / 2","name":["claim2"],"isProp":true,"id":["_uniq",1207767]}]}],"start":8567},{"state":[{"type":"|{ m := 0, seq := fun n => if 0 ≤ n then af n.toNat else 0, vanish := ⋯ }.partial M' - L'| < ε","tag":["h"],"mvarId":["_uniq",1207768],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"value":"Trans.trans\n  (Trans.trans (Finset.abs_sum_le_sum_abs a X)\n    (Finset.sum_le_sum_of_subset_of_nonneg why2\n      (of_eq_true\n        (Eq.trans\n          (forall_congr fun i =>\n            Eq.trans\n              (implies_congr Finset.mem_Icc._simp_1\n                (Eq.trans (implies_congr (Eq.refl (i ∉ X)) (one_le_mabs._simp_4 (a i))) (implies_true (i ∉ X))))\n              (implies_true (N.toNat + 1 ≤ i ∧ i ≤ q)))\n          (implies_true ℕ)))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n|)\n        |∑ n ∈ Finset.Icc ((↑N.toNat : ℤ) + 1) (↑q : ℤ),\n            { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs.seq n|\n        (Eq.mpr\n          (id\n            (congrArg (fun x => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = |x|)\n              (Finset.sum_congr\n                (congrArg (fun x => Finset.Icc (x + 1) (↑q : ℤ)) (Eq.trans (Int.ofNat_toNat N) (sup_of_le_left hNpos)))\n                fun x a_1 =>\n                dite_congr ge_iff_le._simp_1\n                  (fun h =>\n                    congrArg _root_.abs\n                      (ite_congr ge_iff_le._simp_1 (fun a_2 => Eq.refl (a x.toNat)) fun a => Eq.refl 0))\n                  fun h => Eq.refl 0)))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = _a)\n                (abs_of_nonneg\n                  (Finset.sum_nonneg fun i x =>\n                    Mathlib.Meta.Positivity.ite_nonneg✝ (0 ≤ i)\n                      (IsAbsoluteValue.abv_nonneg _root_.abs (if 0 ≤ i then a i.toNat else 0))\n                      (Mathlib.Meta.Positivity.nonneg_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))))\n            (Eq.symm\n              (Eq.mpr\n                (eq_of_heq\n                  ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                            (fun e_2 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                    (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                (Eq.refl a'_1) (HEq.refl e'_3))\n                            (Eq.symm h) e'_2)\n                        (Eq.refl a') (HEq.refl e'_2))\n                    ℝ (∑ x ∈ Finset.Icc (N + 1) (↑q : ℤ), if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (∑ x ∈ Finset.image (fun n => (↑n : ℤ)) (Finset.Icc (N.toNat + 1) q),\n                      if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (Finset.sum_congr\n                      (Finset.ext fun x =>\n                        Eq.mpr\n                          (id\n                            (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                              (Eq.trans Finset.mem_image._simp_1 (congrArg Exists (funext ⋯)))))\n                          ⋯)\n                      ⋯)\n                    ⋯ ⋯ ⋯))\n                ⋯))))\n        ⋯))\n    ⋯)","type":"|∑ n ∈ X, a n| ≤ ε / 2","name":["claim2"],"isProp":true,"id":["_uniq",1207767]}]}],"start":8574},{"state":[],"start":8682},{"state":[],"start":8758},{"state":[{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial M' -\n        { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N| +\n    ε / 2 ≤\n  ε / 2 + ε / 2","tag":[],"mvarId":["_uniq",1331446],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"value":"Trans.trans\n  (Trans.trans (Finset.abs_sum_le_sum_abs a X)\n    (Finset.sum_le_sum_of_subset_of_nonneg why2\n      (of_eq_true\n        (Eq.trans\n          (forall_congr fun i =>\n            Eq.trans\n              (implies_congr Finset.mem_Icc._simp_1\n                (Eq.trans (implies_congr (Eq.refl (i ∉ X)) (one_le_mabs._simp_4 (a i))) (implies_true (i ∉ X))))\n              (implies_true (N.toNat + 1 ≤ i ∧ i ≤ q)))\n          (implies_true ℕ)))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n|)\n        |∑ n ∈ Finset.Icc ((↑N.toNat : ℤ) + 1) (↑q : ℤ),\n            { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs.seq n|\n        (Eq.mpr\n          (id\n            (congrArg (fun x => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = |x|)\n              (Finset.sum_congr\n                (congrArg (fun x => Finset.Icc (x + 1) (↑q : ℤ)) (Eq.trans (Int.ofNat_toNat N) (sup_of_le_left hNpos)))\n                fun x a_1 =>\n                dite_congr ge_iff_le._simp_1\n                  (fun h =>\n                    congrArg _root_.abs\n                      (ite_congr ge_iff_le._simp_1 (fun a_2 => Eq.refl (a x.toNat)) fun a => Eq.refl 0))\n                  fun h => Eq.refl 0)))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = _a)\n                (abs_of_nonneg\n                  (Finset.sum_nonneg fun i x =>\n                    Mathlib.Meta.Positivity.ite_nonneg✝ (0 ≤ i)\n                      (IsAbsoluteValue.abv_nonneg _root_.abs (if 0 ≤ i then a i.toNat else 0))\n                      (Mathlib.Meta.Positivity.nonneg_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))))\n            (Eq.symm\n              (Eq.mpr\n                (eq_of_heq\n                  ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                            (fun e_2 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                    (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                (Eq.refl a'_1) (HEq.refl e'_3))\n                            (Eq.symm h) e'_2)\n                        (Eq.refl a') (HEq.refl e'_2))\n                    ℝ (∑ x ∈ Finset.Icc (N + 1) (↑q : ℤ), if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (∑ x ∈ Finset.image (fun n => (↑n : ℤ)) (Finset.Icc (N.toNat + 1) q),\n                      if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (Finset.sum_congr\n                      (Finset.ext fun x =>\n                        Eq.mpr\n                          (id\n                            (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                              (Eq.trans Finset.mem_image._simp_1 (congrArg Exists (funext ⋯)))))\n                          ⋯)\n                      ⋯)\n                    ⋯ ⋯ ⋯))\n                ⋯))))\n        ⋯))\n    ⋯)","type":"|∑ n ∈ X, a n| ≤ ε / 2","name":["claim2"],"isProp":true,"id":["_uniq",1207767]}]}],"start":8786},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then af n.toNat else 0, vanish := ⋯ }.partial M' -\n    { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N =\n  ∑ n ∈ X, a n","tag":["h","e'_3","h","e'_4"],"mvarId":["_uniq",1344827],"isProp":true,"context":[{"type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",846628],"binderInfo":"implicit"},{"type":"∀ ε > 0,\n  ∃ N ≥ { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.m,\n    ∀ p ≥ N,\n      ∀ q ≥ N,\n        |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε","name":["ha✝"],"isProp":true,"id":["_uniq",1078225],"binderInfo":"default"},{"type":"ℕ → ℕ","name":["f"],"isProp":false,"id":["_uniq",1078228],"binderInfo":"implicit"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",1078229],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.sum","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",1078230]},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.converges","name":["hconv"],"isProp":true,"id":["_uniq",1078231],"binderInfo":"default"},{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.converges ∧\n  L = { m := 0, seq := fun n => if n ≥ 0 then (fun n => |a (f n)|) n.toNat else 0, vanish := ⋯ }.sum","name":["habs"],"isProp":true,"id":["_uniq",1078232],"binderInfo":"default"},{"value":"{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.sum","type":"ℝ","name":["L'"],"isProp":false,"id":["_uniq",1078233]},{"value":"fun n => a (f n)","type":"ℕ → ℝ","name":["af"],"isProp":false,"id":["_uniq",1078234]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",1078235],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",1078236],"binderInfo":"default"},{"type":"ℤ","name":["N₁"],"isProp":false,"id":["_uniq",1078345],"binderInfo":"default"},{"type":"∀ p ≥ N₁,\n  ∀ q ≥ N₁,\n    |∑ n ∈ Finset.Icc p q, { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.abs.seq n| ≤ ε / 2","name":["ha"],"isProp":true,"id":["_uniq",1078357],"binderInfo":"default"},{"type":"0 ≤ N₁","name":["hN₁"],"isProp":true,"id":["_uniq",1079286],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",1184577],"binderInfo":"default"},{"type":"N ≥ N₁","name":["hN"],"isProp":true,"id":["_uniq",1184586],"binderInfo":"default"},{"type":"|{ m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := ⋯ }.partial N - L'| < ε / 2","name":["hN2"],"isProp":true,"id":["_uniq",1184590],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf N₁)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul N₁ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N₁ ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf N₁) (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul N (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (N₁ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero N₁ (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (N ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf N)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (N ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero N (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN₁))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hN))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"N ≥ 0","name":["hNpos"],"isProp":true,"id":["_uniq",1184634]},{"value":"Function.invFun f","type":"ℕ → ℕ","name":["finv"],"isProp":false,"id":["_uniq",1186711]},{"type":"ℕ","name":["M"],"isProp":false,"id":["_uniq",1193903],"binderInfo":"default"},{"type":"∀ n ≤ N.toNat, finv n ≤ M","name":["hM"],"isProp":true,"id":["_uniq",1193907],"binderInfo":"default"},{"type":"ℤ","name":["M'"],"isProp":false,"id":["_uniq",1194012],"binderInfo":"default"},{"type":"(↑M : ℤ) ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",1194015],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑M : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                  (Mathlib.Tactic.Ring.add_pf_zero_add ((↑M : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑M : ℤ)) (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul M' (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt ((↑M : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑M : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (M' ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf M')\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (M' ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero M' (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ M)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hM'))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"M' ≥ 0","name":["hM'_pos"],"isProp":true,"id":["_uniq",1194058]},{"value":"sorry","type":"Finset.image f (Finset.Iic M'.toNat) ⊇ Finset.Iic N.toNat","name":["why"],"isProp":true,"id":["_uniq",1196289]},{"value":"Finset.image f (Finset.Iic M'.toNat) \\ Finset.Iic N.toNat","type":"Finset ℕ","name":["X"],"isProp":false,"id":["_uniq",1196544]},{"value":"Trans.trans (Eq.symm (Finset.sum_image fun ⦃x₁⦄ a ⦃x₂⦄ a => hf.left))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑ n ∈ Finset.image f (Finset.Iic M'.toNat), a n) (∑ x ∈ Finset.Iic N.toNat ∪ X, a x)\n        (Finset.sum_congr\n          (of_eq_true\n            (Eq.trans\n              (Eq.trans (congrArg (Eq (Finset.image f (Finset.Iic M'.toNat))) Finset.union_sdiff_self_eq_union)\n                Finset.right_eq_union._simp_1)\n              (eq_true why)))\n          fun x a_1 => Eq.refl (a x))\n        (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n) (∑ x ∈ Finset.Iic N.toNat, a x + ∑ x ∈ X, a x)\n        (Eq.refl (∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n))))\n    (Finset.sum_union\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Finset.disjoint_right))) fun ⦃n⦄ hn a_1 =>\n        Exists.casesOn hconv fun w h =>\n          And.casesOn habs fun left right =>\n            And.casesOn (Eq.mp absConverges_of_permute._simp_16 hn) fun left_1 right =>\n              Exists.casesOn left fun w h => False.elim (right a_1))))","type":"∑ m ∈ Finset.Iic M'.toNat, a (f m) = ∑ n ∈ Finset.Iic N.toNat, a n + ∑ n ∈ X, a n","name":["claim"],"isProp":true,"id":["_uniq",1197274]},{"type":"ℕ","name":["q'"],"isProp":false,"id":["_uniq",1206066],"binderInfo":"default"},{"type":"q' ∈ upperBounds (↑X : Set ℕ)","name":["hq"],"isProp":true,"id":["_uniq",1206069],"binderInfo":"default"},{"value":"max q' N.toNat","type":"ℕ","name":["q"],"isProp":false,"id":["_uniq",1206081]},{"value":"sorry","type":"X ⊆ Finset.Icc (N.toNat + 1) q","name":["why2"],"isProp":true,"id":["_uniq",1206561]},{"value":"Trans.trans\n  (Trans.trans (Finset.abs_sum_le_sum_abs a X)\n    (Finset.sum_le_sum_of_subset_of_nonneg why2\n      (of_eq_true\n        (Eq.trans\n          (forall_congr fun i =>\n            Eq.trans\n              (implies_congr Finset.mem_Icc._simp_1\n                (Eq.trans (implies_congr (Eq.refl (i ∉ X)) (one_le_mabs._simp_4 (a i))) (implies_true (i ∉ X))))\n              (implies_true (N.toNat + 1 ≤ i ∧ i ≤ q)))\n          (implies_true ℕ)))))\n  (Eq.mpr\n    (eq_of_heq\n      ((fun α self a a' e'_3 a_1 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a_1)) e'_3\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a_1))\n                (fun e_3 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_3)\n            (Eq.refl a') (HEq.refl e'_3))\n        ℝ Real.instLE (∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n|)\n        |∑ n ∈ Finset.Icc ((↑N.toNat : ℤ) + 1) (↑q : ℤ),\n            { m := 0, seq := fun n => if n ≥ 0 then a n.toNat else 0, vanish := instCoe._proof_1 a }.abs.seq n|\n        (Eq.mpr\n          (id\n            (congrArg (fun x => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = |x|)\n              (Finset.sum_congr\n                (congrArg (fun x => Finset.Icc (x + 1) (↑q : ℤ)) (Eq.trans (Int.ofNat_toNat N) (sup_of_le_left hNpos)))\n                fun x a_1 =>\n                dite_congr ge_iff_le._simp_1\n                  (fun h =>\n                    congrArg _root_.abs\n                      (ite_congr ge_iff_le._simp_1 (fun a_2 => Eq.refl (a x.toNat)) fun a => Eq.refl 0))\n                  fun h => Eq.refl 0)))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => ∑ n ∈ Finset.Icc (N.toNat + 1) q, |a n| = _a)\n                (abs_of_nonneg\n                  (Finset.sum_nonneg fun i x =>\n                    Mathlib.Meta.Positivity.ite_nonneg✝ (0 ≤ i)\n                      (IsAbsoluteValue.abv_nonneg _root_.abs (if 0 ≤ i then a i.toNat else 0))\n                      (Mathlib.Meta.Positivity.nonneg_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))))\n            (Eq.symm\n              (Eq.mpr\n                (eq_of_heq\n                  ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                            (fun e_2 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                    (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                                (Eq.refl a'_1) (HEq.refl e'_3))\n                            (Eq.symm h) e'_2)\n                        (Eq.refl a') (HEq.refl e'_2))\n                    ℝ (∑ x ∈ Finset.Icc (N + 1) (↑q : ℤ), if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (∑ x ∈ Finset.image (fun n => (↑n : ℤ)) (Finset.Icc (N.toNat + 1) q),\n                      if 0 ≤ x then |if 0 ≤ x then a x.toNat else 0| else 0)\n                    (Finset.sum_congr\n                      (Finset.ext fun x =>\n                        Eq.mpr\n                          (id\n                            (congr (congrArg Iff Finset.mem_Icc._simp_1)\n                              (Eq.trans Finset.mem_image._simp_1 (congrArg Exists (funext ⋯)))))\n                          ⋯)\n                      ⋯)\n                    ⋯ ⋯ ⋯))\n                ⋯))))\n        ⋯))\n    ⋯)","type":"|∑ n ∈ X, a n| ≤ ε / 2","name":["claim2"],"isProp":true,"id":["_uniq",1207767]}]}],"start":8815},{"state":[],"start":8892},{"state":[],"start":8914},{"state":[],"start":8915},{"state":[],"start":8916},{"state":[],"start":8937},{"state":[],"start":9019},{"state":[],"start":9020},{"state":[],"start":9092},{"state":[],"start":9093},{"state":[],"start":9162},{"state":[],"start":9163},{"state":[],"start":9261},{"state":[],"start":9262},{"state":[],"start":9330},{"state":[],"start":9331},{"state":[],"start":9425},{"state":[],"start":9426},{"state":[],"start":9517},{"state":[],"start":9518},{"state":[],"start":9540},{"state":[],"start":9665},{"state":[],"start":9719},{"state":[],"start":9720},{"state":[],"start":9811},{"state":[],"start":9887},{"state":[],"start":9974},{"state":[],"start":10022},{"state":[],"start":10131},{"state":[],"start":10132},{"state":[],"start":10145},{"state":[],"start":10145}]
