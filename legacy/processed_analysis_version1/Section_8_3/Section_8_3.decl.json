[{"value":{"range":[829,1138],"original":true},"type":{"range":[806,828],"original":true},"signature":{"range":[795,828],"pp":" (X : Type) : ¬EqualCard X (Set X)","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"],["Chapter8","EqualCard"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8","EqualCard"]},"ref":{"range":[740,1138],"pp":"/-- Theorem 8.3.1 -/\ntheorem power_set_false (X : Type) : ¬EqualCard X (Set X) := by\n  -- This proof is written to follow the structure of the original text.\n  \n  by_contra!; choose f hf using this\n  set A := {x | x ∉ f x}; choose x hx using hf.2 A\n  by_cases h : x ∈ A <;> have h' := h\n  . simp [A] at h'; simp_all\n  rw [← hx] at h'\n  have : x ∈ A := by simp [A, h']\n  contradiction","original":true},"params":[{"type":[798,802],"ref":[796,797],"id":[796,797],"bi":"default"}],"name":["Chapter8","EqualCard","power_set_false"],"modifiers":null,"kind":"theorem","id":{"range":[769,794],"original":true}},{"value":{"range":[1214,1277],"original":true},"type":{"range":[1175,1213],"original":true},"signature":{"range":[1164,1213],"pp":" (X : Type) : Uncountable X ↔ ¬AtMostCountable X","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"],["Chapter8","Uncountable"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8","Uncountable"]},"ref":{"range":[1140,1277],"pp":"theorem iff (X : Type) : Uncountable X ↔ ¬AtMostCountable X := by\n  rw [AtMostCountable.iff, uncountable_iff_not_countable]","original":true},"params":[{"type":[1167,1171],"ref":[1165,1166],"id":[1165,1166],"bi":"default"}],"name":["Chapter8","Uncountable","iff"],"modifiers":null,"kind":"theorem","id":{"range":[1148,1163],"original":true}},{"value":{"range":[1376,1435],"original":true},"type":{"range":[1344,1375],"original":true},"signature":{"range":[1306,1375],"pp":" {X Y : Type} (hXY : EqualCard X Y) : Uncountable X ↔ Uncountable Y","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"],["Chapter8","Uncountable"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8","Uncountable"]},"ref":{"range":[1280,1435],"pp":"theorem equiv {X Y : Type} (hXY : EqualCard X Y) : Uncountable X ↔ Uncountable Y := by\n  simp [Uncountable.iff, AtMostCountable.equiv hXY]","original":true},"params":[{"type":[1312,1316],"ref":[1307,1308],"id":[1307,1308],"bi":"implicit"},{"type":[1312,1316],"ref":[1309,1310],"id":[1309,1310],"bi":"implicit"},{"type":[1325,1338],"ref":[1319,1322],"id":[1319,1322],"bi":"default"}],"name":["Chapter8","Uncountable","equiv"],"modifiers":null,"kind":"theorem","id":{"range":[1288,1305],"original":true}},{"value":{"range":[1518,2235],"original":true},"type":{"range":[1496,1517],"original":true},"signature":{"range":[1494,1517],"pp":" : Uncountable (Set ℕ)","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"],["Chapter8","Uncountable"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8","Uncountable"]},"ref":{"range":[1437,2235],"pp":"/-- Corollary 8.3.3 -/\ntheorem power_set_nat : Uncountable (Set ℕ) := by\n  -- This proof is written to follow the structure of the original text.\n  \n  rw [Uncountable.iff]\n  unfold AtMostCountable\n  have : ¬CountablyInfinite (Set ℕ) := by\n    have := EqualCard.power_set_false ℕ\n    contrapose! this; exact this.symm\n  have : ¬Finite (Set ℕ) := by\n    by_contra!\n    have : Finite ((fun x : ℕ ↦ ({ x } : Set ℕ)) '' .univ) := Finite.Set.subset (s := .univ) (by aesop)\n    replace : Finite ℕ := by\n      apply Finite.of_finite_univ\n      rw [← Set.finite_coe_iff]\n      apply Finite.Set.finite_of_finite_image (f := fun x ↦ ({ x } : Set ℕ))\n      intro _ _ _ _ _; aesop\n    have hinf : ¬Finite ℕ := by rw [not_finite_iff_infinite]; infer_instance\n    contradiction\n  tauto","original":true},"params":[],"name":["Chapter8","Uncountable","power_set_nat"],"modifiers":null,"kind":"theorem","id":{"range":[1468,1493],"original":true}},{"value":{"range":[2316,7000],"original":true},"type":{"range":[2300,2315],"original":true},"signature":{"range":[2298,2315],"pp":" : Uncountable ℝ","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Real"],["Chapter8"],["Chapter8","Uncountable"]],"openDecl":[{"simple":{"namespace":["Real"],"except":[]}}],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8","Uncountable"]},"ref":{"range":[2250,7000],"pp":"/-- Corollary 8.3.4 -/\ntheorem real : Uncountable ℝ := by\n  -- This proof is written to follow the structure of the original text.\n  \n  set a : ℕ → ℝ := fun n ↦ (10 : ℝ) ^ (-(n : ℝ))\n  set f : Set ℕ → ℝ := fun A ↦ ∑' n : A, a n\n  have hsummable (A : Set ℕ) : Summable (fun n : A ↦ a n) :=\n    by\n    apply Summable.subtype (f := a)\n    convert summable_geometric_of_lt_one (?_ : 0 ≤ (1 / 10 : ℝ)) ?_ using 2 with n <;> try norm_num\n    unfold a\n    rw [one_div_pow, rpow_neg, one_div]; simp; norm_num\n  have h_decomp {A B C : Set ℕ} (hC : C = A ∪ B) (hAB : ∀ n, n ∉ A ∩ B) :\n    ∑' n : C, a n = ∑' n : A, a n + ∑' n : B, a n :=\n    by\n    convert Summable.tsum_union_disjoint ?_ ?_ ?_ <;>\n      first\n      | infer_instance\n      | try apply hsummable\n    . rw [hC]\n    rw [Set.disjoint_iff_inter_eq_empty]; grind\n  have h_nonneg (A : Set ℕ) : ∑' n : A, a n ≥ 0 := by simp [a]; positivity\n  have h_congr {A B : Set ℕ} (hAB : A = B) : ∑' n : A, a n = ∑' n : B, a n := by rw [hAB]\n  have : Function.Injective f := by\n    intro A B hAB; by_contra!\n    rw [← Set.symmDiff_nonempty] at this\n    apply Nat.min_spec at this\n    set n₀ := Nat.min (symmDiff A B)\n    simp [symmDiff] at this; choose h1 h2 using this\n    wlog h : n₀ ∈ A ∧ n₀ ∉ B generalizing A B\n    . simp [h] at h1\n      apply this hAB.symm <;> simp [symmDiff_comm] <;> grind\n    replace h2 {n : ℕ} (hn : n < n₀) : n ∈ A ↔ n ∈ B := by grind\n    have : (0 : ℝ) > 0 :=\n      calc\n        _ = f A - f B := by linarith\n        _ = ∑' n : A, a n - ∑' n : B, a n := rfl\n        _ =\n            (∑' n : {n ∈ A | n ≤ n₀}, a n + ∑' n : {n ∈ A | n > n₀}, a n) -\n              (∑' n : {n ∈ B | n ≤ n₀}, a n + ∑' n : {n ∈ B | n > n₀}, a n) :=\n          by congr;\n          all_goals {\n            apply h_decomp\n            . ext n; simp; grind\n            intro n hn; simp at hn; linarith\n          }\n        _ =\n            ((∑' n : {n ∈ A | n < n₀}, a n + ∑' n : {n ∈ A | n = n₀}, a n) + ∑' n : {n ∈ A | n > n₀}, a n) -\n              ((∑' n : {n ∈ B | n < n₀}, a n + ∑' n : {n ∈ B | n = n₀}, a n) + ∑' n : {n ∈ B | n > n₀}, a n) :=\n          by congr;\n          all_goals {\n            apply h_decomp\n            . ext n; simp [le_iff_lt_or_eq]\n            intro n hn; simp at hn; linarith\n          }\n        _ =\n            ((∑' n : {n ∈ A | n < n₀}, a n + a n₀) + ∑' n : {n ∈ A | n > n₀}, a n) -\n              ((∑' n : {n ∈ B | n < n₀}, a n + 0) + ∑' n : {n ∈ B | n > n₀}, a n) :=\n          by\n          congr 3\n          .\n            calc\n              _ = ∑' n : ({ n₀ } : Set ℕ), a n := by apply h_congr; ext n; simp; grind\n              _ = _ := by simp\n          .\n            calc\n              _ = ∑' n : (∅ : Set ℕ), a n := by apply h_congr; ext n; simp; grind\n              _ = _ := by simp\n        _ =\n            (∑' n : {n ∈ A | n < n₀}, a n - ∑' n : {n ∈ B | n < n₀}, a n) + a n₀ + ∑' n : {n ∈ A | n > n₀}, a n -\n              ∑' n : {n ∈ B | n > n₀}, a n :=\n          by abel\n        _ = 0 + a n₀ + ∑' n : {n ∈ A | n > n₀}, a n - ∑' n : {n ∈ B | n > n₀}, a n := by congr; rw [sub_eq_zero];\n          apply tsum_congr_set_coe; grind\n        _ ≥ 0 + a n₀ + 0 - ∑' n : {n | n > n₀}, a n := by\n          gcongr; positivity\n          calc\n            _ = ∑' (n : {n ∈ B | n > n₀}), a n + ∑' (n : {n ∉ B | n > n₀}), a n :=\n              by\n              apply h_decomp\n              . ext n; simp; tauto\n              intro n hn; simp at hn; tauto\n            _ ≥ ∑' (n : {n ∈ B | n > n₀}), a n + 0 := by gcongr; solve_by_elim\n            _ = _ := by simp\n        _ = 0 + (10 : ℝ) ^ (-(n₀ : ℝ)) + 0 - (1 / (9 : ℝ)) * (10 : ℝ) ^ (-(n₀ : ℝ)) :=\n          by\n          congr\n          set ι : ℕ → {n | n > n₀} := fun j ↦ ⟨j + (n₀ + 1), by simp; linarith⟩\n          have hι : Function.Bijective ι := by\n            split_ands\n            . intro j k hjk; simpa [ι] using hjk\n            intro ⟨n, hn⟩; simp [ι] at hn ⊢; use n - n₀ - 1; omega\n          rw [← (Equiv.ofBijective ι hι).tsum_eq]\n          simp [ι, a]\n          calc\n            _ = ∑' j : ℕ, (10 : ℝ) ^ (-1 - n₀ : ℝ) * (1 / (10 : ℝ)) ^ j :=\n              by\n              apply tsum_congr; intro j\n              rw [pow_add, pow_add, rpow_sub, rpow_neg, rpow_one, rpow_natCast] <;> try positivity\n              simp; congr\n            _ = (10 : ℝ) ^ (-1 - n₀ : ℝ) * ∑' j : ℕ, (1 / (10 : ℝ)) ^ j := tsum_mul_left\n            _ = _ :=\n              by\n              rw [tsum_geometric_of_lt_one, (?_ : -1 - (n₀ : ℝ) = (-n₀ : ℝ) + (-1 : ℝ)), rpow_add, rpow_neg,\n                  rpow_natCast] <;>\n                try positivity\n              ring; abel; norm_num\n        _ = (8 / (9 : ℝ)) * (10 : ℝ) ^ (-(n₀ : ℝ)) := by ring\n        _ > 0 := by positivity\n    simp at this\n  replace : EqualCard (Set ℕ) (Set.range f) := ⟨(Equiv.ofInjective _ this).toFun, (Equiv.ofInjective _ this).bijective⟩\n  replace := (equiv this).mp power_set_nat\n  contrapose this\n  rw [not_uncountable_iff] at this ⊢\n  apply SetCoe.countable","original":true},"params":[],"name":["Chapter8","Uncountable","real"],"modifiers":null,"kind":"theorem","id":{"range":[2281,2297],"original":true}},{"value":{"range":[7088,7101],"original":true},"type":{"range":[7054,7087],"original":true},"signature":{"range":[7032,7087],"pp":" {X : Type} [Finite X] : Nat.card (Set X) = 2 ^ Nat.card X","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[7002,7101],"pp":"/-- Exercise 8.3.1 -/\nexample {X : Type} [Finite X] : Nat.card (Set X) = 2 ^ Nat.card X := by sorry","original":true},"params":[{"type":[7035,7039],"ref":[7033,7034],"id":[7033,7034],"bi":"implicit"},{"type":[7042,7050],"ref":null,"id":null,"bi":"instImplicit"}],"name":["Chapter8","_example"],"modifiers":null,"kind":"example","id":{"range":[7024,7031],"original":false}},{"value":{"range":[7822,7835],"original":true},"type":{"range":[7409,7819],"original":true},"signature":{"range":[7337,7819],"pp":" {X : Type} {A B C : Set X} (hAB : A ⊆ B) (hBC : B ⊆ C) (f : C ↪ A) :\n  let D : ℕ → Set A :=\n    Nat.rec ((f.image ∘ ((B.embeddingOfSubset _ hBC).image)) {x : B | ↑x ∉ A})\n      (fun _ ↦ (f.image ∘ ((B.embeddingOfSubset _ hBC).image) ∘ (A.embeddingOfSubset _ hAB).image))\n  Set.univ.PairwiseDisjoint D ∧\n    let g : A → B := fun x ↦\n      if h : x ∈ ⋃ n, D n ∧ ∃ y : B, f ⟨↑y, hBC y.property⟩ = x then h.2.choose else ⟨↑x, hAB x.property⟩\n    Function.Bijective g","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"],["Classical"]],"openDecl":[{"simple":{"namespace":["Classical"],"except":[]}}],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[7121,7835],"pp":"/--\nExercise 8.3.2.  Some subtle type changes due to how sets are implemented in Mathlib. Also we shift the sequence `D` by one so that we can work in `Set A` rather than `Set B`. -/\ntheorem Schroder_Bernstein_lemma {X : Type} {A B C : Set X} (hAB : A ⊆ B) (hBC : B ⊆ C) (f : C ↪ A) :\n    let D : ℕ → Set A :=\n      Nat.rec ((f.image ∘ ((B.embeddingOfSubset _ hBC).image)) {x : B | ↑x ∉ A})\n        (fun _ ↦ (f.image ∘ ((B.embeddingOfSubset _ hBC).image) ∘ (A.embeddingOfSubset _ hAB).image))\n    Set.univ.PairwiseDisjoint D ∧\n      let g : A → B := fun x ↦\n        if h : x ∈ ⋃ n, D n ∧ ∃ y : B, f ⟨↑y, hBC y.property⟩ = x then h.2.choose else ⟨↑x, hAB x.property⟩\n      Function.Bijective g :=\n  by sorry","original":true},"params":[{"type":[7341,7345],"ref":[7338,7339],"id":[7338,7339],"bi":"implicit"},{"type":[7355,7360],"ref":[7348,7349],"id":[7348,7349],"bi":"implicit"},{"type":[7355,7360],"ref":[7350,7351],"id":[7350,7351],"bi":"implicit"},{"type":[7355,7360],"ref":[7352,7353],"id":[7352,7353],"bi":"implicit"},{"type":[7368,7375],"ref":[7363,7366],"id":[7363,7366],"bi":"default"},{"type":[7383,7390],"ref":[7378,7381],"id":[7378,7381],"bi":"default"},{"type":[7396,7403],"ref":[7393,7394],"id":[7393,7394],"bi":"default"}],"name":["Chapter8","Schroder_Bernstein_lemma"],"modifiers":null,"kind":"theorem","id":{"range":[7312,7336],"original":true}},{"value":{"range":[7870,7909],"original":true},"type":{"range":[7865,7869],"original":true},"signature":{"range":[7851,7869],"pp":" (X Y : Type) : Prop","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[7837,7909],"pp":"abbrev LeCard (X Y : Type) : Prop :=\n  ∃ f : X → Y, Function.Injective f","original":true},"params":[{"type":[7857,7861],"ref":[7852,7853],"id":[7852,7853],"bi":"default"},{"type":[7857,7861],"ref":[7854,7855],"id":[7854,7855],"bi":"default"}],"name":["Chapter8","LeCard"],"modifiers":null,"kind":"abbrev","id":{"range":[7844,7850],"original":true}},{"value":{"range":[8025,8038],"original":true},"type":{"range":[8011,8024],"original":true},"signature":{"range":[7960,8024],"pp":" {X Y : Type} (hXY : LeCard X Y) (hYX : LeCard Y X) : EqualCard X Y","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[7911,8038],"pp":"/-- Exercise 8.3.3 -/\ntheorem Schroder_Bernstein {X Y : Type} (hXY : LeCard X Y) (hYX : LeCard Y X) : EqualCard X Y := by sorry","original":true},"params":[{"type":[7965,7969],"ref":[7961,7962],"id":[7961,7962],"bi":"implicit"},{"type":[7965,7969],"ref":[7963,7964],"id":[7963,7964],"bi":"implicit"},{"type":[7978,7988],"ref":[7972,7975],"id":[7972,7975],"bi":"default"},{"type":[7997,8007],"ref":[7991,7994],"id":[7991,7994],"bi":"default"}],"name":["Chapter8","Schroder_Bernstein"],"modifiers":null,"kind":"theorem","id":{"range":[7941,7959],"original":true}},{"value":{"range":[8073,8107],"original":true},"type":{"range":[8068,8072],"original":true},"signature":{"range":[8054,8072],"pp":" (X Y : Type) : Prop","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[8040,8107],"pp":"abbrev LtCard (X Y : Type) : Prop :=\n  LeCard X Y ∧ ¬EqualCard X Y","original":true},"params":[{"type":[8060,8064],"ref":[8055,8056],"id":[8055,8056],"bi":"default"},{"type":[8060,8064],"ref":[8057,8058],"id":[8057,8058],"bi":"default"}],"name":["Chapter8","LtCard"],"modifiers":null,"kind":"abbrev","id":{"range":[8047,8053],"original":true}},{"value":{"range":[8167,8178],"original":true},"type":{"range":[8150,8166],"original":true},"signature":{"range":[8139,8166],"pp":" {X : Type} : LtCard X (Set X)","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[8109,8178],"pp":"/-- Exercise 8.3.4 -/\nexample {X : Type} : LtCard X (Set X) := by sorry","original":true},"params":[{"type":[8142,8146],"ref":[8140,8141],"id":[8140,8141],"bi":"implicit"}],"name":["Chapter8","_example"],"modifiers":null,"kind":"example","id":{"range":[8131,8138],"original":false}},{"value":{"range":[8253,8266],"original":true},"type":{"range":[8242,8252],"original":true},"signature":{"range":[8188,8252],"pp":" {A B C : Type} (hAB : LtCard A B) (hBC : LtCard B C) : LtCard A C","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[8180,8266],"pp":"example {A B C : Type} (hAB : LtCard A B) (hBC : LtCard B C) : LtCard A C := by sorry","original":true},"params":[{"type":[8196,8200],"ref":[8189,8190],"id":[8189,8190],"bi":"implicit"},{"type":[8196,8200],"ref":[8191,8192],"id":[8191,8192],"bi":"implicit"},{"type":[8196,8200],"ref":[8193,8194],"id":[8193,8194],"bi":"implicit"},{"type":[8208,8218],"ref":[8203,8206],"id":[8203,8206],"bi":"default"},{"type":[8226,8236],"ref":[8221,8224],"id":[8221,8224],"bi":"default"}],"name":["Chapter8","_example"],"modifiers":null,"kind":"example","id":{"range":[8180,8187],"original":false}},{"value":{"range":[8301,8425],"original":true},"type":{"range":[8287,8300],"original":true},"signature":{"range":[8285,8300],"pp":" : Preorder Type","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[8268,8425],"pp":"abbrev CardOrder : Preorder Type :=\n  { le := LeCard\n    lt := LtCard\n    le_refl := by sorry\n    le_trans := by sorry\n    lt_iff_le_not_ge := by sorry }","original":true},"params":[],"name":["Chapter8","CardOrder"],"modifiers":null,"kind":"abbrev","id":{"range":[8275,8284],"original":true}},{"value":{"range":[8497,8510],"original":true},"type":{"range":[8468,8496],"original":true},"signature":{"range":[8457,8496],"pp":" (X : Type) : ¬CountablyInfinite (Set X)","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter8"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter8"]},"ref":{"range":[8427,8510],"pp":"/-- Exercise 8.3.5 -/\nexample (X : Type) : ¬CountablyInfinite (Set X) := by sorry","original":true},"params":[{"type":[8460,8464],"ref":[8458,8459],"id":[8458,8459],"bi":"default"}],"name":["Chapter8","_example"],"modifiers":null,"kind":"example","id":{"range":[8449,8456],"original":false}}]
