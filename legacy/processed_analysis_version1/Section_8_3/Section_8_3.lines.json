[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":78},{"state":[],"start":79},{"state":[],"start":83},{"state":[],"start":127},{"state":[],"start":128},{"state":[],"start":224},{"state":[],"start":312},{"state":[],"start":407},{"state":[],"start":500},{"state":[],"start":510},{"state":[],"start":511},{"state":[],"start":559},{"state":[],"start":560},{"state":[],"start":580},{"state":[],"start":581},{"state":[],"start":674},{"state":[],"start":715},{"state":[],"start":716},{"state":[],"start":719},{"state":[],"start":720},{"state":[],"start":739},{"state":[],"start":740},{"state":[],"start":761},{"state":[{"type":"¬EqualCard X (Set X)","tag":[],"mvarId":["_uniq",8],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"}]}],"start":835},{"state":[{"type":"¬EqualCard X (Set X)","tag":[],"mvarId":["_uniq",8],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"}]}],"start":908},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",28],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"},{"type":"X → Set X","name":["f"],"isProp":false,"id":["_uniq",22],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",27],"binderInfo":"default"}]}],"start":945},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",127],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"},{"type":"X → Set X","name":["f"],"isProp":false,"id":["_uniq",22],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",27],"binderInfo":"default"},{"value":"{x | x ∉ f x}","type":"Set X","name":["A"],"isProp":false,"id":["_uniq",59]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",123],"binderInfo":"default"},{"type":"f x = A","name":["hx"],"isProp":true,"id":["_uniq",126],"binderInfo":"default"}]}],"start":999},{"state":[{"type":"False","tag":["pos","_@","_hyg",148],"mvarId":["_uniq",200],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"},{"type":"X → Set X","name":["f"],"isProp":false,"id":["_uniq",22],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",27],"binderInfo":"default"},{"value":"{x | x ∉ f x}","type":"Set X","name":["A"],"isProp":false,"id":["_uniq",59]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",123],"binderInfo":"default"},{"type":"f x = A","name":["hx"],"isProp":true,"id":["_uniq",126],"binderInfo":"default"},{"type":"x ∈ A","name":["h"],"isProp":true,"id":["_uniq",183],"binderInfo":"default"},{"value":"h","type":"x ∈ A","name":["h'"],"isProp":true,"id":["_uniq",199]}]},{"type":"False","tag":["neg","_@","_hyg",148],"mvarId":["_uniq",207],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"},{"type":"X → Set X","name":["f"],"isProp":false,"id":["_uniq",22],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",27],"binderInfo":"default"},{"value":"{x | x ∉ f x}","type":"Set X","name":["A"],"isProp":false,"id":["_uniq",59]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",123],"binderInfo":"default"},{"type":"f x = A","name":["hx"],"isProp":true,"id":["_uniq",126],"binderInfo":"default"},{"type":"x ∉ A","name":["h"],"isProp":true,"id":["_uniq",190],"binderInfo":"default"},{"value":"h","type":"x ∉ A","name":["h'"],"isProp":true,"id":["_uniq",206]}]}],"start":1039},{"state":[{"type":"False","tag":["neg","_@","_hyg",148],"mvarId":["_uniq",207],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"},{"type":"X → Set X","name":["f"],"isProp":false,"id":["_uniq",22],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",27],"binderInfo":"default"},{"value":"{x | x ∉ f x}","type":"Set X","name":["A"],"isProp":false,"id":["_uniq",59]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",123],"binderInfo":"default"},{"type":"f x = A","name":["hx"],"isProp":true,"id":["_uniq",126],"binderInfo":"default"},{"type":"x ∉ A","name":["h"],"isProp":true,"id":["_uniq",190],"binderInfo":"default"},{"value":"h","type":"x ∉ A","name":["h'"],"isProp":true,"id":["_uniq",206]}]}],"start":1068},{"state":[{"type":"False","tag":["neg","_@","_hyg",148],"mvarId":["_uniq",1234],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"},{"type":"X → Set X","name":["f"],"isProp":false,"id":["_uniq",22],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",27],"binderInfo":"default"},{"value":"{x | x ∉ f x}","type":"Set X","name":["A"],"isProp":false,"id":["_uniq",59]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",123],"binderInfo":"default"},{"type":"f x = A","name":["hx"],"isProp":true,"id":["_uniq",126],"binderInfo":"default"},{"type":"x ∉ A","name":["h"],"isProp":true,"id":["_uniq",190],"binderInfo":"default"},{"type":"x ∉ f x","name":["h'"],"isProp":true,"id":["_uniq",1231],"binderInfo":"default"}]}],"start":1087},{"state":[{"type":"False","tag":["neg","_@","_hyg",148],"mvarId":["_uniq",1319],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",7],"binderInfo":"default"},{"type":"X → Set X","name":["f"],"isProp":false,"id":["_uniq",22],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",27],"binderInfo":"default"},{"value":"{x | x ∉ f x}","type":"Set X","name":["A"],"isProp":false,"id":["_uniq",59]},{"type":"X","name":["x"],"isProp":false,"id":["_uniq",123],"binderInfo":"default"},{"type":"f x = A","name":["hx"],"isProp":true,"id":["_uniq",126],"binderInfo":"default"},{"type":"x ∉ A","name":["h"],"isProp":true,"id":["_uniq",190],"binderInfo":"default"},{"type":"x ∉ f x","name":["h'"],"isProp":true,"id":["_uniq",1231],"binderInfo":"default"},{"value":"of_eq_true (Eq.trans (congrArg Not (eq_false h')) not_false_eq_true)","type":"x ∈ A","name":["this"],"isProp":true,"id":["_uniq",1318]}]}],"start":1123},{"state":[],"start":1139},{"state":[],"start":1140},{"state":[{"type":"Uncountable X ↔ ¬AtMostCountable X","tag":[],"mvarId":["_uniq",1688],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1687],"binderInfo":"default"}]}],"start":1220},{"state":[],"start":1278},{"state":[],"start":1279},{"state":[],"start":1280},{"state":[],"start":1342},{"state":[{"type":"Uncountable X ↔ Uncountable Y","tag":[],"mvarId":["_uniq",1718],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",1715],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",1716],"binderInfo":"implicit"},{"type":"EqualCard X Y","name":["hXY"],"isProp":true,"id":["_uniq",1717],"binderInfo":"default"}]}],"start":1382},{"state":[],"start":1436},{"state":[],"start":1437},{"state":[],"start":1460},{"state":[{"type":"Uncountable (Set ℕ)","tag":[],"mvarId":["_uniq",3870],"isProp":true,"context":[]}],"start":1524},{"state":[{"type":"Uncountable (Set ℕ)","tag":[],"mvarId":["_uniq",3870],"isProp":true,"context":[]}],"start":1597},{"state":[{"type":"¬AtMostCountable (Set ℕ)","tag":[],"mvarId":["_uniq",3876],"isProp":true,"context":[]}],"start":1620},{"state":[{"type":"¬(CountablyInfinite (Set ℕ) ∨ Finite (Set ℕ))","tag":[],"mvarId":["_uniq",3893],"isProp":true,"context":[]}],"start":1645},{"state":[{"type":"¬CountablyInfinite (Set ℕ)","tag":[],"mvarId":["_uniq",3896],"isProp":true,"context":[]}],"start":1691},{"state":[{"type":"¬CountablyInfinite (Set ℕ)","tag":[],"mvarId":["_uniq",3905],"isProp":true,"context":[{"value":"EqualCard.power_set_false ℕ","type":"¬EqualCard ℕ (Set ℕ)","name":["this"],"isProp":true,"id":["_uniq",3904]}]}],"start":1733},{"state":[{"type":"¬(CountablyInfinite (Set ℕ) ∨ Finite (Set ℕ))","tag":[],"mvarId":["_uniq",3898],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this"],"isProp":true,"id":["_uniq",3897]}]}],"start":1771},{"state":[{"type":"¬Finite (Set ℕ)","tag":[],"mvarId":["_uniq",3950],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this"],"isProp":true,"id":["_uniq",3897]}]}],"start":1806},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",3958],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3897]},{"type":"Finite (Set ℕ)","name":["this"],"isProp":true,"id":["_uniq",3957],"binderInfo":"default"}]}],"start":1821},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",4414],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝¹"],"isProp":true,"id":["_uniq",3897]},{"type":"Finite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3957],"binderInfo":"default"},{"value":"Finite.Set.subset Set.univ\n  (of_eq_true\n    (Eq.trans (congrArg (fun x => x ⊆ Set.univ) Set.image_univ) (Set.subset_univ._simp_1 (Set.range fun x => {x}))))","type":"Finite (↑((fun x => {x}) '' Set.univ) : Type)","name":["this"],"isProp":true,"id":["_uniq",4413]}]}],"start":1925},{"state":[{"type":"Finite ℕ","tag":[],"mvarId":["_uniq",5522],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝¹"],"isProp":true,"id":["_uniq",3897]},{"type":"Finite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3957],"binderInfo":"default"},{"value":"Finite.Set.subset Set.univ\n  (of_eq_true\n    (Eq.trans (congrArg (fun x => x ⊆ Set.univ) Set.image_univ) (Set.subset_univ._simp_1 (Set.range fun x => {x}))))","type":"Finite (↑((fun x => {x}) '' Set.univ) : Type)","name":["this"],"isProp":true,"id":["_uniq",4413]}]}],"start":1956},{"state":[{"type":"Set.univ.Finite","tag":["a","_@","Init","Core","_hyg",599],"mvarId":["_uniq",5531],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝¹"],"isProp":true,"id":["_uniq",3897]},{"type":"Finite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3957],"binderInfo":"default"},{"value":"Finite.Set.subset Set.univ\n  (of_eq_true\n    (Eq.trans (congrArg (fun x => x ⊆ Set.univ) Set.image_univ) (Set.subset_univ._simp_1 (Set.range fun x => {x}))))","type":"Finite (↑((fun x => {x}) '' Set.univ) : Type)","name":["this"],"isProp":true,"id":["_uniq",4413]}]}],"start":1990},{"state":[{"type":"Finite (↑Set.univ : Type)","tag":["a","_@","Init","Core","_hyg",599],"mvarId":["_uniq",5542],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝¹"],"isProp":true,"id":["_uniq",3897]},{"type":"Finite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3957],"binderInfo":"default"},{"value":"Finite.Set.subset Set.univ\n  (of_eq_true\n    (Eq.trans (congrArg (fun x => x ⊆ Set.univ) Set.image_univ) (Set.subset_univ._simp_1 (Set.range fun x => {x}))))","type":"Finite (↑((fun x => {x}) '' Set.univ) : Type)","name":["this"],"isProp":true,"id":["_uniq",4413]}]}],"start":2023},{"state":[{"type":"Set.InjOn (fun x => {x}) Set.univ","tag":["a","h","_@","Init","Core","_hyg",599],"mvarId":["_uniq",5622],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝¹"],"isProp":true,"id":["_uniq",3897]},{"type":"Finite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3957],"binderInfo":"default"},{"value":"Finite.Set.subset Set.univ\n  (of_eq_true\n    (Eq.trans (congrArg (fun x => x ⊆ Set.univ) Set.image_univ) (Set.subset_univ._simp_1 (Set.range fun x => {x}))))","type":"Finite (↑((fun x => {x}) '' Set.univ) : Type)","name":["this"],"isProp":true,"id":["_uniq",4413]}]}],"start":2100},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",6991],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝¹"],"isProp":true,"id":["_uniq",3897]},{"type":"Finite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3957],"binderInfo":"default"},{"value":"Finite.of_finite_univ\n  (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext Set.finite_coe_iff))))\n    ((fun s => Finite.Set.finite_of_finite_image s) Set.univ fun ⦃x₁⦄ a ⦃x₂⦄ a a =>\n      of_eq_true\n        (Eq.trans (congrArg (fun x => x = x₂) (id (Eq.mp Set.singleton_eq_singleton_iff._simp_1 a))) (eq_self x₂))))","type":"Finite ℕ","name":["this"],"isProp":true,"id":["_uniq",5523]}]}],"start":2129},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",6996],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝¹"],"isProp":true,"id":["_uniq",3897]},{"type":"Finite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3957],"binderInfo":"default"},{"value":"Finite.of_finite_univ\n  (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext Set.finite_coe_iff))))\n    ((fun s => Finite.Set.finite_of_finite_image s) Set.univ fun ⦃x₁⦄ a ⦃x₂⦄ a a =>\n      of_eq_true\n        (Eq.trans (congrArg (fun x => x = x₂) (id (Eq.mp Set.singleton_eq_singleton_iff._simp_1 a))) (eq_self x₂))))","type":"Finite ℕ","name":["this"],"isProp":true,"id":["_uniq",5523]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext not_finite_iff_infinite))) inferInstance","type":"¬Finite ℕ","name":["hinf"],"isProp":true,"id":["_uniq",6995]}]}],"start":2210},{"state":[{"type":"¬(CountablyInfinite (Set ℕ) ∨ Finite (Set ℕ))","tag":[],"mvarId":["_uniq",3952],"isProp":true,"context":[{"value":"have this := EqualCard.power_set_false ℕ;\nMathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id\n      (implies_congr (Mathlib.Tactic.PushNeg.not_not_eq (CountablyInfinite (Set ℕ)))\n        (Mathlib.Tactic.PushNeg.not_not_eq (EqualCard ℕ (Set ℕ)))))\n    fun this => EqualCard.symm this)\n  this","type":"¬CountablyInfinite (Set ℕ)","name":["this✝"],"isProp":true,"id":["_uniq",3897]},{"value":"fun this =>\n  have this :=\n    Finite.Set.subset Set.univ\n      (of_eq_true\n        (Eq.trans (congrArg (fun x => x ⊆ Set.univ) Set.image_univ)\n          (Set.subset_univ._simp_1 (Set.range fun x => {x}))));\n  have this :=\n    Finite.of_finite_univ\n      (Eq.mpr (id (congrArg (fun _a => _a) (Eq.symm (propext Set.finite_coe_iff))))\n        ((fun s => Finite.Set.finite_of_finite_image s) Set.univ fun ⦃x₁⦄ a ⦃x₂⦄ a a =>\n          of_eq_true\n            (Eq.trans (congrArg (fun x => x = x₂) (id (Eq.mp Set.singleton_eq_singleton_iff._simp_1 a)))\n              (eq_self x₂))));\n  have hinf := Eq.mpr (id (congrArg (fun _a => _a) (propext not_finite_iff_infinite))) inferInstance;\n  False.elim (hinf this)","type":"¬Finite (Set ℕ)","name":["this"],"isProp":true,"id":["_uniq",3951]}]}],"start":2228},{"state":[],"start":2236},{"state":[],"start":2237},{"state":[],"start":2250},{"state":[],"start":2273},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",10209],"isProp":true,"context":[]}],"start":2322},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",10209],"isProp":true,"context":[]}],"start":2395},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",10316],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]}]}],"start":2450},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",10718],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]}]}],"start":2503},{"state":[{"type":"Summable fun n => a (↑n : ℕ)","tag":[],"mvarId":["_uniq",11063],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",10759],"binderInfo":"default"}]}],"start":2568},{"state":[{"type":"Summable a","tag":["hf"],"mvarId":["_uniq",11227],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",10759],"binderInfo":"default"}]}],"start":2604},{"state":[{"type":"a n = (1 / 10) ^ n","tag":["h","e'_5","h"],"mvarId":["_uniq",12654],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",10759],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",12274],"binderInfo":"default"}]}],"start":2702},{"state":[{"type":"10 ^ (-(↑n : ℝ)) = (1 / 10) ^ n","tag":["h","e'_5","h"],"mvarId":["_uniq",12753],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",10759],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",12274],"binderInfo":"default"}]}],"start":2715},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",11067],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]}]}],"start":2771},{"state":[{"type":"∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","tag":[],"mvarId":["_uniq",13644],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",13283],"binderInfo":"implicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",13286],"binderInfo":"implicit"},{"type":"Set ℕ","name":["C"],"isProp":false,"id":["_uniq",13289],"binderInfo":"implicit"},{"type":"C = A ∪ B","name":["hC"],"isProp":true,"id":["_uniq",13305],"binderInfo":"default"},{"type":"∀ (n : ℕ), n ∉ A ∩ B","name":["hAB"],"isProp":true,"id":["_uniq",13350],"binderInfo":"default"}]}],"start":2906},{"state":[{"type":"∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)","tag":["h","e'_2"],"mvarId":["_uniq",16128],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",13283],"binderInfo":"implicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",13286],"binderInfo":"implicit"},{"type":"Set ℕ","name":["C"],"isProp":false,"id":["_uniq",13289],"binderInfo":"implicit"},{"type":"C = A ∪ B","name":["hC"],"isProp":true,"id":["_uniq",13305],"binderInfo":"default"},{"type":"∀ (n : ℕ), n ∉ A ∩ B","name":["hAB"],"isProp":true,"id":["_uniq",13350],"binderInfo":"default"}]},{"type":"Disjoint A B","tag":["convert_10"],"mvarId":["_uniq",13662],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",13283],"binderInfo":"implicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",13286],"binderInfo":"implicit"},{"type":"Set ℕ","name":["C"],"isProp":false,"id":["_uniq",13289],"binderInfo":"implicit"},{"type":"C = A ∪ B","name":["hC"],"isProp":true,"id":["_uniq",13305],"binderInfo":"default"},{"type":"∀ (n : ℕ), n ∉ A ∩ B","name":["hAB"],"isProp":true,"id":["_uniq",13350],"binderInfo":"default"}]}],"start":3005},{"state":[{"type":"Disjoint A B","tag":["convert_10"],"mvarId":["_uniq",13662],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",13283],"binderInfo":"implicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",13286],"binderInfo":"implicit"},{"type":"Set ℕ","name":["C"],"isProp":false,"id":["_uniq",13289],"binderInfo":"implicit"},{"type":"C = A ∪ B","name":["hC"],"isProp":true,"id":["_uniq",13305],"binderInfo":"default"},{"type":"∀ (n : ℕ), n ∉ A ∩ B","name":["hAB"],"isProp":true,"id":["_uniq",13350],"binderInfo":"default"}]}],"start":3019},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",13647],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]}]}],"start":3067},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",18323],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]}]}],"start":3144},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",32427],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]}]}],"start":3235},{"state":[{"type":"Function.Injective f","tag":[],"mvarId":["_uniq",32454],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]}]}],"start":3271},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",32985],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",32459],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",32462],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",32465],"binderInfo":"default"},{"type":"A ≠ B","name":["this"],"isProp":true,"id":["_uniq",32972],"binderInfo":"default"}]}],"start":3301},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",33003],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",32459],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",32462],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",32465],"binderInfo":"default"},{"type":"(symmDiff A B).Nonempty","name":["this"],"isProp":true,"id":["_uniq",33000],"binderInfo":"default"}]}],"start":3343},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",33017],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",32459],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",32462],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",32465],"binderInfo":"default"},{"type":"Nat.min (symmDiff A B) ∈ symmDiff A B ∧ ∀ n ∈ symmDiff A B, Nat.min (symmDiff A B) ≤ n","name":["this"],"isProp":true,"id":["_uniq",33014],"binderInfo":"default"}]}],"start":3374},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",33304],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",32459],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",32462],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",32465],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",33188]},{"type":"n₀ ∈ symmDiff A B ∧ ∀ n ∈ symmDiff A B, n₀ ≤ n","name":["this"],"isProp":true,"id":["_uniq",33301],"binderInfo":"default"}]}],"start":3413},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",41652],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",32459],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",32462],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",32465],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",33188]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41645],"binderInfo":"default"},{"type":"∀ (n : ℕ), n ∈ A ∧ n ∉ B ∨ n ∈ B ∧ n ∉ A → n₀ ≤ n","name":["h2"],"isProp":true,"id":["_uniq",41649],"binderInfo":"default"}]}],"start":3466},{"state":[{"type":"False","tag":["inr"],"mvarId":["_uniq",41734],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",32459],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",32462],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",32465],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",33188]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41645],"binderInfo":"default"},{"type":"∀ (n : ℕ), n ∈ A ∧ n ∉ B ∨ n ∈ B ∧ n ∉ A → n₀ ≤ n","name":["h2"],"isProp":true,"id":["_uniq",41649],"binderInfo":"default"},{"type":"∀ ⦃A B : Set ℕ⦄,\n  f A = f B →\n    let n₀ := Nat.min (symmDiff A B);\n    n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A → (∀ (n : ℕ), n ∈ A ∧ n ∉ B ∨ n ∈ B ∧ n ∉ A → n₀ ≤ n) → n₀ ∈ A ∧ n₀ ∉ B → False","name":["this"],"isProp":true,"id":["_uniq",41681],"binderInfo":"default"},{"type":"¬(n₀ ∈ A ∧ n₀ ∉ B)","name":["h"],"isProp":true,"id":["_uniq",41733],"binderInfo":"default"}]},{"type":"False","tag":[],"mvarId":["_uniq",41707],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"∀ (n : ℕ), n ∈ A ∧ n ∉ B ∨ n ∈ B ∧ n ∉ A → n₀ ≤ n","name":["h2"],"isProp":true,"id":["_uniq",41701],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"}]}],"start":3522},{"state":[{"type":"False","tag":["inr"],"mvarId":["_uniq",41839],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",32459],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",32462],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",32465],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",33188]},{"type":"∀ (n : ℕ), n ∈ A ∧ n ∉ B ∨ n ∈ B ∧ n ∉ A → n₀ ≤ n","name":["h2"],"isProp":true,"id":["_uniq",41649],"binderInfo":"default"},{"type":"∀ ⦃A B : Set ℕ⦄,\n  f A = f B →\n    let n₀ := Nat.min (symmDiff A B);\n    n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A → (∀ (n : ℕ), n ∈ A ∧ n ∉ B ∨ n ∈ B ∧ n ∉ A → n₀ ≤ n) → n₀ ∈ A ∧ n₀ ∉ B → False","name":["this"],"isProp":true,"id":["_uniq",41681],"binderInfo":"default"},{"type":"¬(n₀ ∈ A ∧ n₀ ∉ B)","name":["h"],"isProp":true,"id":["_uniq",41733],"binderInfo":"default"},{"type":"n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41836],"binderInfo":"default"}]}],"start":3543},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",41707],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"∀ (n : ℕ), n ∈ A ∧ n ∉ B ∨ n ∈ B ∧ n ∉ A → n₀ ≤ n","name":["h2"],"isProp":true,"id":["_uniq",41701],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"}]}],"start":3604},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",64858],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":3676},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",69537],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt 0 (f A - f B)\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f A) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Eq.refl (Int.ofNat 1)))))))\n                                          Mathlib.Tactic.Ring.neg_zero))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f A ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                          (f B ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (f A) (Nat.rawCast 1)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 0)))))\n                                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (f B) (Nat.rawCast 1)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                            (Eq.refl (Int.ofNat 0)))))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                            (Mathlib.Tactic.Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hAB)\n                              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.neg_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯))\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"0 > 0","name":["this"],"isProp":true,"id":["_uniq",69536]}]}],"start":3707},{"state":[],"start":3742},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",69537],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt 0 (f A - f B)\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f A) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Eq.refl (Int.ofNat 1)))))))\n                                          Mathlib.Tactic.Ring.neg_zero))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f A ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                          (f B ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (f A) (Nat.rawCast 1)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 0)))))\n                                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (f B) (Nat.rawCast 1)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                            (Eq.refl (Int.ofNat 0)))))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                            (Mathlib.Tactic.Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hAB)\n                              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.neg_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯))\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"0 > 0","name":["this"],"isProp":true,"id":["_uniq",69536]}]}],"start":3789},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",69537],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt 0 (f A - f B)\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f A) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Eq.refl (Int.ofNat 1)))))))\n                                          Mathlib.Tactic.Ring.neg_zero))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f A ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                          (f B ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (f A) (Nat.rawCast 1)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 0)))))\n                                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (f B) (Nat.rawCast 1)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                            (Eq.refl (Int.ofNat 0)))))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                            (Mathlib.Tactic.Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hAB)\n                              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.neg_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯))\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"0 > 0","name":["this"],"isProp":true,"id":["_uniq",69536]}]}],"start":3869},{"state":[{"type":"∑' (n : (↑A : Type)), a (↑n : ℕ) - ∑' (n : (↑B : Type)), a (↑n : ℕ) =\n  ∑' (n : (↑{n | n ∈ A ∧ n ≤ n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ) -\n    (∑' (n : (↑{n | n ∈ B ∧ n ≤ n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ))","tag":[],"mvarId":["_uniq",65887],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":3953},{"state":[{"type":"∑' (n : (↑A : Type)), a (↑n : ℕ) =\n  ∑' (n : (↑{n | n ∈ A ∧ n ≤ n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ)","tag":["e_a","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",70325],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∑' (n : (↑B : Type)), a (↑n : ℕ) =\n  ∑' (n : (↑{n | n ∈ B ∧ n ≤ n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ)","tag":["e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",70326],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":3980},{"state":[{"type":"A = {n | n ∈ A ∧ n ≤ n₀} ∪ {n | n ∈ A ∧ n > n₀}","tag":["e_a","hC","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",70913],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∀ (n : ℕ), n ∉ {n | n ∈ A ∧ n ≤ n₀} ∩ {n | n ∈ A ∧ n > n₀}","tag":["e_a","hAB","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",70914],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"B = {n | n ∈ B ∧ n ≤ n₀} ∪ {n | n ∈ B ∧ n > n₀}","tag":["e_a","hC","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",80304],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∀ (n : ℕ), n ∉ {n | n ∈ B ∧ n ≤ n₀} ∩ {n | n ∈ B ∧ n > n₀}","tag":["e_a","hAB","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",80305],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4005},{"state":[{"type":"∀ (n : ℕ), n ∉ {n | n ∈ A ∧ n ≤ n₀} ∩ {n | n ∈ A ∧ n > n₀}","tag":["e_a","hAB","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",70914],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∀ (n : ℕ), n ∉ {n | n ∈ B ∧ n ≤ n₀} ∩ {n | n ∈ B ∧ n > n₀}","tag":["e_a","hAB","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",80305],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4036},{"state":[],"start":4079},{"state":[],"start":4089},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",69537],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt 0 (f A - f B)\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f A) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Eq.refl (Int.ofNat 1)))))))\n                                          Mathlib.Tactic.Ring.neg_zero))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f A ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                          (f B ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (f A) (Nat.rawCast 1)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 0)))))\n                                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (f B) (Nat.rawCast 1)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                            (Eq.refl (Int.ofNat 0)))))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                            (Mathlib.Tactic.Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hAB)\n                              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.neg_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯))\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"0 > 0","name":["this"],"isProp":true,"id":["_uniq",69536]}]}],"start":4202},{"state":[{"type":"∑' (n : (↑{n | n ∈ A ∧ n ≤ n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ) -\n    (∑' (n : (↑{n | n ∈ B ∧ n ≤ n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ)) =\n  ∑' (n : (↑{n | n ∈ A ∧ n < n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ A ∧ n = n₀} : Type)), a (↑n : ℕ) +\n      ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ) -\n    (∑' (n : (↑{n | n ∈ B ∧ n < n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ B ∧ n = n₀} : Type)), a (↑n : ℕ) +\n      ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ))","tag":[],"mvarId":["_uniq",66746],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4319},{"state":[{"type":"∑' (n : (↑{n | n ∈ A ∧ n ≤ n₀} : Type)), a (↑n : ℕ) =\n  ∑' (n : (↑{n | n ∈ A ∧ n < n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ A ∧ n = n₀} : Type)), a (↑n : ℕ)","tag":["e_a","e_a","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",89920],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∑' (n : (↑{n | n ∈ B ∧ n ≤ n₀} : Type)), a (↑n : ℕ) =\n  ∑' (n : (↑{n | n ∈ B ∧ n < n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ B ∧ n = n₀} : Type)), a (↑n : ℕ)","tag":["e_a","e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",90319],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4346},{"state":[{"type":"{n | n ∈ A ∧ n ≤ n₀} = {n | n ∈ A ∧ n < n₀} ∪ {n | n ∈ A ∧ n = n₀}","tag":["e_a","e_a","hC","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",90594],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∀ (n : ℕ), n ∉ {n | n ∈ A ∧ n < n₀} ∩ {n | n ∈ A ∧ n = n₀}","tag":["e_a","e_a","hAB","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",90595],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"{n | n ∈ B ∧ n ≤ n₀} = {n | n ∈ B ∧ n < n₀} ∪ {n | n ∈ B ∧ n = n₀}","tag":["e_a","e_a","hC","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",95397],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∀ (n : ℕ), n ∉ {n | n ∈ B ∧ n < n₀} ∩ {n | n ∈ B ∧ n = n₀}","tag":["e_a","e_a","hAB","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",95398],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4371},{"state":[{"type":"∀ (n : ℕ), n ∉ {n | n ∈ A ∧ n < n₀} ∩ {n | n ∈ A ∧ n = n₀}","tag":["e_a","e_a","hAB","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",90595],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∀ (n : ℕ), n ∉ {n | n ∈ B ∧ n < n₀} ∩ {n | n ∈ B ∧ n = n₀}","tag":["e_a","e_a","hAB","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",95398],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4413},{"state":[],"start":4456},{"state":[],"start":4466},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",69537],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt 0 (f A - f B)\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f A) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Eq.refl (Int.ofNat 1)))))))\n                                          Mathlib.Tactic.Ring.neg_zero))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f A ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                          (f B ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (f A) (Nat.rawCast 1)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 0)))))\n                                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (f B) (Nat.rawCast 1)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                            (Eq.refl (Int.ofNat 0)))))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                            (Mathlib.Tactic.Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hAB)\n                              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.neg_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯))\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"0 > 0","name":["this"],"isProp":true,"id":["_uniq",69536]}]}],"start":4555},{"state":[{"type":"∑' (n : (↑{n | n ∈ A ∧ n < n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ A ∧ n = n₀} : Type)), a (↑n : ℕ) +\n      ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ) -\n    (∑' (n : (↑{n | n ∈ B ∧ n < n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∈ B ∧ n = n₀} : Type)), a (↑n : ℕ) +\n      ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ)) =\n  ∑' (n : (↑{n | n ∈ A ∧ n < n₀} : Type)), a (↑n : ℕ) + a n₀ + ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ) -\n    (∑' (n : (↑{n | n ∈ B ∧ n < n₀} : Type)), a (↑n : ℕ) + 0 + ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ))","tag":[],"mvarId":["_uniq",67405],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4643},{"state":[{"type":"∑' (n : (↑{n | n ∈ A ∧ n = n₀} : Type)), a (↑n : ℕ) = a n₀","tag":["e_a","e_a","e_a","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",100538],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∑' (n : (↑{n | n ∈ B ∧ n = n₀} : Type)), a (↑n : ℕ) = 0","tag":["e_a","e_a","e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",100808],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4659},{"state":[{"type":"∑' (n : (↑{n | n ∈ A ∧ n = n₀} : Type)), a (↑n : ℕ) = a n₀","tag":["e_a","e_a","e_a","_@","Init","Prelude","_hyg",2150],"mvarId":["_uniq",100538],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4674},{"state":[],"start":4759},{"state":[{"type":"∑' (n : (↑{n | n ∈ B ∧ n = n₀} : Type)), a (↑n : ℕ) = 0","tag":["e_a","e_a","e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",100808],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4788},{"state":[{"type":"∑' (n : (↑{n | n ∈ B ∧ n = n₀} : Type)), a (↑n : ℕ) = 0","tag":["e_a","e_a","e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",100808],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":4803},{"state":[],"start":4885},{"state":[],"start":4914},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",69537],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt 0 (f A - f B)\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f A) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Eq.refl (Int.ofNat 1)))))))\n                                          Mathlib.Tactic.Ring.neg_zero))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f A ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                          (f B ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (f A) (Nat.rawCast 1)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 0)))))\n                                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (f B) (Nat.rawCast 1)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                            (Eq.refl (Int.ofNat 0)))))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                            (Mathlib.Tactic.Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hAB)\n                              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.neg_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯))\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"0 > 0","name":["this"],"isProp":true,"id":["_uniq",69536]}]}],"start":5001},{"state":[],"start":5086},{"state":[{"type":"∑' (n : (↑{n | n ∈ A ∧ n < n₀} : Type)), a (↑n : ℕ) - ∑' (n : (↑{n | n ∈ B ∧ n < n₀} : Type)), a (↑n : ℕ) + a n₀ +\n      ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ) -\n    ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ) =\n  0 + a n₀ + ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ) - ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ)","tag":[],"mvarId":["_uniq",68393],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5179},{"state":[],"start":5244},{"state":[{"type":"0 + a n₀ + ∑' (n : (↑{n | n ∈ A ∧ n > n₀} : Type)), a (↑n : ℕ) - ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ) ≥\n  0 + a n₀ + 0 - ∑' (n : (↑{n | n > n₀} : Type)), a (↑n : ℕ)","tag":[],"mvarId":["_uniq",68676],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5304},{"state":[{"type":"∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ) ≤ ∑' (n : (↑{n | n > n₀} : Type)), a (↑n : ℕ)","tag":["hcd"],"mvarId":["_uniq",115806],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5331},{"state":[{"type":"∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ) ≤ ∑' (n : (↑{n | n > n₀} : Type)), a (↑n : ℕ)","tag":["hcd"],"mvarId":["_uniq",115806],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5344},{"state":[{"type":"∑' (n : (↑{n | n > n₀} : Type)), a (↑n : ℕ) =\n  ∑' (n : (↑{n | n ∈ B ∧ n > n₀} : Type)), a (↑n : ℕ) + ∑' (n : (↑{n | n ∉ B ∧ n > n₀} : Type)), a (↑n : ℕ)","tag":[],"mvarId":["_uniq",123095],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5436},{"state":[{"type":"{n | n > n₀} = {n | n ∈ B ∧ n > n₀} ∪ {n | n ∉ B ∧ n > n₀}","tag":["hC"],"mvarId":["_uniq",123425],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]},{"type":"∀ (n : ℕ), n ∉ {n | n ∈ B ∧ n > n₀} ∩ {n | n ∉ B ∧ n > n₀}","tag":["hAB"],"mvarId":["_uniq",123426],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5463},{"state":[{"type":"∀ (n : ℕ), n ∉ {n | n ∈ B ∧ n > n₀} ∩ {n | n ∉ B ∧ n > n₀}","tag":["hAB"],"mvarId":["_uniq",123426],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5496},{"state":[],"start":5538},{"state":[],"start":5621},{"state":[],"start":5648},{"state":[{"type":"0 + a n₀ + 0 - ∑' (n : (↑{n | n > n₀} : Type)), a (↑n : ℕ) = 0 + 10 ^ (-(↑n₀ : ℝ)) + 0 - 1 / 9 * 10 ^ (-(↑n₀ : ℝ))","tag":[],"mvarId":["_uniq",69166],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5736},{"state":[{"type":"∑' (n : (↑{n | n > n₀} : Type)), a (↑n : ℕ) = 1 / 9 * 10 ^ (-(↑n₀ : ℝ))","tag":["e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",141479],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]}]}],"start":5750},{"state":[{"type":"∑' (n : (↑{n | n > n₀} : Type)), a (↑n : ℕ) = 1 / 9 * 10 ^ (-(↑n₀ : ℝ))","tag":["e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",144571],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]}]}],"start":5841},{"state":[{"type":"Function.Bijective ι","tag":[],"mvarId":["_uniq",144791],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]}]}],"start":5888},{"state":[{"type":"Function.Injective ι","tag":["refine_1"],"mvarId":["_uniq",144798],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]}]},{"type":"Function.Surjective ι","tag":["refine_2"],"mvarId":["_uniq",144799],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]}]}],"start":5909},{"state":[{"type":"Function.Surjective ι","tag":["refine_2"],"mvarId":["_uniq",144799],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]}]}],"start":5957},{"state":[{"type":"∑' (n : (↑{n | n > n₀} : Type)), a (↑n : ℕ) = 1 / 9 * 10 ^ (-(↑n₀ : ℝ))","tag":["e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",144793],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]}],"start":6033},{"state":[{"type":"∑' (c : ℕ), a (↑((Equiv.ofBijective ι hι) c) : ℕ) = 1 / 9 * 10 ^ (-(↑n₀ : ℝ))","tag":["e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",148507],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]}],"start":6084},{"state":[{"type":"∑' (c : ℕ), (10 ^ (c + (n₀ + 1)))⁻¹ = 9⁻¹ * (10 ^ n₀)⁻¹","tag":["e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",151843],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]}],"start":6104},{"state":[{"type":"∑' (c : ℕ), (10 ^ (c + (n₀ + 1)))⁻¹ = 9⁻¹ * (10 ^ n₀)⁻¹","tag":["e_a","_@","Init","Prelude","_hyg",2152],"mvarId":["_uniq",151843],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]}],"start":6117},{"state":[{"type":"∑' (c : ℕ), (10 ^ (c + (n₀ + 1)))⁻¹ = ∑' (j : ℕ), 10 ^ (-1 - (↑n₀ : ℝ)) * (1 / 10) ^ j","tag":[],"mvarId":["_uniq",152245],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]}],"start":6189},{"state":[{"type":"(10 ^ (j + (n₀ + 1)))⁻¹ = 10 ^ (-1 - (↑n₀ : ℝ)) * (1 / 10) ^ j","tag":["hfg"],"mvarId":["_uniq",153196],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",153195],"binderInfo":"default"}]}],"start":6227},{"state":[{"type":"(10 ^ j * (10 ^ n₀ * 10 ^ 1))⁻¹ = 10⁻¹ / 10 ^ n₀ * (1 / 10) ^ j","tag":["hfg"],"mvarId":["_uniq",153757],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",153195],"binderInfo":"default"}]}],"start":6324},{"state":[],"start":6348},{"state":[],"start":6431},{"state":[{"type":"10 ^ (-1 - (↑n₀ : ℝ)) * ∑' (j : ℕ), (1 / 10) ^ j = 9⁻¹ * (10 ^ n₀)⁻¹","tag":[],"mvarId":["_uniq",153064],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]}],"start":6453},{"state":[{"type":"10 ^ (-(↑n₀ : ℝ) + -1) * (1 - 1 / 10)⁻¹ = 9⁻¹ * (10 ^ n₀)⁻¹","tag":[],"mvarId":["_uniq",158282],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]},{"type":"-1 - (↑n₀ : ℝ) = -(↑n₀ : ℝ) + -1","tag":[],"mvarId":["_uniq",158270],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]},{"type":"0 ≤ 1 / 10","tag":["h₁"],"mvarId":["_uniq",157975],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]},{"type":"1 / 10 < 1","tag":["h₂"],"mvarId":["_uniq",157976],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]}],"start":6542},{"state":[{"type":"(10 ^ n₀)⁻¹ * 10 ^ (-1) * (1 - 1 / 10)⁻¹ = 9⁻¹ * (10 ^ n₀)⁻¹","tag":[],"mvarId":["_uniq",158341],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]},{"type":"-1 - (↑n₀ : ℝ) = -(↑n₀ : ℝ) + -1","tag":[],"mvarId":["_uniq",158270],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]},{"type":"1 / 10 < 1","tag":["h₂"],"mvarId":["_uniq",157976],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"fun j => ⟨j + (n₀ + 1), ⋯⟩","type":"ℕ → (↑{n | n > n₀} : Type)","name":["ι"],"isProp":false,"id":["_uniq",144569]},{"value":"⟨fun ⦃j k⦄ hjk => Eq.mp (Eq.trans ⋯ ⋯) ⋯, ⋯⟩","type":"Function.Bijective ι","name":["hι"],"isProp":true,"id":["_uniq",144792]}]}],"start":6611},{"state":[],"start":6644},{"state":[],"start":6704},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",69537],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Set ℕ","name":["A"],"isProp":false,"id":["_uniq",41696],"binderInfo":"strictImplicit"},{"type":"Set ℕ","name":["B"],"isProp":false,"id":["_uniq",41697],"binderInfo":"strictImplicit"},{"type":"f A = f B","name":["hAB"],"isProp":true,"id":["_uniq",41698],"binderInfo":"default"},{"value":"Nat.min (symmDiff A B)","type":"ℕ","name":["n₀"],"isProp":false,"id":["_uniq",41699]},{"type":"n₀ ∈ A ∧ n₀ ∉ B ∨ n₀ ∈ B ∧ n₀ ∉ A","name":["h1"],"isProp":true,"id":["_uniq",41700],"binderInfo":"default"},{"type":"n₀ ∈ A ∧ n₀ ∉ B","name":["h"],"isProp":true,"id":["_uniq",41706],"binderInfo":"default"},{"value":"fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 _fvar.41701 h hn","type":"∀ {n : ℕ}, n < n₀ → (n ∈ A ↔ n ∈ B)","name":["h2"],"isProp":true,"id":["_uniq",61934]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Trans.trans\n            (Trans.trans\n              (Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt 0 (f A - f B)\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.sub_congr\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul (f A) (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Eq.refl (Int.ofNat 1)))))))\n                                          Mathlib.Tactic.Ring.neg_zero))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f A ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                          (f B ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (f A) (Nat.rawCast 1)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 0)))))\n                                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (f B) (Nat.rawCast 1)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                            (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                            (Eq.refl (Int.ofNat 0)))))\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                            (Mathlib.Tactic.Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hAB)\n                              (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n                      (Not.intro fun a =>\n                        Mathlib.Tactic.Linarith.lt_irrefl\n                          (Eq.mp\n                            (congrArg (fun _a => _a < 0)\n                              (Mathlib.Tactic.Ring.of_eq\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.neg_congr\n                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                      (Mathlib.Tactic.Ring.atom_pf (f B))\n                                      (Mathlib.Tactic.Ring.sub_pf\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          Mathlib.Tactic.Ring.neg_zero)\n                                        (Mathlib.Tactic.Ring.add_pf_add_lt (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                                            (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                    (Mathlib.Tactic.Ring.neg_add (Mathlib.Tactic.Ring.neg_mul ⋯ ⋯ ⋯) ⋯))\n                                  ⋯ ⋯)\n                                ⋯))\n                            ⋯)))\n                    ⋯)\n                  ⋯)\n                ⋯)\n              ⋯)\n            ⋯)\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"0 > 0","name":["this"],"isProp":true,"id":["_uniq",69536]}]}],"start":6733},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",32456],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"value":"fun ⦃A B⦄ hAB =>\n  Classical.byContradiction fun this =>\n    let n₀ := Nat.min (symmDiff A B);\n    Or.casesOn (Classical.em (n₀ ∈ A ∧ n₀ ∉ B))\n      (fun h =>\n        (fun ⦃A B⦄ hAB =>\n            let n₀ := Nat.min (symmDiff A B);\n            fun h1 h2 h =>\n            have h2 := fun {n} hn => real._proof_8 h_decomp h_nonneg h_congr hAB h1 h2 h hn;\n            have this :=\n              Trans.trans\n                (Trans.trans\n                  (Trans.trans\n                    (Trans.trans\n                      (Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (Trans.trans\n                              (Trans.trans\n                                (Trans.trans\n                                  (Mathlib.Tactic.Linarith.eq_of_not_lt_of_not_gt 0 (f A - f B)\n                                    (Not.intro fun a =>\n                                      Mathlib.Tactic.Linarith.lt_irrefl\n                                        (Eq.mp\n                                          (congrArg (fun _a => _a < 0)\n                                            (Mathlib.Tactic.Ring.of_eq\n                                              (Mathlib.Tactic.Ring.add_congr\n                                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                                  (Mathlib.Tactic.Ring.atom_pf (f B))\n                                                  (Mathlib.Tactic.Ring.sub_pf\n                                                    (Mathlib.Tactic.Ring.neg_add\n                                                      (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                              (Eq.refl (Int.negOfNat 1))))))\n                                                      Mathlib.Tactic.Ring.neg_zero)\n                                                    (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                      (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                        (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                                (Mathlib.Tactic.Ring.sub_congr\n                                                  (Mathlib.Tactic.Ring.cast_zero\n                                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                                    (Mathlib.Tactic.Ring.sub_pf\n                                                      (Mathlib.Tactic.Ring.neg_add\n                                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                                (Eq.refl (Int.negOfNat 1))))))\n                                                        Mathlib.Tactic.Ring.neg_zero)\n                                                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                        (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                                  (Mathlib.Tactic.Ring.sub_pf\n                                                    (Mathlib.Tactic.Ring.neg_add\n                                                      (Mathlib.Tactic.Ring.neg_mul (f A) (Nat.rawCast 1)\n                                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                              (Eq.refl (Int.negOfNat 1))))))\n                                                      (Mathlib.Tactic.Ring.neg_add\n                                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                                  (Eq.refl (Int.ofNat 1)))))))\n                                                        Mathlib.Tactic.Ring.neg_zero))\n                                                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                      (f A ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                                        (f B ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (f A) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (f B) (Nat.rawCast 1)\n                                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                          (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                          (Eq.refl (Int.ofNat 0)))))\n                                                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                              (Mathlib.Tactic.Ring.cast_zero\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                          (Mathlib.Tactic.Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hAB)\n                                            (Mathlib.Tactic.Linarith.sub_neg_of_lt a))))\n                                    (Not.intro fun a =>\n                                      Mathlib.Tactic.Linarith.lt_irrefl\n                                        (Eq.mp\n                                          (congrArg (fun _a => _a < 0)\n                                            (Mathlib.Tactic.Ring.of_eq\n                                              (Mathlib.Tactic.Ring.add_congr\n                                                (Mathlib.Tactic.Ring.neg_congr\n                                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f A))\n                                                    (Mathlib.Tactic.Ring.atom_pf (f B))\n                                                    (Mathlib.Tactic.Ring.sub_pf\n                                                      (Mathlib.Tactic.Ring.neg_add\n                                                        (Mathlib.Tactic.Ring.neg_mul (f B) (Nat.rawCast 1)\n                                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                                (Eq.refl (Int.negOfNat 1))))))\n                                                        Mathlib.Tactic.Ring.neg_zero)\n                                                      (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                        (f A ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                          (f B ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                                  (Mathlib.Tactic.Ring.neg_add ⋯ ⋯))\n                                                ⋯ ⋯)\n                                              ⋯))\n                                          ⋯)))\n                                  ⋯)\n                                ⋯)\n                              ⋯)\n                            ⋯)\n                          ⋯)\n                        ⋯)\n                      ⋯)\n                    ⋯)\n                  ⋯)\n                ⋯;\n            ⋯)\n          ⋯ ⋯ ⋯ ⋯)\n      ⋯","type":"Function.Injective f","name":["this"],"isProp":true,"id":["_uniq",32455]}]}],"start":6750},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",161422],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"value":"Exists.intro (Equiv.ofInjective f _fvar.32455).toFun (Equiv.bijective (Equiv.ofInjective f _fvar.32455))","type":"EqualCard (Set ℕ) (↑(Set.range f) : Type)","name":["this"],"isProp":true,"id":["_uniq",161418]}]}],"start":6876},{"state":[{"type":"Uncountable ℝ","tag":[],"mvarId":["_uniq",161437],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"value":"(equiv _fvar.161418).mp power_set_nat","type":"Uncountable (↑(Set.range f) : Type)","name":["this"],"isProp":true,"id":["_uniq",161433]}]}],"start":6919},{"state":[{"type":"¬Uncountable (↑(Set.range f) : Type)","tag":[],"mvarId":["_uniq",161445],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"¬Uncountable ℝ","name":["this"],"isProp":true,"id":["_uniq",161444],"binderInfo":"default"}]}],"start":6937},{"state":[{"type":"Countable (↑(Set.range f) : Type)","tag":[],"mvarId":["_uniq",161469],"isProp":true,"context":[{"value":"fun n => 10 ^ (-(↑n : ℝ))","type":"ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",10315]},{"value":"fun A => ∑' (n : (↑A : Type)), a (↑n : ℕ)","type":"Set ℕ → ℝ","name":["f"],"isProp":false,"id":["_uniq",10717]},{"value":"fun A =>\n  Summable.subtype\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α β inst inst' e'_3 inst_1 f f' e'_5 =>\n            Eq.casesOn (motive := fun a x => inst' = a → e'_3 ≍ x → Summable f ≍ Summable f') e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun inst' => ∀ (e_3 : inst = inst'), e_3 ≍ Eq.refl inst → Summable f ≍ Summable f')\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a x => f' = a → e'_5 ≍ x → Summable f ≍ Summable f') e'_5\n                      (fun h =>\n                        Eq.ndrec (motive := fun f' => ∀ (e_5 : f = f'), e_5 ≍ Eq.refl f → Summable f ≍ Summable f')\n                          (fun e_5 h => HEq.refl (Summable f)) (Eq.symm h) e'_5)\n                      (Eq.refl f') (HEq.refl e'_5))\n                  (Eq.symm h) e'_3)\n              (Eq.refl inst') (HEq.refl e'_3))\n          ℝ ℕ instAddCommGroup.toAddCommMonoid instAddCommMonoid (Eq.refl instAddCommGroup.toAddCommMonoid)\n          PseudoMetricSpace.toUniformSpace.toTopologicalSpace a (fun n => (1 / 10) ^ n)\n          (funext fun n =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congrArg (Eq (a n))\n                    (Eq.trans\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))\n                      (congrArg (fun x => x ^ n)\n                        (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                          (Mathlib.Meta.NormNum.isNNRat_div\n                            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                  (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                          Nat.cast_one (Eq.refl 10)))))\n                  (congrArg (fun x => a n = x ^ n)\n                    (Mathlib.Meta.NormNum.IsNNRat.to_eq\n                      (Mathlib.Meta.NormNum.isNNRat_div\n                        (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                          (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n                      Nat.cast_one (Eq.refl 10)))))\n              (id\n                (Eq.mpr (id (congrArg (fun _a => 10 ^ (-(↑n : ℝ)) = _a) (one_div_pow 10 n)))\n                  (Eq.mpr\n                    (id\n                      (congrArg (fun _a => _a = 1 / 10 ^ n)\n                        (rpow_neg\n                          (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10)) (Eq.refl true))\n                          (↑n : ℝ))))\n                    (Eq.mpr (id (congrArg (fun _a => (10 ^ (↑n : ℝ))⁻¹ = _a) (one_div (10 ^ n))))\n                      (of_eq_true\n                        (Eq.trans (congrArg (fun x => x⁻¹ = (10 ^ n)⁻¹) (rpow_natCast 10 n))\n                          (eq_self (10 ^ n)⁻¹))))))))))\n      (summable_geometric_of_lt_one\n        (Mathlib.Meta.NormNum.isRat_le_true\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)))\n          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n            (Mathlib.Meta.NormNum.isNNRat_div\n              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n                (Eq.refl (Nat.mul 1 1)) (Eq.refl 10))))\n          (Eq.refl true))\n        (Mathlib.Meta.NormNum.isNNRat_lt_true\n          (Mathlib.Meta.NormNum.isNNRat_div\n            (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))))\n              (Eq.refl (Nat.mul 1 1)) (Eq.refl 10)))\n          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)) (Eq.refl true))))\n    A","type":"∀ (A : Set ℕ), Summable fun n => a (↑n : ℕ)","name":["hsummable"],"isProp":true,"id":["_uniq",11065]},{"value":"fun {A B C} hC hAB =>\n  Eq.mpr\n    (eq_of_heq\n      ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n          Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n            (fun h =>\n              Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                (fun e_2 h =>\n                  Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                        (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                    (Eq.refl a'_1) (HEq.refl e'_3))\n                (Eq.symm h) e'_2)\n            (Eq.refl a') (HEq.refl e'_2))\n        ℝ (∑' (n : (↑C : Type)), a (↑n : ℕ)) (∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ))\n        (Eq.mpr\n          (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (x : (↑(A ∪ B) : Type)), a (↑x : ℕ)) hC))\n          (Eq.refl (∑' (n : (↑(A ∪ B) : Type)), a (↑n : ℕ))))\n        (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ))\n        (∑' (x : (↑A : Type)), a (↑x : ℕ) + ∑' (x : (↑B : Type)), a (↑x : ℕ))\n        (Eq.refl (∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)))))\n    (Summable.tsum_union_disjoint\n      (Eq.mpr (id (congrArg (fun _a => _a) (propext Set.disjoint_iff_inter_eq_empty))) (real._proof_2 hAB))\n      (hsummable A) (hsummable B))","type":"∀ {A B C : Set ℕ},\n  C = A ∪ B →\n    (∀ (n : ℕ), n ∉ A ∩ B) →\n      ∑' (n : (↑C : Type)), a (↑n : ℕ) = ∑' (n : (↑A : Type)), a (↑n : ℕ) + ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_decomp"],"isProp":true,"id":["_uniq",13646]},{"value":"fun A =>\n  Eq.mpr\n    (id\n      (Eq.trans\n        (congrArg (fun x => tsum x ≥ 0)\n          (funext fun n =>\n            congrFun\n              (funext fun n =>\n                Eq.trans (rpow_neg_natCast 10 n)\n                  (Eq.trans (zpow_neg 10 (↑n : ℤ)) (congrArg Inv.inv (zpow_natCast 10 n))))\n              (↑n : ℕ)))\n        ge_iff_le._simp_1))\n    (tsum_nonneg fun n =>\n      le_of_lt\n        (inv_pos_of_pos\n          (pow_pos\n            (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 10))\n              (Eq.refl (Nat.ble 1 10)))\n            (↑n : ℕ))))","type":"∀ (A : Set ℕ), ∑' (n : (↑A : Type)), a (↑n : ℕ) ≥ 0","name":["h_nonneg"],"isProp":true,"id":["_uniq",18321]},{"value":"fun {A B} hAB =>\n  Eq.mpr (id (congrArg (fun _a => ∑' (n : (↑_a : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)) hAB))\n    (Eq.refl (∑' (n : (↑B : Type)), a (↑n : ℕ)))","type":"∀ {A B : Set ℕ}, A = B → ∑' (n : (↑A : Type)), a (↑n : ℕ) = ∑' (n : (↑B : Type)), a (↑n : ℕ)","name":["h_congr"],"isProp":true,"id":["_uniq",32426]},{"type":"Countable ℝ","name":["this"],"isProp":true,"id":["_uniq",161461],"binderInfo":"default"}]}],"start":6976},{"state":[],"start":7001},{"state":[],"start":7002},{"state":[],"start":7024},{"state":[{"type":"Nat.card (Set X) = 2 ^ Nat.card X","tag":[],"mvarId":["_uniq",161581],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",161579],"binderInfo":"implicit"},{"type":"Finite X","name":["inst✝"],"isProp":true,"id":["_uniq",161580],"binderInfo":"instImplicit"}]}],"start":7094},{"state":[],"start":7102},{"state":[],"start":7103},{"state":[],"start":7121},{"state":[],"start":7304},{"state":[],"start":7407},{"state":[],"start":7613},{"state":[],"start":7647},{"state":[],"start":7797},{"state":[],"start":7820},{"state":[{"type":"let D := fun t =>\n  Nat.rec\n    (((⇑f.image : Set (↑C : Type) → Set (↑A : Type)) ∘\n        (⇑(B.embeddingOfSubset C hBC).image : Set (↑B : Type) → Set (↑C : Type)))\n      {x | (↑x : X) ∉ A})\n    (fun x =>\n      (⇑f.image : Set (↑C : Type) → Set (↑A : Type)) ∘\n        (⇑(B.embeddingOfSubset C hBC).image : Set (↑B : Type) → Set (↑C : Type)) ∘\n          (⇑(A.embeddingOfSubset B hAB).image : Set (↑A : Type) → Set (↑B : Type)))\n    t;\nSet.univ.PairwiseDisjoint D ∧\n  let g := fun x => if h : x ∈ ⋃ n, D n ∧ ∃ y, f ⟨(↑y : X), ⋯⟩ = x then ⋯.choose else ⟨(↑x : X), ⋯⟩;\n  Function.Bijective g","tag":[],"mvarId":["_uniq",163970],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",163963],"binderInfo":"implicit"},{"type":"Set X","name":["A"],"isProp":false,"id":["_uniq",163964],"binderInfo":"implicit"},{"type":"Set X","name":["B"],"isProp":false,"id":["_uniq",163965],"binderInfo":"implicit"},{"type":"Set X","name":["C"],"isProp":false,"id":["_uniq",163966],"binderInfo":"implicit"},{"type":"A ⊆ B","name":["hAB"],"isProp":true,"id":["_uniq",163967],"binderInfo":"default"},{"type":"B ⊆ C","name":["hBC"],"isProp":true,"id":["_uniq",163968],"binderInfo":"default"},{"type":"(↑C : Type) ↪ (↑A : Type)","name":["f"],"isProp":false,"id":["_uniq",163969],"binderInfo":"default"}]}],"start":7828},{"state":[],"start":7836},{"state":[],"start":7837},{"state":[],"start":7910},{"state":[],"start":7911},{"state":[],"start":7933},{"state":[{"type":"EqualCard X Y","tag":[],"mvarId":["_uniq",164055],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",164051],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",164052],"binderInfo":"implicit"},{"type":"LeCard X Y","name":["hXY"],"isProp":true,"id":["_uniq",164053],"binderInfo":"default"},{"type":"LeCard Y X","name":["hYX"],"isProp":true,"id":["_uniq",164054],"binderInfo":"default"}]}],"start":8031},{"state":[],"start":8039},{"state":[],"start":8040},{"state":[],"start":8108},{"state":[],"start":8109},{"state":[],"start":8131},{"state":[],"start":8179},{"state":[],"start":8180},{"state":[],"start":8240},{"state":[{"type":"LtCard A C","tag":[],"mvarId":["_uniq",164098],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",164093],"binderInfo":"implicit"},{"type":"Type","name":["B"],"isProp":false,"id":["_uniq",164094],"binderInfo":"implicit"},{"type":"Type","name":["C"],"isProp":false,"id":["_uniq",164095],"binderInfo":"implicit"},{"type":"LtCard A B","name":["hAB"],"isProp":true,"id":["_uniq",164096],"binderInfo":"default"},{"type":"LtCard B C","name":["hBC"],"isProp":true,"id":["_uniq",164097],"binderInfo":"default"}]}],"start":8259},{"state":[],"start":8267},{"state":[],"start":8268},{"state":[],"start":8306},{"state":[],"start":8321},{"state":[],"start":8336},{"state":[{"type":"∀ (a : Type), LeCard a a","tag":[],"mvarId":["_uniq",164125],"isProp":true,"context":[]}],"start":8352},{"state":[],"start":8362},{"state":[{"type":"∀ (a b c : Type), LeCard a b → LeCard b c → LeCard a c","tag":[],"mvarId":["_uniq",164141],"isProp":true,"context":[]}],"start":8379},{"state":[],"start":8389},{"state":[{"type":"∀ (a b : Type), LtCard a b ↔ LeCard a b ∧ ¬LeCard b a","tag":[],"mvarId":["_uniq",164148],"isProp":true,"context":[]}],"start":8414},{"state":[],"start":8424},{"state":[],"start":8426},{"state":[],"start":8427},{"state":[],"start":8449},{"state":[{"type":"¬CountablyInfinite (Set X)","tag":[],"mvarId":["_uniq",164278],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",164277],"binderInfo":"default"}]}],"start":8503},{"state":[],"start":8511},{"state":[],"start":8512},{"state":[],"start":8525},{"state":[],"start":8525}]
