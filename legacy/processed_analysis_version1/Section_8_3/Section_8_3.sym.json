[{"valueReferences":[["implies_congr"],["instAddNat"],["PseudoMetricSpace","toUniformSpace"],["Eq","trans"],["Classical","propDecidable"],["eq_true"],["Union","union"],["Subtype","val"],["Classical","choose"],["False","elim"],["NatCast","natCast"],["Eq","symm"],["Set","instUnion"],["Bool","true"],["Set","instInter"],["Set","instSDiff"],["instLTNat"],["Exists"],["Lean","Grind","not_not"],["Set","instMembership"],["Lean","Grind","eq_false_of_or_eq_false_right"],["Set","instCompleteAtomicBooleanAlgebra"],["eq_false"],["Iff"],["Eq","refl"],["Classical","byContradiction"],["Bool"],["symmDiff"],["Lean","Grind","and_eq_of_eq_true_right"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["Lean","Grind","Nat","lt_eq"],["Lean","Grind","nestedDecidable"],["Lean","Grind","or_eq_of_eq_true_left"],["instOfNatNat"],["tsum"],["congr"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Lean","Grind","Nat","le_eq_false_of_lo"],["Set"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","iff_eq"],["Lean","Grind","or_eq_of_eq_false_right"],["dite"],["instHSub"],["And","casesOn"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Inter","inter"],["Membership","mem"],["CompleteBooleanAlgebra","toCompleteLattice"],["Lean","Grind","not_eq_prop"],["Or"],["Lean","Grind","forall_imp_eq_or"],["forall_congr"],["funext"],["HSub","hSub"],["Lean","Grind","not_eq_of_eq_false"],["Lean","Grind","not_eq_of_eq_true"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["Nat","Simproc","add_le_add_le"],["instHPow"],["Real"],["Neg","neg"],["Lean","Grind","rfl_true"],["And"],["Lean","Grind","eq_true_of_and_eq_true_right"],["True","intro"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Subtype"],["Lean","Grind","not_and"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["UniformSpace","toTopologicalSpace"],["Lean","Grind","not_or"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Real","instPow"],["Nat","not_le_eq"],["Real","instNeg"],["Zero","toOfNat0"],["Lean","Grind","or_eq_of_eq_false_left"],["of_decide_eq_true"],["Not"],["Set","Nonempty"],["True"],["instHAdd"],["Nat","decLe"],["LT","lt"],["Or","casesOn"],["of_eq_true"],["instSubNat"],["Lean","Grind","and_eq_of_eq_true_left"],["SemilatticeSup","toMax"],["LE","le"],["False"],["Lean","Grind","intro_with_eq"],["instLENat"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Real"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Real","instZero"],["LE","le"],["SemilatticeSup","toMax"],["instLENat"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          Or\n              (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))))\n              (And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B))))) →\n            And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))) →\n              (∀ {n : Nat},\n                  instLTNat.lt n (Chapter8.Nat.min (symmDiff A B)) →\n                    Iff (Set.instMembership.mem A n) (Set.instMembership.mem B n)) →\n                ∀ (n : Nat),\n                  Iff (Set.instMembership.mem A n)\n                    (Or (And (Set.instMembership.mem A n) (instLENat.le n (Chapter8.Nat.min (symmDiff A B))))\n                      (And (Set.instMembership.mem A n) (instLTNat.lt (Chapter8.Nat.min (symmDiff A B)) n)))","name":["Chapter8","Uncountable","real","_proof_1_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Function","Injective"]],"typeReferences":[],"type":"Type → Type → Prop","name":["Chapter8","LeCard"],"kind":"definition","isProp":false},{"valueReferences":[["implies_congr"],["instAddNat"],["PseudoMetricSpace","toUniformSpace"],["Eq","trans"],["Classical","propDecidable"],["eq_true"],["Union","union"],["Subtype","val"],["Classical","choose"],["NatCast","natCast"],["Eq","symm"],["Lean","Grind","false_of_not_eq_self"],["Set","instUnion"],["Bool","true"],["Set","instInter"],["Set","instSDiff"],["instLTNat"],["Exists"],["Lean","Grind","not_not"],["Set","instMembership"],["Lean","Grind","eq_false_of_or_eq_false_right"],["Lean","Grind","and_eq_of_eq_false_right"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["Eq","refl"],["eq_false"],["Classical","byContradiction"],["Set","ext"],["setOf"],["Bool"],["symmDiff"],["Lean","Grind","and_eq_of_eq_true_right"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["Lean","Grind","imp_eq_of_eq_true_left"],["Lean","Grind","Nat","lt_eq"],["or_false"],["Lean","Grind","nestedDecidable"],["instOfNatNat"],["tsum"],["congr"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Lean","Grind","Nat","lo_eq_false_of_le"],["Lean","Grind","Nat","le_eq_false_of_lo"],["Set"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","iff_eq"],["Lean","Grind","or_eq_of_eq_false_right"],["Lean","Grind","of_lookahead"],["dite"],["instHSub"],["And","casesOn"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Inter","inter"],["Membership","mem"],["CompleteBooleanAlgebra","toCompleteLattice"],["Lean","Grind","not_eq_prop"],["Or"],["Lean","Grind","forall_imp_eq_or"],["forall_congr"],["funext"],["HSub","hSub"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["Nat","Simproc","add_le_add_le"],["instHPow"],["Real"],["Neg","neg"],["Lean","Grind","rfl_true"],["And"],["True","intro"],["Real","instLE"],["Exists","casesOn"],["Nat"],["Real","pseudoMetricSpace"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Subtype"],["Lean","Grind","not_and"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["UniformSpace","toTopologicalSpace"],["congrArg"],["Real","instPow"],["Nat","not_le_eq"],["Real","instNeg"],["Zero","toOfNat0"],["of_decide_eq_true"],["Not"],["Set","Nonempty"],["Lean","Grind","em"],["Lean","Grind","alreadyNorm"],["True"],["instHAdd"],["Nat","decLe"],["LT","lt"],["Or","casesOn"],["of_eq_true"],["instSubNat"],["SemilatticeSup","toMax"],["LE","le"],["False"],["Lean","Grind","intro_with_eq"],["instLENat"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Real"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["setOf"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Real","instZero"],["SemilatticeSup","toMax"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          Or\n              (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))))\n              (And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B))))) →\n            And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))) →\n              (∀ {n : Nat},\n                  instLTNat.lt n (Chapter8.Nat.min (symmDiff A B)) →\n                    Iff (Set.instMembership.mem A n) (Set.instMembership.mem B n)) →\n                Eq (setOf fun n => And (Set.instMembership.mem A n) (instLTNat.lt n (Chapter8.Nat.min (symmDiff A B))))\n                  (setOf fun n => And (Set.instMembership.mem B n) (instLTNat.lt n (Chapter8.Nat.min (symmDiff A B))))","name":["Chapter8","Uncountable","real","_proof_1_14"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","LeCard"],["Chapter8","CardOrder","_proof_3"],["LE","mk"],["Chapter8","CardOrder","_proof_2"],["LT","mk"],["Preorder","mk"],["Chapter8","CardOrder","_proof_1"],["Chapter8","LtCard"]],"typeReferences":[["Preorder"]],"type":"Preorder Type","name":["Chapter8","CardOrder"],"kind":"definition","isProp":false},{"valueReferences":[["Nat"],["instOfNatNat"],["instNatAtLeastTwo"],["OfNat","ofNat"]],"typeReferences":[["instAddNat"],["HAdd","hAdd"],["Nat"],["instOfNatNat"],["instHAdd"],["Nat","AtLeastTwo"],["OfNat","ofNat"]],"type":"(instHAdd.hAdd 8 2).AtLeastTwo","name":["Chapter8","Uncountable","real","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Chapter8","AtMostCountable"],["Uncountable"],["Chapter8","Uncountable","iff"],["propext"]],"typeReferences":[["Not"],["Chapter8","AtMostCountable"],["Uncountable"],["Eq"]],"type":"∀ (X : Type), Eq (Uncountable X) (Not (Chapter8.AtMostCountable X))","name":["Chapter8","Uncountable","equiv","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Lattice","toSemilatticeSup"],["Nat"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Set","instCompleteAtomicBooleanAlgebra"],["Set"],["symmDiff"],["SemilatticeSup","toMax"],["CompleteBooleanAlgebra","toCompleteLattice"],["Chapter8","Nat","min","_proof_1"],["ConditionallyCompleteLattice","toLattice"],["CompleteLattice","toConditionallyCompleteLattice"],["Set","instSDiff"]],"typeReferences":[["Lattice","toSemilatticeSup"],["Set","Nonempty"],["Exists"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Set"],["symmDiff"],["Membership","mem"],["And"],["CompleteBooleanAlgebra","toCompleteLattice"],["Set","instMembership"],["Nat"],["Set","instCompleteAtomicBooleanAlgebra"],["LE","le"],["SemilatticeSup","toMax"],["ConditionallyCompleteLattice","toLattice"],["instLENat"],["CompleteLattice","toConditionallyCompleteLattice"],["Set","instSDiff"]],"type":"∀ ⦃A B : Set Nat⦄,\n  (symmDiff A B).Nonempty →\n    Exists fun x =>\n      And (Set.instMembership.mem (symmDiff A B) x)\n        (∀ (n : Nat), Set.instMembership.mem (symmDiff A B) n → instLENat.le x n)","name":["Chapter8","Uncountable","real","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["instLTNat"],["Nat"],["Set"],["Membership","mem"],["Subtype","casesOn"],["GT","gt"],["setOf"],["Set","instMembership"]],"typeReferences":[["instLTNat"],["Nat"],["Set"],["Membership","mem"],["Subtype","mk"],["GT","gt"],["Set","Elem"],["Set","instMembership"],["setOf"]],"type":"∀ (n₀ : Nat) (motive : (setOf fun n => GT.gt n n₀).Elem → Prop) (h : (setOf fun n => GT.gt n n₀).Elem),\n  (∀ (n : Nat) (hn : Set.instMembership.mem (setOf fun n => GT.gt n n₀) n), motive ⟨n, hn⟩) → motive h","name":["Chapter8","Uncountable","real","match_1_15"],"kind":"definition","isProp":true},{"valueReferences":[["Classical","choose_spec"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["Classical","propDecidable"],["eq_true"],["Classical","choose"],["congrArg"],["False","elim"],["not_false_eq_true"],["Eq","symm"],["not_true_eq_false"],["Eq"],["Not"],["True"],["Set"],["And","right"],["Function","Bijective"],["Function","Surjective"],["Set","instMembership"],["Set","decidableSetOf"],["of_eq_true"],["eq_false"],["False"],["dite"],["instDecidableNot"],["setOf"],["Function","Injective"]],"typeReferences":[["Not"],["Set"],["Chapter8","EqualCard"]],"type":"∀ (X : Type), Not (Chapter8.EqualCard X (Set X))","name":["Chapter8","EqualCard","power_set_false"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","LeCard"],["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Chapter8","LeCard"]],"type":"∀ (a b c : Type), Chapter8.LeCard a b → Chapter8.LeCard b c → Chapter8.LeCard a c","name":["Chapter8","CardOrder","_proof_2"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Uncountable"],["Eq","trans"],["instInfiniteNat"],["Singleton","singleton"],["Membership","mem"],["Exists","intro"],["Set","Elem"],["Chapter8","AtMostCountable"],["False","elim"],["Finite","of_finite_univ"],["Eq","symm"],["Finite"],["Chapter8","CountablyInfinite"],["not_finite_iff_infinite"],["Chapter8","EqualCard"],["Function","Bijective"],["Chapter8","EqualCard","symm"],["Set","instMembership"],["Set","finite_coe_iff"],["Exists","casesOn"],["Set","image_univ"],["Set","image"],["Nat"],["HasSubset","Subset"],["id"],["Set","subset_univ","_simp_1"],["Eq","mpr"],["Set","Finite"],["Eq","mp"],["Finite","Set","finite_of_finite_image"],["Set","singleton_eq_singleton_iff","_simp_1"],["Set","range"],["congrArg"],["Finite","Set","subset"],["Eq"],["Infinite"],["propext"],["Not"],["Mathlib","Tactic","PushNeg","not_not_eq"],["True"],["Set"],["Subtype","finite"],["Set","instSingletonSet"],["Mathlib","Tactic","Contrapose","mtr"],["Or","casesOn"],["Set","univ"],["Set","instHasSubset"],["eq_self"],["of_eq_true"],["Chapter8","Uncountable","iff"],["False"],["inferInstance"],["Chapter8","EqualCard","power_set_false"]],"typeReferences":[["Uncountable"],["Nat"],["Set"]],"type":"Uncountable (Set Nat)","name":["Chapter8","Uncountable","power_set_nat"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["instAddNat"],["PseudoMetricSpace","toUniformSpace"],["Eq","trans"],["Classical","propDecidable"],["eq_true"],["Union","union"],["Subtype","val"],["Classical","choose"],["False","elim"],["NatCast","natCast"],["Eq","symm"],["Set","instUnion"],["Bool","true"],["Set","instInter"],["Set","instSDiff"],["instLTNat"],["Exists"],["Lean","Grind","not_not"],["Set","instMembership"],["Lean","Grind","eq_false_of_or_eq_false_right"],["Set","instCompleteAtomicBooleanAlgebra"],["eq_false"],["Iff"],["Eq","refl"],["Classical","byContradiction"],["Bool"],["symmDiff"],["Lean","Grind","and_eq_of_eq_true_right"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["Lean","Grind","Nat","lt_eq"],["Lean","Grind","nestedDecidable"],["Lean","Grind","or_eq_of_eq_true_left"],["instOfNatNat"],["tsum"],["congr"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Lean","Grind","Nat","le_eq_false_of_lo"],["Set"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","iff_eq"],["Lean","Grind","or_eq_of_eq_false_right"],["dite"],["instHSub"],["And","casesOn"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Inter","inter"],["Membership","mem"],["CompleteBooleanAlgebra","toCompleteLattice"],["Lean","Grind","not_eq_prop"],["Or"],["Lean","Grind","forall_imp_eq_or"],["forall_congr"],["funext"],["HSub","hSub"],["Lean","Grind","not_eq_of_eq_false"],["Lean","Grind","not_eq_of_eq_true"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["Nat","Simproc","add_le_add_le"],["instHPow"],["Real"],["Neg","neg"],["Lean","Grind","rfl_true"],["And"],["Lean","Grind","eq_true_of_and_eq_true_right"],["True","intro"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Subtype"],["Lean","Grind","not_and"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["UniformSpace","toTopologicalSpace"],["Lean","Grind","not_or"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Real","instPow"],["Nat","not_le_eq"],["Real","instNeg"],["Zero","toOfNat0"],["Lean","Grind","or_eq_of_eq_false_left"],["of_decide_eq_true"],["Not"],["Set","Nonempty"],["True"],["instHAdd"],["Nat","decLe"],["LT","lt"],["Or","casesOn"],["of_eq_true"],["instSubNat"],["Lean","Grind","and_eq_of_eq_true_left"],["SemilatticeSup","toMax"],["LE","le"],["False"],["Lean","Grind","intro_with_eq"],["instLENat"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Real"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Real","instZero"],["LE","le"],["SemilatticeSup","toMax"],["instLENat"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          Or\n              (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))))\n              (And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B))))) →\n            And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))) →\n              (∀ {n : Nat},\n                  instLTNat.lt n (Chapter8.Nat.min (symmDiff A B)) →\n                    Iff (Set.instMembership.mem A n) (Set.instMembership.mem B n)) →\n                ∀ (n : Nat),\n                  Iff (Set.instMembership.mem B n)\n                    (Or (And (Set.instMembership.mem B n) (instLENat.le n (Chapter8.Nat.min (symmDiff A B))))\n                      (And (Set.instMembership.mem B n) (instLTNat.lt (Chapter8.Nat.min (symmDiff A B)) n)))","name":["Chapter8","Uncountable","real","_proof_1_10"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Real","normedCommRing"],["Mathlib","Tactic","Ring","div_pf"],["MonoidWithZero","toMulZeroOneClass"],["Equiv"],["AddGroup","toSubtractionMonoid"],["Int","instCommSemiring"],["Order","Frame","toHeytingAlgebra"],["AddCommMonoid"],["congrFun"],["Chapter8","Uncountable","power_set_nat"],["Int","instLTInt"],["HeytingAlgebra","toOrderBot"],["Real","lattice"],["Bool","true"],["Nat","ble"],["instLatticeInt"],["Exists"],["Real","instCommSemiring"],["Real","instCompleteSpace"],["Mathlib","Meta","NormNum","IsNNRat","den_nz"],["TopologicalSpace","t2Space_of_metrizableSpace"],["DivisionSemiring","toSemiring"],["Mathlib","Tactic","Abel","term_add_constg"],["Classical","em"],["summable_geometric_of_lt_one"],["eq_false"],["gt_iff_lt","_simp_1"],["Int","negOfNat"],["Mathlib","Meta","NormNum","natPow_one"],["Mathlib","Tactic","Ring","cast_nnrat"],["Real","instIsStrictOrderedRing"],["sub_le_sub"],["Mathlib","Tactic","Ring","add_mul"],["Mathlib","Meta","NormNum","IsRat","to_isNNRat"],["Real","instNatCast"],["Mathlib","Tactic","Linarith","lt_irrefl"],["CancelMonoidWithZero","toMonoidWithZero"],["pow_one"],["EquivLike","toFunLike"],["Set","sep_or"],["Eq"],["instNatCastInt"],["Mathlib","Tactic","Ring","neg_zero"],["DivisionRing","toRing"],["Int","instIsOrderedAddMonoid"],["Mathlib","Meta","NormNum","IsNNRat","of_raw"],["Real","instAdd"],["Real","instZero"],["Set","mem_empty_iff_false","_simp_1"],["Mathlib","Meta","NormNum","instAddMonoidWithOne'"],["Ne"],["add_le_add_left"],["Real","instDivInvMonoid"],["Function","Injective"],["Mathlib","Meta","NormNum","IsNat","to_isNNRat"],["false_and"],["Real","instMonoidWithZero"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Mathlib","Tactic","Linarith","eq_of_not_lt_of_not_gt"],["instNontrivialOfCharZero"],["Preorder","toLT"],["CommGroupWithZero","toDivisionCommMonoid"],["GT","gt"],["Chapter8","Nat","min"],["forall_congr"],["Int","instLEInt"],["Mathlib","Tactic","Ring","div_congr"],["Semifield","toDivisionSemiring"],["Eq","rec"],["Real","rpow_neg"],["Int","mul"],["Real"],["AddZeroClass","toZero"],["InvOneClass","toOne"],["And","right"],["Mathlib","Meta","NormNum","IsNat","raw_refl"],["zero_add"],["Mathlib","Tactic","Ring","atom_pf"],["Chapter8","Uncountable","real","match_1_15"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Real","instOne"],["PosMulStrictMono","toPosMulReflectLE"],["Mathlib","Meta","NormNum","IsNNRat","to_isRat"],["Eq","mp"],["Mathlib","Tactic","Abel","unfold_sub"],["UniformSpace","toTopologicalSpace"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Mathlib","Tactic","Linarith","lt_of_eq_of_lt"],["Set","range"],["PosMulReflectLE","toPosMulReflectLT"],["neg_eq_zero"],["instDistribLatticeOfLinearOrder"],["Real","rpow_neg_natCast"],["Monoid","toMulOneClass"],["NormedCommRing","toNormedRing"],["AddCommSemigroup","toAddCommMagma"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Inv","inv"],["mul_eq_mul_right_iff","_simp_1"],["inv_pow"],["Real","rpow_pos_of_pos"],["Set","instSingletonSet"],["iff_false"],["Mathlib","Tactic","Ring","add_congr"],["Set","mem_union","_simp_1"],["LT","lt"],["ContinuousAdd"],["of_eq_true"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["le_of_lt"],["Mathlib","Tactic","Ring","neg_congr"],["Mathlib","Meta","NormNum","IsRat","to_raw_eq"],["SemilatticeSup","toMax"],["Mathlib","Meta","NormNum","isNNRat_lt_true"],["Field","toSemifield"],["Mathlib","Tactic","Abel","const_add_termg"],["False"],["Subtype","mk"],["NormedCommRing","toNonUnitalNormedCommRing"],["DivInvMonoid","toInv"],["Uncountable"],["SubtractionMonoid","toSubNegZeroMonoid"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["Real","instPreorder"],["zpow_neg"],["PseudoMetricSpace","toUniformSpace"],["Eq","trans"],["inv_pos_of_pos"],["Singleton","singleton"],["Exists","intro"],["Subtype","val"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["IsDomain","toCancelMonoidWithZero"],["DivisionMonoid","toDivInvMonoid"],["instTransGeGt_mathlib"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Linarith","sub_neg_of_lt"],["iff_self"],["Mathlib","Tactic","Ring","one_mul"],["sub_eq_zero_of_eq"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["Set","instSDiff"],["rfl"],["EMetricSpace","metrizableSpace"],["DivisionSemiring","toGroupWithZero"],["Summable","tsum_union_disjoint"],["Set","instMembership"],["false_or"],["BoundedOrder","toOrderBot"],["Set","instCompleteAtomicBooleanAlgebra"],["Eq","refl"],["AddMonoidWithOne","toOne"],["Classical","byContradiction"],["AddCommGroup","toAddCommMonoid"],["GeneralizedCoheytingAlgebra","toSDiff"],["Nat","rawCast"],["AddMonoid","toAddZeroClass"],["Set","mem_inter_iff","_simp_1"],["Bool"],["symmDiff"],["one_div"],["BooleanAlgebra","toBiheytingAlgebra"],["div_pos"],["instHDiv"],["Int","add_one_le_iff"],["instOfNatNat"],["tsum"],["Mathlib","Tactic","Ring","pow_congr"],["congr"],["Int","instAdd"],["tsum_mul_left"],["AddCommMagma","toAdd"],["Preorder","toLE"],["ge_iff_le","_simp_1"],["lt_of_not_ge"],["Equiv","bijective"],["Equiv","tsum_eq"],["Chapter8","Uncountable","real","_proof_1_2"],["Chapter8","Uncountable","real","_proof_1_8"],["Chapter8","Uncountable","real","_proof_1_7"],["Set","instDistribLattice"],["Int"],["Set","disjoint_iff_inter_eq_empty"],["Real","instInv"],["AddCommGroup","toDivisionAddCommMonoid"],["instDecidableEqNat"],["NormedField","toNormedDivisionRing"],["Countable"],["Equiv","ofInjective"],["Semifield","toCommGroupWithZero"],["Mathlib","Tactic","Ring","zero_mul"],["Trans","trans"],["Mathlib","Tactic","Ring","inv_single"],["GroupWithZero","toDivInvMonoid"],["HMul","hMul"],["HDiv","hDiv"],["Real","instRCLike"],["Ring","toAddGroupWithOne"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocRing"],["HSub","hSub"],["lt_self_iff_false","_simp_1"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["neg_zero"],["Real","instAddCommMonoid"],["Mathlib","Tactic","Linarith","zero_lt_one"],["BiheytingAlgebra","toCoheytingAlgebra"],["RCLike","charZero_rclike"],["AddSemigroup","toAdd"],["instHPow"],["not_and","_simp_1"],["Chapter8","Uncountable","real","_proof_1_5"],["And"],["add_zero"],["Decidable","not_and_iff_not_or_not'"],["mul_pos"],["Chapter8","Nat","min_spec"],["Real","instLE"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Classical","or_iff_not_imp_left"],["Mathlib","Tactic","Ring","mul_pf_right"],["NegZeroClass","toZero"],["Set","instIsEmptyElemEmptyCollection"],["instHMul"],["Real","linearOrder"],["instNatAtLeastTwo"],["CompleteDistribLattice","toCoframe"],["Mathlib","Tactic","Abel","term_atomg"],["Subtype"],["Mathlib","Tactic","Zify","natCast_eq","_simp_1"],["sub_eq_zero"],["Mathlib","Tactic","Ring","neg_mul"],["Set","instEmptyCollection"],["SubNegZeroMonoid","toNegZeroClass"],["congrArg"],["Real","instPow"],["symmDiff_comm"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Real","instLT"],["MonoidWithZero","toMonoid"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["NNRat","rawCast"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["Real","metricSpace"],["HEq","refl"],["tsum_congr"],["Semiring","toMonoidWithZero"],["DivInvMonoid","toDiv"],["Set","mem_diff","_simp_1"],["NegZeroClass","toNeg"],["Mathlib","Tactic","Ring","mul_pf_left"],["Int","instSemiring"],["LE","le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Real","rpow_sub"],["Set","mem_singleton_iff","_simp_1"],["instLENat"],["Mathlib","Meta","NormNum","isNat_natCast"],["Mathlib","Meta","NormNum","isRat_mul"],["tsum_singleton"],["Mathlib","Meta","NormNum","IsInt","to_isRat"],["Ring","toNonAssocRing"],["Real","instAddGroup"],["MulZeroClass","toMul"],["AddGroupWithOne","toAddMonoidWithOne"],["Chapter8","Uncountable","real","_proof_1_13"],["Chapter8","Uncountable","equiv"],["Mathlib","Meta","NormNum","isNat_pow"],["CompleteSemilatticeInf","toPartialOrder"],["tsum_geometric_of_lt_one"],["Eq","symm"],["Equiv","toFun"],["NonAssocSemiring","toAddCommMonoidWithOne"],["Real","rpow_natCast"],["Real","normedAddCommGroup"],["instLTNat"],["Mathlib","Meta","NormNum","IsNNRat","to_isNat"],["Function","Bijective"],["Ring","toSemiring"],["Chapter8","Uncountable","real","_proof_1_9"],["MulZeroOneClass","toMulZeroClass"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Iff"],["Chapter8","Uncountable","real","_simp_1_11"],["Eq","mpr"],["Mathlib","Tactic","Ring","inv_mul"],["Not","intro"],["Mathlib","Meta","NormNum","isNat_le_true"],["AddCommMonoid","toAddMonoid"],["Mathlib","Meta","NormNum","isInt_neg"],["Nat","add_right_cancel_iff","_simp_1"],["Mathlib","Tactic","Ring","neg_one_mul"],["Int","instIsStrictOrderedRing"],["Chapter8","Uncountable","real","_proof_1_10"],["Mathlib","Tactic","Abel","termg"],["Set"],["instOfNatAtLeastTwo"],["Field","toDivisionRing"],["HPow","hPow"],["Mathlib","Tactic","Ring","mul_congr"],["Nat","cast_add"],["eq_self"],["Mathlib","Tactic","Ring","inv_congr"],["AddZeroClass","toAdd"],["Monoid","toNatPow"],["OfNat","ofNat_ne_zero","_simp_1"],["SDiff","sdiff"],["CompleteLattice","toCompleteSemilatticeInf"],["Mathlib","Meta","Positivity","pos_of_isNat"],["instHSub"],["IsStrictOrderedRing","toZeroLEOneClass"],["PartialOrder","toPreorder"],["Summable","subtype"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Inter","inter"],["Membership","mem"],["Real","instNontrivial"],["T2Space"],["GE","ge"],["IsTopologicalRing","toIsTopologicalSemiring"],["Semiring","toNonAssocSemiring"],["Mathlib","Tactic","Ring","add_pf_add_overlap"],["Or"],["PartialOrder"],["eq_of_heq"],["Mathlib","Tactic","Ring","single_pow"],["AddGroup","toSubNegMonoid"],["Real","rpow_add"],["Int","ofNat"],["Set","instBooleanAlgebra"],["SemilatticeInf","toPartialOrder"],["And","left"],["IsStrictOrderedRing","toPosMulStrictMono"],["Nat","mul"],["Nat","instPartialOrder"],["Real","instIsOrderedAddMonoid"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Mathlib","Tactic","Ring","mul_zero"],["IsTopologicalSemiring","toContinuousAdd"],["Int","instNegInt"],["NormMulClass","toNoZeroDivisors"],["Nat"],["AddMonoidWithOne","toNatCast"],["Real","instMonoid"],["Mathlib","Meta","NormNum","isRat_add"],["Mathlib","Meta","NormNum","isRat_le_true"],["DivisionMonoid","toDivInvOneMonoid"],["GroupWithZero","toDivisionMonoid"],["Mathlib","Tactic","Ring","mul_one"],["Mathlib","Meta","NormNum","isNNRat_rpow_neg"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Mathlib","Meta","NormNum","IsNNRat","to_raw_eq"],["DFunLike","coe"],["Chapter8","Uncountable","real","_proof_1_12"],["Real","instNeg"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["GroupWithZero","toMonoidWithZero"],["Chapter8","Uncountable","real","_proof_1_17"],["Mathlib","Meta","NormNum","isNNRat_inv_pos"],["Real","instDivisionRing"],["Real","partialOrder"],["CompleteDistribLattice","toFrame"],["IsStrictOrderedRing","toCharZero"],["Not"],["Real","instMul"],["Set","Nonempty"],["tsum_congr_set_coe"],["instHAdd"],["Distrib","toMul"],["Mathlib","Tactic","Ring","cast_pos"],["Mathlib","Tactic","Abel","term_neg"],["Real","semiring"],["instSubNat"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Real","instAddCommGroup"],["instAddNat"],["Subtype","mk","injEq"],["Mathlib","Meta","NormNum","IsRat","den_nz"],["Real","rpow_one"],["Union","union"],["Set","Elem"],["Mathlib","Meta","NormNum","isNNRat_div"],["False","elim"],["SubNegMonoid","toSub"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["NormedDivisionRing","toNormMulClass"],["MulOneClass","toMul"],["Set","instUnion"],["Eq","ndrec"],["Mathlib","Tactic","Ring","sub_pf"],["Set","instInter"],["Int","instAddGroup"],["instTransEq"],["Mathlib","Tactic","Ring","pow_prod_atom"],["pow_add"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["tsum_nonneg"],["DivInvMonoid","toMonoid"],["SubtractionMonoid","toSubNegMonoid"],["Mathlib","Meta","NormNum","IsRat","of_raw"],["HEq"],["Set","ext"],["setOf"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["inv_eq_zero","_simp_1"],["pow_pos"],["Order","Coframe","toCoheytingAlgebra"],["Real","field"],["SubtractionCommMonoid","toSubtractionMonoid"],["EmptyCollection","emptyCollection"],["Chapter8","Uncountable","real","_proof_1_14"],["Int","instRing"],["HasSolidNorm","orderClosedTopology"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["or_false"],["Set","symmDiff_nonempty"],["Int","instAddCommGroup"],["DivisionRing","toDivisionSemiring"],["Mathlib","Tactic","Ring","mul_add"],["propext"],["CompleteLattice","toConditionallyCompleteLattice"],["Mathlib","Tactic","Ring","pow_zero"],["mul_inv_rev"],["Distrib","toAdd"],["pow_eq_zero_iff'","_simp_1"],["IsStrictOrderedRing","toIsOrderedRing"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["Function","Surjective"],["OfNat","ofNat"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["Mathlib","Meta","NormNum","isNNRat_zpow_neg"],["Real","normedField"],["MulZeroClass","toZero"],["Equiv","ofBijective"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["inferInstance"],["Int","instNormedCommRing"],["Mathlib","Meta","NormNum","isNNRat_mul"],["Real","instAddMonoid"],["neg_neg_of_pos"],["And","casesOn"],["Nat","cast_one"],["Lattice","toSemilatticeSup"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["Mathlib","Tactic","Linarith","lt_of_lt_of_eq"],["DivInvMonoid","toZPow"],["Iff","mp"],["Int","rawCast"],["CompleteBooleanAlgebra","toCompleteLattice"],["Mathlib","Meta","NormNum","IsNNRat","to_eq"],["AddMonoidWithOne","toAddMonoid"],["And","intro"],["Mathlib","Tactic","Abel","subst_into_negg"],["Disjoint"],["funext"],["Rat","rawCast"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["not_uncountable_iff"],["InvOneClass","toInv"],["NonUnitalNonAssocSemiring","toDistrib"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Neg","neg"],["Mathlib","Tactic","Linarith","natCast_nonneg"],["Real","instSub"],["IsOrderedAddMonoid","toAddLeftMono"],["instIsTopologicalRingReal"],["Summable"],["Nat","decLt"],["Decidable","byContradiction"],["Real","pseudoMetricSpace"],["Nat","cast_zero"],["Mathlib","Meta","NormNum","instAddMonoidWithOne"],["Iff","mpr"],["id"],["ConditionallyCompleteLattice","toLattice"],["Mathlib","Meta","NormNum","isNat_ofNat"],["instTransEq_1"],["GeneralizedCoheytingAlgebra","toLattice"],["Equiv","instEquivLike"],["Chapter8","Uncountable","real","_proof_1_6"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Abel","subst_into_addg"],["Real","instRing"],["Real","instIsOrderedRing"],["Iff","intro"],["instIsUniformAddGroupReal"],["and_iff_right_iff_imp","_simp_1"],["MulOneClass","toOne"],["SetCoe","countable"],["MetricSpace","toEMetricSpace"],["zpow_natCast"],["Mathlib","Tactic","Ring","cast_zero"],["DivisionCommMonoid","toDivisionMonoid"],["Mathlib","Tactic","Ring","add_overlap_pf"],["Mathlib","Meta","NormNum","isInt_mul"],["tsum_empty"],["True"],["Mathlib","Tactic","Ring","pow_add"],["Real","instIsDomain"],["Set","instBoundedOrder"],["CommSemiring","toSemiring"],["one_div_pow"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["Eq","casesOn"],["Mathlib","Tactic","Contrapose","mtr"],["instHasSolidNormReal"],["Or","casesOn"],["DistribLattice","toLattice"],["DivInvOneMonoid","toInvOneClass"],["AddCommMonoid","toAddCommSemigroup"],["Int","instAddMonoid"]],"typeReferences":[["Uncountable"],["Real"]],"type":"Uncountable Real","name":["Chapter8","Uncountable","real"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Chapter8","LeCard"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["And"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["Iff"],["Lean","Name","num"],["Chapter8","LtCard"]],"typeReferences":[["Not"],["Chapter8","LeCard"],["Iff"],["And"],["Chapter8","LtCard"]],"type":"∀ (a b : Type), Iff (Chapter8.LtCard a b) (And (Chapter8.LeCard a b) (Not (Chapter8.LeCard b a)))","name":["Chapter8","CardOrder","_proof_3"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Lattice","toSemilatticeSup"],["Int","instSub"],["Eq","trans"],["le_of_le_of_eq"],["CompleteBooleanAlgebra","toCompleteLattice"],["GT","gt"],["Chapter8","Nat","min"],["Int","instLEInt"],["Eq","symm"],["Lean","Omega","tidy_sat"],["HSub","hSub"],["Lean","Omega","LinearCombo","add_eval"],["Int","add_one_le_of_lt"],["Bool","true"],["List","cons"],["And","left"],["Set","instSDiff"],["instLTNat"],["Neg","neg"],["And","right"],["Lean","Omega","Constraint","addInequality_sat"],["And"],["Lean","Omega","Int","ofNat_sub_sub"],["Lean","Omega","LinearCombo","coordinate"],["Int","instNegInt"],["instDecidableEqBool"],["Nat"],["instOfNat"],["Set","instCompleteAtomicBooleanAlgebra"],["Eq","refl"],["Lean","Omega","Constraint","addEquality_sat"],["id"],["ConditionallyCompleteLattice","toLattice"],["Lean","Omega","LinearCombo","instAdd"],["Lean","Omega","Int","sub_congr"],["Or","elim"],["Lean","Omega","LinearCombo","coordinate_eval_2"],["Nat","cast"],["Bool"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["Lean","Omega","LinearCombo","coordinate_eval_0"],["Lean","Omega","Constraint","combine_sat'"],["Option","some"],["Int","sub_eq_zero_of_eq"],["Decidable","decide"],["Lean","Omega","LinearCombo","mk"],["Nat","lt_or_gt_of_ne"],["Lean","Omega","LinearCombo","instSub"],["Lean","Omega","Coeffs","ofList"],["instOfNatNat"],["Lean","Omega","Int","ofNat_sub_dichotomy"],["Int","instAdd"],["Eq"],["Lean","Omega","Constraint","not_sat'_of_isImpossible"],["CompleteLattice","toConditionallyCompleteLattice"],["instNatCastInt"],["of_decide_eq_true"],["List","nil"],["instHAdd"],["Set"],["Lean","Omega","LinearCombo"],["Lean","Omega","Int","add_congr"],["Lean","Omega","Constraint","isImpossible"],["Int","sub_nonneg_of_le"],["OfNat","ofNat"],["Int"],["Lean","Omega","LinearCombo","coordinate_eval_1"],["LT","lt"],["HAdd","hAdd"],["Lean","Omega","Int","ofNat_lt_of_lt"],["Lean","Omega","LinearCombo","sub_eval"],["Option","none"],["instSubNat"],["SemilatticeSup","toMax"],["LE","le"],["Int","natCast_add"],["False"],["Lean","Omega","LinearCombo","eval"],["Lean","Omega","Constraint","mk"],["instHSub"],["instLENat"]],"typeReferences":[["instAddNat"],["Lattice","toSemilatticeSup"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["CompleteBooleanAlgebra","toCompleteLattice"],["Chapter8","Nat","min"],["instOfNatNat"],["HSub","hSub"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Set","instSDiff"],["Not"],["instLTNat"],["Set"],["instHAdd"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Nat"],["instSubNat"],["Set","instCompleteAtomicBooleanAlgebra"],["SemilatticeSup","toMax"],["False"],["ConditionallyCompleteLattice","toLattice"],["instHSub"]],"type":"∀ ⦃A B : Set Nat⦄ (n : Nat),\n  instLTNat.lt (Chapter8.Nat.min (symmDiff A B)) n →\n    Not\n        (Eq\n          (instHAdd.hAdd (instHSub.hSub (instHSub.hSub n (Chapter8.Nat.min (symmDiff A B))) 1)\n            (instHAdd.hAdd (Chapter8.Nat.min (symmDiff A B)) 1))\n          n) →\n      False","name":["Chapter8","Uncountable","real","_proof_1_17"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["not_or","_simp_1"],["Uncountable"],["Chapter8","CountablyInfinite"],["Exists"],["not_finite_iff_infinite","_simp_1"],["Eq","trans"],["True"],["Chapter8","AtMostCountable","equiv"],["And"],["Function","Bijective"],["not_exists","_simp_1"],["congrArg"],["Chapter8","AtMostCountable"],["Nat"],["iff_self"],["Or"],["of_eq_true"],["Chapter8","Uncountable","equiv","_simp_1_1"],["Iff"],["congr"],["Finite"],["Infinite"],["propext"]],"typeReferences":[["Uncountable"],["Iff"],["Chapter8","EqualCard"]],"type":"∀ {X Y : Type}, Chapter8.EqualCard X Y → Iff (Uncountable X) (Uncountable Y)","name":["Chapter8","Uncountable","equiv"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Eq","trans"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Classical","choose"],["Subtype","val"],["Or"],["NatCast","natCast"],["Lean","Grind","forall_imp_eq_or"],["funext"],["forall_congr"],["Eq","symm"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["Set","instUnion"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["Exists"],["Real"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Neg","neg"],["And"],["Lean","Grind","not_not"],["True","intro"],["Lean","Grind","nestedProof"],["Set","instMembership"],["Real","instLE"],["Nat"],["Set","instCompleteAtomicBooleanAlgebra"],["Real","pseudoMetricSpace"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["GeneralizedCoheytingAlgebra","toSDiff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["CompleteDistribLattice","toCoframe"],["Lean","Grind","imp_false_eq"],["Lean","Grind","not_and"],["GeneralizedCoheytingAlgebra","toLattice"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Order","Coframe","toCoheytingAlgebra"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Lean","Grind","dite_cond_eq_false'"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Real","instPow"],["Lean","Grind","nestedDecidable"],["tsum"],["instOfNatNat"],["Real","instNeg"],["Lean","Grind","dite_cond_eq_true'"],["Zero","toOfNat0"],["Chapter8","Uncountable","real","_proof_1_4"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set","Nonempty"],["Lean","Grind","em"],["True"],["Lean","Grind","alreadyNorm"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["Or","casesOn"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","or_eq_of_eq_false_right"],["LE","le"],["SemilatticeSup","toMax"],["False"],["Lean","Grind","intro_with_eq"],["dite"],["instLENat"],["And","casesOn"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["Real"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["GeneralizedCoheytingAlgebra","toSDiff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["CompleteDistribLattice","toCoframe"],["GeneralizedCoheytingAlgebra","toLattice"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Order","Coframe","toCoheytingAlgebra"],["Real","instNatCast"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Real","instZero"],["LE","le"],["SemilatticeSup","toMax"],["False"],["instLENat"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          (∀ (n : Nat),\n              Or (And (Set.instMembership.mem A n) (Not (Set.instMembership.mem B n)))\n                  (And (Set.instMembership.mem B n) (Not (Set.instMembership.mem A n))) →\n                instLENat.le (Chapter8.Nat.min (symmDiff A B)) n) →\n            (∀ ⦃A B : Set Nat⦄,\n                Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n                    ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n                  let n₀ := Chapter8.Nat.min (symmDiff A B);\n                  Or (And (Set.instMembership.mem A n₀) (Not (Set.instMembership.mem B n₀)))\n                      (And (Set.instMembership.mem B n₀) (Not (Set.instMembership.mem A n₀))) →\n                    (∀ (n : Nat),\n                        Or (And (Set.instMembership.mem A n) (Not (Set.instMembership.mem B n)))\n                            (And (Set.instMembership.mem B n) (Not (Set.instMembership.mem A n))) →\n                          instLENat.le n₀ n) →\n                      And (Set.instMembership.mem A n₀) (Not (Set.instMembership.mem B n₀)) → False) →\n              Not\n                  (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                    (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B))))) →\n                And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                    (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))) →\n                  And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                    (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B))))","name":["Chapter8","Uncountable","real","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter8","EqualCard"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Chapter8","LeCard"],["Chapter8","EqualCard"]],"type":"∀ {X Y : Type}, Chapter8.LeCard X Y → Chapter8.LeCard Y X → Chapter8.EqualCard X Y","name":["Chapter8","Schroder_Bernstein"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Eq","trans"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Classical","choose"],["Subtype","val"],["Or"],["NatCast","natCast"],["Lean","Grind","forall_imp_eq_or"],["funext"],["forall_congr"],["Eq","symm"],["Lean","Grind","not_eq_of_eq_true"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["Set","instUnion"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["Exists"],["Real"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Neg","neg"],["And"],["Lean","Grind","not_not"],["True","intro"],["Lean","Grind","nestedProof"],["Set","instMembership"],["Real","instLE"],["Nat"],["Set","instCompleteAtomicBooleanAlgebra"],["Real","pseudoMetricSpace"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["GeneralizedCoheytingAlgebra","toSDiff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["CompleteDistribLattice","toCoframe"],["Lean","Grind","imp_false_eq"],["Lean","Grind","not_and"],["GeneralizedCoheytingAlgebra","toLattice"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Order","Coframe","toCoheytingAlgebra"],["Lean","Grind","not_or"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Lean","Grind","dite_cond_eq_false'"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Real","instPow"],["Lean","Grind","nestedDecidable"],["tsum"],["instOfNatNat"],["congr"],["Real","instNeg"],["Lean","Grind","dite_cond_eq_true'"],["Zero","toOfNat0"],["Chapter8","Uncountable","real","_proof_1_4"],["Eq"],["Lean","Grind","or_eq_of_eq_false_left"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set","Nonempty"],["Lean","Grind","em"],["True"],["Lean","Grind","alreadyNorm"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["Or","casesOn"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","or_eq_of_eq_false_right"],["LE","le"],["SemilatticeSup","toMax"],["False"],["Lean","Grind","intro_with_eq"],["dite"],["instLENat"],["And","casesOn"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["Real"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["GeneralizedCoheytingAlgebra","toSDiff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["CompleteDistribLattice","toCoframe"],["GeneralizedCoheytingAlgebra","toLattice"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Order","Coframe","toCoheytingAlgebra"],["Real","instNatCast"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Real","instZero"],["LE","le"],["SemilatticeSup","toMax"],["False"],["instLENat"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          (∀ (n : Nat),\n              Or (And (Set.instMembership.mem A n) (Not (Set.instMembership.mem B n)))\n                  (And (Set.instMembership.mem B n) (Not (Set.instMembership.mem A n))) →\n                instLENat.le (Chapter8.Nat.min (symmDiff A B)) n) →\n            (∀ ⦃A B : Set Nat⦄,\n                Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n                    ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n                  let n₀ := Chapter8.Nat.min (symmDiff A B);\n                  Or (And (Set.instMembership.mem A n₀) (Not (Set.instMembership.mem B n₀)))\n                      (And (Set.instMembership.mem B n₀) (Not (Set.instMembership.mem A n₀))) →\n                    (∀ (n : Nat),\n                        Or (And (Set.instMembership.mem A n) (Not (Set.instMembership.mem B n)))\n                            (And (Set.instMembership.mem B n) (Not (Set.instMembership.mem A n))) →\n                          instLENat.le n₀ n) →\n                      And (Set.instMembership.mem A n₀) (Not (Set.instMembership.mem B n₀)) → False) →\n              Not\n                  (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                    (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B))))) →\n                And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                    (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))) →\n                  Or\n                    (And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                      (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))))\n                    (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                      (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))))","name":["Chapter8","Uncountable","real","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Chapter8","LeCard"],["And"],["Chapter8","EqualCard"]],"typeReferences":[],"type":"Type → Type → Prop","name":["Chapter8","LtCard"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter8","LeCard"],["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Chapter8","LeCard"]],"type":"∀ (a : Type), Chapter8.LeCard a a","name":["Chapter8","CardOrder","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Uncountable"],["Chapter8","AtMostCountable","iff"],["Iff","rfl"],["uncountable_iff_not_countable"],["congrArg"],["Chapter8","AtMostCountable"],["Iff"],["id"],["Eq","mpr"],["Countable"],["Eq"],["propext"]],"typeReferences":[["Not"],["Chapter8","AtMostCountable"],["Uncountable"],["Iff"]],"type":"∀ (X : Type), Iff (Uncountable X) (Not (Chapter8.AtMostCountable X))","name":["Chapter8","Uncountable","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["implies_congr"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Eq","trans"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Classical","choose"],["Subtype","val"],["Or"],["NatCast","natCast"],["Lean","Grind","forall_imp_eq_or"],["funext"],["forall_congr"],["Eq","symm"],["Lean","Grind","not_eq_of_eq_true"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["Set","instUnion"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Exists"],["Real"],["Neg","neg"],["Lean","Grind","eq_true_of_and_eq_true_right"],["And"],["Lean","Grind","not_not"],["True","intro"],["Set","instMembership"],["Real","instLE"],["Nat"],["Lean","Grind","and_eq_of_eq_false_right"],["Set","instCompleteAtomicBooleanAlgebra"],["Real","pseudoMetricSpace"],["Eq","refl"],["Iff"],["Classical","byContradiction"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Real","instPow"],["Lean","Grind","Nat","lt_eq"],["Lean","Grind","nestedDecidable"],["tsum"],["instOfNatNat"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set","Nonempty"],["True"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","iff_eq"],["Lean","Grind","or_eq_of_eq_false_right"],["LE","le"],["SemilatticeSup","toMax"],["False"],["Lean","Grind","intro_with_eq"],["dite"],["instLENat"],["And","casesOn"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Real"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Real","instZero"],["SemilatticeSup","toMax"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          Or\n              (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))))\n              (And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B))))) →\n            And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))) →\n              (∀ {n : Nat},\n                  instLTNat.lt n (Chapter8.Nat.min (symmDiff A B)) →\n                    Iff (Set.instMembership.mem A n) (Set.instMembership.mem B n)) →\n                ∀ (n : Nat), Set.instMembership.mem B n → Not (Eq n (Chapter8.Nat.min (symmDiff A B)))","name":["Chapter8","Uncountable","real","_proof_1_13"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["instAddNat"],["PseudoMetricSpace","toUniformSpace"],["Eq","trans"],["Classical","propDecidable"],["eq_true"],["Union","union"],["Subtype","val"],["Classical","choose"],["Lean","Grind","Nat","lo_le"],["NatCast","natCast"],["Eq","symm"],["Set","instUnion"],["Set","instInter"],["Set","instSDiff"],["Nat","le_trans"],["Exists"],["Lean","Grind","not_not"],["Set","instMembership"],["Lean","Grind","Nat","le_of_eq_2"],["Lean","Grind","eq_false_of_or_eq_false_right"],["Set","instCompleteAtomicBooleanAlgebra"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["GeneralizedCoheytingAlgebra","toSDiff"],["symmDiff"],["Order","Coframe","toCoheytingAlgebra"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["Lean","Grind","nestedDecidable"],["instOfNatNat"],["tsum"],["Lean","Grind","Nat","le_of_eq_1"],["Eq"],["Chapter8","Uncountable","real","_proof_1_4"],["CompleteLattice","toConditionallyCompleteLattice"],["Lean","Grind","Nat","le_eq_false_of_lo"],["Set"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","or_eq_of_eq_false_right"],["dite"],["And","casesOn"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Inter","inter"],["Membership","mem"],["CompleteBooleanAlgebra","toCompleteLattice"],["Or"],["Lean","Grind","forall_imp_eq_or"],["forall_congr"],["funext"],["Lean","Grind","eq_false_of_imp_eq_true"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["instHPow"],["Real"],["Neg","neg"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Lean","Grind","rfl_true"],["And"],["True","intro"],["Lean","Grind","nestedProof"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["CompleteDistribLattice","toCoframe"],["Lean","Grind","imp_false_eq"],["Subtype"],["GeneralizedCoheytingAlgebra","toLattice"],["Lean","Grind","not_and"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["UniformSpace","toTopologicalSpace"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Lean","Grind","dite_cond_eq_false'"],["congrArg"],["Real","instPow"],["Nat","not_le_eq"],["Real","instNeg"],["Lean","Grind","dite_cond_eq_true'"],["Zero","toOfNat0"],["Lean","Grind","or_eq_of_eq_false_left"],["Not"],["Set","Nonempty"],["Lean","Grind","em"],["Lean","Grind","alreadyNorm"],["True"],["instHAdd"],["Or","casesOn"],["SemilatticeSup","toMax"],["LE","le"],["False"],["Lean","Grind","intro_with_eq"],["instLENat"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["Real"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["GeneralizedCoheytingAlgebra","toSDiff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["CompleteDistribLattice","toCoframe"],["GeneralizedCoheytingAlgebra","toLattice"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Order","Coframe","toCoheytingAlgebra"],["Real","instNatCast"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["Real","instZero"],["LE","le"],["SemilatticeSup","toMax"],["False"],["instLENat"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          (∀ (n : Nat),\n              Or (And (Set.instMembership.mem A n) (Not (Set.instMembership.mem B n)))\n                  (And (Set.instMembership.mem B n) (Not (Set.instMembership.mem A n))) →\n                instLENat.le (Chapter8.Nat.min (symmDiff A B)) n) →\n            (∀ ⦃A B : Set Nat⦄,\n                Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n                    ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n                  let n₀ := Chapter8.Nat.min (symmDiff A B);\n                  Or (And (Set.instMembership.mem A n₀) (Not (Set.instMembership.mem B n₀)))\n                      (And (Set.instMembership.mem B n₀) (Not (Set.instMembership.mem A n₀))) →\n                    (∀ (n : Nat),\n                        Or (And (Set.instMembership.mem A n) (Not (Set.instMembership.mem B n)))\n                            (And (Set.instMembership.mem B n) (Not (Set.instMembership.mem A n))) →\n                          instLENat.le n₀ n) →\n                      And (Set.instMembership.mem A n₀) (Not (Set.instMembership.mem B n₀)) → False) →\n              Not\n                  (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                    (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B))))) →\n                And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                    (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))) →\n                  ∀ (n : Nat),\n                    Or (And (Set.instMembership.mem B n) (Not (Set.instMembership.mem A n)))\n                        (And (Set.instMembership.mem A n) (Not (Set.instMembership.mem B n))) →\n                      instLENat.le (Chapter8.Nat.min (symmDiff A B)) n","name":["Chapter8","Uncountable","real","_proof_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["CompleteLattice","instOmegaCompletePartialOrder"],["Lean","Name","anonymous"],["instDecidableAnd"],["sorryAx"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Lean","Name"],["Set","embeddingOfSubset"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["OmegaCompletePartialOrder","toPartialOrder"],["Classical","propDecidable"],["Set","iUnion"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["CompleteBooleanAlgebra","toCompleteLattice"],["DFunLike","coe"],["Subtype","val"],["Set","Elem"],["Order","Frame","toHeytingAlgebra"],["instOfNatNat"],["Subtype","property"],["Set","PairwiseDisjoint"],["HeytingAlgebra","toOrderBot"],["Eq"],["Function","instFunLikeEmbedding"],["CompleteDistribLattice","toFrame"],["Not"],["Exists"],["Function","Embedding","image"],["Set"],["And","right"],["Function","Embedding"],["And"],["Function","Bijective"],["Function","comp"],["Exists","choose"],["OfNat","ofNat"],["Set","instMembership"],["Set","univ"],["Nat"],["Set","instCompleteAtomicBooleanAlgebra"],["Nat","rec"],["Lean","Name","num"],["Subtype","mk"],["dite"],["setOf"]],"typeReferences":[["CompleteLattice","instOmegaCompletePartialOrder"],["instDecidableAnd"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Set","embeddingOfSubset"],["Membership","mem"],["OmegaCompletePartialOrder","toPartialOrder"],["Classical","propDecidable"],["Set","iUnion"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["CompleteBooleanAlgebra","toCompleteLattice"],["DFunLike","coe"],["Subtype","val"],["Set","Elem"],["Order","Frame","toHeytingAlgebra"],["Subtype","property"],["Set","PairwiseDisjoint"],["HeytingAlgebra","toOrderBot"],["Eq"],["Function","instFunLikeEmbedding"],["CompleteDistribLattice","toFrame"],["Not"],["Exists"],["Function","Embedding","image"],["Set"],["And","right"],["Function","Embedding"],["And"],["Function","Bijective"],["Function","comp"],["Exists","choose"],["Set","instMembership"],["Set","univ"],["Set","instHasSubset"],["Nat"],["HasSubset","Subset"],["Set","instCompleteAtomicBooleanAlgebra"],["Nat","rec"],["Subtype","mk"],["dite"],["setOf"]],"type":"∀ {X : Type} {A B C : Set X} (hAB : Set.instHasSubset.Subset A B) (hBC : Set.instHasSubset.Subset B C)\n  (f : Function.Embedding C.Elem A.Elem),\n  have D := fun t =>\n    Nat.rec\n      (Function.comp (Function.instFunLikeEmbedding.coe f.image)\n        (Function.instFunLikeEmbedding.coe (B.embeddingOfSubset C hBC).image)\n        (setOf fun x => Not (Set.instMembership.mem A x.val)))\n      (fun x =>\n        Function.comp (Function.instFunLikeEmbedding.coe f.image)\n          (Function.comp (Function.instFunLikeEmbedding.coe (B.embeddingOfSubset C hBC).image)\n            (Function.instFunLikeEmbedding.coe (A.embeddingOfSubset B hAB).image)))\n      t;\n  And (Set.univ.PairwiseDisjoint D)\n    (have g := fun x =>\n      if h :\n          And (Set.instMembership.mem (Set.iUnion fun n => D n) x)\n            (Exists fun y => Eq (Function.instFunLikeEmbedding.coe f ⟨y.val, ⋯⟩) x) then\n        ⋯.choose\n      else ⟨x.val, ⋯⟩;\n    Function.Bijective g)","name":["Chapter8","Schroder_Bernstein_lemma"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["Inter","inter"],["Set","mem_empty_iff_false"],["Set","instEmptyCollection"],["EmptyCollection","emptyCollection"],["Lean","Grind","not_eq_prop"],["Lean","Grind","eq_false_eq"],["congrArg"],["or_false"],["Or"],["Lean","Grind","forall_imp_eq_or"],["forall_congr"],["funext"],["Eq","symm"],["Eq"],["Set","instInter"],["Not"],["Exists"],["True"],["Set"],["True","intro"],["Lean","Grind","eq_true_of_not_eq_false"],["Set","instMembership"],["Exists","casesOn"],["Nat"],["Lean","Grind","iff_eq"],["eq_false"],["Iff"],["Eq","refl"],["Classical","byContradiction"],["Set","ext"],["False"]],"typeReferences":[["Not"],["Nat"],["Set"],["Inter","inter"],["Membership","mem"],["Set","instEmptyCollection"],["EmptyCollection","emptyCollection"],["Eq"],["Set","instInter"],["Set","instMembership"]],"type":"∀ {A B : Set Nat},\n  (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n    Eq (Set.instInter.inter A B) Set.instEmptyCollection.emptyCollection","name":["Chapter8","Uncountable","real","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Lattice","toSemilatticeSup"],["GeneralizedCoheytingAlgebra","toLattice"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["Set"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Order","Coframe","toCoheytingAlgebra"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Nat"],["Set","instCompleteAtomicBooleanAlgebra"],["SemilatticeSup","toMax"],["GeneralizedCoheytingAlgebra","toSDiff"],["Chapter8","Nat","min","_proof_1"],["CompleteDistribLattice","toCoframe"]],"typeReferences":[["Lattice","toSemilatticeSup"],["Set","Nonempty"],["Exists"],["GeneralizedCoheytingAlgebra","toLattice"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Set"],["symmDiff"],["CoheytingAlgebra","toGeneralizedCoheytingAlgebra"],["Membership","mem"],["And"],["Order","Coframe","toCoheytingAlgebra"],["CompleteBooleanAlgebra","toCompleteDistribLattice"],["Set","instMembership"],["Nat"],["Set","instCompleteAtomicBooleanAlgebra"],["LE","le"],["SemilatticeSup","toMax"],["GeneralizedCoheytingAlgebra","toSDiff"],["instLENat"],["CompleteDistribLattice","toCoframe"]],"type":"∀ ⦃A B : Set Nat⦄,\n  (symmDiff A B).Nonempty →\n    Exists fun x =>\n      And (Set.instMembership.mem (symmDiff A B) x)\n        (∀ (n : Nat), Set.instMembership.mem (symmDiff A B) n → instLENat.le x n)","name":["Chapter8","Uncountable","real","_proof_1_4"],"kind":"theorem","isProp":true},{"valueReferences":[["LT","lt"],["PartialOrder","toPreorder"],["Or"],["LE","le"],["Preorder","toLT"],["Eq"],["Preorder","toLE"],["le_iff_lt_or_eq"],["propext"]],"typeReferences":[["LT","lt"],["PartialOrder","toPreorder"],["Or"],["PartialOrder"],["LE","le"],["Preorder","toLT"],["Preorder","toLE"],["Eq"]],"type":"∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, Eq (inst.le a b) (Or (inst.lt a b) (Eq a b))","name":["Chapter8","Uncountable","real","_simp_1_11"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["implies_congr"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Eq","trans"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Classical","choose"],["Subtype","val"],["Or"],["NatCast","natCast"],["Lean","Grind","forall_imp_eq_or"],["funext"],["forall_congr"],["Eq","symm"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["Set","instUnion"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Exists"],["Real"],["Neg","neg"],["And"],["Lean","Grind","not_not"],["True","intro"],["Set","instMembership"],["Real","instLE"],["Nat"],["Set","instCompleteAtomicBooleanAlgebra"],["Real","pseudoMetricSpace"],["eq_false"],["Eq","refl"],["Iff"],["Classical","byContradiction"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["congrArg"],["Real","instPow"],["Lean","Grind","Nat","lt_eq"],["Lean","Grind","nestedDecidable"],["tsum"],["instOfNatNat"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set","Nonempty"],["True"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","iff_eq"],["LE","le"],["SemilatticeSup","toMax"],["False"],["Lean","Grind","intro_with_eq"],["dite"],["instLENat"],["And","casesOn"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Real"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["Real","instZero"],["SemilatticeSup","toMax"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          Or\n              (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))))\n              (And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B))))) →\n            And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))) →\n              (∀ {n : Nat},\n                  instLTNat.lt n (Chapter8.Nat.min (symmDiff A B)) →\n                    Iff (Set.instMembership.mem A n) (Set.instMembership.mem B n)) →\n                ∀ (n : Nat), Eq n (Chapter8.Nat.min (symmDiff A B)) → Set.instMembership.mem A n","name":["Chapter8","Uncountable","real","_proof_1_12"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["implies_congr"],["Lattice","toSemilatticeSup"],["Chapter8","Uncountable","real","_proof_1_1"],["Eq","trans"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["Classical","propDecidable"],["eq_true"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Classical","choose"],["Subtype","val"],["Lean","Grind","not_eq_prop"],["False","elim"],["Or"],["NatCast","natCast"],["Lean","Grind","forall_imp_eq_or"],["Lean","Grind","eq_false_of_imp_eq_true"],["funext"],["forall_congr"],["Eq","symm"],["Chapter8","Nat","min","_proof_1"],["Real","instAddCommMonoid"],["Set","instUnion"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Exists"],["Real"],["Neg","neg"],["Lean","Grind","rfl_true"],["And"],["Lean","Grind","not_not"],["True","intro"],["Set","instMembership"],["Real","instLE"],["Nat"],["Lean","Grind","eq_false_of_or_eq_false_right"],["Set","instCompleteAtomicBooleanAlgebra"],["Real","pseudoMetricSpace"],["eq_false"],["Eq","refl"],["Iff"],["Classical","byContradiction"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Subtype"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["Eq","mp"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Chapter8","Uncountable","real","_proof_1_3"],["Lean","Grind","of_eq_eq_true"],["congrArg"],["Real","instPow"],["Lean","Grind","Nat","lt_eq"],["Lean","Grind","nestedDecidable"],["tsum"],["instOfNatNat"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set","Nonempty"],["Lean","Grind","Nat","le_eq_false_of_lo"],["True"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["Lean","Grind","eq_true_of_not_eq_false"],["HPow","hPow"],["OfNat","ofNat"],["Or","casesOn"],["LT","lt"],["HAdd","hAdd"],["Real","instZero"],["Lean","Grind","and_eq_of_eq_true_left"],["Lean","Grind","iff_eq"],["Lean","Grind","or_eq_of_eq_false_right"],["LE","le"],["SemilatticeSup","toMax"],["False"],["Lean","Grind","intro_with_eq"],["dite"],["instLENat"],["And","casesOn"]],"typeReferences":[["Lattice","toSemilatticeSup"],["PseudoMetricSpace","toUniformSpace"],["Membership","mem"],["Inter","inter"],["CompleteBooleanAlgebra","toCompleteLattice"],["Union","union"],["Subtype","val"],["GE","ge"],["Set","Elem"],["Chapter8","Nat","min"],["Or"],["Set","instUnion"],["Real","instAddCommMonoid"],["Set","instInter"],["Set","instSDiff"],["instHPow"],["instLTNat"],["Real"],["Neg","neg"],["And"],["Set","instMembership"],["Real","instLE"],["Nat"],["Real","pseudoMetricSpace"],["Set","instCompleteAtomicBooleanAlgebra"],["Iff"],["instNatAtLeastTwo"],["ConditionallyCompleteLattice","toLattice"],["Nat","cast"],["CompleteAtomicBooleanAlgebra","toCompleteBooleanAlgebra"],["symmDiff"],["UniformSpace","toTopologicalSpace"],["Real","instNatCast"],["Real","instPow"],["instOfNatNat"],["tsum"],["Real","instNeg"],["Zero","toOfNat0"],["Eq"],["CompleteLattice","toConditionallyCompleteLattice"],["Not"],["Set"],["instHAdd"],["instOfNatAtLeastTwo"],["Real","instAdd"],["HPow","hPow"],["OfNat","ofNat"],["LT","lt"],["HAdd","hAdd"],["Real","instZero"],["SemilatticeSup","toMax"],["LE","le"],["instLENat"]],"type":"(∀ {A B C : Set Nat},\n    Eq C (Set.instUnion.union A B) →\n      (∀ (n : Nat), Not (Set.instMembership.mem (Set.instInter.inter A B) n)) →\n        Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n          (instHAdd.hAdd (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val))) →\n  (∀ (A : Set Nat), GE.ge (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) 0) →\n    (∀ {A B : Set Nat},\n        Eq A B →\n          Eq (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)\n            (tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val)) →\n      ∀ ⦃A B : Set Nat⦄,\n        Eq ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) A)\n            ((fun A => tsum fun n => (fun n => instHPow.hPow 10 (Real.instNeg.neg n.cast)) n.val) B) →\n          Or\n              (And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))))\n              (And (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))\n                (Not (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B))))) →\n            (∀ (n : Nat),\n                Or (And (Set.instMembership.mem A n) (Not (Set.instMembership.mem B n)))\n                    (And (Set.instMembership.mem B n) (Not (Set.instMembership.mem A n))) →\n                  instLENat.le (Chapter8.Nat.min (symmDiff A B)) n) →\n              And (Set.instMembership.mem A (Chapter8.Nat.min (symmDiff A B)))\n                  (Not (Set.instMembership.mem B (Chapter8.Nat.min (symmDiff A B)))) →\n                ∀ {n : Nat},\n                  instLTNat.lt n (Chapter8.Nat.min (symmDiff A B)) →\n                    Iff (Set.instMembership.mem A n) (Set.instMembership.mem B n)","name":["Chapter8","Uncountable","real","_proof_1_8"],"kind":"theorem","isProp":true}]
